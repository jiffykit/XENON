<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>XENON</title>
    <!-- Retro font (Oswald) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --retro-font: 'Oswald','Arial Narrow','Helvetica Neue',Arial,sans-serif;
            /* Top bar height; tweaked by media query for touch later */
            --bar-h: 56px;
            --string-gap: 1px;
            --string-min: 1px;
            --string-max: 9999px;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        /* Base layout and background (black background layer for modals) */
        body {
            font-family: var(--retro-font) !important;
            background: transparent; /* Transparent to show black background layer */
            color: #fff;
            overflow: hidden;
            /* Use dynamic viewport height to avoid mobile URL bar issues (with small-viewport fallback) */
            height: 100svh;
            height: 100dvh;
            padding-top: 0; /* No padding needed since transport is now floating */
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            padding-bottom: 0; /* No bottom padding - eliminate blue space */
        }

        /* Black background layer for clean modal presentation */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000; /* Pure black background */
            z-index: -1; /* Behind all content */
            pointer-events: none; /* Don't interfere with interactions */
        }

        :root {
            --xenon-footer-h: 28px; /* synced at runtime */
        }

        .instrument {
            display: flex;
            flex-direction: column;
            height: calc(100dvh - 20px); /* Match minimal top padding for transport row */
            width: 100vw;
            padding-bottom: 0; /* Remove bottom padding to eliminate blue space */
        }

        .root-notes-area {
            height: 320px; /* more space for 10 drum lanes incl. BASS */
            background: #000000; /* Black background for clean modal layer */
            border-bottom: none;
            padding: 10px;
            display: flex;
            align-items: flex-start;
        }

        .strum-area {
            flex: 1 1 auto; /* fill remaining vertical space */
            position: relative;
            background: #000000; /* Black background for clean modal layer */
            overflow: hidden;
            display: flex;
            padding: 0;
            border: none;
            gap: 0;
            min-height: 200px;
            /* Position to the right of sidebar */
            margin-left: 80px;
            /* Anchor to XENON bar at bottom */
            position: absolute;
            top: 0;
            bottom: auto;
            left: 80px; /* Right of sidebar */
            right: 0;
            /* Remove vertical line by ensuring no borders on child elements */
        }

        .strum-area:hover {
            border-color: #8fb3d3;
        }

        /* Chord Resize Container */
        .chord-resize-container {
            position: relative;
            height: 100%;
            background: #000000; /* Explicit black background to prevent color blending */
            display: flex;
            flex-direction: column;
        }

        .chord-resize-handle {
            position: absolute;
            top: calc(50vh - 12px); /* Position just above the strum-area */
            left: 0;
            right: 0;
            height: 24px;
            background: linear-gradient(180deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border-bottom: 1px solid #333333; /* Dark gray border instead of blue */
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 15;
        }

        .chord-collapse-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
            border-bottom: 1px solid #2a2a2a;
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 16;
        }

        .chord-collapse-handle .resize-grip {
            width: 36px;
            height: 4px;
            background: #ffd046;
            border-radius: 2px;
            opacity: 0.8;
        }

        .chord-resize-handle:hover {
            background: linear-gradient(180deg, rgba(255,255,255,0.15), rgba(255,255,255,0.08));
        }

        .resize-grip {
            width: 44px;
            height: 4px;
            background: #8fb3d3;
            border-radius: 2px;
            opacity: 0.6;
        }

        .chord-resize-handle:hover .resize-grip {
            opacity: 1;
        }

        /* Inline JAM (one octave) under chord view */
        .jam-area {
            position: absolute;
            left: 0;
            right: 0;
            bottom: var(--xenon-footer-h, 28px);
            top: 50vh;
            background: #000000;
            border-top: 1px solid #1f2f3a;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 5;
        }
        #jamArea #bellsHeader {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 6px 8px;
            border-bottom: 1px solid #1f2f3a;
            background: #060c10;
        }
        #jamArea #bellsTransportRow { display:flex; align-items:center; gap:8px; }
        #jamArea .bells-transport-btn {
            padding: 4px 10px; background: #214051; color: #e8f5ff; border: 1px solid #2b5567;
            border-radius: 8px; font-size: 12px; cursor: pointer; min-width: 70px; text-align: center;
        }
        #jamArea .bells-transport-btn.active { background: #2ecc71; border-color: #27ae60; color: #0a1014; }
        #jamArea #bellsChords, #jamArea #bellsModeToggle { display: none !important; }
        #jamArea #bellsControls { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
        #jamArea #bellsCountLabel,
        #jamArea #bellsCount,
        #jamArea #bellsCountValue,
        #jamArea [for="bellsOctave"],
        #jamArea #bellsOctave,
        #jamArea #bellsOctaveValue { display: none !important; }
        #jamArea #bellsGlideWrap { display:flex; align-items:center; gap:6px; font-size:12px; color:#9db6c8; }
        #jamArea #bellsDrawerRow { display:flex; align-items:center; gap:8px; margin-top:2px; }
        #jamArea .bells-gear {
            width:26px; height:24px; display:inline-flex; align-items:center; justify-content:center;
            background:#214051; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px;
            cursor:pointer; font-size:13px; line-height:1; padding:0; flex:0 0 auto;
        }
        #jamArea .bells-gear[aria-expanded="true"] { outline:2px solid #ffd046; outline-offset:1px; }
        #jamArea .bells-drawer { display:none; flex-wrap:wrap; gap:8px; align-items:center; padding:6px 8px; border:1px solid rgba(74,106,112,0.55); border-radius:8px; background:rgba(13,41,56,0.7); }
        #jamArea .bells-drawer.open { display:flex; }
        #jamArea .bells-osc-row { display:flex; gap:6px; flex-wrap:wrap; }
        #jamArea .bells-osc-btn {
            padding:4px 8px; background:#1a2f3c; color:#e8f5ff; border:1px solid #2b5567;
            border-radius:6px; font-size:11px; cursor:pointer; min-width:40px; text-align:center;
        }
        #jamArea .bells-osc-btn.active { background:#f39c12; border-color:#e67e22; color:#111; }
        #jamArea .bells-osc-slider { display:flex; align-items:center; gap:6px; font-size:11px; color:#9db6c8; }
        #jamArea .bells-osc-slider input[type="range"] { width:110px; }
        #jamArea #bellsBars { position: relative; width: 100%; flex: 1 1 auto; overflow: hidden; touch-action: none; }

        .sidebar-zoom-wrap {
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 6px 4px;
            border: 1px solid rgba(143,179,211,0.35);
            border-radius: 10px;
            background: rgba(7, 14, 18, 0.5);
        }
        .sidebar-zoom-label {
            font-size: 9px;
            color: #9db6c8;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        .sidebar-zoom-value {
            font-size: 10px;
            color: #e8f5ff;
        }
        .sidebar-zoom-wrap input[type="range"] {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            width: 18px;
            height: 120px;
            accent-color: #8fb3d3;
        }
        #jamArea #bellsBars .bells-scroll-track { position:absolute; left:0; top:0; width:100%; height:200%; will-change: transform; transition: none; }
        #jamArea #bellsBars .bells-scroll-panel { position: relative; width:100%; height:50%; }
        #jamArea .bells-key {
            position: absolute; display: flex; align-items: center; justify-content: center;
            font-size: 16px; font-weight: 600; color: #000; text-shadow: 0 1px 0 rgba(255,255,255,0.2);
            user-select: none; cursor: pointer; border: 2px solid rgba(255,255,255,0.55);
            border-radius: 6px 6px 0 0;
            box-shadow: inset 0 0 0 2px rgba(0,0,0,0.25), inset 0 0 14px rgba(0,0,0,0.35), 0 4px 14px rgba(0,0,0,0.35);
            outline: 2px solid rgba(0,0,0,0.35);
            outline-offset: -2px;
            overflow: hidden;
        }
        #jamArea .bells-key::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, rgba(255,255,255,0.45), rgba(255,255,255,0.05) 45%, rgba(0,0,0,0) 65%);
            opacity: 0.25;
            pointer-events: none;
            transform: translateX(-30%);
        }
        #jamArea .bells-key.ringing::after { opacity: 0.75; animation: bellsShimmer 0.9s linear infinite; }
        #jamArea .bells-key.bells-dim { filter: brightness(0.9); opacity: 0.9; }
        #jamArea .bells-key.bells-current { box-shadow: inset 0 0 0 2px rgba(255,255,255,0.65), 0 0 18px rgba(255,255,255,0.25); }
        #jamArea .bells-natural { height: 100%; z-index: 1; bottom: 0; }
        #jamArea .bells-accidental { height: 75%; z-index: 2; top: 0; }
        #jamArea .bells-micro { height: 55%; z-index: 3; top: 0; }
        #jamArea .bells-micro.small { height: 35%; }

        /* Chord Ruler (16th-note divisions) */
        #chordRuler {
            position: absolute;
            left: 0;
            right: 0;
            height: 14px;
            background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.02));
            border-bottom: 1px solid rgba(255,255,255,0.18);
            z-index: 11;
            pointer-events: auto;
            display: block;
        }
        #chordRuler .chord-ruler-tooltip {
            position: absolute;
            top: -20px;
            transform: translateX(-50%);
            background: rgba(12, 24, 38, 0.92);
            color: #e8f5ff;
            border: 1px solid rgba(124,201,255,0.45);
            border-radius: 6px;
            padding: 2px 6px;
            font-size: 10px;
            line-height: 1.2;
            white-space: nowrap;
            box-shadow: 0 6px 14px rgba(0,0,0,0.25);
            pointer-events: none;
            z-index: 12;
        }
        #chordRuler .chord-ruler-split-marker {
            position: absolute;
            top: -6px;
            height: 22px;
            width: 2px;
            background: rgba(255, 214, 110, 0.9);
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(255, 214, 110, 0.6);
            pointer-events: auto;
            cursor: pointer;
            z-index: 12;
        }
        #chordRuler .chord-ruler-row {
            height: 100%;
            display: flex;
            gap: 0px;
            width: 100%;
        }
        #chordRuler .chord-ruler-seg {
            height: 100%;
            min-width: 0;
        }
        #chordRuler .chord-ruler-seg.chord {
            --len16: 16;
            background-image:
                linear-gradient(to right, rgba(255,255,255,0.65) 0px, rgba(255,255,255,0.65) 2px, transparent 2px, transparent 100%),
                linear-gradient(to right, rgba(255,255,255,0.35) 0px, rgba(255,255,255,0.35) 1px, transparent 1px, transparent 100%),
                linear-gradient(to right, rgba(255,255,255,0.20) 0px, rgba(255,255,255,0.20) 1px, transparent 1px, transparent 100%);
            background-size: calc(100% / (var(--len16) / 16)) 100%, calc(100% / (var(--len16) / 4)) 100%, calc(100% / var(--len16)) 100%;
            background-repeat: repeat;
            opacity: 1;
        }
        #chordRuler .chord-ruler-seg.marker {
            background: transparent;
        }

        /* Now-playing chord highlight (PLAY mode) */
        .extension-header.now-playing,
        .extension-column-header.now-playing {
            box-shadow: 0 0 10px rgba(80, 200, 255, 0.25), 0 0 18px rgba(80, 200, 255, 0.14);
            outline: 1px solid rgba(80, 200, 255, 0.20);
            position: relative;
            z-index: 2;
        }
        @keyframes xenChordPulse {
            0% { box-shadow: 0 0 10px rgba(80, 200, 255, 0.22), 0 0 18px rgba(80, 200, 255, 0.12); }
            45% { box-shadow: 0 0 18px rgba(80, 200, 255, 0.55), 0 0 28px rgba(80, 200, 255, 0.28); }
            100% { box-shadow: 0 0 10px rgba(80, 200, 255, 0.22), 0 0 18px rgba(80, 200, 255, 0.12); }
        }
        .extension-header.now-playing.pulse,
        .extension-column-header.now-playing.pulse {
            animation: xenChordPulse 220ms ease-out;
        }

        /* Extend outer loop bracket markers up toward the ruler */
        .repeat-marker-column.loop-bracket {
            position: relative;
        }
        .repeat-marker-column.loop-bracket::before {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: -22px; /* 10px ruler + 12px handle */
            width: 2px;
            height: 22px;
            background: rgba(255,255,255,0.14);
            border-radius: 2px;
        }

        .clear-triads-container {
            display: flex;
            align-items: center;
        }

        .clear-triads-btn {
            background: linear-gradient(135deg, #e94560, #c73650);
            border: 1px solid #c73650;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .clear-triads-btn:hover {
            background: linear-gradient(135deg, #c73650, #a52a42);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .clear-triads-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .notes-area {
            height: 18vh;
            background: rgba(0, 20, 40, 0.8);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px;
        }

        .control-panel {
            /* Switch to dynamic viewport height so the math stays correct on mobile */
            height: calc(100dvh - 70px - 28vh - 28vh);
            min-height: 35vh;
            padding: 10px;
            margin-top: 0; /* Remove margin - sit directly below universal menu */
            overflow: visible;
            display: grid;
            grid-template-columns: 300px 200px 280px 1fr;
            gap: 15px;
            align-content: start;
            min-width: 0;
            width: 100%;
            position: relative; /* Ensure proper stacking context */
            z-index: 1; /* Above background elements */
        }


        .tuning-btn {
            padding: 6px 8px;
            background: #2a4858;
            border: 1px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 10px;
            white-space: nowrap;
            font-weight: bold;
        }

        .tuning-btn.active {
            background: #4a8fa0;
            border-color: #6aa0b0;
            box-shadow: 0 0 10px rgba(74, 143, 160, 0.5);
        }

        .chord-section {
            margin-bottom: 20px;
        }
        .section-title {
            font-size: 20px;
            margin-bottom: 15px;
            color: #8fb3d3;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 8px;
            margin-bottom: 15px;
        }

        .chord-btn {
            aspect-ratio: 1;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .chord-btn:hover {
            background: #3a5868;
            transform: scale(1.05);
        }

        .chord-btn:active {
            background: #4a7888;
            transform: scale(0.98);
        }

        .chord-btn.active {
            background: #e74c3c;
            border-color: #c0392b;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }

        /* Touch-specific feedback states */
        .chord-btn.touch-pressed {
            background: #4a7888;
            transform: scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .chord-btn.touch-long-press {
            background: #5a8898;
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(90, 136, 152, 0.6);
            border-color: #6a98a8;
        }

        .quality-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .quality-btn {
            flex: 1;
            padding: 10px;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
        }

        .quality-btn.active {
            background: #f39c12;
            border-color: #e67e22;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        .extension-columns {
            flex: 1;
            display: flex;
            height: 100%; /* Fill parent height (resizable strum-area) */
            max-height: 100%;
            min-height: 120px; /* Minimum to show chord headers + compressed strings */
            gap: 0;
            padding: 0;
            justify-content: stretch;
            overflow: hidden; /* Prevent overflow past bounds */
        }

        .quality-section {
            display: flex;
            flex-direction: row;
            flex: 1;
            gap: 2px;
            padding: 0;
            border-radius: 0;
            min-width: 0; /* Allow shrinking */
            max-width: 33.33%; /* Ensure 3 equal sections */
        }

        .extension-column {
            position: relative;
            border-right: none; /* Remove vertical line completely */
            display: flex;
            flex-direction: column;
            /* Chordbox duration in 16th-note units (default 16) */
            flex: var(--len16, 16) 1 0px;
            min-height: 120px; /* Ensure minimum height for header + compressed strings */
            max-height: 100%; /* Respect parent height constraint */
            min-width: 0;
            width: auto;
            cursor: grab;
            transition: all 0.2s ease;
            height: 100%;
            overflow: hidden; /* Prevent strings from overflowing */
        }

        /* Chordbox duration resize handles (left/right) */
        .chordbox-resize-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 10px;
            z-index: 250;
            cursor: ew-resize;
            touch-action: none;
            background: linear-gradient(180deg, rgba(255, 229, 0, 0.95) 0%, rgba(255, 185, 0, 0.95) 100%);
            box-shadow: inset 0 0 0 2px rgba(0,0,0,0.55), 0 0 10px rgba(255, 210, 0, 0.25);
            opacity: 0.85;
        }
        .chordbox-resize-handle:hover { opacity: 1; }
        .chordbox-resize-handle.left {
            left: 0;
            border-right: 1px solid rgba(0,0,0,0.55);
        }
        .chordbox-resize-handle.right {
            right: 0;
            border-left: 1px solid rgba(0,0,0,0.55);
        }

        /* Ensure header stays at fixed height */
        .extension-header {
            flex-shrink: 0; /* Don't allow header to compress */
            min-height: 40px;
            max-height: 40px;
        }

        .extension-column:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        /* Enhanced touch feedback for improved responsiveness */
        .touch-active {
            background: rgba(255, 255, 255, 0.1) !important;
            transform: scale(1.02) !important;
            transition: all 0.05s ease !important;
        }

        .extension-column:active {
            cursor: grabbing;
        }


        .extension-column:last-child {
            border-right: none; /* Ensure no borders anywhere */
        }

        .extension-header {
            height: auto; /* allow header to grow when buttons wrap */
            min-height: 76px;
            max-height: none;
            background: rgba(0, 0, 0, 0.5);
            /* Subtle root tint overlay, if provided */
            background-image: var(--root-tint-gradient, none);
            background-repeat: no-repeat;
            background-size: cover;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            padding: 10px 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            position: relative;
            transition: background 0.2s, transform 0.1s;
            z-index: 100;
            user-select: none;
            border-radius: 4px 4px 0 0;
            margin: 2px 2px 0 2px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            flex-wrap: wrap;
            align-content: flex-start; /* stack rows from the top when wrapping */
        }

        .chord-name {
            /* Only as wide as its text */
            flex: 0 0 auto;
            display: inline-block;
            white-space: nowrap;
            text-align: center;
            margin: 0 auto; /* center within flex container without stretching */
            font-size: 22px;
            font-weight: 800;
            letter-spacing: 0.4px;
            line-height: 1.1;
        }

        .lock-button {
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s;
            margin-left: 6px;
            flex-shrink: 0;
            z-index: 100;
            position: relative;
            pointer-events: auto;
            touch-action: manipulation;
        }

        .lock-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .lock-button.locked {
            background: #4CAF50;
            border-color: #45a049;
            color: #fff;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }


        .chord-action-button {
            width: 34px;
            height: 34px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s;
            margin-left: 6px;
            flex-shrink: 0;
            pointer-events: auto;
            touch-action: manipulation;
        }

        .chord-action-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        /* High-contrast styling for per-chord transpose arrows */
        .chord-action-button.transpose-up,
        .chord-action-button.transpose-down {
            background: rgba(17, 24, 39, 0.85); /* slate-900 */
            border-color: rgba(255, 255, 255, 0.35);
            color: #ffffff;
        }
        .chord-action-button.transpose-up:hover,
        .chord-action-button.transpose-down:hover {
            background: rgba(31, 41, 55, 0.95); /* slate-800 */
            border-color: rgba(255, 255, 255, 0.55);
        }

        .chord-action-button.edit {
            background: rgba(33, 150, 243, 0.2);
            border-color: rgba(33, 150, 243, 0.5);
        }


        .chord-action-button.duplicate {
            background: rgba(156, 39, 176, 0.2);
            border-color: rgba(156, 39, 176, 0.5);
        }

        .header-buttons {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
            pointer-events: auto;
            z-index: 99;
            position: relative;
            flex-wrap: wrap;
            row-gap: 6px;
        }

        .extension-header:hover {
            /* Minimal hover feedback to avoid interfering with tap/hold system */
            background: rgba(255, 255, 255, 0.05);
        }

        .extension-header:active {
            /* Completely disable active state visual feedback - header taps should have no visual change */
            /* Use a minimal property that doesn't change appearance */
            pointer-events: auto;
        }
        
        /* Prevent touch-pressed class from altering header colors; preserve root-based background */
        .extension-header.touch-pressed {
            transform: none !important;
            transition: none !important;
        }

        /* Extension footer for ARP/CHORD trigger buttons */
        .extension-footer {
            height: 48px;
            min-height: 48px;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 6px 14px 6px; /* Added bottom padding to prevent menu bar overlap */
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            gap: 4px;
        }

        .trigger-button {
            flex: 1;
            height: 36px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .trigger-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .trigger-button:active {
            transform: translateY(0) scale(0.95);
            background: rgba(255, 255, 255, 0.3);
        }

        .trigger-button.arp-trigger {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.2);
        }

        .trigger-button.arp-trigger:hover {
            background: rgba(16, 185, 129, 0.3);
            border-color: #10b981;
        }

        .trigger-button.chord-trigger {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.2);
        }

        .trigger-button.chord-trigger:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
        }

        /* Mode-specific colors for unified trigger button */
        .trigger-button.mode-arp {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.2);
        }

        .trigger-button.mode-arp:hover {
            background: rgba(16, 185, 129, 0.3);
            border-color: #10b981;
        }

        .trigger-button.mode-chord {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.2);
        }

        .trigger-button.mode-chord:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
        }

        .trigger-button.mode-off {
            background: rgba(127, 140, 141, 0.2);
            border-color: rgba(127, 140, 141, 0.4);
            cursor: not-allowed;
            opacity: 0.6;
        }

        .trigger-button.active {
            background: rgba(255, 255, 255, 0.4) !important;
            border-color: white !important;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
        }

        /* Touch feedback styles */
        .touch-pressed {
            background: rgba(233, 69, 96, 0.3) !important;
            transform: scale(0.98);
            transition: background 0.1s, transform 0.1s;
        }

        .touch-long-press {
            background: rgba(233, 69, 96, 0.5) !important;
            transform: scale(1.02);
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
            transition: background 0.2s, transform 0.2s, box-shadow 0.2s;
        }

        .strings-column {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            padding: 0; /* no inner gaps */
            overflow: hidden; /* Prevent scrollbars */
            min-height: 0; /* allow shrinking when header grows */
            box-sizing: border-box;
            /* High-contrast backdrop for neon strings */
            background: #000000;
            /* Subtle root tint overlay, if provided */
            background-image: var(--root-tint-gradient, none);
            background-repeat: no-repeat;
            background-size: cover;
        }

        .note-label {
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
            color: #8fb3d3;
            text-align: center;
            padding: 1px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Hit area fills the lane from string to string (no gaps) */
        .string {
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center; /* center the visible core */
            justify-content: stretch;
            flex: 0 0 var(--string-row, auto);
            margin: 0; /* no gaps */
            padding: 0; /* keep tight */
            overflow: visible; /* allow glow to bloom */
            min-height: var(--string-min, 1px);
            max-height: var(--string-max, 30px);
            height: var(--string-row, auto);
        }

        /* String container flexibility for compression */
        .strings-container {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            gap: var(--string-gap, 0px);
        }

        /* The actual visible 6px neon line lives inside the hit area */
        .string-core {
            position: relative;
            width: 100%;
                height: clamp(var(--string-min, 1px), 100%, var(--string-max, 30px));
            border-radius: 4px;
            transition: transform 0.08s ease, box-shadow 0.1s ease, opacity 0.1s ease, filter 0.1s ease;
            transform-origin: center;
            will-change: transform;
            pointer-events: none; /* events on the hit area (.string) */
        }

        .string:hover .string-core {
            transform: scaleY(1.2);
            filter: brightness(1.05);
        }

        .string.active .string-core {
            transform: scaleY(1.25);
            filter: brightness(1.15);
        }

    .string-wave {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.1s;
            background: transparent; /* Removed gradient animation that caused purple lines */
            /* background-size: 20px 100%; */
            /* animation: wave-flow 1s linear infinite; */
        }

    .string.active .string-wave {
            opacity: 1;
        }

        @keyframes wave-flow {
            0% {
                background-position-x: 0;
            }
            100% {
                background-position-x: 20px;
            }
        }

        /* Subtle vertical vibration tied to frequency (period set via --vib-period) */
        @keyframes vibrate-y {
            0% { transform: translateY(0) scaleY(1); }
            20% { transform: translateY(-2px) scaleY(1.12); }
            50% { transform: translateY(0) scaleY(1); }
            80% { transform: translateY(2px) scaleY(1.12); }
            100% { transform: translateY(0) scaleY(1); }
        }

        .string-core.vibrating {
            animation: vibrate-y var(--vib-period, 60ms) ease-in-out infinite;
        }

        /* Subtle highlight band for middle octaves (3â€“4) */
        .string.mid-octave {
            background: rgba(255, 255, 255, 0.035);
        }
        .string.mid-octave .string-core {
            filter: brightness(1.12) saturate(1.06);
        }

        .note-labels {
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #8fb3d3;
            text-align: center;
            padding: 2px;
        }

        .frequency-display {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #bdc3c7;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .string:hover .frequency-display {
            opacity: 1;
        }

        .current-chord {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 12px;
            border: 2px solid #4a6870;
            z-index: 1000;
        }

        .current-chord h3 {
            color: #e74c3c;
            margin-bottom: 8px;
            font-size: 24px;
            text-align: center;
        }

        .current-chord div {
            font-size: 16px;
            text-align: center;
            color: #8fb3d3;
        }

        .root-notes-selector {
            display: flex;
            gap: 4px;
            align-items: center;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap;
        }
        /* panelHost removed: legacy reference stripped */

        .root-notes-selector .section-title {
            font-size: 18px;
            color: #8fb3d3;
            margin-right: 20px;
            white-space: nowrap;
        }

        .root-chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(20px, 1fr));
            grid-template-rows: 1fr;
            gap: 1px;
            flex: 1;
            width: 100%;
            max-height: none !important;
            height: 100% !important;
            position: relative;
        }

        .root-btn {
            flex: 1;
            min-width: 20px;
            height: 45px;
            background: linear-gradient(145deg, #2c5aa0, #1e3a8a);
            border: 1px solid #4a90e2;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .root-btn:hover {
            background: linear-gradient(145deg, #3d6bb5, #2949a0);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .root-btn:active {
            background: linear-gradient(145deg, #1e3a8a, #1a2f70);
            transform: translateY(0px) scale(0.95);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        /* Touch-specific feedback states for root buttons */
        .root-btn.touch-pressed {
            background: linear-gradient(145deg, #1e3a8a, #1a2f70);
            transform: translateY(0px) scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .root-btn.touch-long-press {
            background: linear-gradient(145deg, #4d7bc5, #3959b0);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(74, 144, 226, 0.6);
            border-color: #6aa0e2;
        }

        .root-btn.active {
            background: linear-gradient(145deg, #f59e0b, #d97706);
            border-color: #fbbf24;
            color: #000;
            font-weight: bold;
        }

        /* Generic panel buttons (bottom/top bar etc.) */
    .panel-btn {
            background: #1f3744;
            color: #e8f5ff;
            border: 1px solid #4a6870;
            border-radius: 10px;
            padding: 10px 14px;
            min-width: 48px;
            height: 44px;
            font-size: 14px;
            line-height: 1;
            cursor: pointer;
        }

        /* Traffic-light state system for cued DRUM/PATTERN instance buttons */
        .panel-btn.traffic-green { background:#1f8f4a !important; border-color:#46c37b !important; color:#eafff3 !important; }
        .panel-btn.traffic-red { background:#7f1d1d !important; border-color:#ff5a5a !important; color:#fff !important; }
        .panel-btn.traffic-yellow { background:#b08900 !important; border-color:#ffd046 !important; color:#1b1300 !important; }
        .panel-btn.traffic-orange { background:#b45309 !important; border-color:#ff9a3c !important; color:#1b0b00 !important; }
        .panel-btn.pending-change { box-shadow: 0 0 0 2px rgba(255,208,70,0.35), 0 0 10px rgba(255,208,70,0.18) !important; }

        /* Visual feedback: briefly swell dots when they fire */
        @keyframes stepPulse {
            0% { transform: scale(1); }
            45% { transform: scale(1.18); }
            100% { transform: scale(1); }
        }
        .drum-step.step-pulse, .pattern-step.step-pulse {
            animation: stepPulse 140ms ease-out;
        }

    /* Reserve space for bottom brand footer */
    body { padding-bottom: 32px; }

    /* Make transport buttons finger friendly */
    #playSeqBtn, #stopSeqBtn { border-radius: 10px; padding: 10px 12px !important; height: 44px; font-size: 14px !important; }

        /* Larger, finger-friendly controls on touch screens */
        @media (pointer: coarse) {
            :root { --bar-h: 64px; }
            body { font-size: 18px; }
            .section-title { font-size: 22px; }
            .control-panel { gap: 18px; }

            .tuning-btn { padding: 10px 14px; font-size: 14px; border-width: 2px; border-radius: 8px; }

            .chord-grid { grid-template-columns: repeat(auto-fit, minmax(84px, 1fr)); gap: 10px; }
            .chord-btn { min-width: 84px; min-height: 84px; font-size: 16px; border-width: 3px; border-radius: 12px; }

            .quality-btn { padding: 14px; font-size: 16px; border-width: 2px; }

            .lock-button, .chord-action-button { width: 44px; height: 44px; font-size: 20px; border-width: 2px; }

            .root-btn { height: 56px; font-size: 16px; border-width: 2px; }

            .panel-btn { padding: 14px 18px; height: 52px; font-size: 18px; border-width: 2px; border-radius: 12px; }

            .note-labels { height: 36px; font-size: 11px; }
            .note-label { height: 26px; font-size: 10px; }

            /* Keep string sizing driven by runtime layout vars */
        }

        /* ================= Piano Keyboard Revamp (Top Row) ================ */
        /* Wrapper row to place transpose controls to the left of the keyboard */
        .keyboard-row {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin: 8px 0 0 0;
        }
        .transpose-controls-left {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            user-select: none;
        }
        .transpose-controls-left button {
            background:#1f3a4a;
            color:#e8f5ff;
            border:1px solid #3b6a7a;
            border-radius:6px;
            padding:4px 6px;
            font-size:14px;
            width: 36px;
            cursor: pointer;
        }
        .transpose-controls-left .delta {
            color:#9db6c8;
            font-weight:700;
            font-size:14px;
            min-height: 18px;
        }
        /* Inline mode controls placed between transpose and keyboard */
        .mode-controls {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin: 0 10px 0 2px;
            user-select: none;
        }
        .mode-controls .mode-btn {
            background: #2a4858;
            color: #e8f5ff;
            border: 1px solid #4a6870;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            white-space: nowrap;
        }
        
        /* Centralized controls row styling */
        #centralizedControlsRow {
            flex-wrap: wrap;
            gap: 8px;
        }
        
        /* Mode buttons horizontal layout */
        #modeButtonsHorizontal {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        /* Responsive design for mobile */
        @media (max-width: 768px) {
            #universalMenu {
                gap: 4px;
                font-size: 10px;
            }
            
            #centralizedControlsRow {
                flex-direction: column;
                gap: 8px;
                align-items: center;
            }
            
            #modeButtonsHorizontal {
                justify-content: center;
            }
            
            .transpose-controls-left button {
                width: 28px;
                height: 28px;
                font-size: 14px;
            }
            
            /* Stack transpose and keyboard controls vertically on phones */
            #centralizedControlsRow > div {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
            }
        }
        
        @media (max-width: 480px) {
            #universalMenu {
                gap: 2px;
            }
            
            #centralizedControlsRow {
                padding: 6px;
                gap: 6px;
            }
            
            #modeButtonsHorizontal {
                gap: 4px;
            }
            
            .mode-btn {
                padding: 6px 8px;
                font-size: 10px;
            }
            
            /* Vertical stacking for very small screens */
            #centralizedControlsRow {
                flex-direction: column;
            }
            
            /* Make buttons evenly spaced on phones */
            #modeButtonsHorizontal {
                width: 100%;
                justify-content: space-around;
            }
        }
        .mode-controls .mode-btn.active { background: #3498db; border-color: #2980b9; }

        /* Universal menu and mode button styling */
        #universalMenu {
            min-height: 40px;
        }
        
        #modeButtonsStack .mode-btn {
            background: #1a2530; /* Start dark */
            color: #9db6c8; /* Dim text */
            border: 1px solid #3a4850;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            white-space: nowrap;
            min-width: 70px;
            text-align: center;
            transition: all 0.2s ease;
        }
        
        #modeButtonsStack .mode-btn:hover {
            background: #2a3540;
            border-color: #5a6870;
        }
        
        #modeButtonsStack .mode-btn.active {
            background: #3498db; /* Light up when active */
            border-color: #2980b9;
            color: #ffffff;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.5);
        }
        
        /* Desktop mode buttons styling */
        .root-notes-selector .mode-btn {
            background: #1a2530; /* Start dark */
            color: #9db6c8; /* Dim text */
            border: 1px solid #3a4850;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            white-space: nowrap;
            min-width: 70px;
            text-align: center;
            transition: all 0.2s ease;
        }
        
        .root-notes-selector .mode-btn:hover {
            background: #2a3540;
            border-color: #5a6870;
        }
        
        .root-notes-selector .mode-btn.active {
            background: #3498db !important; /* Light up when active */
            border-color: #2980b9 !important;
            color: #ffffff !important;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.5) !important;
        }
        
        /* More specific targeting for desktop mode buttons */
        #modeStrum.active,
    #modeChordArp.active,
        #universalBass.active {
            background: #3498db !important;
            border-color: #2980b9 !important;
            color: #ffffff !important;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.5) !important;
        }
        /* MIDI status LED */
        .midi-led {
            display:inline-block;
            width:10px;
            height:10px;
            border-radius:50%;
            background:#3a3f46;
            border:1px solid #555;
            box-shadow:0 0 2px #000 inset;
            transition:background 0.25s, box-shadow 0.25s, filter 0.25s;
            position:relative;
            top:1px;
        }
        .midi-led.on {
            background:#10b981;
            border-color:#0d8f66;
            box-shadow:0 0 4px 1px rgba(16,185,129,0.9), 0 0 10px 3px rgba(16,185,129,0.4);
            filter:brightness(1.2);
        }
        
        
        #topContainer {
            position: fixed; /* Fixed positioning to stay below browser UI */
            top: 40px; /* Leave space for browser UI and bookmarks */
            left: 0;
            right: 0;
            z-index: 1000;
            margin-bottom: 0; /* No margin needed with fixed positioning */
            padding: 12px 16px; /* Increased padding for better spacing */
            background: rgba(0, 0, 0, 0.98); /* Black semi-transparent background */
            backdrop-filter: blur(8px);
            border-bottom: 1px solid #333333;
        }

        /* Ensure panel toggles show a clear active glow (used by BASS/GLIDE buttons) */
        .panel-btn.active {
            background: #0ea5e9 !important;
            color: #05222b !important;
            border-color: #0284c7 !important;
            box-shadow: 0 0 10px 2px rgba(56, 189, 248, 0.7), 0 0 18px 6px rgba(14, 165, 233, 0.5) !important;
            position: relative;
            z-index: 0; /* keep inside normal stacking without clipping */
        }
        .piano-keyboard {
            position: relative;
            width: 66.666vw; /* fixed 2/3 viewport width */
            max-width: 1500px; /* cap width on large screens */
            height: 200px; /* fixed height */
            margin: 12px auto 8px auto; /* centered near top */
            user-select: none;
            background: transparent; /* remove purple rectangle so keys float on blue */
            border-radius: 8px;
            /* remove dark border/inset so it blends with background */
            box-shadow: none;
            overflow: hidden;
            padding-top: 4px; /* slight top padding so glow/outline never alters outer box */
            padding-left: 8px;
        }
        /* Reserve vertical space inside for active glow so layout never shifts */
        .piano-keyboard .white-key.root-btn,
        .piano-keyboard .black-key.root-btn,
        .piano-keyboard .edo-dot { will-change: transform; }
        /* Neutralize any accidental layout influence from outlines */
        .piano-keyboard .white-key.root-btn.active,
        .piano-keyboard .black-key.root-btn.active,
        .piano-keyboard .edo-dot.active { outline-offset: 0; }
    /* Light currently active chord tones on the keyboard */
    .piano-keyboard .chord-tone { filter: brightness(1.25) contrast(1.1); box-shadow: 0 0 12px 3px rgba(255,255,200,0.5); }
    /* Prevent reflow on hover/active transitions */
        .piano-keyboard .white-key.root-btn,
        .piano-keyboard .black-key.root-btn { position:absolute; }
        /* Hardware accelerate transforms for smoother glow without jitter */
    .piano-keyboard, .piano-keyboard * { backface-visibility:hidden; }
    /* Subtle drag hint overlay */
    .piano-keyboard .drag-hint { position:absolute; top:8px; left:50%; transform:translateX(-50%); font-size:12px; color:#cfe6ff; opacity:.18; pointer-events:none; transition: opacity .2s ease; }
    .piano-keyboard:hover .drag-hint { opacity:.28; }
    .piano-keyboard.is-dragging .drag-hint { opacity:.6; }
    @media (max-width: 900px){ }
        /* Ensure retro font everywhere */
        button, .root-btn, .extension-header, .control-panel, input, select, .edo-dot { font-family: var(--retro-font) !important; }
        /* Base circle key */
        .piano-keyboard .white-key.root-btn,
        .piano-keyboard .black-key.root-btn {
            position:absolute;
            width:35px;
            height:35px;
            z-index:2; /* keep keys above micro dots so labels (like B) remain visible */
            border-radius:50%;
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:11px;
            font-weight:bold;
            cursor:pointer;
            transform:translate(-50%, -50%);
            transition:filter .15s, transform .1s;
            box-shadow:0 4px 10px rgba(0,0,0,0.6), inset 0 -4px 6px rgba(0,0,0,0.4);
            opacity: 1 !important; /* Never fade keys */
        }
        .piano-keyboard .white-key.root-btn {
            background:radial-gradient(circle at 30% 30%, #ffffff, #d9d9d9 60%, #bdbdbd);
            color:#222;
            top:80%; /* Adjust for gap between white and black */
        }
        .piano-keyboard .white-key.root-btn.disabled { filter:grayscale(60%) brightness(0.8); opacity:1 !important; }
        .piano-keyboard .white-key.root-btn.active { outline:3px solid #ffd046; box-shadow:0 0 14px 4px rgba(255,208,70,0.7); }
        .piano-keyboard .black-key.root-btn {
            background:radial-gradient(circle at 30% 30%, #444, #111 65%, #000);
            color:#eee;
            top:20%; /* Adjust for gap between black and white */
            width:35px;
            height:35px;
        }
        .piano-keyboard .black-key.root-btn.disabled { filter:grayscale(60%) brightness(0.6); opacity:1 !important; }
        .piano-keyboard .black-key.root-btn.active { outline:3px solid #9d6bff; box-shadow:0 0 16px 4px rgba(157,107,255,0.8); }
        .piano-keyboard .white-key.root-btn:active, .piano-keyboard .black-key.root-btn:active { transform:translate(-50%, -50%) scale(.94); }
        .piano-keyboard .white-key.root-btn:hover, .piano-keyboard .black-key.root-btn:hover { filter:brightness(1.15); }

        .piano-keyboard .microtone-key.root-btn { display:none; }
        .piano-keyboard .microtone-key.root-btn span { pointer-events:none; }

        /* 96-EDO microtone dot system */
        .piano-keyboard .edo-dot {
            position:absolute;
            width:22px;
            height:22px;
            z-index:1; /* ensure dots don't obscure white/black key labels */
            border-radius:50%;
            transform:translateX(-50%);
            box-shadow:0 1px 3px rgba(0,0,0,0.6), inset 0 0 3px rgba(255,255,255,0.4);
            cursor:pointer;
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:9px;
            font-weight:bold;
            color:#fff;
            text-shadow:0 1px 2px rgba(0,0,0,0.9);
            padding:2px;
            box-sizing:border-box;
            opacity: 1 !important; /* Never fade dots */
        }
        .piano-keyboard .edo-dot.blue { background:radial-gradient(circle at 30% 30%, #6fa9ff, #2563eb 60%, #1e3a8a); }
        .piano-keyboard .edo-dot.green { background:radial-gradient(circle at 30% 30%, #5ef0b2, #0d9e6f 60%, #065f46); }
        .piano-keyboard .edo-dot.red { background:radial-gradient(circle at 30% 30%, #ff9a9a, #dc2626 60%, #7f1d1d); }
    .piano-keyboard .edo-dot.active { outline:2px solid #fff; box-shadow:0 0 10px 4px rgba(255,255,255,0.9); filter:brightness(1.2); }
    .piano-keyboard .edo-dot.red.active { box-shadow:0 0 12px 5px rgba(220,38,38,0.9),0 0 6px 3px rgba(255,255,255,0.8); }
    .piano-keyboard .edo-dot.green.active { box-shadow:0 0 12px 5px rgba(13,158,111,0.9),0 0 6px 3px rgba(255,255,255,0.8); }
    .piano-keyboard .edo-dot.blue.active { box-shadow:0 0 12px 5px rgba(37,99,235,0.9),0 0 6px 3px rgba(255,255,255,0.8); }
    /* Chord-builder selection glow (non-root) */
    .piano-keyboard .edo-dot.selected { outline:3px solid #f39c12; box-shadow:0 0 14px 5px rgba(243,156,18,0.85),0 0 6px 3px rgba(255,255,255,0.5); filter:brightness(1.15); }
        /* Vertical lanes (percent from top of keyboard height) */
    /* Updated vertical lane centers to match reference image (from top to bottom: black, blue, green, red, white) */
    .piano-keyboard .edo-lane-blue  { top:39%; }
    .piano-keyboard .edo-lane-green { top:52%; }
    .piano-keyboard .edo-lane-red   { top:65%; }

        /* ================================================================== */

        /* ================= Drum Grid (Skeleton) ================ */
    .drum-grid-container { display:block !important; width:100%; max-width:none; margin:0 auto; height:auto; min-height:400px; box-sizing:border-box; overflow-x:auto; overflow-y:visible; white-space:nowrap; scrollbar-width: thin; -ms-overflow-style: auto; }
    .drum-grid-container::-webkit-scrollbar { display: none; }
        .drum-grid-header { display:flex; align-items:center; gap:10px; margin:6px 0 8px 0; font-size:12px; color:#cfe6ff; }
    .drum-grid { display:grid; grid-template-rows: repeat(var(--npc-rows, 3), 1fr); gap:0px; height: auto; }
    .drum-row { display:grid; grid-template-columns: 88px 1fr 100px 120px 76px 170px; align-items:center; gap:4px; margin:0; }
        .drum-label { font-size:12px; color:#e0e8ff; opacity:.9; text-align:right; padding-right:6px; white-space:nowrap; }

    /* DRUMS REVAMP: collapsed row + gear drawer for the Drum Sequencer grid only */
    #drumGrid.drum-grid { display:flex; flex-direction:column; gap:6px; height:auto; }
    #drumGrid.drum-grid .drum-row { display:flex; flex-direction:column; gap:4px; margin:0; padding:0; }
    #drumGrid.drum-grid .drum-row-main { display:flex; align-items:center; gap:6px; width:100%; }
    #drumGrid.drum-grid .drum-gear { width:26px; height:22px; display:inline-flex; align-items:center; justify-content:center; background:#214051; color:#e8f5ff; border:1px solid #4a6870; border-radius:6px; font-size:13px; cursor:pointer; line-height:1; padding:0; flex:0 0 auto; }
    #drumGrid.drum-grid .drum-gear:hover { filter:brightness(1.15); }
    #drumGrid.drum-grid .drum-gear[aria-expanded="true"] { outline:2px solid #ffd046; outline-offset:1px; }
    /* Collapsed: hide label (dots dominate); MIDI stays visible per spec */
    #drumGrid.drum-grid .drum-row:not(.expanded) .drum-label { display:none; }
    #drumGrid.drum-grid .drum-row-main .drum-label { text-align:left; padding:0; min-width:70px; }
    #drumGrid.drum-grid .drum-row-main .drum-lane { flex:1 1 auto; min-width: calc(var(--bar-steps, 16) * var(--step-size, 22px)); }
    #drumGrid.drum-grid .drum-row-main .drum-midi { margin-left:4px; margin-right:4px; }
    #drumGrid.drum-grid .drum-row-main .drum-midi input { width:72px; }
    #drumGrid.drum-grid .drum-drawer { display:none; border:1px solid rgba(74,106,112,0.55); border-radius:8px; padding:6px 8px; background:rgba(42,72,88,0.18); }
    #drumGrid.drum-grid .drum-row.expanded .drum-drawer { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    #drumGrid.drum-grid .drum-drawer .drum-volume { width:120px; margin:0; }
    #drumGrid.drum-grid .drum-drawer .drum-send-wrap { min-width:170px; }
    #drumGrid.drum-grid .drum-drawer .drum-params { margin-left:0; }

    /* Drum FX panel (always visible in drum modal) */
    .drum-fx-panel { margin-top:10px; padding:10px; border:1px solid rgba(155,89,182,0.45); border-radius:10px; background:rgba(155,89,182,0.08); }
    .drum-fx-panel h5 { margin:0 0 8px 0; font-size:12px; color:#d7b8ff; letter-spacing:0.3px; }
    .drum-fx-grid { display:grid; grid-template-columns: repeat(5, minmax(120px, 1fr)); gap:8px; align-items:end; }
    .drum-fx-cell { display:flex; flex-direction:column; gap:4px; }
    .drum-fx-cell label { font-size:10px; color:#cfe6ff; opacity:.85; }
    .drum-fx-cell input[type="range"], .drum-fx-cell input[type="number"] { width:100%; }
    .drum-fx-mini { font-size:10px; opacity:.75; }
    @media (max-width: 980px) {
        .drum-fx-grid { grid-template-columns: repeat(2, minmax(140px, 1fr)); }
    }
    :root { --step-size: 22px; --bar-steps: 16; }
    /* Modal-scalable drum/pattern/bass dots (defaults can be overridden per modal) */
    #drumModal, #bassModal { --dot-size: 16px; --dot-gap: 4px; --tie-height: 12px; }
    /* Pattern modal defaults: sized for laptop/iPad so a 16x16 grid fits comfortably */
    #patternModal, .pattern-modal { --dot-size: 24px; --dot-gap: 2px; --tie-height: 18px; }
    /* Each lane spans the same bar width; cells are sized to fit D within that width */
    /* Lanes fill available width; steps stretch evenly. Ensure a reasonable minimum width so dots never bunch. */
    .drum-lane { position:relative; display:grid; grid-template-columns: repeat(var(--steps-per-bar, 16), minmax(0, 1fr)); gap:var(--dot-gap, 4px); height:max(20px, calc(var(--dot-size, 16px) + 4px)); align-items:center; justify-items:start; width:100%; min-width: calc(var(--bar-steps, 16) * var(--step-size, 22px)); }
                .drum-step { width:var(--dot-size, 16px); height:var(--dot-size, 16px); border-radius:50%; background:radial-gradient(circle at 30% 30%, #6886ff, #2b50ea 60%, #1c2b74); opacity:.33; cursor:pointer; transition:transform .08s ease, opacity .12s ease, box-shadow .12s ease, background .12s ease; }
                .drum-step.disabled { opacity:.18; filter:grayscale(60%); }
    .drum-step.active { opacity:1; box-shadow:0 0 10px 3px rgba(120,180,255,0.6); background:radial-gradient(circle at 30% 30%, #8fb3ff, #5a7dff 60%, #3148b3); }
        .drum-step:active { transform:scale(.9); }
        
        /* Velocity-based coloring: BLUE (quiet) -> RED (loud) */
        /* velocity 0-31 (quiet): blue/cyan - vel-quiet class */
        .drum-step.active.vel-quiet {
            background: radial-gradient(circle at 30% 30%, #40e0d0, #1e90ff 60%, #104578) !important;
            box-shadow: 0 0 10px 3px rgba(30, 144, 255, 0.6) !important;
        }
        /* velocity 32-63 (low): teal/green */
        .drum-step.active.vel-low {
            background: radial-gradient(circle at 30% 30%, #2dd4bf, #10b981 60%, #064e3b) !important;
            box-shadow: 0 0 10px 3px rgba(45, 212, 191, 0.6) !important;
        }
        /* velocity 64-95 (medium): yellow/orange */
        .drum-step.active.vel-mid {
            background: radial-gradient(circle at 30% 30%, #fde047, #f59e0b 60%, #78350f) !important;
            box-shadow: 0 0 10px 3px rgba(245, 158, 11, 0.6) !important;
        }
        /* velocity 96-127 (loud): red */
        .drum-step.active.vel-high {
            background: radial-gradient(circle at 30% 30%, #f87171, #ef4444 60%, #7f1d1d) !important;
            box-shadow: 0 0 10px 3px rgba(239, 68, 68, 0.6) !important;
        }
        /* Velocity drag active indicator */
        .drum-step.vel-dragging {
            outline: 2px solid #ffd046 !important;
            outline-offset: 2px;
        }
        /* Replace lane lines with dot-based beat emphasis */
        .drum-lane::before { display:none; }
        .drum-lane .beat-divider { display:none; }
        .drum-volume { width:100%; }
        .drum-send-wrap { display:flex; align-items:center; gap:6px; justify-content:flex-start; }
        .drum-send { width:100%; }
        .drum-fx { display:flex; align-items:center; gap:6px; font-size:10px; color:#9db6c8; justify-content:flex-start; }
        .drum-playhead { position:absolute; top:-7px; bottom:-7px; width:2px; background:#ffd046; opacity:.75; pointer-events:none; box-shadow:0 0 10px 2px rgba(255,208,70,0.6); transform:translateX(0); }
    .drum-fx { display:flex; align-items:center; gap:4px; justify-content:center; }
    .drum-midi { display:flex; align-items:center; gap:4px; justify-content:center; }
    .drum-midi input { width:72px; background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:2px 4px; font-size:11px; }
    .drum-params { display:flex; align-items:center; gap:6px; justify-content:flex-start; }
    .drum-params .mini { -webkit-appearance:none; appearance:none; height:16px; width:48px; background:#2a4858; border:1px solid #4a6870; border-radius:8px; outline:none; }
    .drum-params .mini::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; width:10px; height:10px; border-radius:50%; background:#ffd046; cursor:pointer; }
    .drum-params .mini::-moz-range-thumb { width:10px; height:10px; border:none; border-radius:50%; background:#ffd046; cursor:pointer; }
    .drum-params label { font-size:9px; color:#cfe6ff; opacity:.8; }
    /* Visual emphasis: steps 1,5,9,13 slightly larger and tinted */
    /* Beat guide: beats slightly bigger/brighter; 16th substeps slightly dimmer */
    .drum-step:not(.active):not(.beat-accent) { opacity: .24; }
    .drum-step.beat-accent { 
        transform: scale(1.12);
        box-shadow: 0 0 0 2px rgba(200,228,255,0.55) inset, 0 0 6px rgba(106,168,255,0.45);
        opacity: .48;
        z-index: 2;
    }
    .drum-step.beat-accent.active {
        /* Keep velocity colors; add accent ring + slight size */
        transform: scale(1.12);
        box-shadow: 0 0 0 2px rgba(210,235,255,0.70) inset, 0 0 10px 3px rgba(120,180,255,0.6);
        opacity: 1;
    }
        /* Bass row: show NPC text inside steps and selection ring */
        .drum-row.bass-row .drum-step::after { content: ''; } /* Hide NPC numbers in bass */
        .drum-row.bass-row .drum-step.selected { outline:2px solid #ffd046; outline-offset:1px; }

        /* Bass tie overlay pills (joined dots visual) */
        .drum-row.bass-row .drum-lane { position:relative; }
        .drum-row.bass-row .bass-tie-layer { position:absolute; inset:0; pointer-events:none; z-index:0; }
    .drum-row.bass-row .bass-tie-pill { position:absolute; top:50%; height:var(--tie-height, 12px); transform:translateY(-50%); border-radius:calc(var(--tie-height, 12px) * 0.6667); background:linear-gradient(90deg, rgba(143,179,255,0.7), rgba(90,125,255,0.7)); box-shadow:0 0 14px 3px rgba(120,180,255,0.55); }
        .drum-row.bass-row .drum-step { position:relative; z-index:1; }
        
        /* Pattern tie overlay pills (joined dots visual for harmonic pattern rows) */
    .drum-row.pattern-row .drum-lane { position:relative; grid-template-columns: repeat(var(--steps-per-bar, 16), minmax(0, 1fr)); width:100%; min-width: calc(var(--bar-steps, 16) * var(--step-size, 22px)); }
        .drum-row.pattern-row .pattern-tie-layer { position:absolute; inset:0; pointer-events:none; z-index:0; }
        .drum-row.pattern-row .pattern-tie-pill { position:absolute; top:50%; height:var(--tie-height, 12px); transform:translateY(-50%); border-radius:calc(var(--tie-height, 12px) * 0.6667); background:linear-gradient(90deg, rgba(255,179,143,0.7), rgba(255,125,90,0.7)); box-shadow:0 0 14px 3px rgba(255,150,100,0.55); }
        .drum-row.pattern-row .drum-step { position:relative; z-index:1; }
        
        /* Pattern grid pixel-tight styling (NPC x LEN grid) */
        /* IMPORTANT: allow the Pattern grid to be the full-height main area of the modal
           without stretching row heights (keep rows tight at the top). */
        #patternGrid, .pattern-grid {
            gap: 0 !important;
            height: 100% !important;
            width: 100% !important;
            overflow: auto !important;
            min-height: 0 !important;
            min-width: 0 !important;
            /* override .drum-grid default (1fr rows) so extra height doesn't create giant gaps */
            grid-template-rows: repeat(var(--npc-rows, 3), auto) !important;
            /* center the (tight) 16x16 pattern within available space */
            justify-content: center;
            align-content: center;
        }
        /* Pattern rows: keep controls inline; lane represents a full bar width */
        #patternGrid .drum-row.pattern-row, .pattern-grid .drum-row.pattern-row { display: flex !important; align-items: center; margin: 0 !important; padding: 0 !important; gap: 0 !important; min-height: max(16px, calc(var(--dot-size, 14px) + (var(--dot-gap, 1px) * 2))); height: max(16px, calc(var(--dot-size, 14px) + (var(--dot-gap, 1px) * 2))); width: fit-content !important; grid-template-columns: none !important; }
        #patternGrid .drum-row.pattern-row .drum-label, .pattern-grid .drum-row.pattern-row .drum-label { font-size: 9px; padding-right: 4px; min-width: 36px; text-align: right; display: none; }
        /* IMPORTANT: distribute dots across the full bar width.
           The lane width is based on --bar-steps (min 16) so fewer steps spread out.
           Each row sets --steps-per-bar to its per-row Q denominator D. */
        #patternGrid .drum-row.pattern-row .drum-lane, .pattern-grid .drum-row.pattern-row .drum-lane {
            height: max(16px, calc(var(--dot-size, 14px) + (var(--dot-gap, 1px) * 2)));
            display: grid !important;
            grid-template-columns: repeat(var(--steps-per-bar, 16), minmax(0, 1fr)) !important;
            align-items: center;
            /* Beat 1 is king: first dot starts exactly at the bar start */
            justify-items: start;
            gap: 0 !important;
            flex: 0 0 auto !important;
            min-width: calc(var(--bar-steps, 16) * (var(--dot-size, 14px) + (var(--dot-gap, 1px) * 2))) !important;
            width: calc(var(--bar-steps, 16) * (var(--dot-size, 14px) + (var(--dot-gap, 1px) * 2))) !important;
        }
        #patternGrid .drum-row.pattern-row .drum-lane::before, .pattern-grid .drum-row.pattern-row .drum-lane::before { display: none; }
        #patternGrid .drum-row.pattern-row .drum-step, .pattern-grid .drum-row.pattern-row .drum-step { width: var(--dot-size, 14px); height: var(--dot-size, 14px); margin: 0; justify-self: start; }
        /* PATTERN per-row controls (e.g. Q) must be visible */
        #patternGrid .drum-row.pattern-row .drum-params, .pattern-grid .drum-row.pattern-row .drum-params { display: inline-flex; align-items: center; gap: 6px; }
        /* Pattern modal: layout so either grid OR synth panel fills the available space */
        #patternModal, .pattern-modal { display: flex; flex-direction: column; }
        #patternModal .modal-body, .pattern-modal .modal-body {
            display: flex !important;
            flex-direction: column;
            flex: 1 1 auto;
            min-height: 0;
            overflow: hidden !important;
        }
        #patternModal .drum-grid-container, .pattern-modal .drum-grid-container {
            display: flex !important;
            flex-direction: column;
            flex: 1 1 auto;
            min-height: 0 !important;
            min-width: 0 !important;
            height: 100% !important;
            width: 100% !important;
            overflow: hidden !important;
            padding-bottom: 0 !important;
        }
        #patternModal .drum-grid-header, .pattern-modal .drum-grid-header { flex: 0 0 auto; }
        #tab-arp, .pattern-arp-panel {
            position: relative !important;
            left: auto !important;
            right: auto !important;
            bottom: auto !important;
            z-index: 20;
            flex: 1 1 auto;
            min-height: 0;
            min-width: 0;
            max-height: none !important;
            overflow: auto !important;
        }
        #patternSynthToggleBar, .pattern-synth-toggle-bar {
            position: relative !important;
            left: auto !important;
            right: auto !important;
            bottom: auto !important;
            height: 32px;
            display: flex !important;
            align-items: center;
            justify-content: flex-end;
            padding: 0 4px;
            pointer-events: auto !important;
        }
        
        @media (max-width: 640px){
            .drum-row { grid-template-columns: 70px 1fr 80px 60px; gap:4px; }
            .drum-label { font-size:10px; }
        }

        /* When drums grid is visible, increase its area and compress strings */
        body.drums-mode .root-notes-area { height: 352px; }
        body.drums-mode .strum-area { margin-top: 8px; }
        body.drums-mode .strings-column { max-height: calc(100vh - 468px); }

        /* Chord creation mode styles */
        .chord-creation-mode .root-notes-area {
            background: rgba(0, 60, 30, 0.9);
            border-color: #2E8B57;
        }

        .chord-creation-mode .root-notes-area::before {
            content: "?? Select intervals for your chord - Click root buttons to add/remove notes";
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #90EE90;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 8px;
            border-radius: 4px;
            z-index: 10;
        }

        .chord-creation-mode .root-btn {
            background: #2a4858;
            border-color: #4a6870;
        }

        .chord-creation-mode .root-btn:hover {
            background: #3a5868;
            border-color: #5a7880;
        }

        .chord-creation-mode .root-btn.selected {
            background: #e74c3c;
            border-color: #c0392b;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.7);
        }

        .chord-creation-mode .root-btn.preview {
            background: #f39c12;
            border-color: #e67e22;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        .chord-types-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .chord-types-selector .section-title {
            font-size: 12px;
            color: #8fb3d3;
            margin-right: 10px;
        }

        .quality-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .quality-selector .section-title {
            font-size: 12px;
            color: #8fb3d3;
            margin-right: 10px;
        }

        .volume-control {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4a6870;
            display: flex;
            flex-direction: column;
            gap: 12px;
            font-size: 11px;
        }


        .osc-btn {
            padding: 10px;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 6px;
            font-size: 11px;
            transition: all 0.2s;
            text-align: center;
            font-weight: bold;
        }

        /* Square, tappable oscillator shape buttons */
        .oscillator-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(54px, 1fr));
            gap: 8px;
        }
        .oscillator-controls .osc-btn {
            padding: 0 !important; /* override inline paddings */
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px !important;
            border-radius: 10px;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .osc-btn.active {
            background: #27ae60;
            border-color: #2ecc71;
            box-shadow: 0 0 8px rgba(39, 174, 96, 0.5);
        }

        .multi-osc-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 6px;
        }

        .osc-group {
            border: 1px solid rgba(74, 104, 112, 0.3);
            border-radius: 4px;
            padding: 6px;
        }

        .osc-group h5 {
            font-size: 8px;
            color: #8fb3d3;
            margin-bottom: 4px;
        }

        .osc-mix-controls {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }

        .effects-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .effect-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .effect-group label {
            font-size: 8px;
            color: #8fb3d3;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .slider-value {
            font-size: 9px;
            color: #bdc3c7;
            text-align: center;
        }

        @media (max-width: 768px) {
            .control-panel {
                height: 60px;
                padding: 5px;
                gap: 8px;
            }
            
            .tuning-btn {
                padding: 4px 6px;
                font-size: 10px;
            }
            
            .chord-header {
                height: 30px;
                font-size: 8px;
            }
            
            .note-labels {
                height: 25px;
                font-size: 7px;
            }
            
            .volume-control {
                min-width: 120px;
                max-width: 140px;
                padding: 6px;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            /* Compact top container for landscape */
            #topContainer {
                padding: 2px 4px;
                min-height: 35px;
            }
            
            #universalMenu {
                min-height: 30px;
                gap: 2px;
            }
            
            /* Ultra-compact universal menu buttons for landscape */
            #universalMenu .panel-btn,
            #universalMenu input,
            #universalMenu select {
                font-size: 8px;
                padding: 2px 4px;
                height: 24px;
                min-width: 0;
            }
            
            #edoQuickInput {
                width: 32px !important;
                font-size: 8px !important;
            }
            
            .control-panel {
                height: 50px;
                padding: 3px;
            }
            
            .chord-header {
                height: 25px;
                font-size: 7px;
            }
            
            .note-labels {
                height: 20px;
                font-size: 6px;
            }
            
            /* Keep string sizing driven by runtime layout vars */
        }

        /* Tablet-specific adjustments for better string visibility */
        @media (min-width: 769px) and (max-width: 1024px) {
            /* Keep string sizing driven by runtime layout vars */
        }

        /* Mobile portrait: Compact layout with menu optimization */
        @media (orientation: portrait) and (max-width: 768px) {
            /* Compact menu for mobile portrait */
            #topContainer {
                padding: 6px 12px !important; /* Reduce padding to minimize blue space */
                top: 20px !important; /* Closer to top */
            }
            
            #universalMenu {
                gap: 3px; /* Tighter spacing */
                min-height: auto;
            }
            
            /* Force body padding adjustment for reduced header */
            body {
                padding-top: calc(100px + env(safe-area-inset-top)) !important;
            }
            
            /* Adjust instrument container for smaller header */
            .instrument {
                margin-top: 90px !important; /* Less space for smaller header */
                height: calc(100vh - 90px);
            }
            /* Fix body padding for mobile */
            body {
                padding-top: calc(env(safe-area-inset-top) + 10px); /* Minimal top padding */
                overflow-y: auto; /* Allow scrolling if needed */
            }
            
            /* Fix top container positioning */
            #topContainer {
                position: fixed; /* Fixed positioning to stay at top */
                top: env(safe-area-inset-top);
                left: 0;
                right: 0;
                z-index: 1000;
                padding: 6px 8px;
                min-height: auto; /* Let content determine height */
                background: rgba(26, 26, 46, 0.95); /* Semi-transparent background */
                backdrop-filter: blur(10px);
                border-bottom: 1px solid #4a6870;
            }
            
            #universalMenu {
                display: flex;
                flex-wrap: wrap;
                gap: 4px; /* Increased gap for better spacing */
                align-items: flex-start;
                justify-content: flex-start;
                line-height: 1.2;
            }
            
            /* Row-based mobile layout - 3 clean rows with narrower buttons */
            .mobile-row-1 {
                order: 1;
                flex-basis: calc(14.28% - 3px); /* 7 items per row, narrower buttons */
                margin-bottom: 3px;
            }
            
            .mobile-row-2 {
                order: 2;
                flex-basis: calc(14.28% - 3px); /* 7 items per row, narrower buttons */
                margin-bottom: 3px;
            }
            
            .mobile-row-3 {
                order: 3;
                flex-basis: calc(14.28% - 3px); /* 7 items per row, narrower buttons */
                margin-bottom: 3px;
            }
            
            /* Make all universal menu buttons consistent for mobile - narrower */
            #universalMenu .panel-btn,
            #universalMenu input,
            #universalMenu select,
            #universalMenu div {
                font-size: 9px !important; /* Smaller font */
                padding: 4px 6px !important; /* Less padding */
                min-width: 0;
                height: 28px; /* Shorter height */
                border-radius: 4px;
            }
            
            /* Preserve active states for mobile buttons */
            #universalMenu .panel-btn.active {
                background: #0ea5e9 !important;
                color: #05222b !important;
                border-color: #0284c7 !important;
                box-shadow: 0 0 10px 2px rgba(56, 189, 248, 0.7), 0 0 18px 6px rgba(14, 165, 233, 0.5) !important;
            }
            
            /* Preserve mode button active states */
            #universalMenu .mode-btn.active,
            .mode-btn.active {
                background: #3498db !important;
                border-color: #2980b9 !important;
                color: #ffffff !important;
                box-shadow: 0 0 8px rgba(52, 152, 219, 0.5) !important;
            }
            
            /* Special sizing for specific elements */
            #universalMenu input[type="number"] {
                width: 45px !important;
            }
            
            #universalMenu select {
                width: auto !important;
                min-width: 60px !important;
            }
            
            /* Ensure labels are readable */
            #universalMenu label {
                font-size: 9px !important;
                color: #9db6c8 !important;
            }
            
            /* Hide duplicate keyboard toggle in keyboard section for mobile */
            #keyboardToggle {
                display: none !important;
            }
            #keyboardToggle + label {
                display: none !important;
            }
            div[style*="KEYBOARD"] {
                display: none !important;
            }
            
            /* Hide master volume control in portrait mode - use phone volume instead */
            .mobile-row-6[style*="margin-left:auto"] {
                display: none !important;
            }
            
            /* Fix help and bells buttons - prevent stretching */
            #tutorialButton, #bellsButton {
                flex-basis: calc(14.28% - 2px) !important;
                width: auto !important;
                min-width: 32px !important;
                height: 28px !important;
                padding: 4px !important;
                font-size: 12px !important;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                border-radius: 4px;
                margin-bottom: 3px;
            }
            
            #universalMenu label {
                font-size: 8px !important;
            }
            
            /* EDO input specifically */
            #edoQuickInput {
                width: 35px !important;
                font-size: 9px !important;
            }
            
            /* Adjust instrument to account for fixed header */
            .instrument {
                margin-top: 120px; /* Space for fixed header */
                height: calc(100vh - 120px);
            }
            
            /* Mode buttons positioning for mobile */
            .root-notes-selector {
                padding-top: 10px !important;
            }
            
            /* Adjust transpose and mode buttons for mobile */
            .transpose-controls-left {
                left: 5px !important;
                top: 60px !important; /* Center with green keyboard keys */
            }
            
            .transpose-controls-left button {
                width: 28px !important;
                height: 28px !important;
                font-size: 14px !important;
            }
            
            /* Mode buttons for mobile */
            .root-notes-selector > div:nth-child(2) {
                left: 40px !important;
                top: 60px !important; /* Center with green keyboard keys */
            }
            
            .root-notes-selector > div:nth-child(2) button {
                width: 60px !important;
                padding: 4px 6px !important;
                font-size: 9px !important;
            }
            
            /* Keyboard toggle for mobile */
            .root-notes-selector > div:nth-child(3) > div {
                left: 120px !important;
                top: 5px !important;
            }
            
            /* Piano keyboard grid responsive - bring up and center on F# */
            .root-chord-grid {
                margin-top: 20px !important; /* Bring keyboard up to be visible */
                max-width: 95% !important;
                padding: 0 5px; /* Move left by reducing left padding */
                transform: translateX(-15px); /* Shift entire keyboard left */
            }
            
            /* Chord columns responsive */
            .extension-columns {
                padding: 10px 5px;
                /* Timeline mode: keep a single row; allow horizontal scroll when needed */
                flex-wrap: nowrap;
                overflow-x: auto;
                overflow-y: hidden;
                max-height: none;
            }
            
            /* Force 2-row layout when more than 8 chords in vertical */
            .extension-columns:has(.extension-column:nth-child(9)) {
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                align-content: flex-start;
            }
            
            .extension-column {
                margin: 0 2px 4px 2px; /* Add bottom margin for multiple rows */
                min-width: 60px;
                flex: var(--len16, 16) 1 0px;
            }
            
            /* String area adjustments */
            .strum-area {
                padding-top: 10px;
            }
            
            .chord-header {
                height: 25px;
                font-size: 9px;
                padding: 3px;
            }
            
            .note-labels {
                height: 20px;
                font-size: 7px;
            }
            
            /* Ensure chord box bottom is visible */
            .strings-column {
                max-height: none;
                overflow-y: hidden;
            }
            
            /* XENON footer adjustments */
            #brandFooter {
                font-size: 12px !important;
                /* Preserve safe-area inset even when overriding padding on mobile */
                padding: 4px 8px calc(4px + env(safe-area-inset-bottom)) 8px !important;
                box-sizing: border-box;
            }
        }
        
        /* Left Sidebar Styles */
        .left-sidebar {
            position: fixed;
            left: 0;
            top: 0; /* Start from top since no transport row */
            width: 80px;
            height: 100vh; /* Full height */
            background: #000000; /* Black background for clean modal layer */
            border-right: 2px solid #333333; /* Dark gray border instead of blue */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 8px 20px 8px; /* Reduced top padding; transpose cluster now sticky at top */
            gap: 8px;
            z-index: 1000;
            overflow-y: auto;
        }
        
        .sidebar-btn {
            width: 64px;
            height: 40px; /* Smaller height for more buttons */
            background: linear-gradient(145deg, #2a4858, #1e3544);
            border: 1px solid #4a6870;
            border-radius: 8px;
            color: #e8f5ff;
            font-size: 9px; /* Smaller font */
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .sidebar-btn:hover {
            background: linear-gradient(145deg, #3a5868, #2e4554);
            border-color: #6a8890;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }
        
        .sidebar-btn.active {
            background: linear-gradient(145deg, #4a90e2, #357abd);
            border-color: #5aa3f0;
            color: #ffffff;
            box-shadow: 0 0 12px rgba(74, 144, 226, 0.5);
        }
        
        .sidebar-btn.active:hover {
            background: linear-gradient(145deg, #5aa3f0, #4080cd);
        }
        
        /* Main content offset for sidebar */
        .main-content {
            margin-left: 80px;
            min-height: calc(100vh - 22px); /* Account for transport row */
            background: linear-gradient(135deg, #0f1419 0%, #1a1a2e 35%, #16213e 100%);
        }
        
        /* Floating Modal Styles */
        .floating-modal {
            position: fixed;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border: 3px solid #4a90e2;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.8), 0 0 20px rgba(74, 144, 226, 0.3);
            z-index: 2000;
            display: none;
            min-width: 100px; /* Allow scaling down to 100x100 */
            min-height: 100px;
            resize: both;
            overflow: auto;
            /* Support extreme scaling */
            font-size: calc(max(8px, min(14px, 1.2vw))); /* Scale font size with viewport */
        }

        /* Pattern/Drum/Bass modals: fixed aspect ratio + custom resize handle */
        #patternModal, #drumModal, #bassModal, .pattern-modal {
            resize: none;
            aspect-ratio: var(--modal-aspect, 4 / 3);
            overflow: hidden;
        }

        .modal-resize-handle {
            position: absolute;
            right: 6px;
            bottom: 6px;
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.3);
            background: linear-gradient(145deg, rgba(74,144,226,0.9), rgba(53,122,189,0.9));
            box-shadow: 0 1px 4px rgba(0,0,0,0.4);
            cursor: nwse-resize;
            z-index: 5;
            touch-action: none;
        }
        
        /* Scale modal content at small sizes */
        .floating-modal[style*="width: 100px"], .floating-modal[style*="width: 1"], 
        .floating-modal[style*="height: 100px"], .floating-modal[style*="height: 1"] {
            font-size: 6px;
        }
        
        /* Make buttons and controls scale down proportionally */
        .floating-modal .osc-btn, .floating-modal .synth-slider {
            min-width: 30px;
            min-height: 20px;
            font-size: inherit;
            padding: 2px 4px;
        }
        
        .modal-header {
            background: linear-gradient(90deg, #4a6870, #3a5860);
            padding: 8px 12px;
            border-radius: 10px 10px 0 0;
            cursor: move !important; /* Always show move cursor */
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #e8f5ff;
            font-weight: bold;
            font-size: 12px;
            touch-action: none; /* Enable touch dragging */
            user-select: none; /* Prevent text selection during drag */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .modal-close {
            background: #e74c3c;
            border: none;
            border-radius: 4px;
            color: white;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-body {
            padding: 16px;
            color: #e8f5ff;
        }
        
        /* Additional mobile styles */
        @media (max-width: 480px) {
            .left-sidebar {
                width: 60px;
                padding: 10px 4px;
            }
            .sidebar-btn {
                width: 52px;
                height: 40px;
                font-size: 9px;
            }
            .main-content {
                margin-left: 60px;
            }
            .extension-columns {
                margin-bottom: 80px; /* Space above XENON menu bar */
            }
            
            .string {
                min-height: 1px;
                height: auto;
                margin: 0;
                flex: 0 0 var(--string-row, auto);
                height: var(--string-row, auto);
            }
            
            .string-core {
                height: clamp(var(--string-min, 1px), 100%, var(--string-max, 30px));
                min-height: 1px;
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 12000;
        }

        .modal-content {
            background: #2a2a2a;
            color: white;
            padding: 20px;
            border-radius: 10px;
            width: min(96vw, 900px);
            max-height: 94vh;
            overflow-y: auto; /* allow scroll if truly needed */
            scrollbar-width: none; /* hide scrollbar in Firefox */
            border: 2px solid #666;
        }
        .modal-content::-webkit-scrollbar { display: none; } /* hide scrollbar in WebKit */

        .add-column-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .add-chord-btn {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .add-chord-btn:hover {
            background: linear-gradient(135deg, #357abd, #2868a3);
            transform: translateY(-2px);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        /* Tutorial System Styles */

    /* TIME modal compact styles */
    #timeModal .modal-content { width: min(92vw, 520px); }
    #timeModal label { font-size:11px; color:#9db6c8; }

        #tutorialOverlay {
            backdrop-filter: blur(2px);
        }

        /* Mobile/touch optimizations */
        @media (hover: none), (pointer: coarse) {
            .osc-btn { min-height: 44px; padding: 10px 12px; font-size: 12px; }
            .synth-slider { height: 28px; }
            .slider-value { font-size: 11px !important; }
            .effect-group label, .section-title { font-size: 13px; }
        }
        .synth-slider::-moz-range-thumb { width: 22px; height: 22px; }

        @media (max-width: 768px) {
            /* Stack dense grids for small screens to avoid horizontal scroll */
            .panel-content { grid-template-columns: 1fr !important; gap: 12px; }
            .modal-content { width: 96vw; max-height: 94vh; }
        }

    #tutorialBox {
            max-height: 88vh;
            overflow-y: auto;
            position: fixed !important;
            top: calc(var(--bar-h) + env(safe-area-inset-top) + 6px) !important;
            left: 50% !important;
        }

    #tutorialButton, #bellsButton { transition: transform 0.3s ease, box-shadow 0.3s ease; }

        #tutorialButton:hover, #bellsButton:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        /* Add pulsing animation for tutorial and dice buttons */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(143, 179, 211, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(143, 179, 211, 0); }
            100% { box-shadow: 0 0 0 0 rgba(143, 179, 211, 0); }
        }

        #tutorialButton {
            animation: pulse 2s infinite;
        }

        @keyframes diceRoll {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(720deg); }
        }

        /* Drag & drop chord boxes */
        .extension-column.dragging {
            opacity: 0.98;
            cursor: grabbing;
        }
        .extension-column.placeholder {
            background: rgba(255,255,255,0.06);
        }
        .extension-column.delete-intent .extension-header {
            background: #8b1e1e !important;
            border-color: #ef4444 !important;
        }

        /* Flash highlight for call-to-action buttons */
        @keyframes flashCTA {
            0% { box-shadow: 0 0 0 0 rgba(80, 200, 120, 0.85); transform: translateZ(0); }
            50% { box-shadow: 0 0 0 10px rgba(80, 200, 120, 0); }
            100% { box-shadow: 0 0 0 0 rgba(80, 200, 120, 0); }
        }
        .flash-cta {
            animation: flashCTA 1.8s ease-out infinite;
        }
        .flash-cta-alt {
            animation: flashCTA 2.2s ease-out infinite;
        }

        /* Lightweight tooltip bubble */
        .hint-bubble {
            position: absolute;
            z-index: 1000;
            background: #0f2a3a;
            color: #dff3ff;
            border: 1px solid #2b5567;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 12px;
            white-space: nowrap;
            box-shadow: 0 6px 18px rgba(0,0,0,0.35);
            pointer-events: none;
        }

        .empty-chord-splash {
            padding: 16px 22px;
            border-radius: 12px;
            border: 1px solid rgba(124,201,255,0.35);
            background: rgba(13, 41, 56, 0.65);
            box-shadow: 0 10px 28px rgba(0,0,0,0.4);
            color: #e8f5ff;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 0.6px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }
        .empty-chord-splash:hover {
            transform: translateY(-1px);
            border-color: rgba(255, 214, 110, 0.7);
            box-shadow: 0 14px 34px rgba(0,0,0,0.5);
        }

        /* CALC (Chord Calculator) */
        #keyboardModal { overflow: hidden; aspect-ratio: 760 / 520; }
        #keyboardModal .modal-body { overflow: hidden; }
        #keyboardModal .calc-layout {
            width: var(--calc-base-w, 760px);
            height: var(--calc-base-h, 460px);
            transform: scale(var(--calc-scale, 1));
            transform-origin: top left;
        }
        .calc-layout { display:grid; grid-template-columns: minmax(280px, 1fr) 320px; gap: 14px; height: 100%; }
        .calc-left { display:flex; flex-direction:column; gap: 10px; min-width: 0; }
        .calc-display {
            background: rgba(13, 24, 34, 0.9);
            border: 1px solid rgba(124,201,255,0.35);
            border-radius: 10px;
            padding: 10px 12px;
            box-shadow: inset 0 0 12px rgba(0,0,0,0.35);
        }
        .calc-display .calc-title { font-size: 11px; color: #9db6c8; letter-spacing: 1px; text-transform: uppercase; }
        .calc-display .calc-name { font-size: 20px; font-weight: 800; color: #e8f5ff; margin-top: 4px; }
        .calc-display .calc-tokens { font-size: 12px; color: #7fb2d6; margin-top: 4px; min-height: 16px; }

        .calc-group { background: rgba(10, 24, 34, 0.65); border: 1px solid rgba(74,106,112,0.45); border-radius: 10px; padding: 8px; }
        .calc-group-title { font-size: 11px; color: #9db6c8; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.6px; }
        .calc-row { display:grid; grid-template-columns: repeat(4, minmax(46px, 1fr)); gap: 6px; }
        .calc-row.tight { grid-template-columns: repeat(6, minmax(42px, 1fr)); }
        .calc-grid { display:grid; grid-template-columns: 1fr; gap: 8px; }
        .calc-grid.root { grid-template-columns: 1fr; }
        .calc-grid.quality { grid-template-columns: repeat(3, minmax(80px, 1fr)); }
        .calc-note-row { display:flex; gap: 6px; }
        .calc-note-seg { flex: 1; padding: 6px 4px; }
        .calc-note-seg.center { flex: 2.2; font-size: 13px; }
        .calc-note-seg.acc { font-size: 12px; opacity: 0.95; }
        .calc-micro-row { display:flex; gap: 6px; grid-column: 1 / -1; }
        .calc-micro-btn { flex: 1; }
        .calc-keypad-actions { display:grid; grid-template-columns: repeat(3, minmax(90px, 1fr)); gap: 8px; margin-top: 10px; }
        .calc-btn {
            background: #1a2f3c;
            color: #e8f5ff;
            border: 1px solid #2b5567;
            border-radius: 8px;
            padding: 6px 4px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            text-align: center;
            transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease;
        }
        .calc-btn.active { background: #f39c12; border-color: #e67e22; color: #111; }
        .calc-btn.mod { background: #1f3a4a; }
        .calc-btn.action { background: #214051; border-color: #4a6870; }
        .calc-btn:hover { transform: translateY(-1px); box-shadow: 0 6px 14px rgba(0,0,0,0.35); }

        .calc-actions { display:flex; gap: 8px; flex-wrap: wrap; }

        .calc-preview { display:flex; flex-direction:column; gap: 8px; }
        .calc-preview-label { font-size: 12px; color: #9db6c8; text-transform: uppercase; letter-spacing: 0.6px; }
        .calc-preview-column { height: 100%; min-height: 220px; border: 2px dashed rgba(80,200,255,0.35); background: rgba(15, 26, 36, 0.65); }
        .calc-preview-hint { font-size: 11px; color: #7fb2d6; text-align: center; opacity: 0.8; }
        @media (max-width: 720px) {
            .calc-layout { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <!-- Floating Transport Modal -->
    <div id="transportModal" style="position:fixed;top:20px;right:20px;background:rgba(0,0,0,0.95);border:2px solid #333333;border-radius:12px;padding:20px;display:flex;align-items:center;gap:15px;z-index:12000;backdrop-filter:blur(8px);box-shadow:0 8px 32px rgba(0,0,0,0.8);">
        <button id="playStopTransportBtn" style="width:60px;height:48px;background:#27ae60;border:2px solid #2ecc71;border-radius:8px;color:#fff;font-size:24px;cursor:pointer;display:flex;align-items:center;justify-content:center;">â–¶</button>
        <div id="countInDisplay" style="min-width:42px;height:48px;display:none;align-items:center;justify-content:center;background:#111827;border:2px solid #334155;border-radius:10px;color:#e8f5ff;font-weight:900;font-size:20px;letter-spacing:1px;">1</div>
        <label style="display:flex;align-items:center;gap:8px;color:#e8f5ff;font-size:14px;font-weight:bold;">
            <input id="loopToggle" type="checkbox" style="transform:scale(1.2);" checked> LOOP
        </label>
        <label style="display:flex;align-items:center;gap:8px;color:#e8f5ff;font-size:14px;font-weight:bold;">
            BPM <input id="transportBpm" type="number" min="20" max="300" value="120" style="width:60px;height:32px;background:#1a1a2e;color:#fff;border:2px solid #4a6870;border-radius:6px;font-size:14px;padding:4px 8px;text-align:center;">
        </label>
        <label style="display:flex;align-items:center;gap:8px;color:#e8f5ff;font-size:14px;font-weight:bold;">
            EDO <input id="edoQuickInputTransport" type="number" min="5" max="53" value="24" title="Steps per octave" style="width:50px;height:32px;background:#1a1a2e;color:#fff;border:2px solid #4a6870;border-radius:6px;font-size:14px;padding:4px 6px;text-align:center;">
        </label>
        <label style="display:flex;align-items:center;gap:8px;color:#e8f5ff;font-size:14px;font-weight:bold;">
            VOL <input id="transportMasterVolume" type="range" min="0" max="10" value="10" style="width:80px;height:32px;" title="Master Volume">
        </label>
    </div>
    <!-- Top control bar (moved from bottom); uses CSS var --bar-h and safe-area insets -->
    <div id="bottomBar" style="position:fixed;top:0;left:0;right:0;height:var(--bar-h);display:none;align-items:center;justify-content:flex-start;gap:14px;padding:0 calc(18px + env(safe-area-inset-right)) 0 calc(18px + env(safe-area-inset-left));background:#000000;border-bottom:2px solid #333333;z-index:9600;font-family:var(--retro-font);">
        <!-- Centered brand -->
    </div>
    
    <!-- Bottom brand footer bar -->
    <div id="brandFooter" style="position:fixed;left:0;right:0;bottom:0;min-height:28px;background:#000000;border-top:1px solid #333333;display:flex;align-items:center;justify-content:center;z-index:1000;box-sizing:border-box;padding-bottom:env(safe-area-inset-bottom);">
        <a id="brandLink" href="https://fastfast.bandcamp.com/" target="_blank" rel="noopener noreferrer" style="color:#e8f5ff;text-decoration:none;font-weight:700;letter-spacing:1px;font-size:14px;text-decoration:none;">XENON</a>
    </div>
    <div id="topContainer" style="display:none;">
        <!-- Universal permanent top menu -->
        <div id="universalMenu" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
            <!-- ROW 1: + EDO OSC FX SEQ PLAY -->
            <button id="createNewChordBtn" class="panel-btn mobile-row-1" title="Add Chord" style="font-weight:bold;">+</button>
            <button id="insertLeftBracketBtn" class="panel-btn mobile-row-1" title="Insert [ start repeat" style="font-weight:bold;">[</button>
            <button id="insertRightBracketBtn" class="panel-btn mobile-row-1" title="Insert ] / ]xN end repeat" style="font-weight:bold;">]</button>
            <div class="mobile-row-1" style="display:flex;align-items:center;gap:6px;">
                <span style="font-size:12px;color:#9db6c8;">EDO</span>
                <input id="edoQuickInput" type="number" min="5" max="53" value="24" title="Steps per octave" style="width:56px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:4px 6px;font-size:13px;" />
            </div>
            <button class="panel-btn mobile-row-1" data-panel="osc" title="Oscillator settings">OSC</button>
            <button class="panel-btn mobile-row-1" data-panel="fx" title="Effects">FX</button>
                    <button id="openTextChordParserBtn" class="panel-btn mobile-row-1" title="Type or paste a chord sequence" style="display:none;">SEQ</button>
            <button id="playStopToggleBtn" class="panel-btn mobile-row-1" title="Play/Stop sequence" style="background:#27ae60;border-color:#2ecc71;">PLAY</button>
            <!-- TIME button removed; its controls are now embedded in DRUMS header -->
            
            <!-- TIME submenu moved to modal -->
            
            <!-- ROW 3: KBD, SAVE XEN, LOAD XEN, BELLS, ? (PRESET button removed in favor of full-session XEN save) -->
            <!-- Keyboard toggle first in row 3 -->
            <div class="mobile-row-3" style="display:flex;align-items:center;gap:6px;">
                <label style="font-size:11px;color:#9db6c8;">KBD</label>
                <input id="keyboardToggleMenu" type="checkbox" title="Show/Hide Piano Keyboard" checked />
            </div>
            
            <!-- PRESET button removed (all state now captured by SAVE XEN). Sequence preset logic still accessible via advanced panels. -->
            <button id="bottomExportOMGBtn" class="panel-btn mobile-row-3" title="Export full session (.XEN)" style="background:#10b981;border-color:#34d399;">SAVE XEN</button>
            <button id="bottomImportOMGBtn" class="panel-btn mobile-row-3" title="Import .XEN session" style="background:#9b59b6;border-color:#8e44ad;">LOAD XEN</button>
            <button id="bellsButton" class="panel-btn mobile-row-3" title="Open JAM">JAM</button>
            <button id="tutorialButton" class="panel-btn mobile-row-3" title="Start Tutorial">?</button>
            
            <!-- MASTER slider moved to main menu line -->
            <div class="mobile-row-6" style="display:flex;align-items:center;gap:6px;margin-left:auto;">
                <label for="masterVolume" style="font-size:12px;color:#9db6c8;">MASTER</label>
                <input type="range" id="masterVolume" min="0" max="10" value="10" style="width:120px; accent-color:#2d9c5d;">
                <span id="masterVolumeValue" style="font-size:11px; color:#b7d4e6; width:40px; text-align:right;">100%</span>
            </div>
        </div>
    </div>

    <div style="padding-top:0px;"> <!-- No extra padding needed now -->
    </div>
    </div>
    <!-- TIME modal removed -->
    <!-- Floating FX Modal (reuses original FX panel content) -->
    <div id="fxModal" class="floating-modal" style="top:120px; left:160px; width:417px; height:846px; display:none; overflow:hidden;">
        <div class="modal-header">
            <span>Effects</span>
            <div style="display:flex; gap:6px; align-items:center;">
                <button id="closeFxModal" class="modal-close" style="background:#e74c3c;">Ã—</button>
            </div>
        </div>
        <div class="modal-body" style="height:calc(100% - 44px); overflow:hidden; padding:14px;">
            <div class="synth-section" id="effectsSection" style="padding:0 4px 8px 4px; overflow:hidden;">
                <h4 style="font-size:15px; margin-bottom:8px; color:#9b59b6;">Effects</h4>
                <div id="effectsPresetsBar" style="display:flex; align-items:center; gap:8px; margin:6px 0 10px 0;">
                    <label for="effectsPresetSelect" style="font-size:12px; color:#8fb3d3;">Preset</label>
                    <select id="effectsPresetSelect" style="background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:6px 8px; min-width:200px;"></select>
                    <button class="osc-btn" id="effectsPresetApply" title="Apply selected FX" style="background:#3498db; border-color:#2980b9;">Apply</button>
                    <button class="osc-btn" id="effectsPresetSave" title="Save current FX as preset" style="background:#10b981; border-color:#059669;">Save</button>
                    <button class="osc-btn" id="effectsPresetDelete" title="Delete selected FX preset" style="background:#e74c3c; border-color:#c0392b;">Delete</button>
                </div>
                <div style="margin-bottom:10px;">
                    <label style="font-size:15px; color:#e67e22;">Drive</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Amount</label>
                            <input type="range" class="synth-slider" id="driveAmount" min="0" max="100" value="0" style="height:20px;">
                            <div class="slider-value" id="driveAmountValue" style="font-size:9px;">0%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Mix</label>
                            <input type="range" class="synth-slider" id="driveMix" min="0" max="100" value="0" style="height:20px;">
                            <div class="slider-value" id="driveMixValue" style="font-size:9px;">0%</div>
                        </div>
                    </div>
                    <!-- Drive per-effect tone controls -->
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px; margin-top:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">HP Cut</label>
                            <input type="range" class="synth-slider" id="driveHpCutoff" min="0" max="100" value="0" style="height:20px;">
                            <div class="slider-value" id="driveHpCutoffValue" style="font-size:9px;">off</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">LP Cut</label>
                            <input type="range" class="synth-slider" id="driveLpCutoff" min="0" max="100" value="100" style="height:20px;">
                            <div class="slider-value" id="driveLpCutoffValue" style="font-size:9px;">off</div>
                        </div>
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <label style="font-size:15px; color:#f59e0b;">Delay</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Time</label>
                            <input type="range" class="synth-slider" id="delayTime" min="0" max="1000" value="280" style="height:20px;">
                            <div class="slider-value" id="delayTimeValue" style="font-size:9px;" contenteditable="true" title="Type ms or musical token (e.g., 1/4). Hold Shift while dragging for fine ms.">280ms</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Feedback</label>
                            <input type="range" class="synth-slider" id="delayFeedback" min="0" max="95" value="25" style="height:20px;">
                            <div class="slider-value" id="delayFeedbackValue" style="font-size:9px;">25%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">LP Cut</label>
                            <input type="range" class="synth-slider" id="delayLpCutoff" min="0" max="100" value="73" style="height:20px;">
                            <div class="slider-value" id="delayLpCutoffValue" style="font-size:9px;">6kHz</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">HP Cut</label>
                            <input type="range" class="synth-slider" id="delayHpCutoff" min="0" max="100" value="0" style="height:20px;">
                            <div class="slider-value" id="delayHpCutoffValue" style="font-size:9px;">off</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Mix</label>
                            <input type="range" class="synth-slider" id="delayMix" min="0" max="100" value="0" style="height:20px;">
                            <div class="slider-value" id="delayMixValue" style="font-size:9px;">0%</div>
                        </div>
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <label style="font-size:15px; color:#2ecc71;">Filters</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Cutoff (LP â†” HP)</label>
                            <!-- Dual-handle filter edges: left = HP edge, right = LP edge (log scale) -->
                            <div style="display:flex; gap:8px; align-items:center; width:100%">
                                <div style="flex:1">
                                    <input type="range" class="synth-slider" id="filterLow" min="0" max="100" value="0" style="height:20px;">
                                    <div class="slider-value" id="filterLowValue" style="font-size:9px;">HP 20Hz</div>
                                </div>
                                <div style="flex:1">
                                    <input type="range" class="synth-slider" id="filterHigh" min="0" max="100" value="100" style="height:20px;">
                                    <div class="slider-value" id="filterHighValue" style="font-size:9px;">LP 20kHz</div>
                                </div>
                            </div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Resonance (Q)</label>
                            <input type="range" class="synth-slider" id="filterRes" min="0.1" max="20" step="0.1" value="1" style="height:20px;">
                            <div class="slider-value" id="filterResValue" style="font-size:9px;">Q 1.0</div>
                        </div>
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <label style="font-size:15px; color:#9b59b6;">Reverb</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Wet</label>
                            <input type="range" class="synth-slider" id="reverbWet" min="0" max="10" value="1" style="height:20px;">
                            <div class="slider-value" id="reverbWetValue" style="font-size:9px;">10%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Room</label>
                            <input type="range" class="synth-slider" id="reverbRoom" min="0" max="10" value="5" style="height:20px;">
                            <div class="slider-value" id="reverbRoomValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Decay</label>
                            <input type="range" class="synth-slider" id="reverbDecay" min="0" max="100" value="20" style="height:20px;">
                            <div class="slider-value" id="reverbDecayValue" style="font-size:9px;">2.0s</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">LP Cut</label>
                            <input type="range" class="synth-slider" id="reverbFilterCutoff" min="0" max="100" value="70" style="height:20px;">
                            <div class="slider-value" id="reverbFilterCutoffValue" style="font-size:9px;">8kHz</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">HP Cut</label>
                            <input type="range" class="synth-slider" id="reverbHpCutoff" min="0" max="100" value="0" style="height:20px;">
                            <div class="slider-value" id="reverbHpCutoffValue" style="font-size:9px;">off</div>
                        </div>
                    </div>
                </div>
                <div>
                    <label style="font-size:15px; color:#e74c3c;">Panning</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Mode</label>
                            <select id="panningMode" style="width:100%; padding:3px; background:#2a4858; color:#fff; border:1px solid #4a6870; border-radius:3px; font-size:10px; height:24px;">
                                <option value="center">Center</option>
                                <option value="frequency">Freq</option>
                                <option value="random">Random</option>
                                <option value="rotating">Rotate</option>
                                <option value="alternating">Alt</option>
                            </select>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Width</label>
                            <input type="range" class="synth-slider" id="panningWidth" min="0" max="100" value="80" style="height:20px;">
                            <div class="slider-value" id="panningWidthValue" style="font-size:9px;">80%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Speed</label>
                            <input type="range" class="synth-slider" id="panningSpeed" min="200" max="10000" value="2000" style="height:20px;">
                            <div class="slider-value" id="panningSpeedValue" style="font-size:9px;" contenteditable="true" title="Type ms (or s). Hold Shift while dragging for fine ms.">2.0s</div>
                        </div>
                        <div style="display:flex; align-items:center; justify-content:center;">
                            <div class="mix-btn" id="panningReset" style="font-size:9px; padding:4px; cursor:pointer;">Reset</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating OSC Modal (reuses original OSC panel content) -->
    <div id="oscModal" class="floating-modal" style="top:80px; left:220px; width:412px; height:803px; display:none; overflow:hidden;">
        <div class="modal-header">
            <span>Oscillators</span>
            <div style="display:flex; gap:6px; align-items:center;">
                <button id="closeOscModal" class="modal-close" style="background:#e74c3c;">Ã—</button>
            </div>
        </div>
        <div class="modal-body" style="height:calc(100% - 44px); overflow:hidden; padding:14px;">
            <div class="synth-section" id="oscillatorsSection" style="padding:0 4px 8px 4px; overflow:hidden;">
                <!-- Instrument Presets Toolbar -->
                <div id="instrumentPresetsBar" style="display:flex; align-items:center; gap:8px; margin:6px 0 10px 0;">
                    <label for="instrumentPresetSelect" style="font-size:12px; color:#8fb3d3;">Preset</label>
                    <select id="instrumentPresetSelect" style="background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:6px 8px; min-width:200px;"></select>
                    <button class="osc-btn" id="instrumentPresetApply" title="Apply selected preset" style="background:#3498db; border-color:#2980b9;">Apply</button>
                    <button class="osc-btn" id="instrumentPresetSave" title="Save current instrument as preset" style="background:#10b981; border-color:#059669;">Save</button>
                    <button class="osc-btn" id="instrumentPresetDelete" title="Delete selected preset" style="background:#e74c3c; border-color:#c0392b;">Delete</button>
                </div>
                <!-- Instrument Tabs: STRUM 1, STRUM 2, CHORD, ARP, BASS -->
                <div id="oscTabsBar" style="display:flex; gap:6px; margin-bottom:8px; flex-wrap:wrap;">
                    <button class="osc-btn osc-tab-btn active" data-tab="strum1">STRUM 1</button>
                    <button class="osc-btn osc-tab-btn" data-tab="strum2">STRUM 2</button>
                    <button class="osc-btn osc-tab-btn" data-tab="chord">CHORD</button>
                </div>
                <!-- MIDI Settings: Octave + Velocity -->
                <div id="midiSettingsRow" style="display:flex; gap:10px; align-items:flex-end; margin:6px 0 10px 0; flex-wrap:wrap;">
                    <div style="display:flex; flex-direction:column; gap:4px; min-width:150px;">
                        <label for="midiOctaveOffset" style="font-size:11px; color:#9db6c8;">MIDI Octave Offset</label>
                        <select id="midiOctaveOffset" title="Transpose outgoing MIDI in octaves" style="background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:6px 8px;">
                            <option value="-3">-3</option>
                            <option value="-2">-2</option>
                            <option value="-1">-1</option>
                            <option value="0" selected>0</option>
                            <option value="1">+1</option>
                            <option value="2">+2</option>
                            <option value="3">+3</option>
                        </select>
                    </div>
                    <div style="display:flex; flex-direction:column; gap:4px; min-width:180px;">
                        <label for="midiDefaultVelocity" style="font-size:11px; color:#9db6c8;">MIDI Default Velocity</label>
                        <input id="midiDefaultVelocity" type="number" min="1" max="127" value="100" title="Default velocity for outgoing MIDI" style="width:100%;background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:6px 8px;font-size:13px;" />
                    </div>
                </div>
                <!-- STRUM 1 tab - OSC 1 only -->
                <div id="tab-strum1" style="display:block; border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2);">
                    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                        <h5 style="font-size:12px; margin:0; color:#8fb3d3;">STRUM 1</h5>
                        <span style="font-size:10px; color:#9db6c8; background:#203848; border:1px solid #4a6870; padding:2px 6px; border-radius:4px;">OSC 1</span>
                    </div>
                    <div class="midi-per-section" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px 0;align-items:flex-end;">
                        <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                            <label style="font-size:10px;color:#9db6c8;">MIDI IN</label>
                            <input id="midiIn-strum1" type="number" min="0" max="15" value="1" title="Listen on MIDI input channel (0-15; 0=omni)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                        </div>
                        <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                            <label style="font-size:10px;color:#9db6c8;">MIDI OUT</label>
                            <select id="midiOut-strum1" title="Select MIDI output port (by name)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;"></select>
                        </div>
                        <div style="display:flex;flex-direction:column;gap:3px;min-width:130px;">
                            <label style="font-size:10px;color:#9db6c8;">MIDI OCTAVE</label>
                            <select id="midiOct-strum1" title="Per-section octave transpose for outgoing MIDI" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;">
                                <option value="-3">-3</option>
                                <option value="-2">-2</option>
                                <option value="-1">-1</option>
                                <option value="0" selected>0</option>
                                <option value="1">+1</option>
                                <option value="2">+2</option>
                                <option value="3">+3</option>
                            </select>
                        </div>
                        <div style="display:flex;flex-direction:column;gap:3px;min-width:150px;">
                            <label style="font-size:10px;color:#9db6c8;">MIDI VELOCITY</label>
                            <input id="midiVel-strum1" type="number" min="1" max="127" value="100" title="Default velocity for this section" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                        </div>
                    </div>
                        <div class="oscillator-controls" style="margin-bottom:8px;">
                            <div class="osc-btn active" data-wave="sine" data-osc="1" style="font-size:11px; padding:6px 8px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-osc="1" style="font-size:11px; padding:6px 8px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-osc="1" style="font-size:11px; padding:6px 8px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-osc="1" style="font-size:11px; padding:6px 8px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-osc="1" style="font-size:11px; padding:6px 8px;">Nse</div>
                            <div class="osc-btn" data-wave="pulse" data-osc="1" style="font-size:11px; padding:6px 8px;">Pulse</div>
                            <div class="osc-btn" data-wave="fullrect" data-osc="1" style="font-size:11px; padding:6px 8px;">FRect</div>
                            <div class="osc-btn" data-wave="halfrect" data-osc="1" style="font-size:11px; padding:6px 8px;">HRect</div>
                            
                            <div class="osc-btn" data-wave="parabolic" data-osc="1" style="font-size:11px; padding:6px 8px;">Para</div>
                            <div class="osc-btn" data-wave="stair" data-osc="1" style="font-size:11px; padding:6px 8px;">Stair</div>
                        </div>
                        <div class="slider-container pulse-width-container" data-osc="1" style="display:none; margin-bottom:6px;">
                            <label style="font-size:9px;">Pulse Width</label>
                            <input type="range" class="synth-slider" id="osc1PulseWidth" min="5" max="95" value="50" style="height:20px;">
                            <div class="slider-value" id="osc1PulseWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container" data-osc="1" style="margin-bottom:6px;">
                            <label style="font-size:9px;">Width of Shape</label>
                            <input type="range" class="synth-slider" id="osc1ShapeWidth" min="0" max="100" value="50" style="height:20px;">
                            <div class="slider-value" id="osc1ShapeWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="osc1Level" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="osc1LevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Fine</label>
                                <input type="range" class="synth-slider" id="osc1Detune" min="-50" max="50" value="0" style="height:20px;">
                                <div class="slider-value" id="osc1DetuneValue" style="font-size:9px;">0Â¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="osc1Octave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="osc1OctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="osc1Coarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="osc1CoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR 1</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="attackSlider" min="0" max="1000" value="5" style="height:18px;">
                                <div class="slider-value" id="attackValue" style="font-size:8px;" contenteditable="true" title="Type ms. Hold Shift while dragging for fine ms.">5ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="decaySlider" min="0" max="1000" value="200" style="height:18px;">
                                <div class="slider-value" id="decayValue" style="font-size:8px;" contenteditable="true" title="Type ms. Hold Shift while dragging for fine ms.">200ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="sustainSlider" min="0" max="100" value="0" style="height:18px;">
                                <div class="slider-value" id="sustainValue" style="font-size:8px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="releaseSlider" min="0" max="1000" value="1000" style="height:18px;">
                                <div class="slider-value" id="releaseValue" style="font-size:8px;" contenteditable="true" title="Type ms. Hold Shift while dragging for fine ms.">1000ms</div>
                            </div>
                        </div>
                        <!-- FX Send Checkbox -->
                        <div style="display:flex; align-items:center; justify-content:center; margin-top:8px; padding:6px; background:rgba(155,89,182,0.1); border-radius:4px; border:1px solid #9b59b6;">
                            <label style="display:flex; align-items:center; gap:6px; font-size:10px; color:#9b59b6; cursor:pointer;">
                                <input type="checkbox" id="strum1FxSend" checked style="margin:0; transform:scale(1.2);">
                                <span>Send to FX</span>
                            </label>
                        </div>
                    </div>
                    <!-- STRUM 2 tab - OSC 2 only -->
                    <div id="tab-strum2" style="display:none; border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2);">
                        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                            <h5 style="font-size:12px; margin:0; color:#8fb3d3;">STRUM 2</h5>
                            <span style="font-size:10px; color:#9db6c8; background:#203848; border:1px solid #4a6870; padding:2px 6px; border-radius:4px;">OSC 2</span>
                        </div>
                        <div class="midi-per-section" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px 0;align-items:flex-end;">
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI IN</label>
                                <input id="midiIn-strum2" type="number" min="0" max="15" value="1" title="Listen on MIDI input channel (0-15; 0=omni)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OUT</label>
                                <select id="midiOut-strum2" title="Select MIDI output port (by name)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;"></select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:130px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OCTAVE</label>
                                <select id="midiOct-strum2" title="Per-section octave transpose for outgoing MIDI" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;">
                                    <option value="-3">-3</option>
                                    <option value="-2">-2</option>
                                    <option value="-1">-1</option>
                                    <option value="0" selected>0</option>
                                    <option value="1">+1</option>
                                    <option value="2">+2</option>
                                    <option value="3">+3</option>
                                </select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:150px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI VELOCITY</label>
                                <input id="midiVel-strum2" type="number" min="1" max="127" value="100" title="Default velocity for this section" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                        </div>
                        <div class="oscillator-controls" style="margin-bottom:8px;">
                            <div class="osc-btn active" data-wave="sine" data-osc="2" style="font-size:11px; padding:6px 8px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-osc="2" style="font-size:11px; padding:6px 8px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-osc="2" style="font-size:11px; padding:6px 8px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-osc="2" style="font-size:11px; padding:6px 8px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-osc="2" style="font-size:11px; padding:6px 8px;">Nse</div>
                            <div class="osc-btn" data-wave="pulse" data-osc="2" style="font-size:11px; padding:6px 8px;">Pulse</div>
                            <div class="osc-btn" data-wave="fullrect" data-osc="2" style="font-size:11px; padding:6px 8px;">FRect</div>
                            <div class="osc-btn" data-wave="halfrect" data-osc="2" style="font-size:11px; padding:6px 8px;">HRect</div>
                            <div class="osc-btn" data-wave="parabolic" data-osc="2" style="font-size:11px; padding:6px 8px;">Para</div>
                            <div class="osc-btn" data-wave="stair" data-osc="2" style="font-size:11px; padding:6px 8px;">Stair</div>
                        </div>
                        <div class="slider-container pulse-width-container" data-osc="2" style="display:none; margin-bottom:6px;">
                            <label style="font-size:9px;">Pulse Width</label>
                            <input type="range" class="synth-slider" id="osc2PulseWidth" min="5" max="95" value="50" style="height:20px;">
                            <div class="slider-value" id="osc2PulseWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container" data-osc="2" style="margin-bottom:6px;">
                            <label style="font-size:9px;">Width of Shape</label>
                            <input type="range" class="synth-slider" id="osc2ShapeWidth" min="0" max="100" value="50" style="height:20px;">
                            <div class="slider-value" id="osc2ShapeWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="osc2Level" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="osc2LevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Fine</label>
                                <input type="range" class="synth-slider" id="osc2Detune" min="-50" max="50" value="-7" style="height:20px;">
                                <div class="slider-value" id="osc2DetuneValue" style="font-size:9px;">-7Â¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="osc2Octave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="osc2OctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="osc2Coarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="osc2CoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR 2</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="osc2AttackSlider" min="0" max="1000" value="5" style="height:18px;">
                                <div class="slider-value" id="osc2AttackValue" style="font-size:8px;" contenteditable="true" title="Type ms. Hold Shift while dragging for fine ms.">5ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="osc2DecaySlider" min="0" max="1000" value="30" style="height:18px;">
                                <div class="slider-value" id="osc2DecayValue" style="font-size:8px;" contenteditable="true" title="Type ms. Hold Shift while dragging for fine ms.">30ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="osc2SustainSlider" min="0" max="100" value="0" style="height:18px;">
                                <div class="slider-value" id="osc2SustainValue" style="font-size:8px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="osc2ReleaseSlider" min="0" max="1000" value="1000" style="height:18px;">
                                <div class="slider-value" id="osc2ReleaseValue" style="font-size:8px;" contenteditable="true" title="Type ms. Hold Shift while dragging for fine ms.">1000ms</div>
                            </div>
                        </div>
                        <!-- FX Send Checkbox -->
                        <div style="display:flex; align-items:center; justify-content:center; margin-top:8px; padding:6px; background:rgba(155,89,182,0.1); border-radius:4px; border:1px solid #9b59b6;">
                            <label style="display:flex; align-items:center; gap:6px; font-size:10px; color:#9b59b6; cursor:pointer;">
                                <input type="checkbox" id="strum2FxSend" checked style="margin:0; transform:scale(1.2);">
                                <span>Send to FX</span>
                            </label>
                        </div>
                    </div>
                    <!-- CHORD instrument panel -->
                    <div id="tab-chord" style="display:none; border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2);">
                        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                            <h5 style="font-size:12px; margin:0; color:#8fb3d3;">CHORD</h5>
                            <span style="font-size:10px; color:#9db6c8; background:#203848; border:1px solid #4a6870; padding:2px 6px; border-radius:4px;">OSC 3</span>
                        </div>
                        <div class="midi-per-section" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px 0;align-items:flex-end;">
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI IN</label>
                                <input id="midiIn-chord" type="number" min="0" max="15" value="1" title="Listen on MIDI input channel (0-15; 0=omni)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OUT</label>
                                <select id="midiOut-chord" title="Select MIDI output port (by name)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;"></select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:130px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OCTAVE</label>
                                <select id="midiOct-chord" title="Per-section octave transpose for outgoing MIDI" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;">
                                    <option value="-3">-3</option>
                                    <option value="-2">-2</option>
                                    <option value="-1">-1</option>
                                    <option value="0" selected>0</option>
                                    <option value="1">+1</option>
                                    <option value="2">+2</option>
                                    <option value="3">+3</option>
                                </select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:150px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI VELOCITY</label>
                                <input id="midiVel-chord" type="number" min="1" max="127" value="100" title="Default velocity for this section" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                        </div>
                        <div class="oscillator-controls" style="margin-bottom:8px;">
                            <div class="osc-btn active" data-wave="sine" data-inst="chord" style="font-size:11px; padding:6px 8px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-inst="chord" style="font-size:11px; padding:6px 8px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-inst="chord" style="font-size:11px; padding:6px 8px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-inst="chord" style="font-size:11px; padding:6px 8px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-inst="chord" style="font-size:11px; padding:6px 8px;">Nse</div>
                            <div class="osc-btn" data-wave="pulse" data-inst="chord" style="font-size:11px; padding:6px 8px;">Pulse</div>
                            <div class="osc-btn" data-wave="fullrect" data-inst="chord" style="font-size:11px; padding:6px 8px;">FRect</div>
                            <div class="osc-btn" data-wave="halfrect" data-inst="chord" style="font-size:11px; padding:6px 8px;">HRect</div>
                            <div class="osc-btn" data-wave="parabolic" data-inst="chord" style="font-size:11px; padding:6px 8px;">Para</div>
                            <div class="osc-btn" data-wave="stair" data-inst="chord" style="font-size:11px; padding:6px 8px;">Stair</div>
                        </div>
                        <div class="slider-container" style="display:none; margin-bottom:6px;" id="chordPulseWidthContainer">
                            <label style="font-size:9px;">Pulse Width</label>
                            <input type="range" class="synth-slider" id="chordPulseWidth" min="5" max="95" value="50" style="height:20px;">
                            <div class="slider-value" id="chordPulseWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container" style="margin-bottom:6px;">
                            <label style="font-size:9px;">Width of Shape</label>
                            <input type="range" class="synth-slider" id="chordShapeWidth" min="0" max="100" value="50" style="height:20px;">
                            <div class="slider-value" id="chordShapeWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="chordLevel" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="chordLevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Fine</label>
                                <input type="range" class="synth-slider" id="chordDetune" min="-50" max="50" value="0" style="height:20px;">
                                <div class="slider-value" id="chordDetuneValue" style="font-size:9px;">0Â¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="chordOctave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="chordOctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="chordCoarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="chordCoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="chordAttackSlider" min="0" max="1000" value="10" style="height:18px;">
                                <div class="slider-value" id="chordAttackValue" style="font-size:8px;">10ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="chordDecaySlider" min="0" max="1000" value="200" style="height:18px;">
                                <div class="slider-value" id="chordDecayValue" style="font-size:8px;">200ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="chordSustainSlider" min="0" max="100" value="70" style="height:18px;">
                                <div class="slider-value" id="chordSustainValue" style="font-size:8px;">70%</div>
                            </div>
                            <div class="slider-container">
                                <label id="chordReleaseLabel" style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="chordReleaseSlider" min="0" max="1000" value="500" style="height:18px;">
                                <div class="slider-value" id="chordReleaseValue" style="font-size:8px;">500ms</div>
                            </div>
                        </div>
                        <!-- FX Send Checkbox -->
                        <div style="display:flex; align-items:center; justify-content:center; margin-top:8px; padding:6px; background:rgba(155,89,182,0.1); border-radius:4px; border:1px solid #9b59b6;">
                            <label style="display:flex; align-items:center; gap:6px; font-size:10px; color:#9b59b6; cursor:pointer;">
                                <input type="checkbox" id="chordFxSend" style="margin:0; transform:scale(1.2);">
                                <span>Send to FX</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Tuning Modal (EDO & Session) -->
    <div id="tuningModal" class="floating-modal" style="top:140px; left:400px; width:420px; height:340px; display:none; overflow:hidden;">
        <div class="modal-header">
            <span>Tuning / Session</span>
            <div style="display:flex; gap:6px; align-items:center;">
                <button id="closeTuningModal" class="modal-close" style="background:#e74c3c;">Ã—</button>
            </div>
        </div>
        <div class="modal-body" style="height:calc(100% - 44px); overflow:hidden; padding:14px;">
            <div class="synth-section" id="tuningSelector" style="padding:0 4px 8px 4px; overflow:hidden;">
                <h4 style="font-size:15px; margin-bottom:8px;">EDO Configuration</h4>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:10px;">
                    <div class="slider-container">
                        <label style="font-size:11px;">Divisions</label>
                        <input type="number" id="edoDivisions" min="5" max="53" value="24" style="width:100%; padding:4px; background:#2a4858; color:#fff; border:1px solid #4a6870; border-radius:4px; font-size:11px;">
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <button id="resetChordsBtn" class="osc-btn" style="width:100%; font-size:12px; padding:8px; background:#e74c3c; border-color:#c0392b; margin-top:5px;">Clear Unlocked</button>
                </div>
                <div style="margin-bottom:10px; display:flex; gap:5px;">
                    <button id="saveSessionBtn" class="osc-btn" style="flex:1; font-size:11px; padding:6px; background:#3498db; border-color:#2980b9;">ðŸ’¾</button>
                    <button id="loadSessionBtn" class="osc-btn" style="flex:1; font-size:11px; padding:6px; background:#9b59b6; border-color:#8e44ad;">ðŸ“‚</button>
                    <input type="file" id="loadSessionInput" accept=".xen" style="display:none;">
                </div>
            </div>
        </div>
    </div>
    </div>
    <div class="instrument">
        <!-- Root Notes at Top -->
        <div class="root-notes-area">
            <div id="patternStrip" style="position:fixed;top:6px;left:88px;right:6px;max-width:calc(100vw - 100px);z-index:9701;display:flex;align-items:flex-start;gap:8px;flex-wrap:wrap;overflow-x:hidden;box-sizing:border-box;">
                <div id="stripLeft" style="display:flex;flex-direction:column;gap:4px;">
                    <button id="newSectionBtn" class="panel-btn" title="New Section" style="background:#513072;color:#f1e8ff;border:1px solid #8457b8;border-radius:6px;padding:6px 10px;font-size:12px;cursor:pointer;">NEW SECTION</button>
                    <button id="newPatternBtn" class="panel-btn" title="New Pattern" style="background:#214051;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:6px 10px;font-size:12px;cursor:pointer;">NEW PATTERN</button>
                    <button id="newDrumBtn" class="panel-btn" title="New Drum" style="background:#1f8f4a;color:#eafff3;border:1px solid #46c37b;border-radius:6px;padding:6px 10px;font-size:12px;cursor:pointer;">NEW DRUM</button>
                </div>
                <div id="stripRight" style="display:flex;flex-direction:column;gap:4px;min-width:0;">
                    <div id="sectionButtons" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;min-height:30px;"></div>
                    <div id="patternButtons" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;min-height:30px;"></div>
                    <div id="drumButtons" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;min-height:30px;"></div>
                </div>
            </div>
            <div class="root-notes-selector" style="display:flex;align-items:flex-start;justify-content:center;gap:12px;padding:10px;position:relative;">
                <!-- Left Sidebar with Module Buttons and Menu Controls -->
                <div class="left-sidebar">
                    <!-- Module Buttons -->
                    <button id="keyboardBtn" class="sidebar-btn" title="Toggle CALC" onclick="sidebarBtnClick('keyboard')" style="display:none;">CALC</button>
                    <button id="strumBtn" class="sidebar-btn" title="Toggle Strum Mode" onclick="sidebarBtnClick('strum')">STRUM</button>
                    <button id="chordsBtn" class="sidebar-btn" title="Toggle Chord Mode" onclick="sidebarBtnClick('chords')">CHORDS</button>
                    <button id="drumsBtn" class="sidebar-btn" title="Toggle Drums" onclick="sidebarBtnClick('drums')">DRUMS</button>
                    <button id="midiBtn" class="sidebar-btn" title="Toggle MIDI" onclick="sidebarBtnClick('midi')">MIDI</button>
                    
                    <!-- Menu Controls moved from top -->
                    <button id="createNewChordBtnSidebar" class="sidebar-btn" title="Add Chord" style="background:#27ae60;border-color:#2ecc71;">+</button>

                    <button id="oscPanelBtn" class="sidebar-btn" title="Oscillator settings">OSC</button>
                    <button id="fxPanelBtn" class="sidebar-btn" title="Effects">FX</button>
                    <button id="seqPanelBtn" class="sidebar-btn" title="Type or paste a chord sequence" style="display:none;">SEQ</button>
                    <button id="loadXenBtn" class="sidebar-btn" title="Import .XEN session" style="background:#9b59b6;border-color:#8e44ad;">LOAD</button>
                    <button id="saveXenBtn" class="sidebar-btn" title="Export full session (.XEN)" style="background:#10b981;border-color:#34d399;">SAVE</button>
                    <button id="bellsBtnSidebar" class="sidebar-btn" title="Open JAM">JAM</button>
                    <button id="tutorialBtnSidebar" class="sidebar-btn" title="Start Tutorial">?</button>
                    
                    <!-- Transpose controls moved to top-right of sidebar -->
                    <div id="sidebarTransposeCluster" style="position:sticky;top:4px;margin-top:4px;display:flex;flex-direction:column;align-items:center;gap:3px;padding:2px 0;z-index:5;">
                        <button id="transposeUpBtn" style="width:34px;height:18px;background:#27ae60;border:1px solid #2ecc71;border-radius:4px;color:#fff;font-size:11px;font-weight:600;line-height:1;cursor:pointer;">â–²</button>
                        <div class="delta" id="transposeDelta" style="font-size:9px;color:#9db6c8;text-align:center;min-width:30px;">Â±0</div>
                        <button id="transposeDownBtn" style="width:34px;height:18px;background:#e74c3c;border:1px solid #c0392b;border-radius:4px;color:#fff;font-size:11px;font-weight:600;line-height:1;cursor:pointer;">â–¼</button>
                    </div>
                    <div id="bellsZoomWrap" class="sidebar-zoom-wrap" aria-label="Keyboard zoom" style="display:none;">
                        <div class="sidebar-zoom-label">Zoom</div>
                        <input id="bellsZoom" type="range" min="1" max="4" step="1" value="1" />
                        <div id="bellsZoomValue" class="sidebar-zoom-value">1 key</div>
                    </div>
                </div>
                
                <!-- Main Content Area -->
                <div class="main-content">
                    <!-- Main Chord Canvas Area -->
                    <div class="chord-canvas-container" style="padding: 20px; min-height: calc(100vh - 100px);">
                        <!-- Piano Keyboard (toggleable) -->
                        <div id="keyboardSection" class="keyboard-section" style="margin-bottom: 20px; display: none;">
                            <div class="root-chord-grid" id="rootGrid" style="max-width:100%; margin:0 auto;"></div>
                        </div>
                        
                        <!-- Main Chord Sequence Area -->
                        <div class="chord-sequence-area" style="flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 400px; /* removed vertical border */ border: none; border-radius: 12px; background: rgba(42, 72, 88, 0.1);">
                            <!-- Empty canvas ready for docking modals -->
                        </div>
                    </div>
                </div>

        <!-- Floating Drum Modal -->
        <div id="drumModal" class="floating-modal" style="top: 100px; left: 200px; width: 870px; height: 560px;">
            <div class="modal-header">
                <span>Drum Sequencer</span>
                <button class="modal-close" onclick="closeDrumModalOnly()">Ã—</button>
            </div>
            <div class="modal-body" style="padding: 12px; height: calc(100% - 60px); overflow: hidden; display:flex; flex-direction:column;">
                <div class="drum-grid-container" style="flex: 1 1 auto; min-height:0; overflow-x: auto; overflow-y: auto;">
                    <div class="drum-grid-header">
                        <span style="opacity:.8;">Pattern</span>
                        <input id="drumPatternNumber" type="number" min="1" max="128" value="1" style="width:64px;background:#2a4858;color:#fff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;" />
                        <button id="drumDuplicateBtn" title="Duplicate to next empty (Ctrl+D)" style="background:#214051;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;font-size:10px;cursor:pointer;">DUP</button>
                        <button id="drumClearBtn" title="Clear all drum lanes (keeps bass lane)" style="background:#214051;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;font-size:10px;cursor:pointer;">CLEAR</button>
                        <!-- Drum cycle length (in 16ths) -->
                        <div style="display:inline-flex;align-items:center;gap:4px;margin-left:6px;">
                            <button id="drumLenDec" style="padding:2px 6px;">-</button>
                            <span>LEN <span id="drumLenValue" style="display:inline-block;min-width:20px;text-align:center;">16</span></span>
                            <button id="drumLenInc" style="padding:2px 6px;">+</button>
                        </div>
                        <!-- Drum MIDI OUT (per-section) -->
                        <span style="font-size:10px;opacity:.7;">OUT</span>
                        <select id="midiOut-drum" title="Drum MIDI OUT (select a Web MIDI output port)"
                            style="min-width:120px;max-width:220px;background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:2px 6px;font-size:11px;">
                            <option value="">(All Outputs)</option>
                        </select>

                        <!-- Compact TIME controls -->
                        <input id="drumBpmMini" type="number" min="20" max="300" placeholder="BPM" title="Tempo (mirrors TIME modal)"
                            style="width:58px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 6px;font-size:11px;" />
                        <input id="drumTSMini" list="tsOptions" type="text" placeholder="TS" title="Time Signature (e.g., 4/4, 7/8)"
                            style="width:58px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 6px;font-size:11px;" />
                        <input id="drumQuantMini" list="quantOptions" type="text" placeholder="QNT" title="Quantization (e.g., 1/16, 1/8T, tuplet:5/4)"
                            style="width:64px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 6px;font-size:11px;" />
                        
                        <!-- Universal controls -->
                        <select id="universalHold" title="Hold Length" style="width:70px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 4px;font-size:11px;">
                            <option value="beat:1">1bt</option>
                            <option value="beat:2">2bt</option>
                            <option value="bar:1" selected>1bar</option>
                            <option value="bar:2">2bar</option>
                            <option value="bar:4">4bar</option>
                            <option value="bar:8">8bar</option>
                            <option value="bar:16">16b</option>
                        </select>
                        <input id="universalSwing" type="number" min="0" max="75" value="0" title="Swing %" style="width:48px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 4px;font-size:11px;"/>
                        <span id="drumLenHint" style="font-size:10px;opacity:.6;">Cycle: 16 steps</span>
                    </div>
                    <div class="drum-grid" id="drumGrid"></div>
                </div>

                <!-- DRUM FX (global bus; always visible) -->
                <div id="drumFxPanel" class="drum-fx-panel">
                    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
                        <h5>DRUM FX</h5>
                        <button id="drumFxReset" title="Reset Drum FX" style="background:#214051;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:4px 8px;font-size:10px;cursor:pointer;">RESET</button>
                    </div>
                    <div class="drum-fx-grid">
                        <div class="drum-fx-cell">
                            <label>SAT MIX <span class="drum-fx-mini" id="drumFxSatMixValue"></span></label>
                            <input id="drumFxSatMix" type="range" min="0" max="100" value="0" />
                        </div>
                        <div class="drum-fx-cell">
                            <label>COMP THR <span class="drum-fx-mini" id="drumFxCompThrValue"></span></label>
                            <input id="drumFxCompThr" type="range" min="-60" max="0" value="-18" />
                        </div>
                        <div class="drum-fx-cell">
                            <label>DELAY TIME <span class="drum-fx-mini" id="drumFxDelayTimeValue"></span></label>
                            <input id="drumFxDelayTime" type="range" min="10" max="1200" value="180" />
                        </div>
                        <div class="drum-fx-cell">
                            <label>REVERB WET <span class="drum-fx-mini" id="drumFxReverbWetValue"></span></label>
                            <input id="drumFxReverbWet" type="range" min="0" max="100" value="15" />
                        </div>
                        <div class="drum-fx-cell">
                            <label>DRUM OUT <span class="drum-fx-mini" id="drumFxOutValue"></span></label>
                            <input id="drumFxOut" type="range" min="0" max="200" value="100" />
                        </div>

                        <div class="drum-fx-cell">
                            <label>SAT HP <span class="drum-fx-mini" id="drumFxSatHpValue"></span></label>
                            <input id="drumFxSatHp" type="range" min="20" max="2000" value="140" />
                        </div>
                        <div class="drum-fx-cell">
                            <label>COMP RATIO <span class="drum-fx-mini" id="drumFxCompRatioValue"></span></label>
                            <input id="drumFxCompRatio" type="range" min="1" max="20" value="4" />
                        </div>
                        <div class="drum-fx-cell">
                            <label>DELAY FB <span class="drum-fx-mini" id="drumFxDelayFbValue"></span></label>
                            <input id="drumFxDelayFb" type="range" min="0" max="95" value="25" />
                        </div>
                        <div class="drum-fx-cell">
                            <label>REVERB DECAY <span class="drum-fx-mini" id="drumFxReverbDecayValue"></span></label>
                            <input id="drumFxReverbDecay" type="range" min="10" max="600" value="120" />
                        </div>
                        <div class="drum-fx-cell">
                            <label>REVERB ROOM <span class="drum-fx-mini" id="drumFxReverbRoomValue"></span></label>
                            <input id="drumFxReverbRoom" type="range" min="0" max="100" value="55" />
                        </div>

                        <div class="drum-fx-cell">
                            <label>SAT LP <span class="drum-fx-mini" id="drumFxSatLpValue"></span></label>
                            <input id="drumFxSatLp" type="range" min="200" max="20000" value="12000" />
                        </div>
                        <div class="drum-fx-cell">
                            <label>COMP ATK <span class="drum-fx-mini" id="drumFxCompAtkValue"></span></label>
                            <input id="drumFxCompAtk" type="range" min="1" max="100" value="3" />
                        </div>
                        <div class="drum-fx-cell">
                            <label>COMP REL <span class="drum-fx-mini" id="drumFxCompRelValue"></span></label>
                            <input id="drumFxCompRel" type="range" min="10" max="1000" value="250" />
                        </div>
                        <div class="drum-fx-cell">
                            <label>DELAY MIX <span class="drum-fx-mini" id="drumFxDelayMixValue"></span></label>
                            <input id="drumFxDelayMix" type="range" min="0" max="100" value="18" />
                        </div>
                        <div class="drum-fx-cell">
                            <label>COMP OUT <span class="drum-fx-mini" id="drumFxCompOutValue"></span></label>
                            <input id="drumFxCompOut" type="range" min="-24" max="24" value="0" />
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Floating Pattern Modal -->
        <div id="patternModal" class="floating-modal pattern-modal" style="display:none; top: 150px; left: 250px; width: 760px; height: 600px; max-width: 92vw; max-height: 86vh; min-width: 300px; min-height: 240px;">
            <div class="modal-header">
                <span>Pattern Editor</span>
                <button id="patternSpeakerBtn" title="Pattern on/off" style="margin-left:auto;margin-right:6px;pointer-events:auto;width:28px;height:26px;display:inline-flex;align-items:center;justify-content:center;background:#214051;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;font-size:14px;cursor:pointer;line-height:1;">ðŸ”‡</button>
                <button class="modal-close" onclick="closePatternModalOnly()">Ã—</button>
            </div>
            <div class="modal-body" style="padding: 10px; height: calc(100% - 44px); overflow: hidden; max-height: calc(90vh - 44px); display:flex; flex-direction:column;">
                <div class="drum-grid-container" style="position:relative; height: 100%; overflow: hidden; width: 100%;">
                    <div class="drum-grid-header" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;margin-bottom:8px;">
                        <span style="opacity:.8;">Pattern</span>
                        <input id="patternPatternNumber" type="number" min="1" max="128" value="1" style="width:50px;background:#2a4858;color:#fff;border:1px solid #4a6870;border-radius:4px;padding:2px 4px;font-size:11px;" />
                        <div style="display:inline-flex;align-items:center;gap:4px;">
                            <button id="patternLenDec" style="padding:2px 6px;">-</button>
                            <span>LEN <span id="patternLenValue" style="display:inline-block;min-width:20px;text-align:center;">16</span></span>
                            <button id="patternLenInc" style="padding:2px 6px;">+</button>
                        </div>
                        <button id="patternClearBtn" title="Clear all pattern rows (keeps bass row)" style="background:#214051;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;font-size:10px;cursor:pointer;">CLEAR</button>
                        <select id="universalPattern" title="ARP Pattern" style="width:80px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 4px;font-size:11px;">
                            <option value="up" selected>Up</option>
                            <option value="down">Down</option>
                            <option value="updown">UpDn</option>
                            <option value="downup">DnUp</option>
                            <option value="walk-up">Walkâ†‘</option>
                            <option value="walk-down">Walkâ†“</option>
                            <option value="alt-ends">AltEnd</option>
                            <option value="alt-center">AltCtr</option>
                            <option value="random">Rand</option>
                            <option value="custom">CUSTOM</option>
                        </select>
                        <input id="universalPatternText" type="text" placeholder="Pattern" title="Pattern tokens (auto-sync)" style="display:none;width:100%;max-width:280px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 4px;font-size:11px;" />
                        <select id="patternQuant" title="Pattern Quant" style="background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 4px;font-size:11px;">
                            <option value="1/4">1/4</option>
                            <option value="1/8">1/8</option>
                            <option value="1/16" selected>1/16</option>
                            <option value="1/32">1/32</option>
                        </select>
                        <input id="universalNpc" type="number" min="1" max="64" value="16" title="Notes Per Cycle (NPC)" style="width:60px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 4px;font-size:11px;" />
                    </div>

                    <!-- ARP Synth (drawer; toggled by gear) -->
                    <div id="tab-arp" class="pattern-arp-panel" style="display:none; border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2); margin:0; max-height:none; overflow:auto; flex:1 1 auto; min-height:0;">
                        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                            <h5 style="font-size:12px; margin:0; color:#8fb3d3;">ARP</h5>
                        </div>
                        <div class="midi-per-section" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px 0;align-items:flex-end;">
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI IN</label>
                                <input id="midiIn-arp" type="number" min="0" max="15" value="1" title="Listen on MIDI input channel (0-15; 0=omni)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OUT</label>
                                <select id="midiOut-arp" title="Select MIDI output port (by name)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;"></select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:130px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OCTAVE</label>
                                <select id="midiOct-arp" title="Per-section octave transpose for outgoing MIDI" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;">
                                    <option value="-3">-3</option>
                                    <option value="-2">-2</option>
                                    <option value="-1">-1</option>
                                    <option value="0" selected>0</option>
                                    <option value="1">+1</option>
                                    <option value="2">+2</option>
                                    <option value="3">+3</option>
                                </select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:150px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI VELOCITY</label>
                                <input id="midiVel-arp" type="number" min="1" max="127" value="100" title="Default velocity for this section" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                        </div>
                        <div class="oscillator-controls" style="margin-bottom:8px;">
                            <div class="osc-btn active" data-wave="sine" data-inst="arp" style="font-size:11px; padding:6px 8px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-inst="arp" style="font-size:11px; padding:6px 8px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-inst="arp" style="font-size:11px; padding:6px 8px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-inst="arp" style="font-size:11px; padding:6px 8px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-inst="arp" style="font-size:11px; padding:6px 8px;">Nse</div>
                            <div class="osc-btn" data-wave="pulse" data-inst="arp" style="font-size:11px; padding:6px 8px;">Pulse</div>
                            <div class="osc-btn" data-wave="fullrect" data-inst="arp" style="font-size:11px; padding:6px 8px;">FRect</div>
                            <div class="osc-btn" data-wave="halfrect" data-inst="arp" style="font-size:11px; padding:6px 8px;">HRect</div>
                            <div class="osc-btn" data-wave="parabolic" data-inst="arp" style="font-size:11px; padding:6px 8px;">Para</div>
                            <div class="osc-btn" data-wave="stair" data-inst="arp" style="font-size:11px; padding:6px 8px;">Stair</div>
                        </div>
                        <div class="slider-container" style="display:none; margin-bottom:6px;" id="arpPulseWidthContainer">
                            <label style="font-size:9px;">Pulse Width</label>
                            <input type="range" class="synth-slider" id="arpPulseWidth" min="5" max="95" value="50" style="height:20px;">
                            <div class="slider-value" id="arpPulseWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container" style="margin-bottom:6px;">
                            <label style="font-size:9px;">Width of Shape</label>
                            <input type="range" class="synth-slider" id="arpShapeWidth" min="0" max="100" value="50" style="height:20px;">
                            <div class="slider-value" id="arpShapeWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="arpLevel" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="arpLevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Fine</label>
                                <input type="range" class="synth-slider" id="arpDetune" min="-50" max="50" value="0" style="height:20px;">
                                <div class="slider-value" id="arpDetuneValue" style="font-size:9px;">0Â¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="arpOctave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="arpOctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="arpCoarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="arpCoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="arpAttackSlider" min="0" max="1000" value="10" style="height:18px;">
                                <div class="slider-value" id="arpAttackValue" style="font-size:8px;">10ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="arpDecaySlider" min="0" max="1000" value="200" style="height:18px;">
                                <div class="slider-value" id="arpDecayValue" style="font-size:8px;">200ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="arpSustainSlider" min="0" max="100" value="70" style="height:18px;">
                                <div class="slider-value" id="arpSustainValue" style="font-size:8px;">70%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="arpReleaseSlider" min="0" max="1000" value="500" style="height:18px;">
                                <div class="slider-value" id="arpReleaseValue" style="font-size:8px;">500ms</div>
                            </div>
                        </div>
                        <!-- FX Send Checkbox -->
                        <div style="display:flex; align-items:center; justify-content:center; margin-top:8px; padding:6px; background:rgba(155,89,182,0.1); border-radius:4px; border:1px solid #9b59b6;">
                            <label style="display:flex; align-items:center; gap:6px; font-size:10px; color:#9b59b6; cursor:pointer;">
                                <input type="checkbox" id="arpFxSend" checked style="margin:0; transform:scale(1.2);">
                                <span>Send to FX</span>
                            </label>
                        </div>
                    </div>

                    <div class="drum-grid pattern-grid" id="patternGrid" data-length="16" style="grid-template-rows:repeat(3,auto);position:relative;"></div>
                    <div id="patternResizeHandle" title="Drag to resize pattern length" style="position:absolute;top:32px;right:-4px;width:8px;height:calc(100% - 40px);cursor:ew-resize;background:linear-gradient(to right, rgba(255,255,255,0.15), rgba(255,255,255,0));"></div>
                    <div id="patternSynthToggleBar" class="pattern-synth-toggle-bar" style="height:32px;display:flex;align-items:center;justify-content:flex-end;padding:0 4px;">
                        <button id="patternSynthToggleBtn" title="Synth controls" style="pointer-events:auto;width:28px;height:26px;display:inline-flex;align-items:center;justify-content:center;background:#214051;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;font-size:14px;cursor:pointer;line-height:1;">âš™</button>
                    </div>
                </div>
            </div>
        </div>
            </div>
        </div>

        <!-- Floating Bass Modal -->
        <div id="bassModal" class="floating-modal" style="top: 180px; left: 300px; width: 500px; height: 535px;">
            <div class="modal-header">
                <span>Bass Editor</span>
                <button class="modal-close" onclick="closeBassModalOnly()">Ã—</button>
            </div>
            <div class="modal-body" style="padding: 15px; height: calc(100% - 60px); overflow-y: auto;">
                <div class="drum-grid-container" style="position:relative; height: 100%; overflow-x: auto; overflow-y: visible;">
                    <div class="drum-grid-header" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
                        <span style="opacity:.8;">Bass Pattern</span>
                        <input id="bassPatternNumber" type="number" min="1" max="128" value="1" style="width:64px;background:#2a4858;color:#fff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;" />
                        <button id="bassDuplicateBtn" title="Duplicate to next empty" style="background:#214051;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;font-size:10px;cursor:pointer;">DUP</button>
                        <button id="bassClearBtn" title="Clear bass pattern" style="background:#214051;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;font-size:10px;cursor:pointer;">CLEAR</button>
                        <div style="display:inline-flex;align-items:center;gap:4px;">
                            <button id="bassLenDec" style="padding:2px 6px;">-</button>
                            <span id="bassLenDisplay" style="min-width:28px;text-align:center;font-size:11px;">16</span>
                            <button id="bassLenInc" style="padding:2px 6px;">+</button>
                        </div>
                        <select id="bassQuantizeSelect" style="background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 4px;font-size:10px;">
                            <option value="step:1">1step</option>
                            <option value="step:2">2step</option>
                            <option value="beat:1">1beat</option>
                            <option value="beat:2">2beat</option>
                            <option value="bar:1">1bar</option>
                        </select>
                        <input id="bassNpc" type="number" min="1" max="9" value="1" title="Notes Per Cycle (NPC)" style="width:60px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 4px;font-size:11px;" />
                        <span style="font-size:10px;opacity:.6;">Bass cycle (1-64)</span>
                    </div>

                    <!-- BASS Synth (moved from OSC modal) -->
                    <div id="tab-bass" style="display:block; border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2); margin:8px 0;">
                        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                            <h5 style="font-size:12px; margin:0; color:#8fb3d3;">BASS</h5>
                            <span style="font-size:10px; color:#9db6c8; background:#203848; border:1px solid #4a6870; padding:2px 6px; border-radius:4px;">OSC 4</span>
                        </div>
                        <div class="midi-per-section" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px 0;align-items:flex-end;">
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI IN</label>
                                <input id="midiIn-bass" type="number" min="0" max="15" value="1" title="Listen on MIDI input channel (0-15; 0=omni)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OUT</label>
                                <select id="midiOut-bass" title="Select MIDI output port (by name)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;"></select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:130px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OCTAVE</label>
                                <select id="midiOct-bass" title="Per-section octave transpose for outgoing MIDI" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;">
                                    <option value="-3">-3</option>
                                    <option value="-2">-2</option>
                                    <option value="-1">-1</option>
                                    <option value="0" selected>0</option>
                                    <option value="1">+1</option>
                                    <option value="2">+2</option>
                                    <option value="3">+3</option>
                                </select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:150px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI VELOCITY</label>
                                <input id="midiVel-bass" type="number" min="1" max="127" value="100" title="Default velocity for this section" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                        </div>
                        <div class="oscillator-controls" style="margin-bottom:8px;">
                            <div class="osc-btn active" data-wave="sine" data-inst="bass" style="font-size:11px; padding:6px 8px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-inst="bass" style="font-size:11px; padding:6px 8px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-inst="bass" style="font-size:11px; padding:6px 8px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-inst="bass" style="font-size:11px; padding:6px 8px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-inst="bass" style="font-size:11px; padding:6px 8px;">Nse</div>
                            <div class="osc-btn" data-wave="pulse" data-inst="bass" style="font-size:11px; padding:6px 8px;">Pulse</div>
                            <div class="osc-btn" data-wave="fullrect" data-inst="bass" style="font-size:11px; padding:6px 8px;">FRect</div>
                            <div class="osc-btn" data-wave="halfrect" data-inst="bass" style="font-size:11px; padding:6px 8px;">HRect</div>
                            <div class="osc-btn" data-wave="parabolic" data-inst="bass" style="font-size:11px; padding:6px 8px;">Para</div>
                            <div class="osc-btn" data-wave="stair" data-inst="bass" style="font-size:11px; padding:6px 8px;">Stair</div>
                        </div>
                        <div class="slider-container" style="display:none; margin-bottom:6px;" id="bassPulseWidthContainer">
                            <label style="font-size:9px;">Pulse Width</label>
                            <input type="range" class="synth-slider" id="bassPulseWidth" min="5" max="95" value="50" style="height:20px;">
                            <div class="slider-value" id="bassPulseWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container" style="margin-bottom:6px;">
                            <label style="font-size:9px;">Width of Shape</label>
                            <input type="range" class="synth-slider" id="bassShapeWidth" min="0" max="100" value="50" style="height:20px;">
                            <div class="slider-value" id="bassShapeWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="bassLevel" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="bassLevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Fine</label>
                                <input type="range" class="synth-slider" id="bassDetune" min="-50" max="50" value="0" style="height:20px;">
                                <div class="slider-value" id="bassDetuneValue" style="font-size:9px;">0Â¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="bassOctave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="bassOctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="bassCoarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="bassCoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="bassAttackSlider" min="0" max="1000" value="5" style="height:18px;">
                                <div class="slider-value" id="bassAttackValue" style="font-size:8px;">5ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="bassDecaySlider" min="0" max="1000" value="80" style="height:18px;">
                                <div class="slider-value" id="bassDecayValue" style="font-size:8px;">80ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="bassSustainSlider" min="0" max="100" value="85" style="height:18px;">
                                <div class="slider-value" id="bassSustainValue" style="font-size:8px;">85%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="bassReleaseSlider" min="0" max="1000" value="120" style="height:18px;">
                                <div class="slider-value" id="bassReleaseValue" style="font-size:8px;">120ms</div>
                            </div>
                        </div>
                        <!-- FX Send Checkbox -->
                        <div style="display:flex; align-items:center; justify-content:center; margin-top:8px; padding:6px; background:rgba(155,89,182,0.1); border-radius:4px; border:1px solid #9b59b6;">
                            <label style="display:flex; align-items:center; gap:6px; font-size:10px; color:#9b59b6; cursor:pointer;">
                                <input type="checkbox" id="bassFxSend" style="margin:0; transform:scale(1.2);">
                                <span>Send to FX</span>
                            </label>
                        </div>
                    </div>

                    <div class="drum-grid" id="bassGrid" data-length="16" style="grid-template-rows:repeat(9,1fr);position:relative;height:400px;"></div>
                    <div id="bassResizeHandle" title="Drag to resize bass pattern length" style="position:absolute;top:32px;right:-4px;width:8px;height:calc(100% - 40px);cursor:ew-resize;background:linear-gradient(to right, rgba(255,255,255,0.15), rgba(255,255,255,0));"></div>
                </div>
            </div>
        </div>

        <!-- Floating CALC Modal (Chord Calculator) -->
        <div id="keyboardModal" class="floating-modal" style="top: 22px; left: 80px; width: 760px; height: 520px; display: none; z-index: 10000;">
            <div class="modal-header">
                <span>CALC</span>
                <div style="display:flex;align-items:center;gap:8px;">
                    <label style="display:flex;align-items:center;gap:3px;color:#9db6c8;font-size:9px;">
                        EDO <input id="edoQuickInputKeyboard" type="number" min="5" max="53" value="24" title="Steps per octave" style="width:40px;height:16px;background:#2a4858;color:#fff;border:1px solid #4a6870;border-radius:2px;font-size:9px;padding:1px 2px;">
                    </label>
                    <button class="modal-close" onclick="closeKeyboardModalOnly()">Ã—</button>
                </div>
            </div>
            <div class="modal-body" style="padding: 8px; height: calc(100% - 60px); overflow: visible;">
                <div id="calcLayout" class="calc-layout">
                    <div class="calc-left">
                        <div class="calc-display">
                            <div class="calc-title">Chord Calculator</div>
                            <div id="calcChordName" class="calc-name">â€”</div>
                            <div id="calcChordTokens" class="calc-tokens"></div>
                        </div>
                        <div class="calc-group">
                            <div class="calc-group-title">Keypad</div>
                            <div id="calcKeypadGrid" class="calc-grid"></div>
                            <div class="calc-keypad-actions">
                                <button class="calc-btn action" id="calcAddBtn">ADD</button>
                                <button class="calc-btn action" id="calcEqualsBtn">=</button>
                                <button class="calc-btn action" id="calcChangeBtn" style="display:none;">CHANGE CHORD</button>
                                <button class="calc-btn action" id="calcClearBtn">CLEAR</button>
                            </div>
                        </div>
                    </div>

                    <div class="calc-preview">
                        <div class="calc-preview-label">Preview</div>
                        <div id="calcPreviewColumn" class="extension-column calc-preview-column">
                            <div class="extension-header" id="calcPreviewHeader"><span class="chord-name" id="calcPreviewName">â€”</span></div>
                            <div class="strings-column" id="calcPreviewStrings"></div>
                            <div class="note-labels" id="calcPreviewNotes"></div>
                        </div>
                        <div class="calc-preview-hint">Drag this chord into the timeline</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Fretboard/Strings with Resize Handle -->
        <div class="chord-resize-container" style="position: absolute; top: 0; bottom: 0; left: 80px; right: 0;">
            <div id="chordRuler" aria-hidden="true"></div>
            <div class="chord-collapse-handle" id="chordCollapseHandle">
                <div class="resize-grip"></div>
            </div>
            <div class="chord-resize-handle" id="chordResizeHandle">
                <div class="resize-grip"></div>
            </div>
            <div class="strum-area" id="strumArea" style="position: absolute; top: 0; height: 50vh; bottom: auto; left: 0; right: 0; margin-left: 0;">
                <div class="extension-columns" id="extensionColumns"></div>
            </div>
            <div class="jam-area" id="jamArea">
                <div id="bellsHeader">
                    <div id="bellsTransportRow">
                        <button id="bellsPlayBtn" class="bells-transport-btn">PLAY</button>
                    </div>
                    <div id="bellsChords"></div>
                    <div id="bellsModeToggle"><button id="bellsModeToggleBtn" class="bells-mode-btn"></button></div>
                    <div id="bellsControls">
                        <label id="bellsCountLabel" for="bellsCount" style="font-size:12px;color:#9db6c8;">NOTES</label>
                        <input id="bellsCount" type="range" min="1" max="16" value="2" />
                        <span id="bellsCountValue">2</span>
                        <label for="bellsOctave" style="font-size:12px;color:#9db6c8;">OCT</label>
                        <input id="bellsOctave" type="range" min="2" max="6" value="4" />
                        <span id="bellsOctaveValue">4</span>
                        <label id="bellsGlideWrap"><input id="bellsGlide" type="checkbox" /> GLIDE</label>
                    </div>
                    <div id="bellsDrawerRow">
                        <button id="bellsGearBtn" class="bells-gear" aria-expanded="false" title="JAM Oscillator">âš™</button>
                        <div id="bellsDrawer" class="bells-drawer">
                            <div class="bells-osc-row" id="bellsOscWaveRow">
                                <button class="bells-osc-btn" data-wave="sine">Sin</button>
                                <button class="bells-osc-btn" data-wave="sawtooth">Saw</button>
                                <button class="bells-osc-btn" data-wave="square">Sqr</button>
                                <button class="bells-osc-btn" data-wave="triangle">Tri</button>
                                <button class="bells-osc-btn" data-wave="noise">Nse</button>
                                <button class="bells-osc-btn" data-wave="pulse">Pulse</button>
                                <button class="bells-osc-btn" data-wave="fullrect">FRect</button>
                                <button class="bells-osc-btn" data-wave="halfrect">HRect</button>
                                <button class="bells-osc-btn" data-wave="parabolic">Para</button>
                                <button class="bells-osc-btn" data-wave="stair">Stair</button>
                            </div>
                            <div class="bells-osc-slider">
                                <span>LEVEL</span>
                                <input id="bellsOscLevel" type="range" min="0" max="10" value="5" />
                                <span id="bellsOscLevelValue">50%</span>
                            </div>
                            <div class="bells-osc-slider">
                                <span>DETUNE</span>
                                <input id="bellsOscDetune" type="range" min="-50" max="50" value="0" />
                                <span id="bellsOscDetuneValue">0Â¢</span>
                            </div>
                            <div class="bells-osc-slider">
                                <span>OCT</span>
                                <input id="bellsOscOctave" type="range" min="-3" max="3" value="0" />
                                <span id="bellsOscOctaveValue">0</span>
                            </div>
                            <div class="bells-osc-slider">
                                <span>COARSE</span>
                                <input id="bellsOscCoarse" type="range" min="-24" max="24" value="0" step="1" />
                                <span id="bellsOscCoarseValue">0 steps</span>
                            </div>
                            <div class="bells-osc-slider">
                                <span>ATTACK</span>
                                <input id="bellsEnvAttack" type="range" min="0" max="1000" value="5" />
                                <span id="bellsEnvAttackValue">5ms</span>
                            </div>
                            <div class="bells-osc-slider">
                                <span>DECAY</span>
                                <input id="bellsEnvDecay" type="range" min="0" max="1000" value="250" />
                                <span id="bellsEnvDecayValue">250ms</span>
                            </div>
                            <div class="bells-osc-slider">
                                <span>SUSTAIN</span>
                                <input id="bellsEnvSustain" type="range" min="0" max="100" value="85" />
                                <span id="bellsEnvSustainValue">85%</span>
                            </div>
                            <div class="bells-osc-slider">
                                <span>RELEASE</span>
                                <input id="bellsEnvRelease" type="range" min="0" max="2000" value="350" />
                                <span id="bellsEnvReleaseValue">350ms</span>
                            </div>
                            <div class="bells-osc-slider">
                                <span>GLIDE</span>
                                <input id="bellsGlideMs" type="range" min="0" max="800" value="0" />
                                <span id="bellsGlideMsValue">AUTO</span>
                            </div>
                            <div class="bells-osc-slider">
                                <span>FUZZ</span>
                                <input id="bellsFuzz" type="range" min="0" max="100" value="0" />
                                <span id="bellsFuzzValue">0%</span>
                            </div>
                            <div class="bells-midi-row" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
                                <label for="midiIn-bells" style="font-size:11px;color:#9db6c8;">MIDI IN</label>
                                <input id="midiIn-bells" type="number" min="0" max="15" value="1" title="Listen on MIDI input channel (0-15; 0=omni)" style="width:64px; background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:2px 4px; font-size:11px;" />
                                <label for="midiOut-bells" style="font-size:11px;color:#9db6c8;">OUT</label>
                                <select id="midiOut-bells" title="Select MIDI output port (by name)" style="min-width:160px; background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:2px 4px; font-size:11px;"></select>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="bellsBars"></div>
            </div>
        </div>


    <!-- Unified Chord Builder Modal -->
    <div id="chordBuilderModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; max-width: 95%; max-height: 95%; overflow-y: auto; width: 800px;">
            <h3 id="chordBuilderTitle">Enhanced Chord Builder</h3>
            
            <!-- Chord Name Input -->
            <div style="margin: 20px 0;">
                <label>Chord Name (flavor only, no root):</label>
                <input type="text" id="chordBuilderName" placeholder="e.g. maj7#11, min9, sus2add6" style="width: 300px; padding: 8px; margin-left: 10px; background: #2a4858; color: #fff; border: 1px solid #4a6870; border-radius: 4px;">
            </div>
            
            <!-- Chord Extensions Checkboxes -->
            <div style="margin: 20px 0;">
                <h4 style="margin: 0 0 10px 0; color: #4a90e2;">ðŸŽµ Diatonic Extensions (Select Multiple)</h4>
                <div id="chordExtensionsCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; margin-bottom: 15px; padding: 15px; border: 2px solid #4a6870; border-radius: 8px; background: rgba(0, 20, 40, 0.3);">
                    <!-- Extension checkboxes will be populated here -->
                </div>
            </div>
            
            <!-- Microtonal Intervals Section -->
            <div id="microtonalSection" style="margin: 20px 0;">
                <h4 style="margin: 0 0 10px 0; color: #27ae60;">ðŸ” Microtonal Intervals</h4>
                <div style="font-size: 12px; color: #8fb3d3; margin-bottom: 8px;">
                    <span style="color: #4a90e2;"> </span> Diatonic approximations &nbsp;
                    <span style="color: #27ae60;"> </span> Neutral/Xenharmonic &nbsp;
                    <span style="color: #f39c12;"> </span> Quarter-tone regions &nbsp;
                    <span style="color: #e74c3c;"> </span> Chromatic equivalents
                </div>
                <div id="microtonalCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 6px; max-height: 300px; overflow-y: auto; padding: 15px; border: 2px solid #4a6870; border-radius: 8px; background: rgba(0, 20, 40, 0.3);">
                    <!-- Microtonal interval checkboxes will be populated here -->
                </div>
            </div>
            
            <!-- Preview Section -->
            <div style="margin: 20px 0; padding: 15px; border: 2px solid #8e44ad; border-radius: 8px; background: rgba(142, 68, 173, 0.1);">
                <h4 style="margin: 0 0 10px 0; color: #8e44ad;">ðŸŽ§ Chord Preview</h4>
                <div id="chordPreviewDisplay" style="font-family: var(--retro-font); font-size: 14px; color: #8fb3d3; min-height: 40px; padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 4px;">
                    No intervals selected
                </div>
            </div>
            
            <!-- Favorites Section -->
            <div id="favoritesSection" style="margin: 20px 0; padding: 15px; border: 1px solid #4a6870; border-radius: 8px; background: rgba(42, 72, 88, 0.3);">
                <h4 style="margin: 0 0 10px 0; color: #f39c12;">? Favorite Chords</h4>
                <div id="chordBuilderFavoritesList" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 10px; min-height: 60px;">
                    <!-- Favorite chords will be populated here -->
                </div>
                <div style="font-size: 12px; color: #8fb3d3;">
                    Click any favorite to load its pattern into the builder
                </div>
            </div>
            
            <!-- Actions -->
            <div style="margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="osc-btn" id="closeChordBuilder">Close</button>
                <button class="osc-btn" id="saveChordBuilder" style="background: #27ae60;">âœ… Save Chord</button>
                <button class="osc-btn" id="addToFavoritesBuilder" style="background: #f39c12;">â˜… Add to Favorites</button>
                <button class="osc-btn" id="previewChordBuilder" style="background: #8e44ad;">ðŸ”Š Preview</button>
                <button class="osc-btn" id="clearChordBuilder" style="background: #e74c3c;">âŒ Clear</button>
            </div>
        </div>
    </div>


    <!-- Edit Pattern Modal -->
    <div id="editPatternModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; max-width: 80%; max-height: 80%; overflow-y: auto;">
            <h3 id="editPatternTitle">Edit Note Pattern</h3>
            <div style="margin: 20px 0;">
                <label>Pattern Name:</label>
                <input type="text" id="editPatternName" style="width: 200px; padding: 5px; margin-left: 10px; background: #2a4858; color: #fff; border: 1px solid #4a6870; border-radius: 4px;">
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Intervals from Root (semitones):</label>
                <div id="intervalEditor" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-top: 10px;"></div>
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Quick Patterns:</label>
                <div style="display: flex; gap: 5px; margin-top: 5px; flex-wrap: wrap;">
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7])">Major</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 3, 7])">Minor</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 10])">Dom7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 11])">Maj7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 3, 7, 10])">m7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 2, 7])">Sus2</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 5, 7])">Sus4</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 9])">6th</button>
                </div>
            </div>
            <div style="margin-top: 20px;">
                <button class="osc-btn" id="closeEditPatternModal">Close</button>
                <button class="osc-btn" id="saveEditPattern">Save Pattern</button>
            </div>
        </div>
    </div>

    <!-- Chord Name Modal -->
    <div id="chordNameModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; min-width: 400px;">
            <h3 style="color: #8fb3d3; margin-bottom: 20px; text-align: center;">ðŸ’¾ Save Your Chord</h3>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #8fb3d3;">Chord Name:</label>
                <input type="text" id="chordNameInput" placeholder="e.g. C, Dm, F?7, etc." style="width: 100%; padding: 10px; background: #2a4858; color: #fff; border: 2px solid #4a6870; border-radius: 6px; font-size: 16px;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #8fb3d3;">Selected Intervals:</label>
                <div id="selectedIntervalsDisplay" style="background: #2a4858; padding: 10px; border-radius: 6px; color: #fff; font-family: var(--retro-font);"></div>
            </div>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="osc-btn" id="cancelChordName" style="background: #666; border-color: #888;">Cancel</button>
                <button class="osc-btn" id="saveChordName" style="background: #2E8B57; border-color: #3CB371;">âœ… Save Chord</button>
            </div>
        </div>
    </div>

    <!-- Text -> Chords Parser Modal -->
    <div id="textChordModal" class="floating-modal" style="display:none; top: 120px; left: 220px; width: 800px; height: 600px; z-index: 10000;">
        <div class="modal-header">
            <span>Chord Sequence Editor</span>
            <button class="modal-close" id="closeTextChordModalBtn">Ã—</button>
        </div>
        <div class="modal-body" style="padding: 15px; height: calc(100% - 60px); overflow-y: auto;">
            <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px; flex-wrap:wrap;">
                <label style="display:flex; align-items:center; gap:6px; color:#8fb3d3; font-size:12px;">
                    <input id="seqRepeat" type="checkbox" style="transform:translateY(1px)"> Repeat unique sections
                </label>
            </div>
            <div style="display:flex; align-items:center; gap:10px; margin:6px 0 8px 0;">
                <label style="font-size:12px;color:#9db6c8;">EDO</label>
                <input id="seqEdoInput" type="number" min="5" max="53" value="24" title="Steps per octave for this sequence" style="width:64px;background:#102a3a;color:#e8f5ff;border:1px solid #2b5567;border-radius:4px;padding:4px 6px;font-size:12px;" />
                <span style="font-size:11px;color:#6ea4bf;">Saved with preset and applied on load</span>
            </div>
            <textarea id="textChordInput" placeholder="EXAMPLE CHORDS: C Am F G
MICROTONAL CHORDS ^ means up one step, v means down one step: C A^m Fvm G7
ROMAN NUMERALS: I vi IV V
ROMAN NUMERALS with up/down: I^ viv ii7 vii7
REPEATS: [C Am F G]x4 
NESTED REPEATS: [[C Am F G]x2 [C Dm Em F^]x2]x4
| DIVIDER COLUMN" style="width:100%; min-height:160px; background:#102a3a; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; line-height:1.5; resize:vertical;"></textarea>

            <!-- Sequence preset controls -->
            <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
                <select id="seqPresetDropdown" style="background:#08222b; color:#e8f5ff; border:1px solid #1f5566; padding:6px; border-radius:6px; min-width:220px;"></select>
                <button class="osc-btn" id="addSeqPresetBtn" title="Save current text as a new preset">Save Preset</button>
                <button class="osc-btn" id="deleteSeqPresetBtn" title="Delete selected preset" style="background:#d9534f; border-color:#c9302c;">Delete</button>
                <button class="osc-btn" id="selectSeqPresetBtn" title="Load selected preset into textarea">Load</button>
            </div>

            <div style="margin-top:8px; display:flex; align-items:center; gap:10px;">
                <div style="font-size:12px; color:#8fb3d3;">Unique chords found:</div>
                <div id="textChordCount" style="font-size:12px; color:#f0f6ff;">0</div>
                <div style="margin-left:auto; display:flex; gap:8px;">
                    <button class="osc-btn" id="parseTextChordsBtn" style="background:#3498db; border-color:#2980b9;">Create Sequence</button>
                </div>
            </div>

            <div id="textChordResults" style="margin-top:10px; display:grid; grid-template-columns:repeat(auto-fill, minmax(120px, 1fr)); gap:8px;"></div>
        </div>
    </div>

    <!-- Tutorial Overlay -->
    <div id="tutorialOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999;">
        <div id="tutorialBox" style="position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: #1a1a2e; border: 2px solid #4a6870; border-radius: 10px; padding: 20px; max-width: 600px; max-height: 70vh; overflow-y: auto; z-index: 10000; box-shadow: 0 10px 30px rgba(0,0,0,0.8);">
            <h3 id="tutorialTitle" style="color: #8fb3d3; margin-top: 0;">Welcome to XENON</h3>
            <p id="tutorialText" style="color: #fff; line-height: 1.5;">Click Next to start the tutorial.</p>
            <div style="margin-top: 15px; text-align: center; font-size: 12px; color: #8fb3d3; opacity: 0.9; background: rgba(74, 104, 112, 0.2); padding: 8px; border-radius: 5px;">
                ðŸ’¡ Press ESC, click outside, or use Skip Tutorial to exit anytime
            </div>
            <div style="margin-top: 20px; text-align: right;">
                <button id="tutorialPrev" class="osc-btn" style="margin-right: 10px;">Previous</button>
                <button id="tutorialNext" class="osc-btn">Next</button>
                <button id="tutorialSkip" class="osc-btn" style="margin-left: 10px; background: #dc2626;">Skip Tutorial</button>
            </div>
        </div>
    </div>

    <!-- Startup Prompt Overlay -->
    <div id="startupPromptOverlay" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.78); z-index:13000;">
        <div style="width:min(520px, 92vw); background:#0e1620; border:1px solid rgba(255,255,255,0.12); border-radius:12px; padding:18px; box-shadow:0 10px 40px rgba(0,0,0,0.6);">
            <div style="font-size:14px; color:#9db6c8; margin-bottom:10px;">Xenmicord</div>
            <div style="font-size:18px; font-weight:700; color:#e8f5ff; margin-bottom:14px;">Choose startup mode</div>
            <div style="display:flex; gap:10px; flex-wrap:wrap;">
                <button id="startupNewProjectBtn" class="osc-btn" style="flex:1; min-width:200px; font-size:13px; padding:10px; background:#214051; border-color:#4a6870;">START NEW PROJECT</button>
                <button id="startupLoadXenBtn" class="osc-btn" style="flex:1; min-width:200px; font-size:13px; padding:10px; background:#9b59b6; border-color:#8e44ad;">LOAD XEN FILE</button>
            </div>
            <div style="margin-top:12px; font-size:11px; color:#9db6c8; opacity:0.85; line-height:1.35;">
                NEW PROJECT starts blank. LOAD opens a .XEN file.
            </div>
        </div>
    </div>


    <script>
        // Mute console logs for performance (default ON); enable with window.enableLogs()
        (function(){
            try {
                const flag = (typeof window !== 'undefined' && window.localStorage) ? window.localStorage.getItem('muteConsole') : null;
                const shouldMute = (flag !== '0'); // default to muted unless explicitly enabled
                if (shouldMute && window.console) {
                    const methods = ['log','info','debug','warn','error','trace','group','groupCollapsed','groupEnd','time','timeEnd','table'];
                    methods.forEach(function(m){ if (typeof window.console[m] === 'function') window.console[m] = function(){}; });
                }
                if (!window.enableLogs) window.enableLogs = function(){ try{ if (window.localStorage) { localStorage.setItem('muteConsole','0'); location.reload(); } }catch(_){} };
                if (!window.disableLogs) window.disableLogs = function(){ try{ if (window.localStorage) { localStorage.setItem('muteConsole','1'); location.reload(); } }catch(_){} };
            } catch(_) {}
        })();

        // Define modal functions early for immediate access
        window.showKeyboardModal = function() {
            console.log('Opening CALC modal');
            try {
                if (window.omnichord && typeof omnichord.openCalcModal === 'function') {
                    omnichord.openCalcModal();
                    return;
                }
            } catch(_){ }
            const modal = document.getElementById('keyboardModal');
            if (modal) {
                modal.style.display = 'block';
                bringModalToFront('keyboardModal');
                if (!modal._draggableSet) {
                    makeDraggable(modal);
                    modal._draggableSet = true;
                }
                if (typeof window.ensureCalcScaleObserver === 'function') window.ensureCalcScaleObserver();
                if (typeof window.updateCalcScale === 'function') window.updateCalcScale();
            }
        };
        
        window.closeKeyboardModal = function() {
            console.log('Closing CALC modal');
            const modal = document.getElementById('keyboardModal');
            if (modal) modal.style.display = 'none';
            const btn = document.getElementById('keyboardBtn');
            if (btn) btn.classList.remove('active');
        };
        
        window.closeKeyboardModalOnly = function() {
            console.log('Closing CALC modal only');
            const modal = document.getElementById('keyboardModal');
            if (modal) modal.style.display = 'none';
            // Don't disable the CALC toggle - keep button active if used
        };

        window.updateCalcScale = function() {
            try {
                const modal = document.getElementById('keyboardModal');
                if (!modal) return;
                const ratio = 760 / 520;
                if (!modal._calcSizing) {
                    const rect = modal.getBoundingClientRect();
                    const targetH = rect.width / ratio;
                    if (Math.abs(targetH - rect.height) > 1) {
                        modal._calcSizing = true;
                        modal.style.height = Math.round(targetH) + 'px';
                        modal._calcSizing = false;
                    }
                }
                const body = modal.querySelector('.modal-body');
                const layout = document.getElementById('calcLayout');
                if (!body || !layout) return;
                const baseWidth = 760;
                const baseHeight = 460;
                const availableW = body.clientWidth || 0;
                const availableH = body.clientHeight || 0;
                if (!availableW || !availableH) return;
                const scale = Math.min(availableW / baseWidth, availableH / baseHeight);
                body.style.setProperty('--calc-scale', scale.toFixed(4));
                body.style.setProperty('--calc-base-w', baseWidth + 'px');
                body.style.setProperty('--calc-base-h', baseHeight + 'px');
            } catch(_){ }
        };

        window.ensureCalcScaleObserver = function() {
            try {
                const modal = document.getElementById('keyboardModal');
                if (!modal || modal._calcScaleObserverSet) return;
                if (typeof ResizeObserver !== 'function') return;
                const observer = new ResizeObserver(() => {
                    if (modal.style.display !== 'none') window.updateCalcScale();
                });
                observer.observe(modal);
                modal._calcScaleObserverSet = true;
            } catch(_){ }
        };

        // Modal resize -> scale drum/pattern/bass dot size + spacing
        if (!window._ensureModalDotScaling) {
            window._ensureModalDotScaling = function(modal) {
                try {
                    if (!modal || modal._dotScaleWired) return;
                    if (typeof ResizeObserver !== 'function') return;

                    const getPxVar = (name, fallback) => {
                        try {
                            const v = getComputedStyle(modal).getPropertyValue(name);
                            const n = parseFloat(v);
                            return Number.isFinite(n) ? n : fallback;
                        } catch(_) { return fallback; }
                    };

                    const baseW = Math.max(1, modal.getBoundingClientRect().width || modal.offsetWidth || 1);
                    const baseH = Math.max(1, modal.getBoundingClientRect().height || modal.offsetHeight || 1);
                    const baseDot = getPxVar('--dot-size', 16);
                    const baseGap = getPxVar('--dot-gap', 4);

                    if (!modal._aspectRatio) {
                        modal._aspectRatio = baseW / baseH;
                        modal.style.setProperty('--modal-aspect', String(modal._aspectRatio));
                    }

                    const apply = () => {
                        try {
                            const r = modal.getBoundingClientRect();
                            const w = Math.max(1, r.width || modal.offsetWidth || 1);
                            const h = Math.max(1, r.height || modal.offsetHeight || 1);
                            // Ignore "hidden" sizes
                            if (w < 50 || h < 50) return;

                            const s = Math.min(w / baseW, h / baseH);
                            const scale = Math.max(0.35, Math.min(3.5, s));

                            const dot = Math.max(4, Math.round(baseDot * scale));
                            const gap = Math.max(0, Math.round(baseGap * scale));
                            const stepSize = Math.max(6, dot + gap + 2);
                            const tieH = Math.max(4, Math.round(dot * 0.75));

                            modal.style.setProperty('--dot-size', dot + 'px');
                            modal.style.setProperty('--dot-gap', gap + 'px');
                            modal.style.setProperty('--step-size', stepSize + 'px');
                            modal.style.setProperty('--tie-height', tieH + 'px');
                        } catch(_) {}
                    };

                    const ro = new ResizeObserver(() => apply());
                    ro.observe(modal);
                    modal._dotScaleWired = true;
                    modal._dotScaleRO = ro;
                    modal._dotScaleApply = apply;
                    // initial apply
                    apply();
                } catch(_) {}
            };
        }

        // Fixed-aspect resize handle for pattern/drum/bass modals (works on iPad)
        if (!window._ensureModalAspectResize) {
            window._ensureModalAspectResize = function(modal) {
                try {
                    if (!modal || modal._aspectResizeWired) return;
                    if (!modal.classList.contains('floating-modal')) return;

                    const rect = modal.getBoundingClientRect();
                    modal._aspectRatio = modal._aspectRatio || (rect.width / rect.height) || 4/3;
                    modal.style.setProperty('--modal-aspect', String(modal._aspectRatio));

                    let handle = modal.querySelector('.modal-resize-handle');
                    if (!handle) {
                        handle = document.createElement('div');
                        handle.className = 'modal-resize-handle';
                        modal.appendChild(handle);
                    }

                    const clampSize = (w, h) => {
                        const cs = getComputedStyle(modal);
                        const minW = Math.max(120, parseFloat(cs.minWidth) || 120);
                        const minH = Math.max(120, parseFloat(cs.minHeight) || 120);
                        const vv = window.visualViewport;
                        const vw = Math.max(240, Math.floor((vv ? vv.width : window.innerWidth) * 0.96));
                        const vh = Math.max(240, Math.floor((vv ? vv.height : window.innerHeight) * 0.92));
                        const maxW = Math.max(minW, Math.min(vw, parseFloat(cs.maxWidth) || vw));
                        const maxH = Math.max(minH, Math.min(vh, parseFloat(cs.maxHeight) || vh));

                        let nextW = Math.max(minW, Math.min(maxW, w));
                        let nextH = Math.max(minH, Math.min(maxH, h));

                        const ratio = modal._aspectRatio || (nextW / nextH) || 4/3;
                        // Enforce aspect ratio
                        if (nextW / nextH > ratio) {
                            nextW = nextH * ratio;
                        } else {
                            nextH = nextW / ratio;
                        }
                        return { w: nextW, h: nextH };
                    };

                    const startResize = (startX, startY) => {
                        const startRect = modal.getBoundingClientRect();
                        modal._resizeState = {
                            startX,
                            startY,
                            startW: startRect.width,
                            startH: startRect.height,
                            ratio: modal._aspectRatio || (startRect.width / startRect.height) || 4/3
                        };
                    };

                    const updateResize = (x, y) => {
                        const st = modal._resizeState;
                        if (!st) return;
                        const dx = x - st.startX;
                        const dy = y - st.startY;
                        let newW = st.startW + dx;
                        let newH = st.startH + dy;
                        // Use the dominant drag axis to preserve intent
                        if (Math.abs(dx) >= Math.abs(dy)) {
                            newH = newW / st.ratio;
                        } else {
                            newW = newH * st.ratio;
                        }
                        const clamped = clampSize(newW, newH);
                        modal.style.width = `${Math.round(clamped.w)}px`;
                        modal.style.height = `${Math.round(clamped.h)}px`;
                        try { modal._dotScaleApply && modal._dotScaleApply(); } catch(_) {}
                    };

                    const endResize = () => { modal._resizeState = null; };

                    handle.addEventListener('pointerdown', (e) => {
                        if (e.button != null && e.button !== 0) return;
                        e.preventDefault();
                        handle.setPointerCapture && handle.setPointerCapture(e.pointerId);
                        startResize(e.clientX, e.clientY);
                        const onMove = (ev) => { updateResize(ev.clientX, ev.clientY); };
                        const onUp = () => {
                            document.removeEventListener('pointermove', onMove);
                            document.removeEventListener('pointerup', onUp);
                            endResize();
                        };
                        document.addEventListener('pointermove', onMove);
                        document.addEventListener('pointerup', onUp);
                    });

                    handle.addEventListener('touchstart', (e) => {
                        const t = e.touches && e.touches[0];
                        if (!t) return;
                        e.preventDefault();
                        startResize(t.clientX, t.clientY);
                        const onMove = (ev) => {
                            const tt = ev.touches && ev.touches[0];
                            if (!tt) return;
                            updateResize(tt.clientX, tt.clientY);
                        };
                        const onEnd = () => {
                            document.removeEventListener('touchmove', onMove);
                            document.removeEventListener('touchend', onEnd);
                            document.removeEventListener('touchcancel', onEnd);
                            endResize();
                        };
                        document.addEventListener('touchmove', onMove, { passive: false });
                        document.addEventListener('touchend', onEnd);
                        document.addEventListener('touchcancel', onEnd);
                    }, { passive: false });

                    modal._aspectResizeWired = true;
                } catch(_) {}
            };
        }
        
        window.showDrumModal = function() {
            console.log('Opening drum modal');
            const modal = document.getElementById('drumModal');
            if (modal) {
                modal.style.display = 'block';
                bringModalToFront('drumModal');
                try { window._ensureModalDotScaling(modal); modal._dotScaleApply && modal._dotScaleApply(); } catch(_) {}
                try { window._ensureModalAspectResize && window._ensureModalAspectResize(modal); } catch(_) {}
                // Ensure drum grid is visible
                const drumContainer = modal.querySelector('.drum-grid-container');
                if (drumContainer) {
                    drumContainer.style.display = 'block';
                }

                // Drum FX panel: wire listeners and apply state to audio on open.
                // (Otherwise the sliders may render but not affect audio until some other code path runs.)
                try {
                    const omni = window.omnichord;
                    if (omni && typeof omni._wireDrumFxPanel === 'function') omni._wireDrumFxPanel();
                    if (omni && typeof omni._applyDrumFxPanel === 'function') omni._applyDrumFxPanel();
                    if (omni && typeof omni.updateDrumFx === 'function') omni.updateDrumFx();
                } catch(_){ }

                // Auto-size to fit full row content (grid + controls) on open only
                try { window._autoSizePatternModals && window._autoSizePatternModals(); } catch(_) {}
                // Make draggable if not already
                if (!modal._draggableSet) {
                    makeDraggable(modal);
                    modal._draggableSet = true;
                }

                // Wire Drum LEN +/- controls on open (ensure single attach)
                try {
                    const grid = document.getElementById('drumGrid');
                    const lenInc = document.getElementById('drumLenInc');
                    const lenDec = document.getElementById('drumLenDec');
                    const lenVal = document.getElementById('drumLenValue');
                    const lenHint = document.getElementById('drumLenHint');
                    if (grid) {
                        const getMaxLen = () => {
                            try {
                                if (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') {
                                    return window.omnichord._getMaxCycleSteps();
                                }
                            } catch(_) { }
                            return 64;
                        };
                        // Initialize display from grid length
                        const currentLen = Math.max(1, Math.min(getMaxLen(), parseInt(grid.dataset.length||'16',10)||16));
                        if (lenVal) lenVal.textContent = String(currentLen);
                        if (lenHint) lenHint.textContent = `Cycle: ${currentLen} steps`;

                        const applyLen = (newLenRaw) => {
                            const maxLen = getMaxLen();
                            let newLen = Math.max(1, Math.min(maxLen, newLenRaw|0));
                            const oldLen = Math.max(1, Math.min(maxLen, parseInt(grid.dataset.length||'16',10)||16));
                            if (newLen === oldLen) return;

                            // If PLAY is running, defer LEN changes to the next bar boundary
                            let isPlaying = false;
                            try { isPlaying = !!(window.omnichord && window.omnichord._isSequencing); } catch(_){ isPlaying = false; }
                            if (isPlaying) {
                                try { grid.dataset.pendingLength = String(newLen); } catch(_){ }
                                if (lenVal) { lenVal.textContent = String(newLen); try { lenVal.dataset.pending = '1'; } catch(_){ } }
                                if (lenHint) lenHint.textContent = `Queued: ${newLen} steps (next cycle)`;
                                try { const scheduleDeferred = window.scheduleDeferred; if (typeof scheduleDeferred === 'function') scheduleDeferred({ transport:true, grid:true, drums:true }); } catch(_){ }
                                return;
                            }

                            grid.dataset.length = String(newLen);
                            if (lenVal) lenVal.textContent = String(newLen);
                            if (lenHint) lenHint.textContent = `Cycle: ${newLen} steps`;
                            try { delete lenVal.dataset.pending; } catch(_){ }
                            try { delete grid.dataset.pendingLength; } catch(_){ }

                            // For each lane, if quant is default (oldLen or oldLen/oldLen) or empty, update to new default newLen
                            const lanes = Array.from(grid.querySelectorAll('.drum-lane'));
                            lanes.forEach(lane => {
                                const qs = String(lane.dataset.quant||'').trim();
                                let isDefault = false;
                                if (!qs) { isDefault = true; }
                                else {
                                    const m = qs.match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
                                    if (m){ const N=parseInt(m[1],10), D=parseInt(m[2],10); if (Number.isFinite(N)&&Number.isFinite(D) && N===oldLen && D===oldLen) isDefault = true; }
                                    else {
                                        const mn = qs.match(/^\s*(\d+)\s*$/);
                                        if (mn){ const D=parseInt(mn[1],10); if (Number.isFinite(D) && D===oldLen) isDefault = true; }
                                    }
                                }
                                if (isDefault) {
                                    lane.dataset.quant = String(newLen);
                                }
                            });

                            // Rebuild drums honoring per-lane quant D (preserve states proportionally)
                            try { if (typeof window.omnichord?._updateDrumGridForTimeSignature === 'function') { window.omnichord._updateDrumGridForTimeSignature(); } } catch(_) { }

                            // Update container min-width scaling to largest D in drums
                            try {
                                if (drumContainer){
                                    const lanes2 = Array.from(grid.querySelectorAll('.drum-lane'));
                                    const maxD = lanes2.reduce((mx,ln)=>{
                                        const qs2 = String(ln.dataset.quant||'');
                                        let d = parseInt(ln.style.getPropertyValue('--steps-per-bar')||String(newLen),10)||newLen;
                                        const mm = qs2.match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
                                        if (mm){ const dd = parseInt(mm[2],10); if (Number.isFinite(dd) && dd>0) d = dd; }
                                        else {
                                            const mn = qs2.match(/^\s*(\d+)\s*$/);
                                            if (mn){ const dd = parseInt(mn[1],10); if (Number.isFinite(dd) && dd>0) d = dd; }
                                        }
                                        return Math.max(mx, d);
                                    }, newLen);
                                    drumContainer.style.setProperty('--bar-steps', String(maxD));
                                    try { window._autoSizePatternModals && window._autoSizePatternModals(maxD); } catch(_){}
                                }
                            } catch(_){ }

                            const contentEditables = {};
                            try {
                                const els = Array.from(document.querySelectorAll('[contenteditable="true"][id]'));
                                els.forEach(el=>{
                                    try {
                                        const id = String(el.id||'');
                                        if (!id) return;
                                        contentEditables[id] = { text: (el.textContent != null) ? String(el.textContent) : '' };
                                    } catch(_){ }
                                });
                            } catch(_){ }

                            const elementStateById = {};
                            try {
                                const els = Array.from(document.querySelectorAll('[id]'));
                                els.forEach(el=>{
                                    try {
                                        const id = String(el.id||'');
                                        if (!id) return;
                                        const tag = String(el.tagName||'').toLowerCase();
                                        if (tag === 'input' || tag === 'select' || tag === 'textarea') return;
                                        if (el.getAttribute && el.getAttribute('contenteditable') === 'true') return;
                                        const rec = {};
                                        const st = el.getAttribute ? (el.getAttribute('style') || '') : '';
                                        const cn = (el.className != null) ? String(el.className) : '';
                                        const ap = el.getAttribute ? el.getAttribute('aria-pressed') : null;
                                        const ae = el.getAttribute ? el.getAttribute('aria-expanded') : null;
                                        if (cn) rec.className = cn;
                                        if (st) rec.styleText = st;
                                        if (ap != null) rec.ariaPressed = String(ap);
                                        if (ae != null) rec.ariaExpanded = String(ae);
                                        if (Object.keys(rec).length) elementStateById[id] = rec;
                                    } catch(_){ }
                                });
                            } catch(_){ }

                            const scroll = { x: (window.scrollX != null) ? window.scrollX : 0, y: (window.scrollY != null) ? window.scrollY : 0 };
                            const activeElementId = (()=>{
                                try {
                                    const ae = document.activeElement;
                                    return (ae && ae.id) ? String(ae.id) : '';
                                } catch(_){ return ''; }
                            })();

                            // Refresh transport timing so bar length reflects LEN override immediately
                            try { if (typeof window.omnichord?._refreshArpTransportTiming === 'function') window.omnichord._refreshArpTransportTiming(); } catch(_) {}
                        };

                        if (lenInc && !lenInc._wired){ lenInc._wired = true; lenInc.addEventListener('click', () => {
                            const cur = Math.max(1, Math.min(getMaxLen(), parseInt(grid.dataset.length||'16',10)||16));
                            applyLen(cur + 1);
                        }); }
                        if (lenDec && !lenDec._wired){ lenDec._wired = true; lenDec.addEventListener('click', () => {
                            const cur = Math.max(1, Math.min(getMaxLen(), parseInt(grid.dataset.length||'16',10)||16));
                            applyLen(cur - 1);
                        }); }
                    }
                } catch(_){}
            }
        };
        
        window.closeDrumModal = function() {
            console.log('Closing drum modal AND disabling drums');
            const modal = document.getElementById('drumModal');
            if (modal) modal.style.display = 'none';
            const btn = document.getElementById('drumsBtn');
            if (btn) btn.classList.remove('active');
            // Disable drums
            if (window.omnichord && typeof omnichord.toggleDrumsMode === 'function') {
                omnichord.drumsEnabled = false;
            }
        };
        
        window.closeDrumModalOnly = function() {
            console.log('Closing drum modal only (keeping drums enabled)');
            const modal = document.getElementById('drumModal');
            if (modal) modal.style.display = 'none';
            // Don't disable the drums - keep button active
        };
        
        window.showPatternModal = function(modalIdOrEl) {
            try { console.log('Opening pattern modal'); } catch(_){ }
            const modal = (typeof modalIdOrEl === 'string')
                ? document.getElementById(modalIdOrEl)
                : (modalIdOrEl && modalIdOrEl.nodeType === 1 ? modalIdOrEl : document.getElementById('patternModal'));
            if (modal) {
                modal.style.display = 'flex';
                try { bringModalToFront(modal.id); } catch(_){ try { bringModalToFront('patternModal'); } catch(__){} }
                try { window._ensureModalDotScaling(modal); modal._dotScaleApply && modal._dotScaleApply(); } catch(_) {}
                try { window._ensureModalAspectResize && window._ensureModalAspectResize(modal); } catch(_) {}
                try { window.ensurePatternTransport && window.ensurePatternTransport(); } catch(_) {}
                // Ensure pattern grid is visible
                const patternContainer = modal.querySelector('.drum-grid-container');
                if (patternContainer) {
                    patternContainer.style.display = 'block';
                }
                // Auto-size to fit full row content on open only
                try { window._autoSizePatternModals && window._autoSizePatternModals(); } catch(_) {}
                // Make draggable if not already
                if (!modal._draggableSet) {
                    makeDraggable(modal);
                    modal._draggableSet = true;
                }
            }
        };
        
        window.closePatternModal = function() {
            console.log('Closing pattern modal AND disabling pattern');
            const modal = document.getElementById('patternModal');
            if (modal) modal.style.display = 'none';
            const btn = document.getElementById('patternBtn');
            if (btn) btn.classList.remove('active');
            // Do not alter pattern transport here; PLAY/STOP controls transport
        };
        
        window.closePatternModalOnly = function(el) {
            try { console.log('Closing pattern modal only (keeping pattern enabled)'); } catch(_){ }
            const modal = (el && el.closest) ? el.closest('.floating-modal') : document.getElementById('patternModal');
            if (modal) modal.style.display = 'none';
            // No changes to transport; UI only
        };

        // Pattern instance support: dblclick PATTERN to spawn another pattern modal.
        (function(){
            if (window._patternInstanceSupportWired) return;
            window._patternInstanceSupportWired = true;

            const PATTERN_ROLE_IDS = [
                'patternSpeakerBtn',
                'patternPatternNumber',
                'patternLenDec',
                'patternLenValue',
                'patternLenInc',
                'patternClearBtn',
                'universalPattern',
                'universalPatternText',
                'patternQuant',
                'universalNpc',
                'tab-arp',
                'patternGrid',
                'patternResizeHandle',
                'patternSynthToggleBar',
                'patternSynthToggleBtn',
            ];

            const deepClone = (obj)=>{
                try {
                    if (typeof structuredClone === 'function') return structuredClone(obj);
                } catch(_){ }
                try { return JSON.parse(JSON.stringify(obj)); } catch(_){ return obj; }
            };

            const buildBlankPatternGrid = (modalEl, gridEl, npc, len)=>{
                if (!gridEl) return;
                const safeNpc = Math.max(1, Math.min(64, parseInt(String(npc||'16'),10) || 16));
                const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                const safeLen = Math.max(1, Math.min(maxLen, parseInt(String(len||'16'),10) || 16));
                try { gridEl.innerHTML = ''; } catch(_){ }
                try { gridEl.dataset.length = String(safeLen); } catch(_){ }
                try { gridEl.dataset.built = '1'; } catch(_){ }
                try { gridEl.style.setProperty('--npc-rows', String(safeNpc)); } catch(_){ }
                try { gridEl.style.gridTemplateRows = `repeat(${safeNpc}, auto)`; } catch(_){ }
                try {
                    const container = gridEl.closest('.drum-grid-container') || gridEl.parentElement;
                    if (container && container.style) container.style.setProperty('--bar-steps', String(safeLen));
                    gridEl.style.setProperty('--bar-steps', String(safeLen));
                } catch(_){ }

                for (let rowIdx = 0; rowIdx < safeNpc; rowIdx++) {
                    const row = document.createElement('div');
                    row.className = 'drum-row pattern-row';
                    const label = document.createElement('div');
                    label.className = 'drum-label';
                    label.textContent = `NOTE ${safeNpc - rowIdx}`;
                    row.appendChild(label);

                    // Per-row QUANT controls (Q) for polyrhythms (clone instances)
                    try {
                        const params = document.createElement('div');
                        params.className = 'drum-params';
                        const qWrap = document.createElement('div');
                        qWrap.className = 'drum-quant';
                        const qLbl = document.createElement('label');
                        qLbl.textContent = 'Q:';
                        qLbl.style.marginRight = '4px';
                        qLbl.style.fontSize = '10px';
                        qLbl.style.opacity = '0.8';
                        const qInput = document.createElement('input');
                        qInput.type = 'text';
                        qInput.placeholder = 'Q';
                        qInput.value = String(safeLen);
                        qInput.size = 6;
                        qInput.style.width = '56px';
                        qInput.title = 'Row subdivisions (Q per bar). Example: 7 = septuplets. â€œ7/16â€ is treated as 7.';
                        qInput.addEventListener('focus', (e)=> e.target && e.target.select && e.target.select());
                        qInput.addEventListener('change', ()=>{
                            const raw = String(qInput.value||'').trim();
                            let D = safeLen;
                            const mf = raw.match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
                            if (mf) {
                                const n = parseInt(mf[1], 10);
                                if (Number.isFinite(n) && n > 0) D = n;
                            } else {
                                const mn = raw.match(/^\s*(\d+)\s*$/);
                                if (mn) {
                                    const n = parseInt(mn[1], 10);
                                    if (Number.isFinite(n) && n > 0) D = n;
                                }
                            }
                            D = Math.max(1, Math.min(256, D|0));
                            const N = D;
                            const str = String(D);
                            try { qInput.value = String(D); } catch(_){ }
                            const isPlaying = !!(window.omnichord && window.omnichord._arpTransport && window.omnichord._arpTransport.running);
                            if (isPlaying) {
                                lane.dataset.pendingQuant = str;
                                lane._pendingQuant = { str, N, D };
                                try { qInput.dataset.pending = '1'; qInput.classList.add('pending-change'); } catch(_){ }
                                try {
                                    const pt = modalEl && modalEl._patternTransport;
                                    if (pt) {
                                        pt._pendingApply = ()=>{ try { window._applyPatternInstancePending && window._applyPatternInstancePending(modalEl); } catch(_){ } };
                                    }
                                } catch(_){ }
                            } else {
                                lane.dataset.quant = str;
                                lane._quant = { str, N, D };
                                try { delete lane.dataset.pendingQuant; } catch(_){ }
                                try { delete lane._pendingQuant; } catch(_){ }
                                try { delete qInput.dataset.pending; qInput.classList.remove('pending-change'); } catch(_){ }
                                // Immediate when stopped: row subdivides into D dots now.
                                try { window.rebuildPatternLaneForQuant && window.rebuildPatternLaneForQuant(lane, gridEl); } catch(_){ }
                            }
                            // Update CSS vars immediately to keep hit-testing aligned
                            try {
                                const d = (lane._pendingQuant ? lane._pendingQuant.D : (lane._quant && lane._quant.D)) || safeLen;
                                lane.style.setProperty('--steps-per-bar', String(d));
                                const container = lane.closest('.drum-grid-container');
                                if (container) {
                                    const lanes = Array.from(container.querySelectorAll('.pattern-lane'));
                                    const maxD = lanes.reduce((mx,ln)=>{
                                        const qs = ln.dataset.quant||'';
                                        let dd = safeLen;
                                        const mm = qs.match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
                                        if (mm){ const d2=parseInt(mm[2],10); if (Number.isFinite(d2)&&d2>0) dd=d2; }
                                        else { const mn=qs.match(/^\s*(\d+)\s*$/); if (mn){ const d2=parseInt(mn[1],10); if (Number.isFinite(d2)&&d2>0) dd=d2; } }
                                        return Math.max(mx, dd);
                                    }, safeLen);
                                    container.style.setProperty('--bar-steps', String(maxD));
                                }
                            } catch(_){ }
                        });
                        qWrap.appendChild(qLbl);
                        qWrap.appendChild(qInput);
                        params.appendChild(qWrap);
                        row.appendChild(params);
                    } catch(_){ }

                    const lane = document.createElement('div');
                    lane.className = 'drum-lane pattern-lane';
                    lane.dataset.row = String(rowIdx);
                    lane.dataset.quant = String(safeLen);
                    lane._quant = { str: String(safeLen), N: safeLen, D: safeLen };
                    try { lane.style.setProperty('--steps-per-bar', String(safeLen)); } catch(_){ }

                    const tieLayer = document.createElement('div');
                    tieLayer.className = 'pattern-tie-layer';
                    lane.appendChild(tieLayer);

                    for (let sIdx = 0; sIdx < safeLen; sIdx++) {
                        const st = document.createElement('div');
                        st.className = 'drum-step pattern-step' + ((sIdx % 4 === 0) ? ' beat-accent' : '');
                        st.dataset.step = String(sIdx);
                        st.dataset.vel = '100';
                        try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(st); } catch(_){ }
                        try { if (window.attachVelocityDrag) window.attachVelocityDrag(st); } catch(_){ }
                        lane.appendChild(st);
                    }

                    row.appendChild(lane);
                    gridEl.appendChild(row);
                }
            };

            // Apply pending LEN/NPC/Q changes for a cloned Pattern instance on the next cycle (Beat 1).
            // This is intentionally instance-scoped (does not touch base pattern transport or rebuild other lanes).
            window._applyPatternInstancePending = function(modalEl){
                try {
                    if (!modalEl || !modalEl.querySelector) return;
                    const gridEl = (modalEl.querySelector('[data-role="patternGrid"]') || modalEl.querySelector('#patternGrid') || modalEl.querySelector('.pattern-grid'));
                    if (!gridEl) return;

                    // Commit any queued mute/unmute at Beat 1.
                    try {
                        if (modalEl._patternPendingEnabled != null) {
                            const desired = !!modalEl._patternPendingEnabled;
                            modalEl._patternPendingEnabled = null;
                            modalEl._patternEnabled = desired;

                            // Sync modal speaker icon if present
                            try {
                                const speakerBtn = (modalEl.querySelector('[data-role="patternSpeakerBtn"]') || modalEl.querySelector('#patternSpeakerBtn'));
                                if (speakerBtn) speakerBtn.textContent = modalEl._patternEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
                            } catch(_){ }

                            // Apply audio behavior (Beat 1 is king)
                            const pt = modalEl._patternTransport;
                            const omni = window.omnichord;
                            const isPlaying = !!(omni && omni._arpTransport && omni._arpTransport.running);
                            if (pt) {
                                if (modalEl._patternEnabled) {
                                    if (isPlaying && typeof pt.start === 'function') pt.start({ alignToTransport: true, preBufferMs: 80 });
                                    else { try { pt.stopVoices && pt.stopVoices(); } catch(_){ } }
                                } else {
                                    try { pt.stopVoices && pt.stopVoices(); } catch(_){ }
                                    try { pt._startAtBarIndex = null; } catch(_){ }
                                }
                            }

                            // Update strip button traffic light
                            try { window._updatePatternInstanceButtonVisual && window._updatePatternInstanceButtonVisual(modalEl); } catch(_){ }
                        }
                    } catch(_){ }

                    const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;

                    const captureShadow = ()=>{
                        const shadow = modalEl._patternShadowState = (modalEl._patternShadowState || {});
                        shadow.lanes = shadow.lanes || {};
                        const lanes = Array.from(gridEl.querySelectorAll('.pattern-lane'));
                        lanes.forEach(lane=>{
                            const r = String(lane.dataset.row||'0');
                            const st = {};
                            Array.from(lane.querySelectorAll('.pattern-step')).forEach(step=>{
                                const i = parseInt(step.dataset.step||'0',10)||0;
                                const obj = {};
                                if (step.classList.contains('active')) obj.active = 1;
                                if (step.dataset.len) obj.len = String(step.dataset.len);
                                if (step.dataset.tie === '1') obj.tie = 1;
                                if (step.dataset.vel) obj.vel = String(step.dataset.vel);
                                if (Object.keys(obj).length) st[i] = obj;
                            });
                            shadow.lanes[r] = {
                                quant: String(lane.dataset.quant||''),
                                pendingQuant: String(lane.dataset.pendingQuant||''),
                                steps: st,
                            };
                        });
                    };
                    const restoreShadow = ()=>{
                        const shadow = modalEl._patternShadowState;
                        if (!shadow || !shadow.lanes) return;
                        Array.from(gridEl.querySelectorAll('.pattern-lane')).forEach(lane=>{
                            const r = String(lane.dataset.row||'0');
                            const saved = shadow.lanes[r];
                            if (!saved) return;

                            if (saved.quant) lane.dataset.quant = String(saved.quant);
                            if (saved.pendingQuant) lane.dataset.pendingQuant = String(saved.pendingQuant);

                            // Recompute cached quant for any helper code
                            try {
                                const qs = String(lane.dataset.quant||'').trim();
                                let N = 0, D = 0;
                                const m = qs.match(/^(\d+)\/(\d+)$/);
                                if (m) { N = parseInt(m[1],10)||0; D = parseInt(m[2],10)||0; }
                                else { const mn = qs.match(/^(\d+)$/); if (mn) { D = parseInt(mn[1],10)||0; N = D; } }
                                if (!D) { D = parseInt(gridEl.dataset.length||'16',10) || 16; N = D; }
                                lane._quant = { N: Math.max(1, Math.min(N||D, D)), D: Math.max(1, D), str: qs || String(D) };
                            } catch(_){ }

                            // Sync Q input UI (if present)
                            try {
                                const qInput = lane.closest('.pattern-row')?.querySelector('.drum-quant input');
                                if (qInput) {
                                    const v = String(lane.dataset.pendingQuant || lane.dataset.quant || '').trim();
                                    if (v) qInput.value = v;
                                    if (lane.dataset.pendingQuant) { qInput.dataset.pending='1'; qInput.classList.add('pending-change'); }
                                    else { delete qInput.dataset.pending; qInput.classList.remove('pending-change'); }
                                }
                            } catch(_){ }

                            const stepMap = saved.steps || {};
                            Array.from(lane.querySelectorAll('.pattern-step')).forEach(step=>{
                                const i = parseInt(step.dataset.step||'0',10)||0;
                                const obj = stepMap[i];
                                if (!obj) return;
                                if (obj.active) step.classList.add('active');
                                if (obj.len) step.dataset.len = String(obj.len);
                                if (obj.tie) step.dataset.tie = '1';
                                if (obj.vel) step.dataset.vel = String(obj.vel);
                                try { window.updateStepVelocityClass && window.updateStepVelocityClass(step); } catch(_){ }
                            });
                        });
                    };

                    const pendingLenRaw = gridEl.dataset.pendingLength;
                    const pendingNpcRaw = gridEl.dataset.pendingNpc;
                    const hasPendingStructure = !!(pendingLenRaw || pendingNpcRaw);

                    if (hasPendingStructure) {
                        captureShadow();
                        const npcInput = (modalEl.querySelector('[data-role="universalNpc"]') || modalEl.querySelector('#universalNpc'));
                        const curNpc = Math.max(1, Math.min(64, parseInt(npcInput?.value||'16',10) || 16));
                        const targetNpc = Math.max(1, Math.min(64, parseInt(pendingNpcRaw||String(curNpc),10) || curNpc));
                        const curLen = Math.max(1, Math.min(maxLen, parseInt(gridEl.dataset.length||'16',10) || 16));
                        const targetLen = Math.max(1, Math.min(maxLen, parseInt(pendingLenRaw||String(curLen),10) || curLen));

                        buildBlankPatternGrid(modalEl, gridEl, targetNpc, targetLen);
                        restoreShadow();
                        try { delete gridEl.dataset.pendingLength; } catch(_){ }
                        try { delete gridEl.dataset.pendingNpc; } catch(_){ }
                    }

                    // Commit any pending per-lane quant changes at the cycle boundary
                    try {
                        const lanes = Array.from(gridEl.querySelectorAll('.pattern-lane'));
                        lanes.forEach(lane=>{
                            const pq = lane?.dataset?.pendingQuant;
                            if (!pq) return;
                            lane.dataset.quant = String(pq);
                            try { delete lane.dataset.pendingQuant; } catch(_){ }
                            try { delete lane._pendingQuant; } catch(_){ }
                            // Recompute cache + CSS var
                            try {
                                const qs = String(lane.dataset.quant||'').trim();
                                let N = 0, D = 0;
                                const m = qs.match(/^(\d+)\/(\d+)$/);
                                if (m) { N = parseInt(m[1],10)||0; D = parseInt(m[2],10)||0; }
                                else { const mn = qs.match(/^(\d+)$/); if (mn) { D = parseInt(mn[1],10)||0; N = D; } }
                                if (!D) { D = parseInt(gridEl.dataset.length||'16',10) || 16; N = D; }
                                lane._quant = { N: Math.max(1, Math.min(N||D, D)), D: Math.max(1, D), str: qs || String(D) };
                                lane.style.setProperty('--steps-per-bar', String(lane._quant.D));
                            } catch(_){ }
                            // Clear pending UI marker
                            try {
                                const qInput = lane.closest('.pattern-row')?.querySelector('.drum-quant input');
                                if (qInput) { delete qInput.dataset.pending; qInput.classList.remove('pending-change'); qInput.value = String(lane.dataset.quant||''); }
                            } catch(_){ }

                            // Rebuild row dots to match D now that quant is committed.
                            try { window.rebuildPatternLaneForQuant && window.rebuildPatternLaneForQuant(lane, gridEl); } catch(_){ }
                        });

                        // Update container geometry to max D
                        try {
                            const container = gridEl.closest('.drum-grid-container');
                            if (container) {
                                const lanes2 = Array.from(container.querySelectorAll('.pattern-lane'));
                                const maxD = lanes2.reduce((mx,ln)=>{
                                    const qs = String(ln.dataset.quant||'').trim();
                                    let d = 0;
                                    const m = qs.match(/^(\d+)\/(\d+)$/);
                                    if (m) d = parseInt(m[2],10)||0;
                                    else { const mn = qs.match(/^(\d+)$/); if (mn) d = parseInt(mn[1],10)||0; }
                                    return Math.max(mx, d||0);
                                }, 0);
                                if (maxD > 0) container.style.setProperty('--bar-steps', String(maxD));
                            }
                        } catch(_){ }
                    } catch(_){ }

                    // Rewire interactions for newly rebuilt lanes, and rebuild tie overlays.
                    try { wirePatternGridInteractions(modalEl); } catch(_){ }
                    try {
                        Array.from(gridEl.querySelectorAll('.pattern-lane')).forEach(lane=>{
                            try { window.rebuildPatternTieOverlays && window.rebuildPatternTieOverlays(lane); } catch(_){ }
                        });
                    } catch(_){ }
                } catch(_){ }
            };

            const nextInstKey = ()=>{
                const arr = window._patternInstances = window._patternInstances || [];
                // Instance 0 is the built-in Pattern (arp). Next are arp2, arp3, ...
                const idx = arr.length + 2;
                return 'arp' + String(idx);
            };

            const remapIdsInSubtree = (root, mapFn)=>{
                if (!root) return;
                const nodes = root.querySelectorAll('[id]');
                nodes.forEach(n=>{
                    const oldId = String(n.id||'');
                    const newId = mapFn(oldId, n);
                    if (newId && newId !== oldId) n.id = newId;
                });
                const labels = root.querySelectorAll('label[for]');
                labels.forEach(l=>{
                    const oldFor = String(l.getAttribute('for')||'');
                    const newFor = mapFn(oldFor, l);
                    if (newFor && newFor !== oldFor) l.setAttribute('for', newFor);
                });
            };

            const wirePatternInstanceTransport = (modalEl, gridEl, instrumentKey, enabledFn)=>{
                // Build a per-instance transport modeled after ensurePatternTransport (but scoped).
                const pt = {
                    running: false,
                    tickCounter: 0,
                    absTickCounter: 0,
                    nextAt: (performance && performance.now ? performance.now() : Date.now()),
                    stepMs: 120,
                    activeVoices: new Set(),
                    swingPct: 0,
                    _rafActive: false,
                    preRollUntil: null,
                    _pendingApply: null,
                    // Beat-locked: driven from omnichord._arpTransport
                    _useMasterClock: true,
                    _gridEl: gridEl,
                    _instrumentKey: instrumentKey,
                    _scheduleStep: null,
                    _masterLastAbsStep: null,
                    _startAtBarIndex: null,
                };

                function refreshTiming(){
                    try {
                        const bpmEl = document.getElementById('universalBpm');
                        const transportBpmEl = document.getElementById('transportBpm');
                        const quantEl = document.getElementById('universalQuant');
                        const patternQuantEl = modalEl ? (modalEl.querySelector('[data-role="patternQuant"]') || modalEl.querySelector('#patternQuant')) : null;
                        const swingEl = document.getElementById('universalSwing');
                        const bpm = Math.max(20, window.__MASTER_BPM || parseFloat(transportBpmEl?.value||'0') || parseFloat(bpmEl?.value||'120')||120);
                        const quant = (patternQuantEl?.value || quantEl?.value || '1/16').trim();
                        let baseDiv = 16; let isTrip = false; let tupletRatio = 1;
                        if (/tuplet:\s*(\d+)\/(\d+)/i.test(quant)) { const m=quant.match(/tuplet:\s*(\d+)\/(\d+)/i); const n=+m[1], d=+m[2]; if(n>0&&d>0){ tupletRatio=n/d; baseDiv=4; } }
                        else if (/^1\/(\d+)(t)?$/i.test(quant)) { const m=quant.match(/^1\/(\d+)(t)?$/i); baseDiv=parseInt(m[1],10)||16; if(m[2]) isTrip=true; }
                        const beatMs = 60000 / bpm;
                        let stepMs = beatMs * 4 / baseDiv; if (isTrip) stepMs *= (2/3); if (tupletRatio !== 1) stepMs *= (1/tupletRatio);
                        pt.stepMs = stepMs; pt.swingPct = Math.max(0, Math.min(75, parseFloat(swingEl?.value||'0')||0));
                    } catch(_) {}
                }
                refreshTiming();
                ['universalBpm','universalQuant','universalSwing','transportBpm'].forEach(id=>{ const el=document.getElementById(id); if(el){ el.addEventListener('input', refreshTiming); el.addEventListener('change', refreshTiming); }});
                try {
                    const pq = modalEl ? (modalEl.querySelector('[data-role="patternQuant"]') || modalEl.querySelector('#patternQuant')) : null;
                    if (pq && !pq._wiredPatternInstTiming) {
                        pq._wiredPatternInstTiming = true;
                        pq.addEventListener('input', refreshTiming);
                        pq.addEventListener('change', refreshTiming);
                    }
                } catch(_){ }

                const getLaneD = (lane, fallback)=>{
                    let D = fallback|0;
                    try {
                        const qs = String(lane?.dataset?.quant||'').trim();
                        const mf = qs.match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
                        if (mf) {
                            const n = parseInt(mf[1],10);
                            if (Number.isFinite(n) && n>0) D = n;
                        } else {
                            const mn = qs.match(/^\s*(\d+)\s*$/);
                            if (mn) {
                                const n = parseInt(mn[1],10);
                                if (Number.isFinite(n) && n>0) D = n;
                            }
                        }
                    } catch(_){ }
                    D = Math.max(1, Math.min(256, D|0));
                    return D;
                };
                function noteId(row, stepIdx){ return `r${row}s${stepIdx}`; }

                function scheduleStep(absTickNow, barTick, ticksPerBar){
                    const tpb = Math.max(1, ticksPerBar|0);
                    const bt = Math.max(0, barTick|0);
                    const noteOpts = pt._noteOpts || (pt._noteOpts = { gridEl: null, instrumentKey: '', transport: pt, gateMs: 0, maxSteps: 0 });
                    // Apply queued changes at cycle start (Beat 1)
                    if (bt === 0 && typeof pt._pendingApply === 'function') {
                        try { pt._pendingApply(); } catch(_){ }
                        pt._pendingApply = null;
                    }

                    // If muted, still advance time but do not trigger audio.
                    try {
                        if (typeof enabledFn === 'function' && !enabledFn()) {
                            if (pt.activeVoices.size){
                                for (const vid of Array.from(pt.activeVoices)){
                                    const meta = pt[vid]; if (meta && meta.stop) { try { meta.stop(); } catch(_){} }
                                    pt.activeVoices.delete(vid); delete pt[vid];
                                }
                            }
                            return;
                        }
                    } catch(_){ }
                    const tickMs = (window.omnichord && window.omnichord._arpTransport && window.omnichord._arpTransport.tickMs) ? Number(window.omnichord._arpTransport.tickMs) : NaN;
                    // Stop expired voices
                    if (pt.activeVoices.size){
                        for (const vid of Array.from(pt.activeVoices)){
                            const meta = pt[vid];
                            if (meta && meta.offAbsTick != null && (meta.offAbsTick|0) <= (absTickNow|0)){
                                try { if (meta.stop) meta.stop(); } catch(_){ }
                                pt.activeVoices.delete(vid);
                                delete pt[vid];
                            }
                        }
                    }

                    const rows = gridEl.querySelectorAll('.pattern-row');
                    const baseFallback = Math.max(1, parseInt(gridEl.dataset.length||'16',10)||16);
                    rows.forEach((rowEl, rowIdx)=>{
                        const lane = rowEl.querySelector('.pattern-lane');
                        if (!lane) return;
                        const D = Math.max(1, (lane.querySelectorAll('.pattern-step').length|0) || getLaneD(lane, baseFallback));
                        // Fraction-based scheduling: works even when ticksPerBar is clamped and not divisible by D.
                        const frac = bt / tpb;
                        const stepIdx = Math.max(0, Math.min(D-1, Math.floor(frac * D + 1e-9)));
                        // Fire at most once per lane-step.
                        if (lane._lastPatternStepIdx === stepIdx) return;
                        lane._lastPatternStepIdx = stepIdx;
                        try { lane.style.setProperty('--steps-per-bar', String(D)); } catch(_){ }
                        const cell = lane.querySelector(`.pattern-step[data-step="${stepIdx}"]`);
                        if (!cell) return;
                        if (!cell.classList.contains('active')) return;
                        if (cell.dataset.tie === '1') return;

                        // Visual feedback: pulse the dot when it fires.
                        try { window._pulseStepEl && window._pulseStepEl(cell); } catch(_){ }

                        const lenSteps = Math.max(1, Math.min(D - stepIdx, parseInt(cell.dataset.len||'1',10)||1));
                        const vel = (window.getStepVelocity ? (window.getStepVelocity(cell) ?? 100) : (parseInt(cell.dataset.vel||'100',10)||100));
                        const vid = noteId(rowIdx, stepIdx);
                        const durTicks = Math.max(1, Math.round((lenSteps * tpb) / D));
                        const offAbsTick = (absTickNow|0) + durTicks;
                        const epsilonMs = 8;
                        const gateMs = (Number.isFinite(tickMs) && tickMs > 0)
                            ? Math.max(10, Math.floor((tickMs * durTicks) - epsilonMs))
                            : NaN;
                        let stopFn = null;
                        try {
                            if (window.omnichord && typeof window.omnichord._playPatternNote === 'function'){
                                noteOpts.gridEl = gridEl;
                                noteOpts.instrumentKey = instrumentKey;
                                noteOpts.transport = pt;
                                noteOpts.gateMs = gateMs;
                                noteOpts.maxSteps = D;
                                stopFn = window.omnichord._playPatternNote(rowIdx, lenSteps, stepIdx, vel, noteOpts);
                            }
                        } catch(_){ }
                        try {
                            if (pt.activeVoices.has(vid)) {
                                const prev = pt[vid];
                                if (prev && prev.stop) { try { prev.stop(); } catch(_){ } }
                                pt.activeVoices.delete(vid);
                                delete pt[vid];
                            }
                        } catch(_){ }
                        pt.activeVoices.add(vid);
                        pt[vid] = { offAbsTick, stop: stopFn };
                    });
                }

                function loop(){
                    pt._rafActive = true;
                    if (!pt.running) { pt._rafActive = false; return; }
                    // Master transport drives steps; never run an independent rAF clock.
                    if (pt._useMasterClock) { pt._rafActive = false; return; }
                    const now=(performance && performance.now ? performance.now() : Date.now());
                    if (pt.preRollUntil != null) {
                        if (now + 0.5 < pt.preRollUntil) {
                            requestAnimationFrame(loop);
                            return;
                        }
                        pt.preRollUntil = null;
                        if (!Number.isFinite(pt.nextAt) || pt.nextAt < now) {
                            pt.nextAt = now + pt.stepMs;
                        }
                    }
                    if (now + 1 >= pt.nextAt){
                        const base = pt.stepMs; const isEven = (pt.tickCounter % 2)===0; let stepDur = base;
                        if (pt.swingPct>0){ const s=pt.swingPct/100; stepDur = isEven ? base*(1+s*0.5) : base*(1-s*0.5); }
                        const tpb = (window.omnichord && window.omnichord._arpTransport && window.omnichord._arpTransport.ticksPerBar)
                            ? (window.omnichord._arpTransport.ticksPerBar | 0)
                            : (parseInt(gridEl.dataset.length||'16',10) || 16);
                        const bt = (tpb > 0) ? ((pt.tickCounter | 0) % tpb) : (pt.tickCounter | 0);
                        scheduleStep(pt.absTickCounter | 0, bt, tpb | 0);
                        pt.tickCounter = (pt.tickCounter + 1) >>> 0; pt.absTickCounter = (pt.absTickCounter + 1) >>> 0;
                        if (pt.tickCounter >= 100000000) pt.tickCounter = tpb > 0 ? (pt.tickCounter % tpb) : pt.tickCounter;
                        pt.nextAt += stepDur;
                    }
                    if (pt.preRollUntil == null && pt.nextAt - now > 5000) pt.nextAt = now + pt.stepMs;
                    requestAnimationFrame(loop);
                }
                pt.nextAt = (performance && performance.now ? performance.now() : Date.now()) + pt.stepMs;
                pt.kick = function(){
                    if (pt._useMasterClock) return;
                    if (!pt._rafActive) { try { requestAnimationFrame(loop); } catch(_){} }
                };
                pt.stopVoices = function(){
                    try {
                        if (pt.activeVoices.size){
                            for (const vid of Array.from(pt.activeVoices)){
                                const meta = pt[vid];
                                if (meta && meta.stop) { try { meta.stop(); } catch(_){ } }
                                if (vid in pt) delete pt[vid];
                            }
                            pt.activeVoices.clear();
                        }
                    } catch(_){ }
                };
                pt.stop = function(resetPhase = true){
                    pt.running = false;
                    pt.stopVoices();
                    pt.preRollUntil = null;
                    if (resetPhase) {
                        pt.tickCounter = 0;
                        pt.absTickCounter = 0;
                        const now = (performance && performance.now ? performance.now() : Date.now());
                        pt.nextAt = now;
                    }
                };
                pt.start = function(resetPhase = true, opts){
                    if (typeof resetPhase === 'object' && opts === undefined) {
                        opts = resetPhase;
                        resetPhase = true;
                    }
                    const options = opts || {};
                    if (pt._useMasterClock) {
                        // Beat 1 is king: always start on Beat 1 of the NEXT bar.
                        const omni = window.omnichord;
                        const transport = omni && omni._arpTransport;
                        const tpBar = Math.max(1, (transport && transport.ticksPerBar) || 16);
                        const absTick = (transport && (transport.absTickCounter|0)) || 0;
                        const curBar = Math.floor(absTick / tpBar);
                        pt._startAtBarIndex = curBar + 1;
                        pt._masterLastAbsStep = null;
                        pt.preRollUntil = null;
                        pt.running = true;
                        try { pt.stopVoices && pt.stopVoices(); } catch(_){ }
                        return;
                    }
                    const now = (performance && performance.now ? performance.now() : Date.now());
                    if (resetPhase) {
                        pt.tickCounter = 0;
                        pt.absTickCounter = 0;
                    }
                    let delayMs = 0;
                    const alignToTransport = options.alignToTransport !== false;
                    const preBufferMs = Math.max(0, Number.isFinite(options.preBufferMs) ? Number(options.preBufferMs) : 0);
                    const omni = window.omnichord;
                    const transport = omni && omni._arpTransport;
                    if (alignToTransport && transport) {
                        const tickMs = transport.tickMs || ((transport.beatMs || (60000 / Math.max(20, transport.bpm || 120))) / Math.max(1, transport.ticksPerBeat || 4));
                        const tpBar = Math.max(1, transport.ticksPerBar || ((transport.beatsPerBar || 4) * Math.max(1, transport.ticksPerBeat || 4)));
                        const curTick = transport.tickCounter|0;
                        const remTicks = (tpBar - (curTick % tpBar)) % tpBar;
                        const waitTicks = remTicks === 0 ? tpBar : remTicks;
                        delayMs += waitTicks * tickMs;
                    }
                    delayMs += preBufferMs;
                    if (delayMs > 1) {
                        pt.preRollUntil = now + delayMs;
                        pt.nextAt = pt.preRollUntil;
                    } else {
                        pt.preRollUntil = null;
                        pt.nextAt = now;
                    }
                    pt.running = true;
                    pt.kick();
                };

                // Expose scheduler so master transport can drive this instance.
                try { pt._scheduleStep = scheduleStep; } catch(_){ }
                return pt;
            };

            const wirePatternGridInteractions = (modalEl)=>{
                const gridEl = (modalEl.querySelector('[data-role="patternGrid"]') || modalEl.querySelector('#patternGrid') || modalEl.querySelector('.pattern-grid'));
                if (!gridEl) return;
                if (!gridEl._wiredPatternInstanceGrid) gridEl._wiredPatternInstanceGrid = true;
                const lenFromGrid = ()=>{
                    const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                    return Math.max(1, Math.min(maxLen, parseInt(gridEl.dataset.length||'16',10)||16));
                };
                const setHeadLen = (lane, headStep, newLen)=>{
                    const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                    const len = Math.max(1, Math.min(newLen|0, steps.length - headStep));
                    const head = steps[headStep];
                    if (!head) return;
                    head.dataset.len = String(len);
                    head.classList.add('active');
                    for (let i=0;i<steps.length;i++){
                        if (i>headStep && i<= headStep+len-1) steps[i].dataset.tie='1';
                        else if (i>headStep) delete steps[i].dataset.tie;
                    }
                    try { if (typeof window.rebuildPatternTieOverlays === 'function') window.rebuildPatternTieOverlays(lane); } catch(_){ }
                };

                // Delegated interactions per lane
                Array.from(gridEl.querySelectorAll('.pattern-lane')).forEach(lane=>{
                    if (lane._wiredPatternLaneInstance) return;
                    lane._wiredPatternLaneInstance = true;
                    lane.addEventListener('mousedown', (e)=>{
                        const st = e.target && e.target.classList && e.target.classList.contains('pattern-step') ? e.target : null;
                        if (!st) return;
                        if (e.button !== 0) return;
                        if (st.classList.contains('disabled')) return;
                        if (st.dataset.tie === '1') return;
                        e.preventDefault();

                        const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                        const headIdx = parseInt(st.dataset.step||'0',10)||0;
                        const startX = e.clientX;
                        const startY = e.clientY;
                        const startVel = parseInt(st.dataset.vel || '100', 10);

                        let dragMode = null; // 'len' | 'vel'

                        const ensureActive = ()=>{
                            if (!st.classList.contains('active')) {
                                st.classList.add('active');
                                st.dataset.len = st.dataset.len || '1';
                            }
                            if (!st.dataset.vel) st.dataset.vel = '100';
                            try { window.updateStepVelocityClass && window.updateStepVelocityClass(st); } catch(_){ }
                        };

                        const applyVel = (clientY)=>{
                            ensureActive();
                            const deltaY = startY - clientY; // up = louder
                            const deltaVel = Math.round(deltaY / 1.5);
                            const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                            st.dataset.vel = String(newVel);
                            try { window.updateStepVelocityClass && window.updateStepVelocityClass(st); } catch(_){ }
                        };

                        const applyLen = (clientX)=>{
                            ensureActive();
                            const rect = lane.getBoundingClientRect();
                            const x = Math.max(0, Math.min(rect.width, clientX - rect.left));
                            const idx = Math.max(0, Math.min(steps.length-1, Math.floor((x/rect.width)*steps.length)));
                            setHeadLen(lane, headIdx, idx - headIdx + 1);
                        };

                        const onMove = (ev)=>{
                            try { ev.preventDefault(); } catch(_){ }
                            const dx = Math.abs(ev.clientX - startX);
                            const dy = Math.abs(ev.clientY - startY);

                            // Determine drag mode (favor horizontal length unless clearly vertical)
                            if (!dragMode) {
                                if (dy > dx * 2 && dy > 10) {
                                    dragMode = 'vel';
                                    st.classList.add('vel-dragging');
                                } else if (dx > 3) {
                                    dragMode = 'len';
                                } else {
                                    return;
                                }
                                // Suppress the click that follows a real drag.
                                try { lane._suppressNextClick = true; lane._suppressNextClickStep = st; } catch(_){ }
                            }

                            if (dragMode === 'vel') {
                                applyVel(ev.clientY);
                            } else if (dragMode === 'len') {
                                applyLen(ev.clientX);
                            }
                        };

                        const onUp = ()=>{
                            document.removeEventListener('mousemove', onMove);
                            document.removeEventListener('mouseup', onUp);
                            try { st.classList.remove('vel-dragging'); } catch(_){ }
                        };

                        document.addEventListener('mousemove', onMove);
                        document.addEventListener('mouseup', onUp);
                    });

                    // Touch drag support: tap toggles (click handler); drag edits length/velocity.
                    lane.addEventListener('touchstart', (e)=>{
                        try {
                            const touch = e.touches && e.touches[0] ? e.touches[0] : null;
                            if (!touch) return;
                            const st = e.target && e.target.classList && e.target.classList.contains('pattern-step') ? e.target : null;
                            if (!st) return;
                            if (st.classList.contains('disabled')) return;
                            if (st.dataset.tie === '1') return;

                            const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                            const headIdx = parseInt(st.dataset.step||'0',10)||0;
                            const startX = touch.clientX;
                            const startY = touch.clientY;
                            const startVel = parseInt(st.dataset.vel || '100', 10);
                            const activeId = touch.identifier;

                            let dragMode = null; // 'len' | 'vel'
                            let prevented = false;

                            const ensureActive = ()=>{
                                if (!st.classList.contains('active')) {
                                    st.classList.add('active');
                                    st.dataset.len = st.dataset.len || '1';
                                }
                                if (!st.dataset.vel) st.dataset.vel = '100';
                                try { window.updateStepVelocityClass && window.updateStepVelocityClass(st); } catch(_){ }
                            };
                            const applyVel = (clientY)=>{
                                ensureActive();
                                const deltaY = startY - clientY;
                                const deltaVel = Math.round(deltaY / 1.5);
                                const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                                st.dataset.vel = String(newVel);
                                try { window.updateStepVelocityClass && window.updateStepVelocityClass(st); } catch(_){ }
                            };
                            const applyLen = (clientX)=>{
                                ensureActive();
                                const rect = lane.getBoundingClientRect();
                                const x = Math.max(0, Math.min(rect.width, clientX - rect.left));
                                const idx = Math.max(0, Math.min(steps.length-1, Math.floor((x/rect.width)*steps.length)));
                                setHeadLen(lane, headIdx, idx - headIdx + 1);
                            };

                            const onMove = (ev)=>{
                                const t = Array.from(ev.touches||[]).find(tt=>tt.identifier===activeId);
                                if (!t) return;
                                const dx = Math.abs(t.clientX - startX);
                                const dy = Math.abs(t.clientY - startY);
                                if (!dragMode) {
                                    if (dy > dx * 2 && dy > 10) {
                                        dragMode = 'vel';
                                        st.classList.add('vel-dragging');
                                    } else if (dx > 6) {
                                        dragMode = 'len';
                                    } else {
                                        return;
                                    }
                                    try { lane._suppressNextClick = true; lane._suppressNextClickStep = st; } catch(_){ }
                                }
                                if (!prevented) { prevented = true; try { ev.preventDefault(); } catch(_){ } }
                                if (dragMode === 'vel') applyVel(t.clientY);
                                else if (dragMode === 'len') applyLen(t.clientX);
                            };
                            const onEnd = ()=>{
                                document.removeEventListener('touchmove', onMove);
                                document.removeEventListener('touchend', onEnd);
                                document.removeEventListener('touchcancel', onEnd);
                                try { st.classList.remove('vel-dragging'); } catch(_){ }
                            };

                            document.addEventListener('touchmove', onMove, { passive: false });
                            document.addEventListener('touchend', onEnd);
                            document.addEventListener('touchcancel', onEnd);
                        } catch(_){ }
                    }, { passive: true });
                    lane.addEventListener('click', (e)=>{
                        const st = e.target && e.target.classList && e.target.classList.contains('pattern-step') ? e.target : null;
                        if (!st) return;
                        if (st.classList.contains('disabled')) return;
                        try {
                            if (lane._suppressNextClick && lane._suppressNextClickStep === st) {
                                lane._suppressNextClick = false;
                                lane._suppressNextClickStep = null;
                                return;
                            }
                            lane._suppressNextClick = false;
                            lane._suppressNextClickStep = null;
                        } catch(_){ }
                        if (st.dataset.tie === '1') return; // tie cells not directly toggled
                        // Toggle active
                        const wasActive = st.classList.contains('active');
                        if (wasActive) {
                            st.classList.remove('active');
                            delete st.dataset.len;
                            // clear ties after
                            const idx = parseInt(st.dataset.step||'0',10)||0;
                            const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                            for (let k=idx+1;k<steps.length;k++) delete steps[k].dataset.tie;
                        } else {
                            st.classList.add('active');
                            st.dataset.len = st.dataset.len || '1';
                        }
                        try { if (typeof window.rebuildPatternTieOverlays === 'function') window.rebuildPatternTieOverlays(lane); } catch(_){ }

                        // Click-audition (only when turning on). Mute gating is enforced inside _playPatternNote.
                        try {
                            if (!wasActive) {
                                const rowIdx = parseInt(lane.dataset.row||'0',10) || 0;
                                const stepIdx = parseInt(st.dataset.step||'0',10) || 0;
                                const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                                const D = Math.max(1, steps.length || 16);
                                const lenSteps = Math.max(1, Math.min(D - stepIdx, parseInt(st.dataset.len||'1',10)||1));
                                const vel = (window.getStepVelocity ? (window.getStepVelocity(st) ?? 100) : (parseInt(st.dataset.vel||'100',10)||100));
                                const instKey = (modalEl && modalEl.dataset && modalEl.dataset.patternInstanceKey) ? String(modalEl.dataset.patternInstanceKey) : 'arp';
                                const pt = (modalEl && modalEl._patternTransport) ? modalEl._patternTransport : (window._patternTransport || { stepMs: 120 });
                                if (window.omnichord && typeof window.omnichord._playPatternNote === 'function') {
                                    const stopFn = window.omnichord._playPatternNote(rowIdx, lenSteps, stepIdx, vel, {
                                        gridEl,
                                        instrumentKey: instKey,
                                        transport: pt,
                                        gateMs: Math.max(30, Math.min(800, Math.floor((pt.stepMs||120) * 1.0))),
                                        maxSteps: D,
                                    });
                                    if (stopFn) { try { window._pulseStepEl && window._pulseStepEl(st); } catch(_){ } }
                                }
                            }
                        } catch(_){ }
                    });
                    lane.addEventListener('contextmenu', (e)=>{
                        const st = e.target && e.target.classList && e.target.classList.contains('pattern-step') ? e.target : null;
                        if (!st) return;
                        e.preventDefault();
                        if (st.classList.contains('disabled')) return;
                        try {
                            const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                            const idx = parseInt(st.dataset.step||'0',10) || 0;
                            if (st.dataset.tie === '1') {
                                let headIdx=-1; for (let k=idx-1;k>=0;k--){ if (steps[k].dataset.len){ headIdx=k; break; } }
                                if (headIdx>=0){ const newLen=Math.max(1, idx-headIdx); steps[headIdx].dataset.len=String(newLen); }
                                for (let k=idx;k<steps.length;k++){ delete steps[k].dataset.tie; }
                                st.classList.remove('active');
                            } else {
                                for (let k=idx+1;k<steps.length;k++){ delete steps[k].dataset.tie; }
                                delete st.dataset.len; st.classList.remove('active');
                            }
                        } catch(_){ }
                        try { if (typeof window.rebuildPatternTieOverlays === 'function') window.rebuildPatternTieOverlays(lane); } catch(_){ }
                    });
                });

                // Ensure velocity drag exists on steps
                try {
                    Array.from(gridEl.querySelectorAll('.pattern-step')).forEach(st=>{
                        if (!st.dataset.vel) st.dataset.vel = '100';
                        try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(st); } catch(_){ }
                        try { if (window.attachVelocityDrag) window.attachVelocityDrag(st); } catch(_){ }
                    });
                } catch(_){ }
            };

            window.spawnPatternInstance = function(){
                const baseModal = document.getElementById('patternModal');
                if (!baseModal) return null;

                const prevInfo = (window._patternInstances && window._patternInstances.length)
                    ? window._patternInstances[window._patternInstances.length - 1]
                    : null;
                const prevKey = prevInfo && prevInfo.key;
                const prevModal = prevInfo && prevInfo.modal;

                const instKey = nextInstKey();
                const clone = baseModal.cloneNode(true);
                clone.id = `patternModal_${instKey}`;
                clone.style.display = 'flex';
                clone.dataset.patternInstanceKey = instKey;
                try {
                    const n = (window._patternInstanceCounter = (window._patternInstanceCounter || 0) + 1);
                    clone.dataset.patternInstanceNumber = String(n);
                } catch(_){ }

                // Mark known Pattern modal elements so we can find them after ID remap
                try {
                    PATTERN_ROLE_IDS.forEach(id=>{
                        const el = clone.querySelector(`#${id}`);
                        if (el) el.dataset.role = id;
                    });
                } catch(_){ }

                // Offset so it doesn't stack exactly on top
                try {
                    const r = baseModal.getBoundingClientRect();
                    clone.style.left = (r.left + 24) + 'px';
                    clone.style.top = (r.top + 24) + 'px';
                } catch(_){ }

                // Remap IDs in the clone so no global IDs collide.
                // Keep ARP control IDs as `${instKey}...` so omnichord._wireArpInstrumentControls(instKey) can drive them.
                const localPrefix = `${instKey}__`;
                remapIdsInSubtree(clone, (oldId)=>{
                    if (!oldId) return oldId;
                    if (oldId === 'midiIn-arp') return `midiIn-${instKey}`;
                    if (oldId === 'midiOut-arp') return `midiOut-${instKey}`;
                    if (oldId === 'midiOct-arp') return `midiOct-${instKey}`;
                    if (oldId === 'midiVel-arp') return `midiVel-${instKey}`;
                    if (/^arp[A-Z0-9_]/.test(oldId) || /^arp[a-zA-Z0-9_]/.test(oldId)) return instKey + oldId.slice(3);
                    if (PATTERN_ROLE_IDS.includes(oldId)) return localPrefix + oldId;
                    return oldId;
                });

                // Route osc buttons inside this modal to the instance instrument
                try {
                    const host = clone.querySelector('[data-role="tab-arp"]') || clone.querySelector('#tab-arp');
                    if (host) {
                        host.querySelectorAll('.osc-btn[data-inst="arp"]').forEach(btn=>{ btn.dataset.inst = instKey; });
                    }
                } catch(_){ }

                const minimizeInstance = ()=>{
                    // UI-only minimize (does not change mute state)
                    try { clone.style.display = 'none'; } catch(_){ }
                };

                // Close button minimizes (does not destroy)
                try {
                    const closeBtn = clone.querySelector('.modal-close');
                    if (closeBtn) {
                        closeBtn.removeAttribute('onclick');
                        closeBtn.addEventListener('click', (e)=>{
                            try { e.preventDefault(); e.stopPropagation(); } catch(_){ }
                            try { minimizeInstance(); } catch(_){ }
                        });
                    }
                } catch(_){ }

                // Add an explicit minimize control in the header
                try {
                    const header = clone.querySelector('.modal-header');
                    if (header && !header.querySelector('.pattern-minimize')) {
                        const minBtn = document.createElement('button');
                        minBtn.className = 'pattern-minimize';
                        minBtn.title = 'Minimize pattern';
                        minBtn.textContent = 'â€”';
                        minBtn.style.pointerEvents = 'auto';
                        minBtn.style.width = '28px';
                        minBtn.style.height = '26px';
                        minBtn.style.display = 'inline-flex';
                        minBtn.style.alignItems = 'center';
                        minBtn.style.justifyContent = 'center';
                        minBtn.style.background = '#214051';
                        minBtn.style.color = '#e8f5ff';
                        minBtn.style.border = '1px solid #4a6870';
                        minBtn.style.borderRadius = '6px';
                        minBtn.style.fontSize = '14px';
                        minBtn.style.cursor = 'pointer';
                        minBtn.style.lineHeight = '1';
                        minBtn.addEventListener('click', (e)=>{
                            try { e.preventDefault(); e.stopPropagation(); } catch(_){ }
                            minimizeInstance();
                        });
                        const speakerBtn = clone.querySelector('[data-role="patternSpeakerBtn"]') || clone.querySelector('#patternSpeakerBtn');
                        if (speakerBtn && speakerBtn.parentElement === header) {
                            header.insertBefore(minBtn, speakerBtn);
                        } else {
                            header.appendChild(minBtn);
                        }
                    }
                } catch(_){ }

                document.body.appendChild(clone);

                // Instance number drives the visible Pattern selector by default (Pattern 1, 2, 3...)
                try {
                    const instNum = Math.max(1, parseInt(clone.dataset.patternInstanceNumber||'1',10) || 1);
                    const patNumEl = (clone.querySelector('[data-role="patternPatternNumber"]') || clone.querySelector('#patternPatternNumber'));
                    if (patNumEl) patNumEl.value = String(instNum);
                } catch(_){ }

                // Build a fresh blank grid for this instance (no shared dots)
                try {
                    const gridEl = (clone.querySelector('[data-role="patternGrid"]') || clone.querySelector('#patternGrid') || clone.querySelector('.pattern-grid'));
                    const npcEl = (clone.querySelector('[data-role="universalNpc"]') || clone.querySelector('#universalNpc'));
                    const lenValueEl = (clone.querySelector('[data-role="patternLenValue"]') || clone.querySelector('#patternLenValue'));
                    const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                    const npc = Math.max(1, Math.min(64, parseInt(npcEl?.value || '16', 10) || 16));
                    const len = Math.max(1, Math.min(maxLen, parseInt((lenValueEl?.textContent || gridEl?.dataset?.length || '16'), 10) || 16));
                    if (gridEl) buildBlankPatternGrid(clone, gridEl, npc, len);
                } catch(_){ }

                // Wire per-instance MIDI controls (arp2/arp3...) to the global MIDI manager
                try {
                    const midi = window.midi;
                    if (midi) {
                        midi.inputChannelMap = midi.inputChannelMap || {};
                        midi.outputPortMap = midi.outputPortMap || {};
                        midi.perSourceOctave = midi.perSourceOctave || {};
                        try { window._ensureModalAspectResize && window._ensureModalAspectResize(modal); } catch(_) {}
                        midi.perSourceVelocity = midi.perSourceVelocity || {};

                        // Seed defaults from ARP if missing
                        if (midi.inputChannelMap[instKey] == null) midi.inputChannelMap[instKey] = (midi.inputChannelMap.arp ?? 1);
                        if (midi.outputPortMap[instKey] == null) midi.outputPortMap[instKey] = (midi.outputPortMap.arp ?? midi.outputPortMap.default ?? null);
                        if (midi.perSourceOctave[instKey] == null) midi.perSourceOctave[instKey] = (midi.perSourceOctave.arp ?? 0);
                        if (midi.perSourceVelocity[instKey] == null) midi.perSourceVelocity[instKey] = (midi.perSourceVelocity.arp ?? midi.defaultVelocity ?? 100);

                        const inEl = clone.querySelector(`#midiIn-${instKey}`);
                        const outEl = clone.querySelector(`#midiOut-${instKey}`);
                        const octEl = clone.querySelector(`#midiOct-${instKey}`);
                        const velEl = clone.querySelector(`#midiVel-${instKey}`);

                        if (inEl && !inEl._wiredMidiInst) {
                            inEl._wiredMidiInst = true;
                            inEl.addEventListener('change', ()=>{
                                midi.inputChannelMap[instKey] = Math.max(0, Math.min(15, parseInt(inEl.value||'0',10)|0));
                                try {
                                    const omn = window.omnichord;
                                    if (omn && typeof omn._ensureArpTransport === 'function') {
                                        omn._ensureArpTransport();
                                        omn._arpTransport.deferFlags = Object.assign(omn._arpTransport.deferFlags||{}, { midi:true });
                                        const tpBeat=Math.max(1,omn._arpTransport.ticksPerBeat||1);
                                        const nowAbs=omn._arpTransport.absTickCounter|0;
                                        omn._arpTransport.deferApplyAtAbsTick=(nowAbs+2*tpBeat)>>>0;
                                    }
                                } catch(_){ }
                                try { midi.saveMIDISettings && midi.saveMIDISettings(); } catch(_){ }
                            });
                        }
                        if (outEl && !outEl._wiredMidiInst) {
                            outEl._wiredMidiInst = true;
                            // Populate outputs list for this cloned select
                            try { midi.populateOutputSelect && midi.populateOutputSelect(outEl); } catch(_){ }
                            try {
                                const sel = midi.outputPortMap[instKey] || midi.outputPortMap.default || '';
                                outEl.value = String(sel || '');
                            } catch(_){ }
                            outEl.addEventListener('change', ()=>{
                                const id = String(outEl.value||'');
                                midi.outputPortMap[instKey] = id || null;
                                try {
                                    const omn = window.omnichord;
                                    if (omn && typeof omn._ensureArpTransport === 'function') {
                                        omn._ensureArpTransport();
                                        omn._arpTransport.deferFlags = Object.assign(omn._arpTransport.deferFlags||{}, { midi:true });
                                        const tpBeat=Math.max(1,omn._arpTransport.ticksPerBeat||1);
                                        const nowAbs=omn._arpTransport.absTickCounter|0;
                                        omn._arpTransport.deferApplyAtAbsTick=(nowAbs+2*tpBeat)>>>0;
                                    }
                                } catch(_){ }
                                try { midi.saveMIDISettings && midi.saveMIDISettings(); } catch(_){ }
                            });
                        }
                        if (octEl && !octEl._wiredMidiInst) {
                            octEl._wiredMidiInst = true;
                            octEl.addEventListener('change', ()=>{
                                midi.perSourceOctave[instKey] = Math.max(-3, Math.min(3, parseInt(octEl.value||'0',10)|0));
                                try { midi.saveMIDISettings && midi.saveMIDISettings(); } catch(_){ }
                            });
                            try { octEl.value = String(midi.perSourceOctave[instKey] ?? 0); } catch(_){ }
                        }
                        if (velEl && !velEl._wiredMidiInst) {
                            velEl._wiredMidiInst = true;
                            velEl.addEventListener('change', ()=>{
                                midi.perSourceVelocity[instKey] = Math.max(1, Math.min(127, parseInt(velEl.value||'100',10)|0));
                                try { midi.saveMIDISettings && midi.saveMIDISettings(); } catch(_){ }
                            });
                            try { velEl.value = String(midi.perSourceVelocity[instKey] ?? midi.defaultVelocity ?? 100); } catch(_){ }
                        }

                        // Initialize IN from current map
                        try { if (inEl) inEl.value = String(midi.inputChannelMap[instKey] ?? 1); } catch(_){ }
                    }
                } catch(_){ }

                try { bringModalToFront(clone.id); } catch(_){ }
                try { window._ensureModalDotScaling && window._ensureModalDotScaling(clone); clone._dotScaleApply && clone._dotScaleApply(); } catch(_){ }
                try { if (!clone._draggableSet) { makeDraggable(clone); clone._draggableSet = true; } } catch(_){ }

                // Wire ARP controls for arp2/arp3
                try {
                    const omni = window.omnichord;
                    if (omni && typeof omni._wireArpInstrumentControls === 'function') omni._wireArpInstrumentControls(instKey);
                } catch(_){ }

                // Clone oscillator/UI state from previous pattern instance (or fall back to defaults)
                try {
                    const host = clone.querySelector('[data-role="tab-arp"]') || clone.querySelector('#tab-arp');
                    if (!host) throw new Error('no arp host');

                    const setInput = (id, val)=>{
                        const el = clone.querySelector(`#${id}`);
                        if (!el) return;
                        el.value = String(val);
                        try { el.dispatchEvent(new Event('input', { bubbles:true })); } catch(_){ }
                        try { el.dispatchEvent(new Event('change', { bubbles:true })); } catch(_){ }
                    };
                    const setCheck = (id, val)=>{
                        const el = clone.querySelector(`#${id}`);
                        if (!el) return;
                        el.checked = !!val;
                        try { el.dispatchEvent(new Event('change', { bubbles:true })); } catch(_){ }
                    };
                    const clickWave = (wave)=>{
                        const b = host.querySelector(`.osc-btn[data-inst="${instKey}"][data-wave="${wave}"]`);
                        if (b && typeof b.click === 'function') b.click();
                    };

                    let cloned = false;
                    if (prevModal && prevKey) {
                        try {
                            const prevHost = prevModal.querySelector('[data-role="tab-arp"]') || prevModal.querySelector('#tab-arp');
                            const prevActive = prevHost ? prevHost.querySelector(`.osc-btn[data-inst="${prevKey}"].active`) : null;
                            const prevWave = prevActive ? String(prevActive.dataset.wave || 'sine') : 'sine';
                            clickWave(prevWave);

                            const copyVal = (suffix, fallback)=>{
                                const from = prevModal.querySelector(`#${prevKey}${suffix}`);
                                const v = from ? from.value : '';
                                return (v !== '' && v != null) ? v : fallback;
                            };
                            const copyChk = (suffix, fallback)=>{
                                const from = prevModal.querySelector(`#${prevKey}${suffix}`);
                                return from ? !!from.checked : !!fallback;
                            };

                            setInput(`${instKey}PulseWidth`, copyVal('PulseWidth', 50));
                            setInput(`${instKey}ShapeWidth`, copyVal('ShapeWidth', 50));
                            setInput(`${instKey}Level`, copyVal('Level', 5));
                            setInput(`${instKey}Detune`, copyVal('Detune', 0));
                            setInput(`${instKey}Octave`, copyVal('Octave', 0));
                            setInput(`${instKey}Coarse`, copyVal('Coarse', 0));
                            setInput(`${instKey}AttackSlider`, copyVal('AttackSlider', 10));
                            setInput(`${instKey}DecaySlider`, copyVal('DecaySlider', 200));
                            setInput(`${instKey}SustainSlider`, copyVal('SustainSlider', 70));
                            setInput(`${instKey}ReleaseSlider`, copyVal('ReleaseSlider', 500));
                            setCheck(`${instKey}FxSend`, copyChk('FxSend', true));
                            cloned = true;
                        } catch(_){ cloned = false; }
                    }
                    if (!cloned) {
                        clickWave('sine');
                        setInput(`${instKey}PulseWidth`, 50);
                        setInput(`${instKey}ShapeWidth`, 50);
                        setInput(`${instKey}Level`, 5);
                        setInput(`${instKey}Detune`, 0);
                        setInput(`${instKey}Octave`, 0);
                        setInput(`${instKey}Coarse`, 0);
                        setInput(`${instKey}AttackSlider`, 10);
                        setInput(`${instKey}DecaySlider`, 200);
                        setInput(`${instKey}SustainSlider`, 70);
                        setInput(`${instKey}ReleaseSlider`, 500);
                        setCheck(`${instKey}FxSend`, true);
                    }
                } catch(_){ }

                // Ensure grid has interaction wiring (re-attach velocity drag etc)
                try { wirePatternGridInteractions(clone); } catch(_){ }

                // Per-instance transport and speaker toggle
                try {
                    const gridEl = (clone.querySelector('[data-role="patternGrid"]') || clone.querySelector('#patternGrid') || clone.querySelector('.pattern-grid'));
                    const speakerBtn = (clone.querySelector('[data-role="patternSpeakerBtn"]') || clone.querySelector('#patternSpeakerBtn'));
                    if (gridEl) {
                        clone._patternEnabled = true;
                        const enabledFn = ()=>!!clone._patternEnabled;
                        const pt = wirePatternInstanceTransport(clone, gridEl, instKey, enabledFn);
                        clone._patternTransport = pt;

                        // Wire LEN/NPC controls for this instance (apply on next cycle)
                        try {
                            const inc = (clone.querySelector('[data-role="patternLenInc"]') || clone.querySelector('#patternLenInc'));
                            const dec = (clone.querySelector('[data-role="patternLenDec"]') || clone.querySelector('#patternLenDec'));
                            const valSpan = (clone.querySelector('[data-role="patternLenValue"]') || clone.querySelector('#patternLenValue'));
                            const handle = (clone.querySelector('[data-role="patternResizeHandle"]') || clone.querySelector('#patternResizeHandle'));
                            const npcInput = (clone.querySelector('[data-role="universalNpc"]') || clone.querySelector('#universalNpc'));
                            const scheduleApply = ()=>{ try { if (pt) pt._pendingApply = ()=>{ try { window._applyPatternInstancePending && window._applyPatternInstancePending(clone); } catch(_){ } }; } catch(_){ } };
                            const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;

                            if (valSpan) valSpan.textContent = gridEl.dataset.length || valSpan.textContent || '16';

                            if (inc && !inc._wiredPatternInstLen) {
                                inc._wiredPatternInstLen = true;
                                inc.addEventListener('click', ()=>{
                                    const cur = Math.max(1, Math.min(maxLen, parseInt(gridEl.dataset.length||'16',10)||16));
                                    const nextLen = Math.min(maxLen, cur + 1);
                                    if (nextLen === cur) return;
                                    try { if (valSpan) { valSpan.textContent = String(nextLen); valSpan.dataset.pending='1'; } } catch(_){ }
                                    try { gridEl.dataset.pendingLength = String(nextLen); } catch(_){ }
                                    scheduleApply();
                                });
                            }
                            if (dec && !dec._wiredPatternInstLen) {
                                dec._wiredPatternInstLen = true;
                                dec.addEventListener('click', ()=>{
                                    const cur = Math.max(1, Math.min(maxLen, parseInt(gridEl.dataset.length||'16',10)||16));
                                    const nextLen = Math.max(1, cur - 1);
                                    if (nextLen === cur) return;
                                    try { if (valSpan) { valSpan.textContent = String(nextLen); valSpan.dataset.pending='1'; } } catch(_){ }
                                    try { gridEl.dataset.pendingLength = String(nextLen); } catch(_){ }
                                    scheduleApply();
                                });
                            }
                            if (npcInput && !npcInput._wiredPatternInstNpc) {
                                npcInput._wiredPatternInstNpc = true;
                                npcInput.addEventListener('change', ()=>{
                                    const nextNpc = Math.max(1, Math.min(64, parseInt(npcInput.value||'16',10)||16));
                                    try { gridEl.dataset.pendingNpc = String(nextNpc); } catch(_){ }
                                    scheduleApply();
                                });
                            }
                            if (handle && !handle._wiredPatternInstResize) {
                                handle._wiredPatternInstResize = true;
                                handle.style.touchAction = 'none';
                                const startDrag = (startX, startLen)=>{
                                    const move = (clientX)=>{
                                        const dx = clientX - startX;
                                        const delta = Math.round(dx / 8);
                                        const newLen = Math.min(maxLen, Math.max(1, startLen + delta));
                                        try { if (valSpan) { valSpan.textContent = String(newLen); valSpan.dataset.pending='1'; } } catch(_){ }
                                        try { gridEl.dataset.pendingLength = String(newLen); } catch(_){ }
                                    };
                                    const end = ()=>{ scheduleApply(); };
                                    return { move, end };
                                };
                                handle.addEventListener('mousedown', (e)=>{
                                    e.preventDefault();
                                    const startX = e.clientX;
                                    const startLen = Math.max(1, Math.min(maxLen, parseInt(gridEl.dataset.length||'16',10)||16));
                                    const h = startDrag(startX, startLen);
                                    const onMove = (ev)=>{ h.move(ev.clientX); };
                                    const onUp = ()=>{ document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); h.end(); };
                                    document.addEventListener('mousemove', onMove);
                                    document.addEventListener('mouseup', onUp);
                                });
                                handle.addEventListener('touchstart', (e)=>{
                                    e.preventDefault();
                                    const touch = e.touches && e.touches[0] ? e.touches[0] : null;
                                    if (!touch) return;
                                    const startX = touch.clientX;
                                    const startLen = Math.max(1, Math.min(maxLen, parseInt(gridEl.dataset.length||'16',10)||16));
                                    const h = startDrag(startX, startLen);
                                    const onMove = (ev)=>{
                                        try { ev.preventDefault(); } catch(_){ }
                                        const t = ev.touches && ev.touches[0] ? ev.touches[0] : null;
                                        if (!t) return;
                                        h.move(t.clientX);
                                    };
                                    const onEnd = ()=>{ document.removeEventListener('touchmove', onMove); document.removeEventListener('touchend', onEnd); h.end(); };
                                    document.addEventListener('touchmove', onMove, { passive: false });
                                    document.addEventListener('touchend', onEnd);
                                }, { passive: false });
                            }
                        } catch(_){ }

                        if (speakerBtn && !speakerBtn._wiredPatternInstanceSpeaker) {
                            speakerBtn._wiredPatternInstanceSpeaker = true;
                            const updateIcon = ()=>{ try { speakerBtn.textContent = clone._patternEnabled ? 'ðŸ”Š' : 'ðŸ”‡'; } catch(_){ } };
                            updateIcon();
                            speakerBtn.addEventListener('click', (ev)=>{
                                try { ev.preventDefault(); ev.stopPropagation(); } catch(_){ }
                                clone._patternEnabled = !clone._patternEnabled;
                                updateIcon();
                                try {
                                    const omni = window.omnichord;
                                    const isPlaying = !!(omni && omni._arpTransport && omni._arpTransport.running);
                                    if (clone._patternEnabled) {
                                        // Beat 1 is king: arm it to start on the next bar when PLAY is running.
                                        if (isPlaying && pt && typeof pt.start === 'function') {
                                            pt.start({ alignToTransport: true, preBufferMs: 80 });
                                        } else {
                                            // Not PLAYing: keep it silent; PLAY will start all instances on Beat 1.
                                            try { if (pt) { pt.stopVoices && pt.stopVoices(); } } catch(_){ }
                                        }
                                    } else {
                                        // Muted: keep time running, just silence voices.
                                        if (pt) {
                                            try { pt.stopVoices && pt.stopVoices(); } catch(_){ }
                                            try { pt._startAtBarIndex = null; } catch(_){ }
                                        }
                                    }
                                } catch(_){ }
                            });
                        }
                    }
                } catch(_){ }

                // Per-instance gear (synth drawer) toggle
                try {
                    const gearBtn = (clone.querySelector('[data-role="patternSynthToggleBtn"]') || clone.querySelector('#patternSynthToggleBtn'));
                    if (gearBtn && !gearBtn._wiredPatternInstanceGear) {
                        gearBtn._wiredPatternInstanceGear = true;
                        gearBtn.addEventListener('click', (ev)=>{
                            try { ev.preventDefault(); ev.stopPropagation(); } catch(_){ }
                            const root = gearBtn.closest('.floating-modal') || clone;
                            const p = root.querySelector
                                ? (root.querySelector('[data-role="tab-arp"]') || root.querySelector('#tab-arp'))
                                : document.getElementById('tab-arp');
                            const open = (p && p.style.display !== 'none');
                            if (p) p.style.display = open ? 'none' : 'block';
                            try {
                                const grid = root.querySelector
                                    ? (root.querySelector('[data-role="patternGrid"]') || root.querySelector('#patternGrid'))
                                    : document.getElementById('patternGrid');
                                const handle = root.querySelector
                                    ? (root.querySelector('[data-role="patternResizeHandle"]') || root.querySelector('#patternResizeHandle'))
                                    : document.getElementById('patternResizeHandle');
                                const showGrid = open;
                                if (grid) grid.style.display = showGrid ? '' : 'none';
                                if (handle) handle.style.display = showGrid ? '' : 'none';
                            } catch(_){ }
                        });
                    }
                } catch(_){ }

                // Per-instance pattern bank + synth bank
                try {
                    const omni = window.omnichord;
                    if (omni) {
                        omni._arpPatternsByInst = omni._arpPatternsByInst || {};
                        omni._arpSynthPatternsByInst = omni._arpSynthPatternsByInst || {};
                        const patterns = omni._arpPatternsByInst[instKey] = omni._arpPatternsByInst[instKey] || new Map();
                        const synthPatterns = omni._arpSynthPatternsByInst[instKey] = omni._arpSynthPatternsByInst[instKey] || new Map();
                        const pg = (clone.querySelector('[data-role="patternGrid"]') || clone.querySelector('#patternGrid') || clone.querySelector('.pattern-grid'));
                        const patNum = (clone.querySelector('[data-role="patternPatternNumber"]') || clone.querySelector('#patternPatternNumber'));

                        const LS_KEY = `xen_arpSynthPatterns_${instKey}_v1`;
                        const loadSynthBank = ()=>{
                            try {
                                const raw = localStorage.getItem(LS_KEY);
                                if (!raw) return;
                                const obj = JSON.parse(raw);
                                if (!obj || typeof obj !== 'object') return;
                                Object.keys(obj).forEach(k=>{
                                    const n = parseInt(k,10);
                                    if (!Number.isFinite(n) || n < 1) return;
                                    const st = obj[k];
                                    if (st && typeof st === 'object') synthPatterns.set(n, st);
                                });
                            } catch(_){ }
                        };
                        const saveSynthBank = ()=>{
                            try {
                                const out = {};
                                synthPatterns.forEach((v,k)=>{ if (k>=1 && k<=128) out[String(k)] = v; });
                                localStorage.setItem(LS_KEY, JSON.stringify(out));
                            } catch(_){ }
                        };
                        loadSynthBank();

                        const captureSynth = ()=>{
                            try {
                                const host = clone.querySelector('[data-role="tab-arp"]') || clone.querySelector('#tab-arp');
                                const activeBtn = host ? host.querySelector(`.osc-btn[data-inst="${instKey}"].active`) : null;
                                const wave = activeBtn ? String(activeBtn.dataset.wave||'sine') : 'sine';
                                const num = (id, fallback)=>{
                                    const el = clone.querySelector(`#${id}`);
                                    const v = el ? parseFloat(el.value) : NaN;
                                    return Number.isFinite(v) ? v : fallback;
                                };
                                const str = (id, fallback)=>{
                                    const el = clone.querySelector(`#${id}`);
                                    const v = el ? String(el.value||'').trim() : '';
                                    return v || fallback;
                                };
                                const chk = (id, fallback)=>{
                                    const el = clone.querySelector(`#${id}`);
                                    return el ? !!el.checked : !!fallback;
                                };
                                return {
                                    wave,
                                    [`${instKey}PulseWidth`]: num(`${instKey}PulseWidth`, 50),
                                    [`${instKey}ShapeWidth`]: num(`${instKey}ShapeWidth`, 50),
                                    [`${instKey}Level`]: num(`${instKey}Level`, 5),
                                    [`${instKey}Detune`]: num(`${instKey}Detune`, 0),
                                    [`${instKey}Octave`]: num(`${instKey}Octave`, 0),
                                    [`${instKey}Coarse`]: num(`${instKey}Coarse`, 0),
                                    [`${instKey}AttackSlider`]: num(`${instKey}AttackSlider`, 10),
                                    [`${instKey}DecaySlider`]: num(`${instKey}DecaySlider`, 200),
                                    [`${instKey}SustainSlider`]: num(`${instKey}SustainSlider`, 70),
                                    [`${instKey}ReleaseSlider`]: num(`${instKey}ReleaseSlider`, 500),
                                    [`${instKey}FxSend`]: chk(`${instKey}FxSend`, true),
                                    midiIn: num(`midiIn-${instKey}`, 1),
                                    midiOut: str(`midiOut-${instKey}`, ''),
                                    midiOct: str(`midiOct-${instKey}`, '0'),
                                    midiVel: num(`midiVel-${instKey}`, 100),
                                };
                            } catch(_){ return null; }
                        };

                        const applySynth = (state)=>{
                            try {
                                if (!state || typeof state !== 'object') return;
                                const host = clone.querySelector('[data-role="tab-arp"]') || clone.querySelector('#tab-arp');
                                if (host) {
                                    const wave = String(state.wave||'').trim();
                                    if (wave) {
                                        const btn = host.querySelector(`.osc-btn[data-inst="${instKey}"][data-wave="${wave}"]`);
                                        if (btn && typeof btn.click === 'function') btn.click();
                                    }
                                }
                                const setInput = (id, val, evtName='input')=>{
                                    const el = clone.querySelector(`#${id}`);
                                    if (!el) return;
                                    el.value = String(val);
                                    try { el.dispatchEvent(new Event(evtName, { bubbles:true })); } catch(_){ }
                                };
                                const setSelect = (id, val)=>setInput(id, val, 'change');
                                const setCheck = (id, val)=>{
                                    const el = clone.querySelector(`#${id}`);
                                    if (!el) return;
                                    el.checked = !!val;
                                    try { el.dispatchEvent(new Event('change', { bubbles:true })); } catch(_){ }
                                };
                                const setMaybe = (key, setter)=>{ if (key in state) setter(state[key]); };
                                setMaybe(`${instKey}PulseWidth`, (v)=>setInput(`${instKey}PulseWidth`, v));
                                setMaybe(`${instKey}ShapeWidth`, (v)=>setInput(`${instKey}ShapeWidth`, v));
                                setMaybe(`${instKey}Level`, (v)=>setInput(`${instKey}Level`, v));
                                setMaybe(`${instKey}Detune`, (v)=>setInput(`${instKey}Detune`, v));
                                setMaybe(`${instKey}Octave`, (v)=>setInput(`${instKey}Octave`, v));
                                setMaybe(`${instKey}Coarse`, (v)=>setInput(`${instKey}Coarse`, v));
                                setMaybe(`${instKey}AttackSlider`, (v)=>setInput(`${instKey}AttackSlider`, v));
                                setMaybe(`${instKey}DecaySlider`, (v)=>setInput(`${instKey}DecaySlider`, v));
                                setMaybe(`${instKey}SustainSlider`, (v)=>setInput(`${instKey}SustainSlider`, v));
                                setMaybe(`${instKey}ReleaseSlider`, (v)=>setInput(`${instKey}ReleaseSlider`, v));
                                setMaybe(`${instKey}FxSend`, (v)=>setCheck(`${instKey}FxSend`, v));
                                if ('midiIn' in state) setInput(`midiIn-${instKey}`, state.midiIn, 'change');
                                if ('midiOut' in state) setSelect(`midiOut-${instKey}`, state.midiOut);
                                if ('midiOct' in state) setSelect(`midiOct-${instKey}`, state.midiOct);
                                if ('midiVel' in state) setInput(`midiVel-${instKey}`, state.midiVel, 'change');
                            } catch(_){ }
                        };

                        const captureGrid = ()=>{
                            if (!pg) return [];
                            const lanes = Array.from(pg.querySelectorAll('.pattern-lane'));
                            return lanes.map(lane=>{
                                const steps = Array.from(lane.querySelectorAll('.pattern-step')).map(s=> {
                                    if (!s.classList.contains('active')) return null;
                                    const obj = { active: 1 };
                                    if (s.dataset.len) obj.len = s.dataset.len;
                                    if (s.dataset.tie === '1') obj.tie = 1;
                                    if (s.dataset.npc) obj.npc = s.dataset.npc;
                                    if (s.dataset.vel) obj.vel = s.dataset.vel;
                                    return obj;
                                });
                                return steps;
                            });
                        };
                        const applyGrid = (gridArr)=>{
                            if (!Array.isArray(gridArr) || !pg) return;
                            const lanes = Array.from(pg.querySelectorAll('.pattern-lane'));
                            lanes.forEach((lane, i)=>{
                                const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                                const row = gridArr[i] || [];
                                steps.forEach((s, j)=>{
                                    const data = row[j];
                                    if (data && data.active) {
                                        s.classList.add('active');
                                        if (data.len) s.dataset.len = data.len; else delete s.dataset.len;
                                        if (data.tie) s.dataset.tie = '1'; else delete s.dataset.tie;
                                        if (data.npc) s.dataset.npc = data.npc; else delete s.dataset.npc;
                                        if (data.vel != null) s.dataset.vel = String(data.vel);
                                    } else {
                                        s.classList.remove('active');
                                        delete s.dataset.len;
                                        delete s.dataset.tie;
                                        delete s.dataset.npc;
                                    }
                                    try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(s); } catch(_){ }
                                });
                                try { window.rebuildPatternTieOverlays && window.rebuildPatternTieOverlays(lane); } catch(_){ }
                            });
                        };

                        const blankGridSnapshot = ()=>{
                            if (!pg) return [];
                            const lanes = Array.from(pg.querySelectorAll('.pattern-lane'));
                            return lanes.map(lane=>{
                                const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                                return steps.map(()=>null);
                            });
                        };

                        if (patNum && !patNum._wiredPatternBankInstance) {
                            patNum._wiredPatternBankInstance = true;
                            // Start blank (do not clone any existing dots from the base modal)
                            const blank0 = blankGridSnapshot();
                            const initialNum = Math.max(1, parseInt(patNum.value,10) || 1);
                            patterns.set(initialNum, blank0);
                            try { applyGrid(blank0); } catch(_){ }
                            const st0 = captureSynth();
                            if (st0) {
                                clone._defaultSynthState = deepClone(st0);
                                synthPatterns.set(initialNum, deepClone(st0));
                                saveSynthBank();
                            }
                            clone._lastArpPatternNumber = initialNum;

                            patNum.addEventListener('change', (e)=>{
                                let v = parseInt(e.target.value,10); if(!Number.isFinite(v) || v<1) v=1; e.target.value=String(v);
                                const prev = clone._lastArpPatternNumber || 1;
                                patterns.set(prev, captureGrid());
                                try {
                                    const stPrev = captureSynth();
                                    if (stPrev) synthPatterns.set(prev, stPrev);
                                    saveSynthBank();
                                } catch(_){ }
                                if (!patterns.has(v)) patterns.set(v, blankGridSnapshot());
                                if (!synthPatterns.has(v)) {
                                    const src = clone._defaultSynthState || synthPatterns.get(1) || captureSynth();
                                    if (src) synthPatterns.set(v, deepClone(src));
                                    saveSynthBank();
                                }
                                const pt = clone._patternTransport;
                                const running = !!(pt && pt.running);
                                const enabled = !!clone._patternEnabled;
                                const shouldDefer = running && enabled;
                                if (shouldDefer && pt) {
                                    e.target.dataset.pending = '1';
                                    e.target.dataset.pendingValue = String(v);
                                    try { e.target.classList.add('pending-change'); } catch(_){ }
                                    try { e.target.title = `Queued â†’ ${v} (switches next cycle)`; } catch(_){ }
                                    e.target.value = String(prev);
                                    pt._pendingApply = ()=>{
                                        try {
                                            const patt = patterns.get(v);
                                            if (patt) applyGrid(patt);
                                            const st = synthPatterns.get(v);
                                            if (st) applySynth(st);
                                        } catch(_){ }
                                        try { delete e.target.dataset.pending; delete e.target.dataset.pendingValue; e.target.classList.remove('pending-change'); e.target.title=''; } catch(_){ }
                                        clone._lastArpPatternNumber = v;
                                    };
                                } else {
                                    const patt = patterns.get(v);
                                    if (patt) applyGrid(patt);
                                    try {
                                        const st = synthPatterns.get(v);
                                        if (st) applySynth(st);
                                    } catch(_){ }
                                    try { delete e.target.dataset.pending; delete e.target.dataset.pendingValue; e.target.classList.remove('pending-change'); e.target.title=''; } catch(_){ }
                                    clone._lastArpPatternNumber = v;
                                }
                            });

                            // Persist synth changes per-pattern (delegated)
                            try {
                                const host = clone.querySelector('[data-role="tab-arp"]') || clone.querySelector('#tab-arp');
                                if (host && !host._wiredPatternSynthSaveInst) {
                                    host._wiredPatternSynthSaveInst = true;
                                    let t = null;
                                    const scheduleSave = ()=>{
                                        try { if (t) clearTimeout(t); } catch(_){ }
                                        t = setTimeout(()=>{
                                            try {
                                                const n = Math.max(1, parseInt(patNum?.value||'1',10));
                                                const st = captureSynth();
                                                if (st) synthPatterns.set(n, st);
                                                saveSynthBank();
                                            } catch(_){ }
                                        }, 120);
                                    };
                                    host.addEventListener('input', scheduleSave);
                                    host.addEventListener('change', scheduleSave);
                                }
                            } catch(_){ }
                        }
                    }
                } catch(_){ }

                // Remember instance
                try { (window._patternInstances = window._patternInstances || []).push({ key: instKey, modal: clone }); } catch(_){ }

                // Create/update the top strip button for this instance
                try {
                    const strip = document.getElementById('patternButtons') || document.getElementById('patternStrip');
                    if (strip) {
                        const n = parseInt(clone.dataset.patternInstanceNumber||'0',10) || ((window._patternInstances||[]).length);
                        const b = document.createElement('button');
                        b.className = 'panel-btn';
                        const defaultLabel = `PATTERN ${n}`;
                        b.textContent = (clone && clone._patternDisplayName) ? String(clone._patternDisplayName) : defaultLabel;
                        b.title = 'Click: mute/unmute â€¢ Double-click: rename â€¢ Hold: edit';
                        b.style.background = '#214051';
                        b.style.borderColor = '#4a6870';
                        b.style.color = '#e8f5ff';
                        b.style.padding = '6px 10px';
                        b.style.fontSize = '12px';

                        // Store for traffic-light updates
                        try { clone._stripBtn = b; } catch(_){ }

                        // Shared traffic-light updater for pattern instances
                        if (!window._updatePatternInstanceButtonVisual) {
                            window._updatePatternInstanceButtonVisual = function(modalEl){
                                try {
                                    if (!modalEl || !modalEl._stripBtn) return;
                                    const btn = modalEl._stripBtn;
                                    const enabledNow = !!modalEl._patternEnabled;
                                    const pendEnabled = (modalEl._patternPendingEnabled != null) ? !!modalEl._patternPendingEnabled : null;
                                    const pendAny = (modalEl._patternPendingEnabled != null) || !!(modalEl.querySelector && (modalEl.querySelector('[data-role="patternGrid"]')||modalEl.querySelector('#patternGrid'))?.dataset?.pendingLength) || !!(modalEl.querySelector && (modalEl.querySelector('[data-role="patternGrid"]')||modalEl.querySelector('#patternGrid'))?.dataset?.pendingNpc);
                                    let traffic = enabledNow ? 'traffic-green' : 'traffic-red';
                                    if (pendEnabled != null) {
                                        if (enabledNow && pendEnabled === false) traffic = 'traffic-orange';
                                        else if (!enabledNow && pendEnabled === true) traffic = 'traffic-yellow';
                                        else traffic = pendEnabled ? 'traffic-green' : 'traffic-red';
                                    }
                                    try {
                                        ['traffic-green','traffic-red','traffic-yellow','traffic-orange'].forEach(c=>btn.classList.remove(c));
                                        btn.classList.add(traffic);
                                    } catch(_){ }
                                    try { if (enabledNow) btn.classList.add('active'); else btn.classList.remove('active'); } catch(_){ }
                                    try { if (pendAny) btn.classList.add('pending-change'); else btn.classList.remove('pending-change'); } catch(_){ }
                                } catch(_){ }
                            };
                        }

                        const setStripState = ()=>{
                            try { window._updatePatternInstanceButtonVisual && window._updatePatternInstanceButtonVisual(clone); } catch(_){ }
                        };

                        const clearTimers = ()=>{
                            try { if (b._singleTapTimer) { clearTimeout(b._singleTapTimer); b._singleTapTimer = null; } } catch(_){ }
                            try { if (b._holdTimer) { clearTimeout(b._holdTimer); b._holdTimer = null; } } catch(_){ }
                        };

                        const toggleMute = ()=>{
                            const pt = clone._patternTransport;
                            const omni = window.omnichord;
                            const isPlaying = !!(omni && omni._arpTransport && omni._arpTransport.running);

                            const base = (clone._patternPendingEnabled != null) ? !!clone._patternPendingEnabled : !!clone._patternEnabled;
                            const desired = !base;

                            if (isPlaying) {
                                // Queue for next cycle (traffic light shows intent)
                                clone._patternPendingEnabled = desired;
                                try { if (pt) pt._pendingApply = ()=>{ try { window._applyPatternInstancePending && window._applyPatternInstancePending(clone); } catch(_){ } }; } catch(_){ }
                            } else {
                                // Apply immediately when stopped
                                clone._patternPendingEnabled = null;
                                clone._patternEnabled = desired;
                                try {
                                    const speakerBtn = (clone.querySelector('[data-role="patternSpeakerBtn"]') || clone.querySelector('#patternSpeakerBtn'));
                                    if (speakerBtn) speakerBtn.textContent = clone._patternEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
                                } catch(_){ }
                                if (pt) {
                                    if (clone._patternEnabled) {
                                        try { pt.stopVoices && pt.stopVoices(); } catch(_){ }
                                    } else {
                                        try { pt.stopVoices && pt.stopVoices(); } catch(_){ }
                                        try { pt._startAtBarIndex = null; } catch(_){ }
                                    }
                                }
                            }
                            setStripState();
                        };

                        const openEditor = ()=>{
                            try { window.showPatternModal && window.showPatternModal(clone); } catch(_){ try { clone.style.display = 'flex'; } catch(__){} }
                        };

                        const doRename = ()=>{
                            try {
                                if (b._renaming) return;
                                b._renaming = true;
                                const prev = (clone && clone._patternDisplayName) ? String(clone._patternDisplayName) : defaultLabel;
                                b.textContent = prev;
                                b.setAttribute('contenteditable', 'true');
                                b.setAttribute('role', 'textbox');
                                b.setAttribute('spellcheck', 'false');
                                b.style.outline = '2px solid #7cc9ff';
                                b.style.outlineOffset = '1px';

                                const cleanup = ()=>{
                                    b.removeAttribute('contenteditable');
                                    b.removeAttribute('role');
                                    b.removeAttribute('spellcheck');
                                    b.style.outline = '';
                                    b.style.outlineOffset = '';
                                    b._renaming = false;
                                };

                                const applyName = (name)=>{
                                    const nm = String(name || '').trim();
                                    clone._patternDisplayName = nm ? nm : defaultLabel;
                                    b.textContent = String(clone._patternDisplayName);
                                    try {
                                        const hdr = clone.querySelector('.modal-header span');
                                        if (hdr) hdr.textContent = `Pattern Sequencer â€” ${clone._patternDisplayName}`;
                                    } catch(_){ }
                                    setStripState();
                                };

                                const finish = (commit)=>{
                                    const raw = String(b.textContent || '').trim();
                                    cleanup();
                                    applyName(commit ? raw : prev);
                                    b.removeEventListener('keydown', onKey);
                                    b.removeEventListener('blur', onBlur);
                                };

                                const onKey = (e)=>{
                                    if (!e) return;
                                    if (e.key === 'Enter') { e.preventDefault(); finish(true); }
                                    else if (e.key === 'Escape') { e.preventDefault(); finish(false); }
                                };
                                const onBlur = ()=> finish(true);

                                b.addEventListener('keydown', onKey);
                                b.addEventListener('blur', onBlur);
                                try { b.focus(); } catch(_){ }
                                try {
                                    const r = document.createRange();
                                    r.selectNodeContents(b);
                                    const s = window.getSelection();
                                    if (s) { s.removeAllRanges(); s.addRange(r); }
                                } catch(_){ }
                            } catch(_){ }
                        };

                        // Hold (~220ms) opens editor.
                        b.addEventListener('pointerdown', (e)=>{
                            try { e.preventDefault(); e.stopPropagation(); } catch(_){ }
                            clearTimers();
                            b._lastTapTs = 0;
                            b._holdFired = false;
                            b._holdTimer = setTimeout(()=>{
                                b._holdTimer = null;
                                b._holdFired = true;
                                b._suppressSingleTap = true;
                                try { openEditor(); } catch(_){ }
                                try { b._suppressUntil = (performance && performance.now ? performance.now() : Date.now()) + 350; } catch(_){ b._suppressUntil = Date.now() + 350; }
                            }, 220);
                        }, { passive:false });
                        const endHold = ()=>{ try { if (b._holdTimer) { clearTimeout(b._holdTimer); b._holdTimer = null; } } catch(_){ } };
                        b.addEventListener('pointerup', endHold, { passive:true });
                        b.addEventListener('pointercancel', endHold, { passive:true });
                        b.addEventListener('pointerleave', endHold, { passive:true });

                        // Single tap: mute/unmute (queued if playing). Double-tap/dblclick: rename.
                        b.addEventListener('click', (e)=>{
                            try { e.preventDefault(); e.stopPropagation(); } catch(_){ }
                            const now = (performance && performance.now ? performance.now() : Date.now());
                            if (b._suppressUntil && now < b._suppressUntil) return;
                            if (b._holdFired) return;

                            // Double-tap rename (touch-friendly): second click within window triggers rename
                            const doubleWindow = 260;
                            const lastTap = b._lastTapTs || 0;
                            if (lastTap && (now - lastTap) <= doubleWindow) {
                                b._lastTapTs = 0;
                                clearTimers();
                                b._suppressSingleTap = true;
                                try { doRename(); } catch(_){ }
                                try { b._suppressUntil = now + 350; } catch(_){ b._suppressUntil = (Date.now() + 350); }
                                return;
                            }
                            b._lastTapTs = now;
                            // Delay to allow double-tap/dblclick to cancel
                            try { if (b._singleTapTimer) clearTimeout(b._singleTapTimer); } catch(_){ }
                            b._suppressSingleTap = false;
                            b._singleTapTimer = setTimeout(()=>{
                                b._singleTapTimer = null;
                                if (b._suppressSingleTap) return;
                                toggleMute();
                            }, doubleWindow);
                        });

                        // Double tap/click: rename pattern (no mute/unmute, no editor)
                        b.addEventListener('dblclick', (e)=>{
                            try { e.preventDefault(); e.stopPropagation(); } catch(_){ }
                            clearTimers();
                            b._suppressSingleTap = true;
                            if (b._holdFired) return;
                            b._lastTapTs = 0;
                            try { doRename(); } catch(_){ }
                        });

                        strip.appendChild(b);
                        clone._stripBtn = b;
                        setStripState();
                    }
                } catch(_){ }

                // Start all patterns unmuted by default
                try {
                    clone._patternEnabled = true;
                    const speakerBtn = (clone.querySelector('[data-role="patternSpeakerBtn"]') || clone.querySelector('#patternSpeakerBtn'));
                    if (speakerBtn) speakerBtn.textContent = 'ðŸ”Š';
                } catch(_){ }

                // If PLAY is already running, start this pattern on beat 1 (next bar) using ticks
                try {
                    const omni = window.omnichord;
                    const isPlaying = !!(omni && omni._arpTransport && omni._arpTransport.running);
                    const pt = clone._patternTransport;
                    if (isPlaying && clone._patternEnabled && pt && typeof pt.start === 'function') {
                        pt.start({ alignToTransport: true, preBufferMs: 80 });
                    }
                } catch(_){ }

                // When unmuted while PLAY is running, this instance will align-start on the next bar.

                return clone;
            };

            window.destroyPatternInstance = function(modalEl){
                if (!modalEl) return;
                try {
                    const pt = modalEl._patternTransport;
                    if (pt) { try { pt.stop(true); } catch(_){} try { pt.stopVoices && pt.stopVoices(); } catch(_){} }
                } catch(_){ }
                try { if (modalEl._stripBtn && modalEl._stripBtn.remove) modalEl._stripBtn.remove(); } catch(_){ }
                try {
                    const arr = window._patternInstances || [];
                    window._patternInstances = arr.filter(x=>x && x.modal !== modalEl);
                } catch(_){ }
                try { modalEl.remove(); } catch(_){ try { modalEl.style.display='none'; } catch(__){} }
            };

            // Wire sidebar click/tap: always spawn a NEW pattern instance and open it maximized
            try {
                const btn = document.getElementById('newPatternBtn') || document.getElementById('patternBtn');
                if (btn && !btn._wiredSpawnPatternInstance) {
                    btn._wiredSpawnPatternInstance = true;

                    const spawnAndOpen = (e)=>{
                        try { e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation && e.stopImmediatePropagation(); } catch(_){ }
                        try {
                            const now = (performance && performance.now ? performance.now() : Date.now());
                            const last = btn._lastPatternSpawnTs || 0;
                            if (now - last < 320) return;
                            btn._lastPatternSpawnTs = now;
                        } catch(_){ }
                        try {
                            const modal = window.spawnPatternInstance && window.spawnPatternInstance();
                            if (modal) {
                                try { modal.style.display = 'flex'; } catch(_){ }
                                try { window.showPatternModal && window.showPatternModal(modal); } catch(_){ }
                            }
                        } catch(_){ }
                    };

                    btn.addEventListener('pointerup', spawnAndOpen, true);
                    btn.addEventListener('click', spawnAndOpen, true);
                }
            } catch(_){ }

            // Keep the shared editor in sync even when opened/closed via sidebar controls.
            try {
                const wrapModals = ()=>{
                    try {
                        if (typeof window.showDrumModal === 'function' && !window.showDrumModal._drumInstanceWrapped) {
                            const origShow = window.showDrumModal;
                            const wrappedShow = function(){
                                const r = origShow.apply(this, arguments);
                                try { window._syncDrumEditorToActiveInstance && window._syncDrumEditorToActiveInstance(); } catch(_){ }
                                return r;
                            };
                            wrappedShow._drumInstanceWrapped = true;
                            window.showDrumModal = wrappedShow;
                        }
                        if (typeof window.closeDrumModal === 'function' && !window.closeDrumModal._drumInstanceWrapped) {
                            const origClose = window.closeDrumModal;
                            const wrappedClose = function(){
                                try { saveActiveFromUI(); } catch(_){ }
                                return origClose.apply(this, arguments);
                            };
                            wrappedClose._drumInstanceWrapped = true;
                            window.closeDrumModal = wrappedClose;
                        }
                    } catch(_){ }
                };
                wrapModals();
                setTimeout(wrapModals, 500);
                setTimeout(wrapModals, 1500);
            } catch(_){ }
        })();

        // Drum instance support: NEW DRUM spawns independent drum sequencers (polymeter LEN), all driven by master transport.
        (function(){
            if (window._drumInstanceSupportWired) return;
            window._drumInstanceSupportWired = true;

            // Shared UI helper: pulse a dot briefly when it fires.
            if (!window._pulseStepEl) {
                window._pulseStepEl = function(el){
                    try {
                        if (!el || !el.classList) return;
                        try { if (el._pulseTimer) { clearTimeout(el._pulseTimer); el._pulseTimer = null; } } catch(_){ }
                        el.classList.remove('step-pulse');
                        try { void el.offsetWidth; } catch(_){ }
                        el.classList.add('step-pulse');
                        el._pulseTimer = setTimeout(()=>{
                            try { el.classList.remove('step-pulse'); } catch(_){ }
                            try { el._pulseTimer = null; } catch(_){ }
                        }, 170);
                    } catch(_){ }
                };
            }

            const _TRAFFIC_CLASSES = ['traffic-green','traffic-red','traffic-yellow','traffic-orange'];
            const setTrafficClass = (btn, cls)=>{
                try {
                    if (!btn || !btn.classList) return;
                    _TRAFFIC_CLASSES.forEach(c=>btn.classList.remove(c));
                    if (cls) btn.classList.add(cls);
                } catch(_){ }
            };

            const getStrip = ()=> document.getElementById('drumButtons');

            const ensureRegistry = ()=>{
                window._drumInstances = window._drumInstances || [];
                if (!window._drumInstanceCounter) window._drumInstanceCounter = 0;
            };

            const blankState = (len)=>{
                const safeLen = Math.max(1, Math.min(64, parseInt(len||'16',10) || 16));
                const lanes = new Array(9).fill(0).map(()=>({
                    steps: new Array(safeLen).fill(0),
                    vel: new Array(safeLen).fill(100),
                    quant: String(safeLen),
                    vol: 80,
                    send: 0,
                    midi: '',
                    pitch: 0,
                    atk: 2,
                    dec: 180,
                }));
                return { len: safeLen, lanes };
            };

            const captureEditorState = ()=>{
                const grid = document.getElementById('drumGrid');
                if (!grid) return null;
                const len = Math.max(1, Math.min(64, parseInt(grid.dataset.length||'16',10)||16));
                const rows = Array.from(grid.querySelectorAll('.drum-row:not(.bass-row)'));
                const lanes = rows.map((row)=>{
                    const laneEl = row.querySelector('.drum-lane');
                    const stepsEl = laneEl ? Array.from(laneEl.querySelectorAll('.drum-step')) : [];
                    const steps = stepsEl.map(s=> s.classList.contains('active') ? 1 : 0);
                    const vel = stepsEl.map(s=> Math.max(0, Math.min(127, parseInt(s.dataset.vel||'100',10)||100)));
                    const volEl = row.querySelector('.drum-volume');
                    const sendEl = row.querySelector('.drum-send');
                    const fxEl = row.querySelector('.drum-fx input[type="checkbox"]');
                    const midiEl = row.querySelector('.drum-midi input[type="text"]');
                    const pitchEl = row.querySelector('.drum-params input[title$="Pitch"]');
                    const atkEl = row.querySelector('.drum-params input[title$="Attack"]');
                    const decEl = row.querySelector('.drum-params input[title$="Decay"]');
                    const sendPct = sendEl ? (parseInt(sendEl.value||'0',10) || 0) : (fxEl && fxEl.checked ? 100 : 0);
                    return {
                        steps,
                        vel,
                        quant: laneEl ? String(laneEl.dataset.quant||'').trim() : String(len),
                        vol: volEl ? (parseInt(volEl.value||'80',10)||80) : 80,
                        send: Math.max(0, Math.min(1, sendPct/100)),
                        midi: midiEl ? String(midiEl.value||'').trim() : '',
                        pitch: pitchEl ? (parseInt(pitchEl.value||'0',10)||0) : 0,
                        atk: atkEl ? (parseInt(atkEl.value||'2',10)||2) : 2,
                        dec: decEl ? (parseInt(decEl.value||'180',10)||180) : 180,
                    };
                });
                // Normalize to 9 lanes
                while (lanes.length < 9) lanes.push(blankState(len).lanes[0]);
                return { len, lanes: lanes.slice(0,9) };
            };

            const applyEditorState = (state)=>{
                if (!state) return;
                const grid = document.getElementById('drumGrid');
                if (!grid) return;
                const len = Math.max(1, Math.min(64, parseInt(state.len||'16',10)||16));

                try { grid.dataset.length = String(len); } catch(_){ }
                try {
                    const lenVal = document.getElementById('drumLenValue');
                    const lenHint = document.getElementById('drumLenHint');
                    if (lenVal) { lenVal.textContent = String(len); try { delete lenVal.dataset.pending; } catch(_){ } }
                    if (lenHint) lenHint.textContent = `Cycle: ${len} steps`;
                } catch(_){ }

                // Apply per-lane Q (N/D) before rebuilding geometry.
                try {
                    const lanesEl = Array.from(grid.querySelectorAll('.drum-lane'));
                    lanesEl.forEach((laneEl, idx)=>{
                        const laneState = (state.lanes && state.lanes[idx]) ? state.lanes[idx] : null;
                        const q = laneState && laneState.quant ? String(laneState.quant).trim() : '';
                        if (q) laneEl.dataset.quant = q;
                        else laneEl.dataset.quant = String(len);
                    });
                } catch(_){ }

                // Rebuild lanes for current time signature while honoring each lane's quant string.
                try {
                    if (window.omnichord && typeof window.omnichord._updateDrumGridForTimeSignature === 'function') {
                        window.omnichord._updateDrumGridForTimeSignature();
                    }
                } catch(_){ }

                const remapArr = (arr, toLen, isVel)=>{
                    const out = new Array(toLen).fill(isVel ? 100 : 0);
                    const src = Array.isArray(arr) ? arr : [];
                    const fromLen = src.length || 0;
                    if (!fromLen) return out;
                    if (fromLen === toLen) {
                        for (let i=0;i<toLen;i++) out[i] = src[i];
                        return out;
                    }
                    for (let i=0;i<toLen;i++){
                        const j = Math.max(0, Math.min(fromLen-1, Math.round((i / Math.max(1,toLen-1)) * (fromLen-1))));
                        out[i] = src[j];
                    }
                    return out;
                };

                const rows = Array.from(grid.querySelectorAll('.drum-row:not(.bass-row)'));
                rows.forEach((row, idx)=>{
                    const laneEl = row.querySelector('.drum-lane');
                    const stepsEl = laneEl ? Array.from(laneEl.querySelectorAll('.drum-step')) : [];
                    const lane = (state.lanes && state.lanes[idx]) ? state.lanes[idx] : null;
                    const volEl = row.querySelector('.drum-volume');
                    const sendEl = row.querySelector('.drum-send');
                    const fxEl = row.querySelector('.drum-fx input[type="checkbox"]');
                    const midiEl = row.querySelector('.drum-midi input[type="text"]');
                    const pitchEl = row.querySelector('.drum-params input[title$="Pitch"]');
                    const atkEl = row.querySelector('.drum-params input[title$="Attack"]');
                    const decEl = row.querySelector('.drum-params input[title$="Decay"]');
                    if (volEl && lane) volEl.value = String(lane.vol ?? 80);
                    if (lane) {
                        const legacyFx = (typeof lane.fx === 'boolean') ? lane.fx : false;
                        const send = (typeof lane.send === 'number') ? lane.send : (legacyFx ? 1 : 0);
                        if (sendEl) sendEl.value = String(Math.round(Math.max(0, Math.min(1, send)) * 100));
                        else if (fxEl) fxEl.checked = !!legacyFx;
                    }
                    if (midiEl && lane) midiEl.value = String(lane.midi||'');
                    if (pitchEl && lane) pitchEl.value = String(lane.pitch ?? 0);
                    if (atkEl && lane) atkEl.value = String(lane.atk ?? 2);
                    if (decEl && lane) decEl.value = String(lane.dec ?? 180);

                    // Keep lane dataset.quant in sync with instance state.
                    try {
                        if (laneEl) laneEl.dataset.quant = String((lane && lane.quant) ? lane.quant : (laneEl.dataset.quant || String(len))).trim();
                    } catch(_){ }

                    const stepsArr = remapArr(lane && lane.steps, stepsEl.length, false);
                    const velArr = remapArr(lane && lane.vel, stepsEl.length, true);
                    stepsEl.forEach((s, j)=>{
                        const on = !!stepsArr[j];
                        if (on) s.classList.add('active'); else s.classList.remove('active');
                        const v = velArr[j];
                        s.dataset.vel = String(Math.max(0, Math.min(127, parseInt(v||'100',10)||100)));
                        try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(s); } catch(_){ }
                    });
                });
            };

            const getActiveInstance = ()=>{
                const id = window._activeDrumInstanceId;
                if (!id) return null;
                return (window._drumInstances||[]).find(x=>x && x.id === id) || null;
            };

            const saveActiveFromUI = ()=>{
                try {
                    const inst = getActiveInstance();
                    if (!inst) return;
                    const st = captureEditorState();
                    if (st) inst.state = st;
                } catch(_){ }
            };

            const updateButtonVisual = (inst)=>{
                if (!inst || !inst._stripBtn) return;
                const b = inst._stripBtn;
                const enabledNow = !!inst.enabled;
                const pendEnabled = (inst.pendingEnabled != null) ? !!inst.pendingEnabled : null;
                const pendAny = (inst.pendingEnabled != null || inst.pendingLen != null);
                // Traffic colors:
                // - GREEN: enabled now
                // - RED: muted now
                // - ORANGE: enabled now, queued to mute
                // - YELLOW: muted now, queued to unmute
                let traffic = enabledNow ? 'traffic-green' : 'traffic-red';
                if (pendEnabled != null) {
                    if (enabledNow && pendEnabled === false) traffic = 'traffic-orange';
                    else if (!enabledNow && pendEnabled === true) traffic = 'traffic-yellow';
                    else traffic = pendEnabled ? 'traffic-green' : 'traffic-red';
                }
                setTrafficClass(b, traffic);
                try { if (enabledNow) b.classList.add('active'); else b.classList.remove('active'); } catch(_){ }
                try {
                    if (pendAny) { b.classList.add('pending-change'); b.title = 'Click: queue mute/unmute â€¢ Double-click: rename â€¢ Hold: edit'; }
                    else { b.classList.remove('pending-change'); b.title = 'Click: queue mute/unmute â€¢ Double-click: rename â€¢ Hold: edit'; }
                } catch(_){ }
            };

            window._updateDrumInstanceButtonVisual = updateButtonVisual;

            const wireDrumButtonForInstance = (inst, defaultLabel)=>{
                const strip = getStrip();
                if (!strip || !inst) return null;
                const b = document.createElement('button');
                b.className = 'panel-btn';
                b.textContent = inst.name || defaultLabel;
                b.style.background = '#1f8f4a';
                b.style.borderColor = '#46c37b';
                b.style.color = '#eafff3';
                b.style.padding = '6px 10px';
                b.style.fontSize = '12px';

                const clearTimers = ()=>{
                    try { if (b._singleTapTimer) { clearTimeout(b._singleTapTimer); b._singleTapTimer = null; } } catch(_){ }
                    try { if (b._holdTimer) { clearTimeout(b._holdTimer); b._holdTimer = null; } } catch(_){ }
                };

                const applyName = (name)=>{
                    const nm = String(name || '').trim();
                    inst.name = nm ? nm : (defaultLabel || inst.name || 'DRUM');
                    b.textContent = inst.name;
                    try {
                        const modal = document.getElementById('drumModal');
                        const hdr = modal ? modal.querySelector('.modal-header span') : null;
                        if (hdr) hdr.textContent = `Drum Sequencer â€” ${inst.name}`;
                    } catch(_){ }
                };

                const doRename = ()=>{
                    try {
                        if (b._renaming) return;
                        b._renaming = true;
                        const prev = String(inst.name || defaultLabel || 'DRUM');
                        b.textContent = prev;
                        b.setAttribute('contenteditable', 'true');
                        b.setAttribute('role', 'textbox');
                        b.setAttribute('spellcheck', 'false');
                        b.style.outline = '2px solid #7cc9ff';
                        b.style.outlineOffset = '1px';

                        const cleanup = ()=>{
                            b.removeAttribute('contenteditable');
                            b.removeAttribute('role');
                            b.removeAttribute('spellcheck');
                            b.style.outline = '';
                            b.style.outlineOffset = '';
                            b._renaming = false;
                        };

                        const finish = (commit)=>{
                            const raw = String(b.textContent || '').trim();
                            cleanup();
                            applyName(commit ? raw : prev);
                            b.removeEventListener('keydown', onKey);
                            b.removeEventListener('blur', onBlur);
                        };

                        const onKey = (e)=>{
                            if (!e) return;
                            if (e.key === 'Enter') { e.preventDefault(); finish(true); }
                            else if (e.key === 'Escape') { e.preventDefault(); finish(false); }
                        };
                        const onBlur = ()=> finish(true);

                        b.addEventListener('keydown', onKey);
                        b.addEventListener('blur', onBlur);
                        try { b.focus(); } catch(_){ }
                        try {
                            const r = document.createRange();
                            r.selectNodeContents(b);
                            const s = window.getSelection();
                            if (s) { s.removeAllRanges(); s.addRange(r); }
                        } catch(_){ }
                    } catch(_){ }
                };

                const openEditor = ()=>{
                    try { saveActiveFromUI(); } catch(_){ }
                    window._activeDrumInstanceId = inst.id;
                    try { if (typeof window.showDrumModal === 'function') window.showDrumModal(); } catch(_){ }
                    try { applyEditorState(inst.state || blankState(inst.len)); } catch(_){ }
                    try {
                        const modal = document.getElementById('drumModal');
                        const hdr = modal ? modal.querySelector('.modal-header span') : null;
                        if (hdr) hdr.textContent = `Drum Sequencer â€” ${inst.name}`;
                    } catch(_){ }
                };

                const queueToggle = ()=>{
                    const isPlaying = !!(window.omnichord && window.omnichord._arpTransport && window.omnichord._arpTransport.running);
                    const base = (inst.pendingEnabled != null) ? !!inst.pendingEnabled : !!inst.enabled;
                    const desired = !base;
                    if (isPlaying) {
                        inst.pendingEnabled = desired;
                    } else {
                        inst.enabled = desired;
                        inst.pendingEnabled = null;
                    }
                    updateButtonVisual(inst);
                    try { window._storeCurrentSectionState && window._storeCurrentSectionState(); } catch(_){ }
                };

                // Hold (~220ms) opens editor.
                b.addEventListener('pointerdown', (e)=>{
                    try { e.preventDefault(); e.stopPropagation(); } catch(_){ }
                    clearTimers();
                    b._lastTapTs = 0;
                    b._holdFired = false;
                    b._holdTimer = setTimeout(()=>{
                        b._holdTimer = null;
                        b._holdFired = true;
                        b._suppressSingleTap = true;
                        try { openEditor(); } catch(_){ }
                        try { b._suppressUntil = (performance && performance.now ? performance.now() : Date.now()) + 350; } catch(_){ b._suppressUntil = Date.now() + 350; }
                    }, 220);
                }, { passive:false });
                const endHold = ()=>{ try { if (b._holdTimer) { clearTimeout(b._holdTimer); b._holdTimer = null; } } catch(_){ } };
                b.addEventListener('pointerup', endHold, { passive:true });
                b.addEventListener('pointercancel', endHold, { passive:true });
                b.addEventListener('pointerleave', endHold, { passive:true });

                // Single tap queues mute/unmute (next cycle); double-tap/dblclick renames.
                b.addEventListener('click', (e)=>{
                    try { e.preventDefault(); e.stopPropagation(); } catch(_){ }
                    const now = (performance && performance.now ? performance.now() : Date.now());
                    if (b._suppressUntil && now < b._suppressUntil) return;
                    if (b._holdFired) return;
                    const doubleWindow = 260;
                    const lastTap = b._lastTapTs || 0;
                    if (lastTap && (now - lastTap) <= doubleWindow) {
                        b._lastTapTs = 0;
                        clearTimers();
                        b._suppressSingleTap = true;
                        try { doRename(); } catch(_){ }
                        try { b._suppressUntil = now + 350; } catch(_){ b._suppressUntil = (Date.now() + 350); }
                        return;
                    }
                    b._lastTapTs = now;
                    try { if (b._singleTapTimer) clearTimeout(b._singleTapTimer); } catch(_){ }
                    b._suppressSingleTap = false;
                    b._singleTapTimer = setTimeout(()=>{
                        b._singleTapTimer = null;
                        if (b._suppressSingleTap) return;
                        queueToggle();
                    }, doubleWindow);
                });
                b.addEventListener('dblclick', (e)=>{
                    try { e.preventDefault(); e.stopPropagation(); } catch(_){ }
                    clearTimers();
                    b._suppressSingleTap = true;
                    if (b._holdFired) return;
                    b._lastTapTs = 0;
                    try { doRename(); } catch(_){ }
                });

                strip.appendChild(b);
                inst._stripBtn = b;
                updateButtonVisual(inst);
                return b;
            };

            window._rebuildDrumInstanceButtons = function(){
                try {
                    const strip = getStrip();
                    if (!strip) return;
                    strip.innerHTML = '';
                    (window._drumInstances || []).forEach((inst, idx)=>{
                        if (!inst) return;
                        const defaultLabel = `DRUM ${idx+1}`;
                        wireDrumButtonForInstance(inst, defaultLabel);
                    });
                } catch(_){ }
            };

            window.spawnDrumInstance = function(){
                ensureRegistry();
                const n = (++window._drumInstanceCounter);
                const id = 'drum' + String(n);
                const defaultLabel = `DRUM ${n}`;
                const len0 = 16;
                const inst = {
                    id,
                    name: defaultLabel,
                    enabled: true,
                    pendingEnabled: null,
                    len: len0,
                    pendingLen: null,
                    state: blankState(len0),
                    startAtBarIndex: null,
                    cycleStartGlobalStep: null,
                    _lastStep: -1,
                };
                window._drumInstances.push(inst);

                let openEditor = null;
                openEditor = ()=>{
                    try { saveActiveFromUI(); } catch(_){ }
                    window._activeDrumInstanceId = inst.id;
                    try { if (typeof window.showDrumModal === 'function') window.showDrumModal(); } catch(_){ }
                    try { applyEditorState(inst.state || blankState(inst.len)); } catch(_){ }
                    try {
                        const modal = document.getElementById('drumModal');
                        const hdr = modal ? modal.querySelector('.modal-header span') : null;
                        if (hdr) hdr.textContent = `Drum Sequencer â€” ${inst.name}`;
                    } catch(_){ }
                };

                wireDrumButtonForInstance(inst, defaultLabel);

                // If PLAY is running, arm this drum to start on the next bar (Beat 1).
                try {
                    const omni = window.omnichord;
                    const transport = omni && omni._arpTransport;
                    const isPlaying = !!(transport && transport.running);
                    if (isPlaying) {
                        const tpBar = Math.max(1, transport.ticksPerBar||16);
                        const absTick = (transport.absTickCounter|0);
                        const barIndex = Math.floor(absTick / tpBar);
                        inst.startAtBarIndex = barIndex + 1;
                        inst.cycleStartGlobalStep = null;
                        inst._lastStep = -1;
                    }
                } catch(_){ }

                // Set as active selection by default and open editor
                try {
                    if (!window._activeDrumInstanceId) window._activeDrumInstanceId = inst.id;
                } catch(_){ }
                try { window._storeCurrentSectionState && window._storeCurrentSectionState(); } catch(_){ }
                try {
                    if (!window._suppressInstanceAutoOpen) openEditor && openEditor();
                } catch(_){ }

                return inst;
            };

            // Make editor reflect active instance when opening drum modal.
            window._syncDrumEditorToActiveInstance = function(){
                try {
                    ensureRegistry();
                    const inst = getActiveInstance();
                    if (!inst) return;
                    // Apply selected instance into editor
                    applyEditorState(inst.state || blankState(inst.len));
                    try {
                        const modal = document.getElementById('drumModal');
                        const hdr = modal ? modal.querySelector('.modal-header span') : null;
                        if (hdr) hdr.textContent = `Drum Sequencer â€” ${inst.name}`;
                    } catch(_){ }
                } catch(_){ }
            };

            // Live editor -> active instance sync.
            // Without this, changing SEND/volume/etc in the editor won't affect playback until the modal closes,
            // because multi-instance scheduling reads from instance state (not DOM).
            const wireLiveEditorSync = ()=>{
                try {
                    const grid = document.getElementById('drumGrid');
                    if (!grid || grid._liveInstanceSyncWired) return;
                    grid._liveInstanceSyncWired = true;

                    const scheduleSave = ()=>{
                        try {
                            if (!(window._drumInstances && window._drumInstances.length)) return;
                            if (grid._liveInstanceSyncTimer) clearTimeout(grid._liveInstanceSyncTimer);
                            grid._liveInstanceSyncTimer = setTimeout(()=>{
                                try { saveActiveFromUI(); } catch(_){ }
                            }, 40);
                        } catch(_){ }
                    };

                    // Inputs (SEND sliders, volume, params, MIDI note text)
                    grid.addEventListener('input', (e)=>{
                        const t = e && e.target;
                        if (!t) return;
                        scheduleSave();
                    }, true);
                    grid.addEventListener('change', ()=> scheduleSave(), true);

                    // Step toggles are clicks, not inputs.
                    grid.addEventListener('click', (e)=>{
                        const t = e && e.target;
                        if (!t || !t.classList) return;
                        if (t.classList.contains('drum-step')) scheduleSave();
                    }, true);
                } catch(_){ }
            };
            wireLiveEditorSync();
            setTimeout(wireLiveEditorSync, 500);
            setTimeout(wireLiveEditorSync, 1500);

            // Wire NEW DRUM button
            try {
                const btn = document.getElementById('newDrumBtn');
                if (btn && !btn._wiredSpawnDrumInstance) {
                    btn._wiredSpawnDrumInstance = true;
                    const spawn = (e)=>{
                        try { e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation && e.stopImmediatePropagation(); } catch(_){ }
                        try {
                            const now = (performance && performance.now ? performance.now() : Date.now());
                            const last = btn._lastDrumSpawnTs || 0;
                            if (now - last < 320) return;
                            btn._lastDrumSpawnTs = now;
                        } catch(_){ }
                        try { window.spawnDrumInstance && window.spawnDrumInstance(); } catch(_){ }
                    };
                    btn.addEventListener('pointerup', spawn, true);
                    btn.addEventListener('click', spawn, true);
                }
            } catch(_){ }

            // Hook omnichord._saveDrumPattern to also persist the active drum instance state.
            try {
                const hook = ()=>{
                    try {
                        const omni = window.omnichord;
                        if (!omni || typeof omni._saveDrumPattern !== 'function') return;
                        if (omni._saveDrumPattern._drumInstanceHooked) return;
                        const orig = omni._saveDrumPattern;
                        const wrapped = function(){
                            try { orig.apply(this, arguments); } catch(_){ }
                            try {
                                ensureRegistry();
                                const inst = getActiveInstance();
                                if (inst) {
                                    const st = captureEditorState();
                                    if (st) inst.state = st;
                                    inst.len = st ? st.len : inst.len;
                                }
                            } catch(_){ }
                        };
                        wrapped._drumInstanceHooked = true;
                        omni._saveDrumPattern = wrapped;
                    } catch(_){ }
                };
                // Attempt now and after load.
                hook();
                setTimeout(hook, 500);
                setTimeout(hook, 1500);
            } catch(_){ }
        })();
        
        // Bass modal functions
        window.showBassModal = function() {
            console.log('Opening bass modal');
            const modal = document.getElementById('bassModal');
            if (modal) {
                modal.style.display = 'block';
                bringModalToFront('bassModal');
                try { window._ensureModalDotScaling(modal); modal._dotScaleApply && modal._dotScaleApply(); } catch(_) {}
                try { window._ensureModalAspectResize && window._ensureModalAspectResize(modal); } catch(_) {}
                
                // Generate bass grid if not already built
                const bassContainer = modal.querySelector('.drum-grid-container');
                if (bassContainer) {
                    // Compute max denominator across lanes and set --bar-steps for correct min-width
                    try {
                        const lanes = Array.from(patternContainer.querySelectorAll('.pattern-lane'));
                        const maxD = lanes.reduce((mx, ln) => {
                            const qs = ln.dataset.quant || '';
                            let d = parseInt(ln.style.getPropertyValue('--steps-per-bar')||'16',10)||16;
                            const m = qs.match(/^(\d+)\/(\d+)$/);
                            if (m) { const dd = parseInt(m[2],10); if (Number.isFinite(dd) && dd>0) d = dd; }
                            else { const mn = qs.match(/^(\d+)$/); if (mn){ const dd=parseInt(mn[1],10); if (Number.isFinite(dd) && dd>0) d = dd; } }
                            return Math.max(mx, d);
                        }, 16);
                        patternContainer.style.setProperty('--bar-steps', String(maxD));
                    } catch(_) {}
                    bassContainer.style.display = 'block';
                    // Build bass pattern grid if not already done
                    const bassGrid = document.getElementById('bassGrid');
                    if (bassGrid && !bassGrid.dataset.built) {
                        generateBassPatternGrid(bassGrid);
                        bassGrid.dataset.built = '1';
                // Auto-size to fit full row content on open only
                try { window._autoSizePatternModals && window._autoSizePatternModals(); } catch(_) {}
                    }
                }
                
                // Make draggable if not already
                if (!modal._draggableSet) {
                    makeDraggable(modal);
                    modal._draggableSet = true;
                }
                // Compute max denominator across lanes for bass grid and set --bar-steps for spacing/min-width
                try {
                    const bassContainer = modal.querySelector('.drum-grid-container');
                    if (bassContainer) {
                        const lanes = Array.from(bassContainer.querySelectorAll('.bass-lane'));
                        const maxD = lanes.reduce((mx, ln) => {
                            const qs = ln.dataset.quant || '';
                            let d = parseInt(ln.style.getPropertyValue('--steps-per-bar')||'16',10)||16;
                            const m = qs.match(/^(\d+)\/(\d+)$/);
                            if (m) { const dd = parseInt(m[2],10); if (Number.isFinite(dd) && dd>0) d = dd; }
                            else { const mn = qs.match(/^(\d+)$/); if (mn){ const dd=parseInt(mn[1],10); if (Number.isFinite(dd) && dd>0) d = dd; } }
                            return Math.max(mx, d);
                        }, 16);
                        bassContainer.style.setProperty('--bar-steps', String(maxD));
                    }
                } catch(_) {}
                // Auto-size to fit full row content on open only
                try { window._autoSizePatternModals && window._autoSizePatternModals(); } catch(_) {}
            }
        };
        
        window.closeBassModal = function() {
            console.log('Closing bass modal and disabling bass');
            const modal = document.getElementById('bassModal');
            if (modal) modal.style.display = 'none';
            const btn = document.getElementById('bassBtn');
            if (btn) btn.classList.remove('active');
        };
        
        window.closeBassModalOnly = function() {
            console.log('Closing bass modal only (keeping bass enabled)');
            const modal = document.getElementById('bassModal');
            if (modal) modal.style.display = 'none';
            // Don't disable the bass - keep button active
        };

        // *** FIX 2: Generate bass pattern grid identical to pattern grid but for bass notes ***
        window.generateBassPatternGrid = function(bassGrid) {
            if (!bassGrid) return;
            
            console.log('ðŸŽ¸ Generating bass pattern grid (9 rows)...');
            
            // Clear existing content
            bassGrid.innerHTML = '';
            bassGrid.dataset.built = '1';
            
            // Get pattern length from bass controls
            const bassLenDisplay = document.getElementById('bassLenDisplay');
            const stepsPerBar = Math.max(4, parseInt(bassLenDisplay?.textContent || '16', 10));
            
            // Create 9 bass rows (NOTE 9 down to NOTE 1) - identical to pattern structure
            const rowLabels = ['NOTE 9','NOTE 8','NOTE 7','NOTE 6','NOTE 5','NOTE 4','NOTE 3','NOTE 2','NOTE 1'];
            
            rowLabels.forEach((labelName, rowIdx) => {
                const row = document.createElement('div');
                row.className = 'drum-row bass-row pattern-row';
                
                const label = document.createElement('div');
                label.className = 'drum-label';
                label.textContent = labelName;
                row.appendChild(label);
                
                const lane = document.createElement('div');
                lane.className = 'drum-lane pattern-lane bass-lane';
                lane.dataset.row = String(rowIdx);
                try { lane.style.setProperty('--steps-per-bar', String(stepsPerBar)); } catch(_){ }
                // Initialize lane quant cache and default value (N=D=stepsPerBar)
                lane.dataset.quant = String(stepsPerBar);
                lane._quant = { str: lane.dataset.quant, N: stepsPerBar, D: stepsPerBar };
                
                // Beat dividers (based on D)
                const fullBeats = Math.max(0, Math.floor(stepsPerBar/4));
                for (let b=1; b<fullBeats; b++) {
                    const div = document.createElement('div');
                    div.className = 'beat-divider';
                    div.style.left = `${(b/fullBeats)*100}%`;
                    lane.appendChild(div);
                }
                
                // Create steps with bass pill behavior (count = D)
                for (let sIdx=0; sIdx<stepsPerBar; sIdx++) {
                    const st = document.createElement('div');
                    st.className = 'drum-step pattern-step bass-step' + ((sIdx%4===0)?' beat-accent':'');
                    st.dataset.step = String(sIdx);
                    st.title = `${labelName} â€¢ Step ${sIdx+1}`;
                    st.dataset.npc = '';
                    
                    // *** BASS PILL BEHAVIOR: Click and drag for extended notes ***
                    // Horizontal drag = pill/length, Vertical drag = velocity
                    
                    st.addEventListener('mousedown', (e) => {
                        if (e.button !== 0) return;
                        e.preventDefault();
                        
                        const startIdx = sIdx;
                        const steps = Array.from(lane.querySelectorAll('.bass-step'));
                        const wasActive = st.classList.contains('active');
                        const startX = e.clientX;
                        const startY = e.clientY;
                        const startVel = parseInt(st.dataset.vel || '100', 10);
                        
                        let isDragging = false;
                        let dragStarted = false;
                        let isVelMode = false;
                        let isLenMode = false;
                        
                        // *** DRAG behavior: Horizontal = pill length, Vertical = velocity ***
                        const applyLen = (toIdx) => {
                            const len = Math.max(1, (toIdx|0) - startIdx + 1);
                            
                            // Set head note
                            st.classList.add('active');
                            st.dataset.npc = st.dataset.npc || '1'; // Default to NPC 1
                            st.dataset.len = String(len);
                            
                            // Set ties for continuation steps (sustain)
                            for (let k=0; k<steps.length; k++) {
                                if (k > startIdx && k <= startIdx + len - 1) {
                                    steps[k].dataset.tie = '1';
                                    steps[k].classList.remove('active'); // Ties are not active, just sustained
                                } else if (k > startIdx) {
                                    delete steps[k].dataset.tie;
                                }
                            }
                        };
                        
                        const applyVel = (clientY) => {
                            const deltaY = startY - clientY; // Drag up = louder
                            const deltaVel = Math.round(deltaY / 1.5);
                            const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                            st.dataset.vel = String(newVel);
                            try { window.updateStepVelocityClass(st); } catch(_){}
                        };
                        
                        const onMove = (ev) => {
                            if (!dragStarted) {
                                dragStarted = true;
                                isDragging = true;
                                // DON'T activate here - wait until mode is determined
                            }
                            
                            const dx = Math.abs(ev.clientX - startX);
                            const dy = Math.abs(ev.clientY - startY);
                            
                            // Determine drag mode: horizontal = length (pills), vertical = velocity
                            // Favor horizontal: only go velocity mode if dy > dx*2 AND dy > 10
                            if (!isVelMode && !isLenMode) {
                                if (dy > dx * 2 && dy > 10) {
                                    // Strong vertical movement = velocity mode
                                    isVelMode = true;
                                    st.classList.add('vel-dragging');
                                    if (!wasActive) {
                                        st.classList.add('active');
                                        st.dataset.npc = '1';
                                        st.dataset.len = '1';
                                    }
                                } else if (dx > 3) {
                                    // Any horizontal movement = length mode
                                    isLenMode = true;
                                    if (!wasActive) {
                                        st.classList.add('active');
                                        st.dataset.npc = '1';
                                        st.dataset.len = '1';
                                    }
                                }
                            }
                            
                            if (isVelMode) {
                                applyVel(ev.clientY);
                            } else if (isLenMode) {
                                const rect = lane.getBoundingClientRect();
                                const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
                                const idx = Math.max(startIdx, Math.min(stepsPerBar-1, Math.floor((x/rect.width)*stepsPerBar)));
                                applyLen(idx);
                                try { computeBassPatternFromGrid(); } catch(_){}
                                try { rebuildBassTieOverlays(lane); } catch(_){}
                            }
                        };
                        
                        const onUp = () => {
                            document.removeEventListener('mousemove', onMove);
                            document.removeEventListener('mouseup', onUp);
                            st.classList.remove('vel-dragging');
                            
                            // *** CLICK behavior for non-drag actions ***
                            if (!isDragging) {
                                if (wasActive) {
                                    // Click full cell = delete note
                                    st.classList.remove('active');
                                    st.dataset.npc = '';
                                    delete st.dataset.len;
                                    // Clear any ties
                                    steps.forEach((s, i) => {
                                        if (i > startIdx) delete s.dataset.tie;
                                    });
                                } else {
                                    // Click empty cell = 1 QUANT length note
                                    st.classList.add('active');
                                    st.dataset.npc = '1'; // Default NPC 1
                                    st.dataset.len = '1';
                                }
                            }
                            
                            try { computeBassPatternFromGrid(); } catch(_){}
                            try { rebuildBassTieOverlays(lane); } catch(_){}
                            isDragging = false;
                            dragStarted = false;
                            isVelMode = false;
                            isLenMode = false;
                        };
                        
                        document.addEventListener('mousemove', onMove);
                        document.addEventListener('mouseup', onUp);
                    });
                    // Touch drag support for bass pills in bass modal grid
                    st.addEventListener('touchstart', (e) => {
                        if (st._touchDragActive) return; // prevent duplicate synthetic mouse
                        st._touchDragActive = true;
                        try { e.preventDefault(); } catch(_) {}
                        const touch = e.touches && e.touches[0] ? e.touches[0] : null;
                        if (!touch) { st._touchDragActive = false; return; }
                        const activeId = touch.identifier;
                        const startIdx = sIdx;
                        const steps = Array.from(lane.querySelectorAll('.bass-step'));
                        const wasActive = st.classList.contains('active');

                        const startX = touch.clientX;
                        const startY = touch.clientY;
                        const startVel = parseInt(st.dataset.vel || '100', 10);

                        let isDragging = false;
                        let dragStarted = false;
                        let isVelMode = false;
                        let isLenMode = false;

                        const applyLen = (toIdx) => {
                            const len = Math.max(1, (toIdx|0) - startIdx + 1);
                            st.classList.add('active');
                            st.dataset.npc = st.dataset.npc || '1';
                            st.dataset.len = String(len);
                            for (let k=0;k<steps.length;k++){
                                if (k>startIdx && k<=startIdx+len-1) { steps[k].dataset.tie='1'; steps[k].classList.remove('active'); }
                                else if (k>startIdx) { delete steps[k].dataset.tie; }
                            }
                        };
                        const applyVel = (clientY) => {
                            const deltaY = startY - clientY; // Drag up = louder
                            const deltaVel = Math.round(deltaY / 1.5);
                            const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                            st.dataset.vel = String(newVel);
                            try { window.updateStepVelocityClass(st); } catch(_){ }
                        };
                        const onMove = (ev) => {
                            try { ev.preventDefault(); } catch(_) {}
                            if (!dragStarted) { dragStarted = true; }
                            const tlist = ev.touches || [];
                            let t=null; for (let j=0;j<tlist.length;j++){ if (tlist[j].identifier===activeId){ t=tlist[j]; break; } }
                            if (!t) return;

                            const dx = Math.abs(t.clientX - startX);
                            const dy = Math.abs(t.clientY - startY);

                            if (!isVelMode && !isLenMode) {
                                if (dy > dx * 2 && dy > 10) {
                                    isDragging = true;
                                    isVelMode = true;
                                    st.classList.add('vel-dragging');
                                    if (!wasActive) {
                                        st.classList.add('active');
                                        st.dataset.npc = '1';
                                        st.dataset.len = '1';
                                    }
                                } else if (dx > 3) {
                                    isDragging = true;
                                    isLenMode = true;
                                    if (!wasActive) {
                                        st.classList.add('active');
                                        st.dataset.npc = '1';
                                        st.dataset.len = '1';
                                    }
                                }
                            }

                            if (isVelMode) {
                                applyVel(t.clientY);
                            } else if (isLenMode) {
                                const rect = lane.getBoundingClientRect();
                                const x = Math.max(0, Math.min(rect.width, t.clientX - rect.left));
                                const idx = Math.max(startIdx, Math.min(stepsPerBar-1, Math.floor((x/rect.width)*stepsPerBar)));
                                applyLen(idx);
                                try { computeBassPatternFromGrid(); } catch(_){ }
                                try { rebuildBassTieOverlays(lane); } catch(_){ }
                            }
                        };
                        const onEnd = (ev) => {
                            const changed = ev.changedTouches || [];
                            let ended=false; for (let j=0;j<changed.length;j++){ if (changed[j].identifier===activeId){ ended=true; break; } }
                            if (!ended) return;
                            document.removeEventListener('touchmove', onMove, { passive: false });
                            document.removeEventListener('touchend', onEnd);
                            document.removeEventListener('touchcancel', onEnd);
                            try { st.classList.remove('vel-dragging'); } catch(_){ }

                            if (!isDragging) {
                                if (wasActive) {
                                    st.classList.remove('active');
                                    st.dataset.npc = '';
                                    delete st.dataset.len;
                                    steps.forEach((s, i) => { if (i>startIdx) delete s.dataset.tie; });
                                } else {
                                    st.classList.add('active');
                                    st.dataset.npc = '1';
                                    st.dataset.len = '1';
                                }
                            }
                            try { computeBassPatternFromGrid(); } catch(_){}
                            try { rebuildBassTieOverlays(lane); } catch(_){}
                            isDragging = false; dragStarted = false; isVelMode = false; isLenMode = false; st._touchDragActive = false;
                        };
                        document.addEventListener('touchmove', onMove, { passive: false });
                        document.addEventListener('touchend', onEnd);
                        document.addEventListener('touchcancel', onEnd);
                    }, { passive: false });
                    
                    // Default velocity and attach velocity drag
                    st.dataset.vel = '100';
                    try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(st); } catch(_) {}
                    try { if (window.attachVelocityDrag) window.attachVelocityDrag(st); } catch(_) {}
                    
                    lane.appendChild(st);
                }
                
                row.appendChild(lane);

                // Per-lane QUANT (N/D) control for bass lanes
                const params = document.createElement('div');
                params.className = 'drum-params';
                params.style.cssText = 'display:inline-flex;align-items:center;gap:6px;margin-left:8px;';
                const qWrap = document.createElement('label');
                qWrap.style.cssText = 'display:inline-flex;align-items:center;gap:4px;';
                const qSpan = document.createElement('span'); qSpan.textContent = 'Q:'; qSpan.title = `${labelName} Quant (N/D per-bar)`; qWrap.appendChild(qSpan);
                const qInput = document.createElement('input');
                qInput.type = 'number'; qInput.min='1'; qInput.max='64'; qInput.step='1'; qInput.placeholder = 'D'; qInput.style.cssText = 'width:56px;';
                qInput.value = lane.dataset.quant;
                qInput.addEventListener('focus', (e)=> e.target && e.target.select && e.target.select());
                qInput.addEventListener('change', ()=>{
                    const raw = String(qInput.value||'').trim();
                    let N = stepsPerBar, D = stepsPerBar, str = String(stepsPerBar);
                    const mf = raw.match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
                    if (mf){ const n=parseInt(mf[1],10), d=parseInt(mf[2],10); if (Number.isFinite(n)&&n>0&&Number.isFinite(d)&&d>0){ N=n; D=d; str=String(D); } }
                    else { const mn = raw.match(/^\s*(\d+)\s*$/); if (mn){ const d=parseInt(mn[1],10); if (Number.isFinite(d)&&d>0){ N=d; D=d; str=String(d); } } }
                    lane.dataset.quant = str;
                    lane.dataset.pendingQuant = str; // for future bar-boundary rebuilds
                    lane._quant = { str, N, D };
                    // Update CSS vars immediately for visual grid responsiveness
                    try {
                        const D = lane._quant.D || stepsPerBar;
                        // Rebuild laneâ€™s step elements to exactly D cells so the dots match the denominator
                        const current = Array.from(lane.querySelectorAll('.bass-step'));
                        const snapshot = current.map(s=>({ active:s.classList.contains('active'), npc:s.dataset.npc, len:s.dataset.len, tie:s.dataset.tie, vel:s.dataset.vel }));
                        current.forEach(el=> el.remove());
                        Array.from(lane.querySelectorAll('.beat-divider')).forEach(el=> el.remove());
                        lane.style.setProperty('--steps-per-bar', String(D));
                        const fullB = Math.max(0, Math.floor(D/4));
                        for (let b=1;b<fullB;b++){ const div=document.createElement('div'); div.className='beat-divider'; div.style.left=`${(b/fullB)*100}%`; lane.appendChild(div); }
                        for (let i=0;i<D;i++){
                            const st = document.createElement('div');
                            st.className='drum-step pattern-step bass-step'+((i%4===0)?' beat-accent':'');
                            st.dataset.step=String(i); st.dataset.npc='';
                            st.title = `${labelName||'BASS'} â€¢ Step ${i+1}`;
                            const prev=snapshot[i];
                            if (prev){ if (prev.npc && prev.npc.toLowerCase()!=='x'){ st.classList.add('active'); st.dataset.npc=prev.npc; if (prev.len) st.dataset.len=prev.len; if (prev.tie) st.dataset.tie=prev.tie; } }
                            // Preserve per-step velocity across Q rebuilds
                            st.dataset.vel = (prev && prev.vel != null) ? String(prev.vel) : '100';
                            try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(st); } catch(_){ }
                            try { if (window.attachVelocityDrag) window.attachVelocityDrag(st); } catch(_){ }
                            // Attach pill handlers (mousedown/touchstart) and click toggle like initial build
                            st.addEventListener('mousedown', (e) => {
                                if (e.button !== 0) return;
                                e.preventDefault();
                                const startIdx = i;
                                const steps = Array.from(lane.querySelectorAll('.bass-step'));
                                const wasActive = st.classList.contains('active');
                                const startX = e.clientX;
                                const startY = e.clientY;
                                const startVel = parseInt(st.dataset.vel || '100', 10);
                                let isDragging = false; let dragStarted = false;
                                let isVelMode = false; let isLenMode = false;
                                const applyLen = (toIdx) => {
                                    const len = Math.max(1, (toIdx|0) - startIdx + 1);
                                    st.classList.add('active');
                                    st.dataset.npc = st.dataset.npc || '1';
                                    st.dataset.len = String(len);
                                    for (let k=0;k<steps.length;k++){
                                        if (k>startIdx && k<=startIdx+len-1) { steps[k].dataset.tie='1'; steps[k].classList.remove('active'); }
                                        else if (k>startIdx) { delete steps[k].dataset.tie; }
                                    }
                                };
                                const applyVel = (clientY) => {
                                    const deltaY = startY - clientY; // Drag up = louder
                                    const deltaVel = Math.round(deltaY / 1.5);
                                    const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                                    st.dataset.vel = String(newVel);
                                    try { window.updateStepVelocityClass(st); } catch(_){ }
                                };
                                const onMove = (ev) => {
                                    if (!dragStarted) { dragStarted = true; }

                                    const dx = Math.abs(ev.clientX - startX);
                                    const dy = Math.abs(ev.clientY - startY);

                                    if (!isVelMode && !isLenMode) {
                                        if (dy > dx * 2 && dy > 10) {
                                            isDragging = true;
                                            isVelMode = true;
                                            st.classList.add('vel-dragging');
                                            if (!wasActive) {
                                                st.classList.add('active');
                                                st.dataset.npc = '1';
                                                st.dataset.len = '1';
                                            }
                                        } else if (dx > 3) {
                                            isDragging = true;
                                            isLenMode = true;
                                            if (!wasActive) {
                                                st.classList.add('active');
                                                st.dataset.npc = '1';
                                                st.dataset.len = '1';
                                            }
                                        }
                                    }

                                    if (isVelMode) {
                                        applyVel(ev.clientY);
                                    } else if (isLenMode) {
                                        const rect = lane.getBoundingClientRect();
                                        const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
                                        const idx = Math.max(startIdx, Math.min(D-1, Math.floor((x/rect.width)*D)));
                                        applyLen(idx);
                                        try { computeBassPatternFromGrid(); } catch(_){ }
                                        try { rebuildBassTieOverlays(lane); } catch(_){ }
                                    }
                                };
                                const onUp = () => {
                                    document.removeEventListener('mousemove', onMove);
                                    document.removeEventListener('mouseup', onUp);
                                    try { st.classList.remove('vel-dragging'); } catch(_){ }
                                    if (!isDragging) {
                                        if (wasActive) {
                                            st.classList.remove('active'); st.dataset.npc=''; delete st.dataset.len;
                                            steps.forEach((s,ii)=>{ if (ii>startIdx) delete s.dataset.tie; });
                                        } else {
                                            st.classList.add('active'); st.dataset.npc='1'; st.dataset.len='1';
                                        }
                                    }
                                    try { computeBassPatternFromGrid(); } catch(_){}
                                    try { rebuildBassTieOverlays(lane); } catch(_){}
                                    isDragging=false; dragStarted=false; isVelMode=false; isLenMode=false;
                                };
                                document.addEventListener('mousemove', onMove);
                                document.addEventListener('mouseup', onUp);
                            });
                            st.addEventListener('touchstart', (e) => {
                                if (st._touchDragActive) return; st._touchDragActive=true; try { e.preventDefault(); } catch(_){ }
                                const touch = e.touches && e.touches[0] ? e.touches[0] : null; if (!touch){ st._touchDragActive=false; return; }
                                const activeId = touch.identifier;
                                const startIdx = i;
                                const steps = Array.from(lane.querySelectorAll('.bass-step'));
                                const wasActive = st.classList.contains('active');
                                const startX = touch.clientX;
                                const startY = touch.clientY;
                                const startVel = parseInt(st.dataset.vel || '100', 10);
                                let isDragging=false; let dragStarted=false;
                                let isVelMode=false; let isLenMode=false;
                                const applyLen = (toIdx)=>{
                                    const len = Math.max(1, (toIdx|0) - startIdx + 1);
                                    st.classList.add('active'); st.dataset.npc = st.dataset.npc || '1'; st.dataset.len = String(len);
                                    for (let k=0;k<steps.length;k++){ if (k>startIdx && k<=startIdx+len-1) { steps[k].dataset.tie='1'; steps[k].classList.remove('active'); } else if (k>startIdx) { delete steps[k].dataset.tie; } }
                                };
                                const applyVel = (clientY)=>{
                                    const deltaY = startY - clientY;
                                    const deltaVel = Math.round(deltaY / 1.5);
                                    const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                                    st.dataset.vel = String(newVel);
                                    try { window.updateStepVelocityClass(st); } catch(_){ }
                                };
                                const onMove = (ev)=>{
                                    try { ev.preventDefault(); } catch(_){}
                                    if (!dragStarted){ dragStarted=true; }
                                    const tlist = ev.touches||[]; let t=null; for (let j=0;j<tlist.length;j++){ if (tlist[j].identifier===activeId){ t=tlist[j]; break; } }
                                    if (!t) return;
                                    const dx = Math.abs(t.clientX - startX);
                                    const dy = Math.abs(t.clientY - startY);

                                    if (!isVelMode && !isLenMode) {
                                        if (dy > dx * 2 && dy > 10) {
                                            isDragging = true;
                                            isVelMode = true;
                                            st.classList.add('vel-dragging');
                                            if (!wasActive) {
                                                st.classList.add('active');
                                                st.dataset.npc = '1';
                                                st.dataset.len = '1';
                                            }
                                        } else if (dx > 3) {
                                            isDragging = true;
                                            isLenMode = true;
                                            if (!wasActive) {
                                                st.classList.add('active');
                                                st.dataset.npc = '1';
                                                st.dataset.len = '1';
                                            }
                                        }
                                    }

                                    if (isVelMode) {
                                        applyVel(t.clientY);
                                    } else if (isLenMode) {
                                        const rect = lane.getBoundingClientRect();
                                        const x = Math.max(0, Math.min(rect.width, t.clientX - rect.left));
                                        const idx = Math.max(startIdx, Math.min(D-1, Math.floor((x/rect.width)*D)));
                                        applyLen(idx);
                                        try { computeBassPatternFromGrid(); } catch(_){}
                                        try { rebuildBassTieOverlays(lane); } catch(_){}
                                    }
                                };
                                const onEnd = (ev)=>{
                                    const changed = ev.changedTouches||[]; let ended=false; for (let j=0;j<changed.length;j++){ if (changed[j].identifier===activeId){ ended=true; break; } }
                                    if (!ended) return; document.removeEventListener('touchmove', onMove, { passive:false }); document.removeEventListener('touchend', onEnd); document.removeEventListener('touchcancel', onEnd);
                                    try { st.classList.remove('vel-dragging'); } catch(_){ }
                                    st._touchDragActive=false;
                                    if (!isDragging){
                                        if (wasActive) {
                                            st.classList.remove('active'); st.dataset.npc=''; delete st.dataset.len;
                                            steps.forEach((s,ii)=>{ if (ii>startIdx) delete s.dataset.tie; });
                                        } else {
                                            st.classList.add('active'); st.dataset.npc='1'; st.dataset.len='1';
                                        }
                                    }
                                    try { computeBassPatternFromGrid(); } catch(_){}
                                    try { rebuildBassTieOverlays(lane); } catch(_){}
                                    isDragging=false; dragStarted=false; isVelMode=false; isLenMode=false;
                                };
                                document.addEventListener('touchmove', onMove, { passive:false });
                                document.addEventListener('touchend', onEnd);
                                document.addEventListener('touchcancel', onEnd);
                            }, { passive:false });
                            lane.appendChild(st);
                        }
                        // Rebuild tie overlay for this lane
                        try { rebuildBassTieOverlays(lane); } catch(_){}
                        const container = lane.closest('.drum-grid-container');
                        if (container) {
                            const lanes = Array.from(container.querySelectorAll('.bass-lane, .pattern-lane, .drum-lane'));
                            const maxD = lanes.reduce((mx,ln)=>{
                                    const qs = ln.dataset.quant||''; let d = stepsPerBar;
                                    const mm=qs.match(/^(\d+)\/(\d+)$/);
                                    if (mm){ const dd=parseInt(mm[2],10); if(Number.isFinite(dd)&&dd>0) d=dd; }
                                    else { const mn=qs.match(/^(\d+)$/); if (mn){ const dd=parseInt(mn[1],10); if(Number.isFinite(dd)&&dd>0) d=dd; } }
                                    return Math.max(mx, d);
                                }, stepsPerBar);
                            container.style.setProperty('--bar-steps', String(maxD));
                        }
                        // Force resampling next bar
                        try { const bg = document.getElementById('bassGrid'); if (bg) { delete bg._tokensTarget; delete bg._Dtarget; } } catch(_) {}
                        try { window._autoSizePatternModals && window._autoSizePatternModals(); } catch(_) {}
                    } catch(_){ }
                    try { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums:true, grid:true }); } catch(_){ }
                });
                qWrap.appendChild(qInput);
                params.appendChild(qWrap);
                row.appendChild(params);
                
                // Add bass tie layer for visual pills
                const tieLayer = document.createElement('div');
                tieLayer.className = 'bass-tie-layer';
                lane.appendChild(tieLayer);
                
                bassGrid.appendChild(row);
            });
            
            console.log('âœ… Bass pattern grid (9 rows) generated successfully');
            
            // Initialize tie overlays for all lanes
            const allLanes = Array.from(bassGrid.querySelectorAll('.bass-lane'));
            allLanes.forEach(lane => {
                try { rebuildBassTieOverlays(lane); } catch(_){}
            });
        };
        
        // *** Bass pattern computation from 9-row grid (single notes only, no chords) ***
        window.computeBassPatternFromGrid = function() {
            try {
                const bassGrid = document.getElementById('bassGrid');
                if (!bassGrid) return;
                
                const lanes = Array.from(bassGrid.querySelectorAll('.bass-lane'));
                if (lanes.length < 9) return;
                
                const npcLanes = lanes.slice(0,9);
                const steps = Array.from(npcLanes[0].querySelectorAll('.bass-step'));
                const maxVisible = Math.max(1, Math.min(steps.length, parseInt(bassGrid.dataset.length||String(steps.length),10)||steps.length));
                const tokens = [];
                
                for (let i=0;i<maxVisible;i++){
                    let foundNote = null;
                    let isTie = false;
                    
                    // Check all lanes for this step
                    for (let idx=0; idx<npcLanes.length; idx++){
                        const cell = npcLanes[idx].querySelector(`.bass-step[data-step="${i}"]`);
                        if (cell) {
                            if (cell.classList.contains('active')) {
                                // Found active note head
                                const npc = 9-idx; // Convert row to NPC (row 0 = NPC 9, row 8 = NPC 1)
                                foundNote = npc;
                                break; // Only one note allowed at a time
                            } else if (cell.dataset.tie === '1') {
                                // Found tie (sustained note)
                                isTie = true;
                                // Don't break - keep looking for the actual note head in other lanes
                            }
                        }
                    }
                    
                    if (foundNote !== null) {
                        tokens.push(String(foundNote)); // Single note: 1, 2, 3, etc.
                    } else if (isTie) {
                        tokens.push('-'); // Sustained note: -
                    } else {
                        tokens.push('x'); // Rest: x
                    }
                }
                
                // Store computed bass pattern
                bassGrid._computedPattern = tokens.join(' ');
                console.log('ðŸŽ¸ Bass pattern computed:', bassGrid._computedPattern);
            } catch(_) {
                console.error('Error computing bass pattern:', _);
            }
        };
        
        // *** Velocity helper: update step velocity color class based on velocity value ***
        window.updateStepVelocityClass = function(step) {
            if (!step) return;
            const vel = parseInt(step.dataset.vel || '100', 10);
            step.classList.remove('vel-quiet', 'vel-low', 'vel-mid', 'vel-high');
            if (vel < 32) {
                step.classList.add('vel-quiet'); // Blue/cyan (quiet)
            } else if (vel < 64) {
                step.classList.add('vel-low'); // Teal/green
            } else if (vel < 96) {
                step.classList.add('vel-mid'); // Yellow/orange
            } else {
                step.classList.add('vel-high'); // Red (loud)
            }
        };

        // Helper: derive a step velocity (0-127) from dataset or color class.
        // Returns null if it cannot infer.
        window.getStepVelocity = function(step) {
            try {
                if (!step) return null;
                const raw = parseInt(step.dataset?.vel ?? '', 10);
                if (Number.isFinite(raw)) return Math.max(0, Math.min(127, raw));
                // Fallback: infer from color class if dataset.vel is missing
                if (step.classList?.contains('vel-quiet')) return 16;
                if (step.classList?.contains('vel-low')) return 48;
                if (step.classList?.contains('vel-mid')) return 80;
                if (step.classList?.contains('vel-high')) return 112;
                return null;
            } catch(_) { return null; }
        };
        
        // *** Velocity drag attachment: adds vertical drag to change velocity on a step ***
        // Horizontal drag = length/pill, Vertical drag = velocity (immediate, no hold required)
        window.attachVelocityDrag = function(step, options = {}) {
            const sensitivity = options.sensitivity || 1.5; // pixels per velocity unit
            
            // Velocity drag state - managed per-step to avoid conflicts
            step._velDragState = { active: false, startY: 0, startVel: 100 };
            
            const startVelDrag = (clientY) => {
                step._velDragState.active = true;
                step._velDragState.startY = clientY;
                step._velDragState.startVel = parseInt(step.dataset.vel || '100', 10);
                step.classList.add('vel-dragging');
            };
            
            const updateVelocity = (clientY) => {
                if (!step._velDragState.active) return;
                const deltaY = step._velDragState.startY - clientY; // Drag up = positive = louder
                const deltaVel = Math.round(deltaY / sensitivity);
                const newVel = Math.max(0, Math.min(127, step._velDragState.startVel + deltaVel));
                step.dataset.vel = String(newVel);
                window.updateStepVelocityClass(step);
            };
            
            const endVelDrag = () => {
                step._velDragState.active = false;
                step.classList.remove('vel-dragging');
            };
            
            // Expose for external use by grid handlers
            step._startVelDrag = startVelDrag;
            step._updateVelocity = updateVelocity;
            step._endVelDrag = endVelDrag;
        };

        // Global helper: STOP/START hooks for all Pattern transports (legacy + spawned instances)
        // Used by the main transport STOP so patterns never keep running after STOP.
        window.__xenStopAllPatterns = function(resetPhase = true){
            try {
                const pt0 = window._patternTransport;
                if (pt0 && typeof pt0.stop === 'function') pt0.stop(!!resetPhase);
                else if (pt0) { pt0.running = false; pt0.tickCounter = 0; pt0.absTickCounter = 0; pt0.stopVoices && pt0.stopVoices(); }
            } catch(_){ }
            try {
                const instances = window._patternInstances || [];
                instances.forEach(info=>{
                    const m = info && info.modal;
                    const pt = m && m._patternTransport;
                    if (!pt) return;
                    try {
                        if (typeof pt.stop === 'function') pt.stop(!!resetPhase);
                        else { pt.running = false; pt.tickCounter = 0; pt.absTickCounter = 0; }
                    } catch(_){ }
                    try { pt.running = false; pt.stopVoices && pt.stopVoices(); } catch(_){ }
                });
            } catch(_){ }
        };
        
        // *** Visual pill rendering for bass sustained notes ***
        window.rebuildBassTieOverlays = function(lane) {
            try {
                if (!lane) return;
                
                // Find or create tie layer
                let tieLayer = lane.querySelector('.bass-tie-layer');
                if (!tieLayer) {
                    tieLayer = document.createElement('div');
                    tieLayer.className = 'bass-tie-layer';
                    lane.appendChild(tieLayer);
                }
                
                // Clear existing pills
                tieLayer.innerHTML = '';
                
                const steps = Array.from(lane.querySelectorAll('.bass-step'));
                const stepsPerBar = steps.length;
                
                // Find all sustained note sequences
                for (let i = 0; i < steps.length; i++) {
                    const step = steps[i];
                    if (step.classList.contains('active') && step.dataset.len) {
                        const len = parseInt(step.dataset.len || '1', 10);
                        if (len > 1) {
                            // Create visual pill for sustained note
                            const pill = document.createElement('div');
                            pill.className = 'bass-tie-pill';
                            
                            // Calculate pill position and width
                            const startPercent = (i / stepsPerBar) * 100;
                            const widthPercent = (len / stepsPerBar) * 100;
                            
                            pill.style.left = `${startPercent}%`;
                            pill.style.width = `${widthPercent}%`;
                            
                            tieLayer.appendChild(pill);
                        }
                    }
                }
            } catch(e) {
                console.error('Error rebuilding bass tie overlays:', e);
            }
        };
        
        
        // Make modals draggable by header
        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const header = element.querySelector('.modal-header');
            if (!header) {
                console.log('No modal header found for dragging');
                return;
            }
            
            header.style.cursor = 'move';
            header.style.touchAction = 'none'; // Prevent default touch behaviors
            header.onmousedown = dragMouseDown;
            
            // Use addEventListener for touch to ensure it's not passive
            header.addEventListener('touchstart', dragTouchStart, { passive: false });
            
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                header.style.cursor = 'grabbing';
                document.body.style.cursor = 'grabbing';
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function dragTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                pos3 = touch.clientX;
                pos4 = touch.clientY;
                header.style.cursor = 'grabbing';
                document.body.style.cursor = 'grabbing';
                document.addEventListener('touchend', closeDragElement, { passive: false });
                document.addEventListener('touchmove', elementDragTouch, { passive: false });
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                const vv = window.visualViewport;
                const safeTop = Math.max(8, (vv ? vv.offsetTop : 0) + 8);
                const maxLeft = Math.max(0, window.innerWidth - element.offsetWidth);
                const maxTop = Math.max(safeTop, (vv ? vv.height : window.innerHeight) - element.offsetHeight);
                const nextLeft = Math.max(0, Math.min(maxLeft, element.offsetLeft - pos1));
                const nextTop = Math.max(safeTop, Math.min(maxTop, element.offsetTop - pos2));
                element.style.top = nextTop + "px";
                element.style.left = nextLeft + "px";
            }
            
            function elementDragTouch(e) {
                e.preventDefault();
                const touch = e.touches[0];
                pos1 = pos3 - touch.clientX;
                pos2 = pos4 - touch.clientY;
                pos3 = touch.clientX;
                pos4 = touch.clientY;
                const vv = window.visualViewport;
                const safeTop = Math.max(8, (vv ? vv.offsetTop : 0) + 8);
                const maxLeft = Math.max(0, window.innerWidth - element.offsetWidth);
                const maxTop = Math.max(safeTop, (vv ? vv.height : window.innerHeight) - element.offsetHeight);
                const nextLeft = Math.max(0, Math.min(maxLeft, element.offsetLeft - pos1));
                const nextTop = Math.max(safeTop, Math.min(maxTop, element.offsetTop - pos2));
                element.style.top = nextTop + "px";
                element.style.left = nextLeft + "px";
            }
            
            function closeDragElement() {
                header.style.cursor = 'move';
                document.body.style.cursor = 'default';
                document.onmouseup = null;
                document.onmousemove = null;
                document.removeEventListener('touchend', closeDragElement);
                document.removeEventListener('touchmove', elementDragTouch);
            }
        }

        // Ensure modals (DRUMS, PATTERN, BASS) can grow to fit content when opened (but allow manual shrinking)
        // Strategy: measure the widest row/header scrollWidth inside each modal and increase width if needed
        window._autoSizePatternModals = function(maxBarSteps){
            try {
                const rs = getComputedStyle(document.documentElement);
                const stepVar = rs.getPropertyValue('--step-size').trim();
                const stepSize = (Number.isFinite(parseFloat(stepVar)) && parseFloat(stepVar) > 0) ? parseFloat(stepVar) : 22;
                const barSteps = Math.max(1, parseInt(maxBarSteps||'16',10) || 16);
                const requiredLaneWidth = barSteps * stepSize; // matches lane width calc

                const measureRequired = (modal) => {
                    // Prefer a non-bass row for measuring controls; fallback to any .drum-row
                    const rows = modal.querySelectorAll('.drum-row');
                    if (!rows || rows.length === 0) return 0;
                    let maxRow = 0;
                    rows.forEach(row => {
                        // Ensure the lane reflects the current barSteps width when measuring
                        const lane = row.querySelector('.drum-lane');
                        if (lane) {
                            lane.style.setProperty('--bar-steps', String(barSteps));
                        }
                        // Use scrollWidth to include overflowed controls
                        maxRow = Math.max(maxRow, row.scrollWidth);
                    });
                    const header = modal.querySelector('.drum-grid-header');
                    const headerWidth = header ? header.scrollWidth : 0;
                    // Safety margin for borders/scrollbar
                    const margin = 24;
                    // Also guarantee at least lane width + fixed controls to the right if 1fr collapsed
                    // Estimate: take the first row's non-lane fixed columns width by subtracting lane clientWidth
                    let fixedRight = 0;
                    const sampleRow = rows[0];
                    const sampleLane = sampleRow ? sampleRow.querySelector('.drum-lane') : null;
                    if (sampleRow && sampleLane) {
                        const rowClient = sampleRow.getBoundingClientRect().width;
                        const laneClient = sampleLane.getBoundingClientRect().width;
                        // If lane is smaller than requiredLaneWidth, add the delta
                        const laneDelta = Math.max(0, requiredLaneWidth - laneClient);
                        fixedRight = Math.max(0, rowClient - laneClient) + laneDelta;
                    }
                    // Compute final requirement
                    const contentNeed = Math.max(maxRow, headerWidth, requiredLaneWidth + fixedRight) + margin;
                    // Clamp to viewport so it never exceeds 96vw visually
                    const vw = Math.max(320, Math.floor(window.innerWidth * 0.96));
                    return Math.min(contentNeed, vw);
                };

                const apply = (modalId) => {
                    const modal = document.getElementById(modalId);
                    if (!modal) return;
                    const container = modal.querySelector('.drum-grid-container');
                    if (!container) return;
                    const need = measureRequired(modal);
                    if (!Number.isFinite(need) || need <= 0) return;
                    const cur = modal.getBoundingClientRect();
                    // Grow width if current modal is smaller than content; do not enforce minWidth to allow manual shrinking
                    if (cur.width < need) {
                        const nextW = Math.ceil(need);
                        modal.style.width = nextW + 'px';
                        if (modal._aspectRatio) {
                            modal.style.height = Math.ceil(nextW / modal._aspectRatio) + 'px';
                        }
                    }
                    // Ensure container spans full width; avoid clipping
                    container.style.maxWidth = 'none';
                    container.style.overflowX = 'auto';
                };

                apply('drumModal');
                apply('patternModal');
                apply('bassModal');
            } catch(_) {}
        };

        // Make transport modal draggable by any non-interactive area
        function makeTransportDraggable() {
            const el = document.getElementById('transportModal');
            if (!el || el._dragWired) return;
            el._dragWired = true;
            el.style.touchAction = 'none';

            let dragging = false;
            let startX = 0, startY = 0;
            let origLeft = 0, origTop = 0;

            const isInteractive = (target) => {
                return !!(target.closest('button, input, select, textarea, label, a, [role="button"], .mix-btn, .osc-btn, .mode-btn, .panel-btn, .sidebar-btn, .modal-close'));
            };

            const onMouseDown = (e) => {
                if (isInteractive(e.target)) return;
                e.preventDefault();
                const rect = el.getBoundingClientRect();
                // Convert from right-anchored to left on first drag
                if (!el._convertedToLeft) {
                    el.style.left = rect.left + 'px';
                    el.style.top = rect.top + 'px';
                    el.style.right = 'auto';
                    el._convertedToLeft = true;
                }
                dragging = true;
                startX = e.clientX;
                startY = e.clientY;
                origLeft = parseInt(el.style.left || rect.left + 'px');
                origTop = parseInt(el.style.top || rect.top + 'px');
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                document.body.style.cursor = 'grabbing';
            };

            const onMouseMove = (e) => {
                if (!dragging) return;
                e.preventDefault();
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                let nextLeft = origLeft + dx;
                let nextTop = origTop + dy;
                // Clamp to viewport
                const rect = el.getBoundingClientRect();
                const w = rect.width, h = rect.height;
                const vv = window.visualViewport;
                const safeTop = Math.max(8, (vv ? vv.offsetTop : 0) + 8);
                nextLeft = Math.max(0, Math.min(window.innerWidth - w, nextLeft));
                nextTop = Math.max(safeTop, Math.min((vv ? vv.height : window.innerHeight) - h, nextTop));
                el.style.left = nextLeft + 'px';
                el.style.top = nextTop + 'px';
            };

            const onMouseUp = () => {
                dragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                document.body.style.cursor = 'default';
            };

            const onTouchStart = (e) => {
                if (isInteractive(e.target)) return;
                const t = e.touches && e.touches[0];
                if (!t) return;
                e.preventDefault();
                const rect = el.getBoundingClientRect();
                if (!el._convertedToLeft) {
                    el.style.left = rect.left + 'px';
                    el.style.top = rect.top + 'px';
                    el.style.right = 'auto';
                    el._convertedToLeft = true;
                }
                dragging = true;
                startX = t.clientX;
                startY = t.clientY;
                origLeft = parseInt(el.style.left || rect.left + 'px');
                origTop = parseInt(el.style.top || rect.top + 'px');
                document.addEventListener('touchmove', onTouchMove, { passive: false });
                document.addEventListener('touchend', onTouchEnd, { passive: false });
                document.body.style.cursor = 'grabbing';
            };

            const onTouchMove = (e) => {
                if (!dragging) return;
                const t = e.touches && e.touches[0];
                if (!t) return;
                e.preventDefault();
                const dx = t.clientX - startX;
                const dy = t.clientY - startY;
                let nextLeft = origLeft + dx;
                let nextTop = origTop + dy;
                const rect = el.getBoundingClientRect();
                const w = rect.width, h = rect.height;
                const vv = window.visualViewport;
                const safeTop = Math.max(8, (vv ? vv.offsetTop : 0) + 8);
                nextLeft = Math.max(0, Math.min(window.innerWidth - w, nextLeft));
                nextTop = Math.max(safeTop, Math.min((vv ? vv.height : window.innerHeight) - h, nextTop));
                el.style.left = nextLeft + 'px';
                el.style.top = nextTop + 'px';
            };

            const onTouchEnd = () => {
                dragging = false;
                document.removeEventListener('touchmove', onTouchMove);
                document.removeEventListener('touchend', onTouchEnd);
                document.body.style.cursor = 'default';
            };

            el.addEventListener('mousedown', onMouseDown);
            el.addEventListener('touchstart', onTouchStart, { passive: false });
        }
        
        // Make bracket markers and chord columns draggable for section rearrangement
        function makeBracketDraggable(marker) {
            if (marker._draggableWired) return; // Prevent duplicate wiring
            marker._draggableWired = true;
            
            marker.draggable = true;
            marker.style.cursor = 'grab';
            marker.style.touchAction = 'none'; // Enable touch handling
            
            // Ensure the marker has the correct class for drop detection
            if (marker.classList.contains('extension-column')) {
                // Chord columns keep their class but also become draggable
            } else if (!marker.classList.contains('repeat-marker-column')) {
                marker.classList.add('repeat-marker-column');
            }
            
            // Touch drag state
            let touchDragData = null;
            
            // Mouse drag events
            marker.addEventListener('dragstart', (e) => {
                marker.style.cursor = 'grabbing';
                e.dataTransfer.setData('text/plain', marker.textContent);
                e.dataTransfer.effectAllowed = 'move';
                marker.classList.add('dragging');
                console.log('ðŸŽµ Started dragging element:', marker.textContent || marker.className);
            });
            
            marker.addEventListener('dragend', (e) => {
                marker.style.cursor = 'grab';
                marker.classList.remove('dragging');
                document.querySelectorAll('.drop-target').forEach(el => {
                    el.classList.remove('drop-target');
                });
                console.log('ðŸŽµ Finished dragging element:', marker.textContent || marker.className);
            });
            
            // Touch drag events
            marker.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                marker.style.cursor = 'grabbing';
                marker.classList.add('dragging');
                
                touchDragData = {
                    element: marker,
                    startX: touch.clientX,
                    startY: touch.clientY,
                    offsetX: touch.clientX - marker.getBoundingClientRect().left,
                    offsetY: touch.clientY - marker.getBoundingClientRect().top
                };
                
                console.log('ðŸŽµ Touch started dragging element:', marker.textContent || marker.className);
            });
            
            marker.addEventListener('touchmove', (e) => {
                if (!touchDragData) return;
                e.preventDefault();
                
                const touch = e.touches[0];
                const container = document.getElementById('extensionColumns');
                if (!container) return;
                
                // Find what element we're hovering over
                const elementAtPoint = document.elementFromPoint(touch.clientX, touch.clientY);
                const target = elementAtPoint?.closest('.extension-column, .repeat-marker-column');
                
                // Clear existing drop targets
                document.querySelectorAll('.drop-target').forEach(el => {
                    el.classList.remove('drop-target');
                });
                
                // Highlight drop target
                if (target && target !== marker) {
                    target.classList.add('drop-target');
                }
            });
            
            marker.addEventListener('touchend', (e) => {
                if (!touchDragData) return;
                e.preventDefault();
                
                const touch = e.changedTouches[0];
                const container = document.getElementById('extensionColumns');
                if (!container) return;
                
                // Find drop target
                const elementAtPoint = document.elementFromPoint(touch.clientX, touch.clientY);
                const target = elementAtPoint?.closest('.extension-column, .repeat-marker-column');
                
                if (target && target !== marker) {
                    // Insert before the target element
                    container.insertBefore(marker, target);
                    console.log('ðŸŽµ Touch dropped element before:', target.textContent || target.querySelector('.extension-header')?.textContent);
                }
                
                // Cleanup
                marker.style.cursor = 'grab';
                marker.classList.remove('dragging');
                document.querySelectorAll('.drop-target').forEach(el => {
                    el.classList.remove('drop-target');
                });
                touchDragData = null;
                
                // Update the data model
                window.omnichord?._updateBracketPositions?.();
                // Rebuild the sequencer plan next cycle if currently playing
                try { window.requestSequencerRebuild && window.requestSequencerRebuild('touch-drop'); } catch(_){ }
            });
        }
        
        // Make chord columns accept bracket drops (using event delegation for dynamic elements)
        function makeChordColumnsDroppable() {
            const container = document.getElementById('extensionColumns');
            if (!container) return;
            
            // Remove any existing listeners to prevent duplicates
            if (container._dropListenersAdded) return;
            container._dropListenersAdded = true;
            
            // Use event delegation to handle all current and future chord columns
            container.addEventListener('dragover', (e) => {
                const dragging = document.querySelector('.dragging');
                const isCalcPreview = dragging && dragging.classList.contains('calc-preview-column');
                if (dragging && (dragging.classList.contains('repeat-marker-column') || dragging.classList.contains('extension-column') || isCalcPreview)) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = isCalcPreview ? 'copy' : 'move';
                    
                    // Clear existing drop targets
                    document.querySelectorAll('.drop-target').forEach(el => {
                        el.classList.remove('drop-target');
                    });
                    
                    // Add drop target to any column type if hovering over them
                    const target = e.target.closest('.extension-column, .repeat-marker-column');
                    if (target && target !== dragging) {
                        target.classList.add('drop-target');
                    }
                    
                    // Also allow dropping on the container itself for end-position drops
                    container.style.backgroundColor = 'rgba(46,204,113,0.05)';
                }
            });
            
            container.addEventListener('dragleave', (e) => {
                const target = e.target.closest('.extension-column');
                if (target && !container.contains(e.relatedTarget)) {
                    target.classList.remove('drop-target');
                }
                
                // Clear container drop styling when leaving the container
                if (e.target === container && !container.contains(e.relatedTarget)) {
                    container.style.backgroundColor = '';
                }
            });
            
            container.addEventListener('drop', (e) => {
                e.preventDefault();
                const dragging = document.querySelector('.dragging');
                if (dragging && (dragging.classList.contains('repeat-marker-column') || dragging.classList.contains('extension-column'))) {
                    const target = e.target.closest('.extension-column, .repeat-marker-column');
                    
                    if (target && target !== dragging) {
                        // Insert before the target element
                        container.insertBefore(dragging, target);
                        console.log('ðŸŽµ Dropped element before:', target.textContent || target.querySelector('.extension-header')?.textContent);
                        target.classList.remove('drop-target');
                    } else {
                        // Enhanced drop-anywhere logic for container
                        const rect = container.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        
                        // Find all draggable elements (chords and brackets)
                        const allElements = Array.from(container.children).filter(el => 
                            (el.classList.contains('extension-column') || el.classList.contains('repeat-marker-column')) && el !== dragging
                        );
                        
                        if (allElements.length === 0) {
                            // Empty container, just append
                            container.appendChild(dragging);
                            console.log('ðŸŽµ Dropped in empty container');
                        } else {
                            // Find insertion point based on mouse position
                            let insertBefore = null;
                            let minDistance = Infinity;
                            
                            for (const el of allElements) {
                                const elRect = el.getBoundingClientRect();
                                const elCenterX = elRect.left + elRect.width / 2 - rect.left;
                                const distance = Math.abs(x - elCenterX);
                                
                                if (x < elCenterX && distance < minDistance) {
                                    minDistance = distance;
                                    insertBefore = el;
                                }
                            }
                            
                            if (insertBefore) {
                                container.insertBefore(dragging, insertBefore);
                                console.log('ðŸŽµ Dropped before closest element');
                            } else {
                                // Drop at the end
                                container.appendChild(dragging);
                                console.log('ðŸŽµ Dropped at end');
                            }
                        }
                    }
                    
                    // Clear all drop targets and container styling
                    document.querySelectorAll('.drop-target').forEach(el => {
                        el.classList.remove('drop-target');
                    });
                    container.style.backgroundColor = '';
                    
                    // Update the data model to reflect the change
                    window.omnichord?._updateBracketPositions?.();
                    // Rebuild the sequencer plan next cycle if currently playing
                    try { window.requestSequencerRebuild && window.requestSequencerRebuild('drop'); } catch(_){ }
                }
            });
        }

        // When chord/bracket columns are added/removed/reordered during playback,
        // request a plan rebuild that will be applied at the next cycle boundary.
        // (BEAT 1 is king: we do NOT re-plan mid-cycle.)
        (function(){
            if (window.requestSequencerRebuild) return;
            window.requestSequencerRebuild = function(why){
                try {
                    const omni = window.omnichord;
                    const t = omni && omni._arpTransport;
                    if (omni && t && omni._isSequencing) {
                        t._seqRebuildRequested = true;
                        if (why) t._seqRebuildWhy = why;
                    }
                } catch(_){ }
            };
        })();

        (function(){
            const bind = () => {
                const container = document.getElementById('extensionColumns');
                if (!container) return false;
                if (container._xenSeqObserverAttached) return true;
                container._xenSeqObserverAttached = true;
                try {
                    const obs = new MutationObserver((mutations) => {
                        // Only childList changes matter; ignore class/active toggles.
                        for (const m of mutations) {
                            if (m && m.type === 'childList') {
                                try { window.requestSequencerRebuild && window.requestSequencerRebuild('dom-childList'); } catch(_){ }
                                break;
                            }
                        }
                    });
                    // Use subtree:true because columns can be moved within row wrappers.
                    obs.observe(container, { childList: true, subtree: true });
                    window.__xenSeqDomObserver = obs;
                } catch(_){ }
                return true;
            };
            if (!bind()) {
                document.addEventListener('DOMContentLoaded', bind, { once: true });
            }
        })();
        
        // Chord section resize functionality
        function _getXenonFooterHeightPx() {
            try {
                const footer = document.getElementById('brandFooter');
                if (!footer) return 28;
                const h = footer.getBoundingClientRect().height;
                return (Number.isFinite(h) && h > 0) ? h : 28;
            } catch (_) {
                return 28;
            }
        }

        function _getChordTopOffsetPx() {
            try {
                const strip = document.getElementById('patternStrip');
                if (strip) {
                    const r = strip.getBoundingClientRect();
                    if (Number.isFinite(r.bottom)) return Math.ceil(r.bottom + 6);
                }
            } catch(_) { }
            try {
                const rootArea = document.querySelector('.root-notes-area');
                if (rootArea) {
                    const r = rootArea.getBoundingClientRect();
                    if (Number.isFinite(r.bottom)) return Math.ceil(r.bottom + 6);
                }
            } catch(_) { }
            return 0;
        }

        function _syncXenonFooterHeightVar() {
            try {
                const footer = document.getElementById('brandFooter');
                if (!footer) return;
                const h = footer.getBoundingClientRect().height;
                const px = (Number.isFinite(h) && h > 0) ? Math.ceil(h) : 28;
                document.documentElement.style.setProperty('--xenon-footer-h', `${px}px`);
            } catch (_) { /* noop */ }
        }

        // Keep footer height var in sync for accurate layout across devices.
        try {
            window.addEventListener('resize', () => { _syncXenonFooterHeightVar(); }, { passive: true });
            document.addEventListener('DOMContentLoaded', () => {
                _syncXenonFooterHeightVar();
                setTimeout(() => { _syncXenonFooterHeightVar(); }, 50);
                setTimeout(() => { _syncXenonFooterHeightVar(); }, 250);
            }, { once: true });
            // If the footer already exists, sync immediately.
            _syncXenonFooterHeightVar();
        } catch (_) { /* noop */ }

        function initChordResize() {
            const handle = document.getElementById('chordResizeHandle');
            const topHandle = document.getElementById('chordCollapseHandle');
            const strumArea = document.getElementById('strumArea');
            const jamArea = document.getElementById('jamArea');
            const ruler = document.getElementById('chordRuler');
            const RULER_H = 14;
            const HANDLE_H = 24;
            const TOP_HANDLE_H = 20;
            
            if (!handle || !strumArea) return;
            const layout = {
                systemTop: null,
                splitHeight: null
            };
            const minStrumHeight = 80;
            const hideAllThreshold = 60;

            const applyLayout = () => {
                const topOffset = _getChordTopOffsetPx();
                const footerH = _getXenonFooterHeightPx();
                const bottom = window.innerHeight - footerH;
                const minSystemHeight = Math.max(120, Math.round(window.innerHeight * 0.25));

                let systemTop = Number.isFinite(layout.systemTop) ? layout.systemTop : topOffset;
                systemTop = Math.max(topOffset, Math.min(bottom - 20, systemTop));
                let totalHeight = Math.max(0, bottom - systemTop);

                if (!Number.isFinite(layout.splitHeight)) {
                    const initialSplit = Math.max(minStrumHeight + RULER_H, Math.min(totalHeight, Math.round(window.innerHeight * 0.5 - systemTop)));
                    layout.splitHeight = initialSplit;
                }

                let splitHeight = layout.splitHeight;
                if (totalHeight <= minSystemHeight) splitHeight = totalHeight;
                const minSplit = Math.min(totalHeight, minStrumHeight + RULER_H);
                splitHeight = Math.max(minSplit, Math.min(totalHeight, splitHeight));

                const showAll = totalHeight > hideAllThreshold;
                const jamHeight = Math.max(0, totalHeight - splitHeight);
                const strumHeight = Math.max(0, splitHeight - RULER_H);

                strumArea.style.top = systemTop + 'px';
                strumArea.style.height = strumHeight + 'px';
                strumArea.style.display = (showAll && strumHeight > 0) ? 'block' : 'none';

                if (ruler) {
                    if (showAll && strumHeight > 0) {
                        ruler.style.top = (systemTop + strumHeight) + 'px';
                        ruler.style.display = 'block';
                    } else {
                        ruler.style.display = 'none';
                    }
                }

                if (jamArea) {
                    if (showAll && jamHeight > 0) {
                        jamArea.style.display = 'flex';
                        jamArea.style.top = (systemTop + splitHeight) + 'px';
                        jamArea.style.bottom = `${footerH}px`;
                    } else {
                        jamArea.style.display = 'none';
                    }
                }

                handle.style.height = HANDLE_H + 'px';
                handle.style.top = (systemTop + splitHeight - (HANDLE_H / 2)) + 'px';
                if (topHandle) {
                    topHandle.style.height = TOP_HANDLE_H + 'px';
                    topHandle.style.top = (systemTop - (TOP_HANDLE_H / 2)) + 'px';
                }

                layout.systemTop = systemTop;
                layout.splitHeight = splitHeight;

                setTimeout(() => updateStringCompression(), 10);
            };

            applyLayout();

            let isResizingMid = false;
            let isResizingTop = false;
            let startY = 0;
            let startSplit = 0;
            let startTop = 0;

            handle.style.touchAction = 'none';
            if (topHandle) topHandle.style.touchAction = 'none';

            const startResize = (type, y) => {
                if (type === 'mid') {
                    isResizingMid = true;
                    startSplit = layout.splitHeight || 0;
                } else {
                    isResizingTop = true;
                    startTop = layout.systemTop || _getChordTopOffsetPx();
                }
                startY = y;
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'ns-resize';
            };

            handle.addEventListener('pointerdown', (e) => {
                try { handle.setPointerCapture(e.pointerId); } catch(_){ }
                startResize('mid', e.clientY);
            });
            if (topHandle) {
                topHandle.addEventListener('pointerdown', (e) => {
                    try { topHandle.setPointerCapture(e.pointerId); } catch(_){ }
                    startResize('top', e.clientY);
                });
            }

            const onMove = (e) => {
                if (!isResizingMid && !isResizingTop) return;
                const deltaY = e.clientY - startY;
                if (isResizingMid) {
                    layout.splitHeight = startSplit + deltaY;
                }
                if (isResizingTop) {
                    layout.systemTop = startTop + deltaY;
                }
                applyLayout();
            };

            const endResize = () => {
                if (isResizingMid || isResizingTop) {
                    isResizingMid = false;
                    isResizingTop = false;
                    document.body.style.userSelect = '';
                    document.body.style.cursor = '';
                }
            };

            document.addEventListener('pointermove', onMove);
            document.addEventListener('pointerup', endResize);
            document.addEventListener('pointercancel', endResize);

            window.addEventListener('resize', () => {
                applyLayout();
            }, { passive: true });
        }

        // Chordbox duration resize (left/right handles)
        function initChordBoxDurationResize() {
            const omni = window.omnichord;
            const rootContainer = document.getElementById('extensionColumns');
            if (!rootContainer) return;
            const ruler = document.getElementById('chordRuler');

            // Spec change: do NOT auto-pad chord timeline to bar multiples.
            // Remove any previously inserted auto-pad spacer blocks.
            try {
                if (omni && Array.isArray(omni.chordExtensions)) {
                    const beforeLen = omni.chordExtensions.length;
                    omni.chordExtensions = omni.chordExtensions.filter(ce => !(ce && ce.isSpacer && ce.isAutoPad));
                    const afterLen = omni.chordExtensions.length;
                    if (afterLen !== beforeLen) {
                        try { omni.saveChordConfiguration && omni.saveChordConfiguration(); } catch(_){ }
                        try { omni.generateExtensionColumns && omni.generateExtensionColumns(); } catch(_){ }
                        return;
                    }
                }
            } catch(_){ }

            const getLen16 = (col) => {
                const raw = col && col.dataset ? col.dataset.len16 : null;
                let v = parseInt(raw || '16', 10);
                if (!Number.isFinite(v) || v <= 0) v = 16;
                return Math.max(1, Math.min(1024, v|0));
            };

            const setLen16 = (col, len16) => {
                if (!col) return;
                const v = Math.max(1, Math.min(1024, (len16|0) || 1));
                col.dataset.len16 = String(v);
                col.style.setProperty('--len16', String(v));
                col.style.flexGrow = String(v);
                col.style.flexShrink = '1';
                col.style.flexBasis = '0px';

                // Persist to model if possible
                try {
                    const chordId = col.dataset && col.dataset.chordId;
                    const origPos = col.dataset && col.dataset.originalPosition;
                    const list = omni && Array.isArray(omni.chordExtensions) ? omni.chordExtensions : null;
                    if (list && list.length) {
                        let idx = -1;
                        if (chordId) idx = list.findIndex(c => c && (String(c.id || '') === String(chordId)));
                        if (idx < 0 && origPos != null) {
                            const op = parseInt(origPos, 10);
                            if (Number.isFinite(op) && op >= 0 && op < list.length) idx = op;
                        }
                        if (idx >= 0 && list[idx]) list[idx].len16 = v;
                    }
                } catch(_){ }
            };

            const ensureHandlesForColumn = (col) => {
                if (!col || col._xenLenHandlesAdded) return;
                col._xenLenHandlesAdded = true;

                const left = document.createElement('div');
                left.className = 'chordbox-resize-handle left';
                left.title = 'Resize duration (16ths)';
                const right = document.createElement('div');
                right.className = 'chordbox-resize-handle right';
                right.title = 'Resize duration (16ths)';

                col.appendChild(left);
                col.appendChild(right);
            };

            const requestSafeRebuild = () => {
                try { window.requestSequencerRebuild && window.requestSequencerRebuild('len16'); } catch(_){ }
            };

            const ensureLenTooltip = () => {
                if (!ruler) return null;
                if (!ruler._lenTooltip) {
                    const tip = document.createElement('div');
                    tip.className = 'chord-ruler-tooltip';
                    tip.style.display = 'none';
                    ruler.appendChild(tip);
                    ruler._lenTooltip = tip;
                }
                return ruler._lenTooltip;
            };

            // Add handles to every chord column
            const allChordCols = Array.from(rootContainer.querySelectorAll('.extension-column'));
            allChordCols.forEach(col => {
                // Ensure a default len if missing
                try { if (!col.dataset.len16) setLen16(col, 16); } catch(_){ }
                ensureHandlesForColumn(col);
            });

            // Wire drag behavior once (event delegation)
            if (rootContainer._xenLenResizeWired) return;
            rootContainer._xenLenResizeWired = true;

            rootContainer.addEventListener('pointerdown', (e) => {
                const handle = e.target && e.target.classList ? e.target.closest('.chordbox-resize-handle') : null;
                if (!handle) return;
                const col = handle.closest('.extension-column');
                if (!col) return;

                try { e.preventDefault(); e.stopPropagation(); } catch(_){ }

                const side = handle.classList.contains('left') ? 'left' : 'right';
                const rowEl = col.parentElement || rootContainer;
                const timelineCols = Array.from(rowEl.querySelectorAll('.extension-column'));
                const idx = timelineCols.indexOf(col);
                const neighbor = (side === 'right') ? (timelineCols[idx + 1] || null) : (timelineCols[idx - 1] || null);

                // Determine unit width in pixels (based on current summed 16ths)
                const totalLen16 = timelineCols.reduce((acc, c) => acc + getLen16(c), 0);
                const rowWidthPx = Math.max(1, rowEl.getBoundingClientRect().width);
                const unitPx = Math.max(1, rowWidthPx / Math.max(1, totalLen16));

                const startX = e.clientX;
                const startThis = getLen16(col);
                const startNeighbor = neighbor ? getLen16(neighbor) : null;
                let lastDeltaUnits = 0;
                let lastMoveTs = (performance && performance.now) ? performance.now() : Date.now();
                let lastRawDelta = 0;
                const tipEl = ensureLenTooltip();

                const showTip = (len16) => {
                    if (!tipEl || !ruler) return;
                    try {
                        const hRect = handle.getBoundingClientRect();
                        const rRect = ruler.getBoundingClientRect();
                        const left = (hRect.left + (hRect.width / 2)) - rRect.left;
                        tipEl.style.left = `${left}px`;
                        tipEl.textContent = `${len16} steps`;
                        tipEl.style.display = 'block';
                    } catch(_){ }
                };

                const hideTip = ()=>{ try { if (tipEl) tipEl.style.display = 'none'; } catch(_){ } };

                const computeDeltaUnits = (rawDeltaUnits, speedUnitsPerMs) => {
                    if (!Number.isFinite(rawDeltaUnits)) return 0;
                    const slow = speedUnitsPerMs <= 0.03;
                    if (slow) return Math.round(rawDeltaUnits);
                    const desiredThis = startThis + (side === 'right' ? rawDeltaUnits : -rawDeltaUnits);
                    const snappedThis = Math.max(1, Math.min(1024, Math.round(desiredThis / 4) * 4));
                    return (side === 'right') ? (snappedThis - startThis) : (startThis - snappedThis);
                };

                const applyDelta = (rawDeltaUnits, speedUnitsPerMs) => {
                    let deltaUnits = computeDeltaUnits(rawDeltaUnits, speedUnitsPerMs);
                    if (deltaUnits === lastDeltaUnits) return;

                    if (neighbor) {
                        if (side === 'right') {
                            // newThis = startThis + delta, newNext = startNext - delta
                            const minDelta = -(startThis - 1);
                            const maxDelta = (startNeighbor - 1);
                            deltaUnits = Math.max(minDelta, Math.min(maxDelta, deltaUnits));
                            setLen16(col, startThis + deltaUnits);
                            setLen16(neighbor, startNeighbor - deltaUnits);
                        } else {
                            // left handle: newThis = startThis - delta, newPrev = startPrev + delta
                            const minDelta = -(startNeighbor - 1);
                            const maxDelta = (startThis - 1);
                            deltaUnits = Math.max(minDelta, Math.min(maxDelta, deltaUnits));
                            setLen16(col, startThis - deltaUnits);
                            setLen16(neighbor, startNeighbor + deltaUnits);
                        }
                    } else {
                        // No neighbor on that side: adjust this chordbox only (sequence total may grow/shrink freely)
                        const minDelta = -(startThis - 1);
                        const maxDelta = 1024 - startThis;
                        deltaUnits = Math.max(minDelta, Math.min(maxDelta, deltaUnits));
                        setLen16(col, startThis + (side === 'right' ? deltaUnits : -deltaUnits));
                    }

                    lastDeltaUnits = deltaUnits;
                    try { showTip(getLen16(col)); } catch(_){ }
                };

                const onMove = (ev) => {
                    try { ev.preventDefault(); } catch(_){ }
                    const nowTs = (performance && performance.now) ? performance.now() : Date.now();
                    const dt = Math.max(1, nowTs - lastMoveTs);
                    const dx = (ev.clientX - startX);
                    const rawDeltaUnits = (dx / unitPx);
                    const speedUnitsPerMs = Math.abs(rawDeltaUnits - lastRawDelta) / dt;
                    lastMoveTs = nowTs;
                    lastRawDelta = rawDeltaUnits;
                    applyDelta(rawDeltaUnits, speedUnitsPerMs);
                };

                const onUp = () => {
                    try { document.removeEventListener('pointermove', onMove, true); } catch(_){ }
                    try { document.removeEventListener('pointerup', onUp, true); } catch(_){ }
                    try { document.removeEventListener('pointercancel', onUp, true); } catch(_){ }

                    try { hideTip(); } catch(_){ }

                    try { omni.saveChordConfiguration && omni.saveChordConfiguration(); } catch(_){ }
                    requestSafeRebuild();
                };

                try { document.addEventListener('pointermove', onMove, true); } catch(_){ }
                try { document.addEventListener('pointerup', onUp, true); } catch(_){ }
                try { document.addEventListener('pointercancel', onUp, true); } catch(_){ }
            }, true);
        }
        
        // Monitor and adjust string compression based on available space
        function updateStringCompression() {
            const extensionColumns = document.querySelectorAll('.extension-column');

            extensionColumns.forEach(column => {
                const stringsContainer = column.querySelector('.strings-column') || column.querySelector('.strings-container');
                if (!stringsContainer) return;
                const rows = stringsContainer.querySelectorAll('.string');
                const count = rows.length || 0;

                const availableHeight = column.clientHeight || column.offsetHeight || 0;
                const headerEl = column.querySelector('.extension-header');
                const headerHeight = headerEl ? Math.ceil(headerEl.getBoundingClientRect().height) : 56;
                const stringsHeight = Math.max(0, availableHeight - headerHeight);

                // Keep strings container height synced to the column size
                try {
                    stringsContainer.style.height = `${stringsHeight}px`;
                    stringsContainer.style.flex = '0 0 auto';
                    stringsContainer.style.minHeight = '0';
                } catch (_){ }
                
                // Remove existing compression classes
                column.removeAttribute('data-compressed');
                
                // Apply compression based on available space
                if (stringsHeight < 60) {
                    column.setAttribute('data-compressed', 'heavy');
                } else if (stringsHeight < 100) {
                    column.setAttribute('data-compressed', 'true');
                }

                // Compute row height + gap so black lines stay thin and bars stay fat
                try {
                    if (count > 0) {
                        const minColor = 1;
                        const maxColor = Math.max(30, stringsHeight || 0);
                        const maxGap = 2;
                        const h = Math.max(1, stringsContainer.clientHeight || stringsHeight || 0);
                        let gap = (count > 1) ? ((h - (minColor * count)) / (count - 1)) : 0;
                        if (!Number.isFinite(gap)) gap = 0;
                        gap = Math.max(0, Math.min(maxGap, gap));
                        let row = (h - (gap * (count - 1))) / count;
                        if (!Number.isFinite(row)) row = minColor;
                        row = Math.max(minColor, Math.min(maxColor, row));
                        column.style.setProperty('--string-gap', `${gap.toFixed(2)}px`);
                        column.style.setProperty('--string-row', `${row.toFixed(2)}px`);
                        column.style.setProperty('--string-min', `${minColor}px`);
                        column.style.setProperty('--string-max', `${maxColor}px`);
                        try { stringsContainer.style.gap = 'var(--string-gap, 1px)'; } catch(_){ }
                    }
                } catch(_){ }
            });
        }

        // Ensure chord visibility on creation
        function ensureChordVisibility() {
            const strumArea = document.getElementById('strumArea');
            const extensionColumns = document.getElementById('extensionColumns');
            const handle = document.getElementById('chordResizeHandle');
            const ruler = document.getElementById('chordRuler');
            const jamArea = document.getElementById('jamArea');
            const RULER_H = 14;
            
            if (!strumArea || !extensionColumns) return;
            
            const chords = extensionColumns.querySelectorAll('.extension-column');
            if (chords.length === 0) return;
            
            // Calculate minimum space needed so chord headers/strings stay visible
            const sample = chords[0];
            const headerEl = sample ? sample.querySelector('.extension-header') : null;
            const footerEl = sample ? sample.querySelector('.extension-footer') : null;
            const headerHeight = headerEl ? Math.ceil(headerEl.getBoundingClientRect().height) : 56;
            const footerHeight = footerEl ? Math.ceil(footerEl.getBoundingClientRect().height) : 0;
            const minStringsHeight = 120;
            const minTotalHeight = headerHeight + footerHeight + minStringsHeight + 10;
            
            // Check current positioning
            const topOffset = _getChordTopOffsetPx();
            const footerH = _getXenonFooterHeightPx();
            const currentHeight = parseInt(strumArea.style.height) || strumArea.getBoundingClientRect().height || (window.innerHeight * 0.5);
            const availableHeight = currentHeight;
            
            // If not enough space, adjust position but respect limits
            if (availableHeight < minTotalHeight && chords.length > 0) {
                const maxHeight = Math.max(minTotalHeight + RULER_H, window.innerHeight - topOffset - footerH - 180);
                const newHeight = Math.min(currentHeight + RULER_H, maxHeight);
                if (newHeight !== currentHeight) {
                    strumArea.style.top = topOffset + 'px';
                    strumArea.style.height = Math.max(60, newHeight - RULER_H) + 'px';
                    if (handle) handle.style.top = (topOffset + newHeight - 12) + 'px';
                    try { if (ruler) ruler.style.top = (topOffset + Math.max(60, newHeight - RULER_H)) + 'px'; } catch(_){ }
                    try {
                        if (jamArea) {
                            jamArea.style.top = (topOffset + newHeight) + 'px';
                            jamArea.style.bottom = `${footerH}px`;
                        }
                    } catch(_){ }
                }
            }
        }

        // Chord ruler: faint 16th-note tick marks aligned to chordbox len16 widths
        (function(){
            const ensure = () => {
                const ruler = document.getElementById('chordRuler');
                const root = document.getElementById('extensionColumns');
                if (!ruler || !root) return false;
                if (ruler._xenRulerWired) return true;
                ruler._xenRulerWired = true;

                const scheduleRender = () => {
                    if (ruler._xenRulerRAF) return;
                    ruler._xenRulerRAF = requestAnimationFrame(() => {
                        ruler._xenRulerRAF = null;
                        try {
                            const hasAny = !!root.querySelector('.extension-column');
                            if (!hasAny) { ruler.style.display = 'none'; ruler.innerHTML = ''; return; }
                            ruler.style.display = 'block';

                            const rowCandidates = Array.from(root.children || []).filter(el => {
                                try {
                                    return el && el.querySelector && (el.querySelector('.extension-column') || el.querySelector('.repeat-marker-column') || el.querySelector('.extension-separator'));
                                } catch(_){ return false; }
                            });
                            const rows = (rowCandidates.length ? rowCandidates : [root]);

                            ruler.innerHTML = '';
                            rows.forEach(rowEl => {
                                const rowDiv = document.createElement('div');
                                rowDiv.className = 'chord-ruler-row';

                                const items = Array.from(rowEl.children || []).filter(el => {
                                    if (!el || !el.classList) return false;
                                    return el.classList.contains('extension-column') || el.classList.contains('repeat-marker-column') || el.classList.contains('extension-separator');
                                });

                                items.forEach(el => {
                                    const seg = document.createElement('div');
                                    seg.className = 'chord-ruler-seg';

                                    if (el.classList.contains('extension-column')) {
                                        let len16 = 16;
                                        try { len16 = Math.max(1, Math.min(1024, parseInt(el.dataset.len16 || '16', 10) || 16)); } catch(_){ len16 = 16; }
                                        seg.classList.add('chord');
                                        seg.style.flex = `${len16} 1 0px`;
                                        seg.style.setProperty('--len16', String(len16));
                                    } else {
                                        seg.classList.add('marker');
                                        let w = 30;
                                        try {
                                            if (el.classList.contains('repeat-marker-column')) w = 50;
                                            else if (el.classList.contains('extension-separator')) w = 30;
                                            const cssW = parseInt(getComputedStyle(el).width || '0', 10);
                                            if (Number.isFinite(cssW) && cssW > 0) w = cssW;
                                        } catch(_){ }
                                        seg.style.flex = `0 0 ${w}px`;
                                    }

                                    rowDiv.appendChild(seg);
                                });

                                ruler.appendChild(rowDiv);
                            });
                        } catch(_){ }
                    });
                };

                window.renderChordRuler = scheduleRender;

                const ensureSplitMarker = ()=>{
                    if (!ruler._splitMarker) {
                        const m = document.createElement('div');
                        m.className = 'chord-ruler-split-marker';
                        m.style.display = 'none';
                        ruler.appendChild(m);
                        ruler._splitMarker = m;
                    }
                    return ruler._splitMarker;
                };

                const getLen16 = (col)=>{
                    const raw = col && col.dataset ? col.dataset.len16 : null;
                    let v = parseInt(raw || '16', 10);
                    if (!Number.isFinite(v) || v <= 0) v = 16;
                    return Math.max(1, Math.min(1024, v|0));
                };

                const findChordIndex = (col, list)=>{
                    if (!col || !list) return -1;
                    const chordId = col.dataset && col.dataset.chordId ? String(col.dataset.chordId) : '';
                    const origPos = col.dataset && col.dataset.originalPosition != null ? parseInt(col.dataset.originalPosition, 10) : null;
                    if (chordId) {
                        const idx = list.findIndex(c => c && String(c.id || '') === chordId);
                        if (idx >= 0) return idx;
                    }
                    if (Number.isFinite(origPos) && origPos >= 0 && origPos < list.length) return origPos;
                    return -1;
                };

                const splitChordAt = (col, splitStep)=>{
                    const omni = window.omnichord;
                    if (!omni || !Array.isArray(omni.chordExtensions)) return;
                    const list = omni.chordExtensions;
                    const idx = findChordIndex(col, list);
                    if (idx < 0 || !list[idx]) return;
                    const base = list[idx];
                    const totalLen = getLen16(col);
                    const cut = Math.max(1, Math.min(totalLen - 1, splitStep|0));
                    const leftLen = cut;
                    const rightLen = totalLen - cut;
                    if (rightLen <= 0) return;

                    const cloneJson = (v)=>{ try { return JSON.parse(JSON.stringify(v)); } catch(_){ return v; } };
                    const dup = cloneJson(base);
                    dup.id = `${String(base.id || 'ch')}_split_${Date.now()}`;
                    dup.len16 = rightLen;
                    base.len16 = leftLen;

                    list.splice(idx + 1, 0, dup);
                    try { list.forEach((c, i)=>{ if (c && typeof c === 'object') c.position = i; }); } catch(_){ }

                    try { omni.generateExtensionColumns && omni.generateExtensionColumns(); } catch(_){ }
                    try { omni.saveChordConfiguration && omni.saveChordConfiguration(); } catch(_){ }
                    try { window.requestSequencerRebuild && window.requestSequencerRebuild('split'); } catch(_){ }
                };

                const wireSplit = ()=>{
                    if (ruler._xenSplitWired) return;
                    ruler._xenSplitWired = true;

                    let armed = false;
                    let startX = 0;
                    let startY = 0;
                    let downCol = null;
                    let downLen = 0;
                    let lastStep = 0;
                    let timer = null;

                    const clearTimer = ()=>{ try { if (timer) { clearTimeout(timer); timer = null; } } catch(_){ } };
                    const hideMarker = ()=>{ try { const m = ensureSplitMarker(); if (m) m.style.display = 'none'; } catch(_){ } };

                    const getColAtX = (clientX)=>{
                        const root = document.getElementById('extensionColumns');
                        if (!root) return null;
                        const cols = Array.from(root.querySelectorAll('.extension-column'));
                        for (const col of cols) {
                            const rect = col.getBoundingClientRect();
                            if (clientX >= rect.left && clientX <= rect.right) return col;
                        }
                        return null;
                    };

                    const updateMarker = (clientX)=>{
                        const m = ensureSplitMarker();
                        if (!m || !ruler || !downCol) return;
                        const colRect = downCol.getBoundingClientRect();
                        const rRect = ruler.getBoundingClientRect();
                        const relX = Math.max(0, Math.min(colRect.width, clientX - colRect.left));
                        const unitPx = Math.max(1, colRect.width / Math.max(1, downLen));
                        const step = Math.max(1, Math.min(downLen - 1, Math.round(relX / unitPx)));
                        const markerX = (colRect.left - rRect.left) + (step * unitPx);
                        m.style.left = `${markerX}px`;
                        m.style.display = 'block';
                        lastStep = step;
                        m._splitStep = step;
                        return step;
                    };

                    ruler.addEventListener('pointerdown', (e)=>{
                        if (e.button != null && e.button !== 0) return;
                        try { e.preventDefault(); } catch(_){ }
                        clearTimer();
                        armed = false;
                        startX = e.clientX;
                        startY = e.clientY;
                        downCol = getColAtX(startX);
                        downLen = downCol ? getLen16(downCol) : 0;
                        if (!downCol || downLen <= 1) return;
                        timer = setTimeout(()=>{
                            armed = true;
                            updateMarker(startX);
                        }, 260);
                    }, { passive:false });

                    ruler.addEventListener('pointermove', (e)=>{
                        if (!downCol) return;
                        if (!armed) {
                            const dx = Math.abs(e.clientX - startX);
                            const dy = Math.abs(e.clientY - startY);
                            if (dx > 6 || dy > 6) clearTimer();
                            return;
                        }
                        updateMarker(e.clientX);
                    }, { passive:true });

                    const onUp = (e)=>{
                        clearTimer();
                        if (armed && downCol) {
                            const dy = e.clientY - startY;
                            const step = Number.isFinite(lastStep) ? lastStep : (updateMarker(e.clientX) || 0);
                            if (step > 0 && step < downLen && (dy > 16 || Math.abs(dy) <= 16)) {
                                splitChordAt(downCol, step);
                            }
                        }
                        armed = false;
                        downCol = null;
                        downLen = 0;
                        lastStep = 0;
                        hideMarker();
                    };

                    ruler.addEventListener('pointerup', onUp, { passive:true });
                    ruler.addEventListener('pointercancel', onUp, { passive:true });
                    ruler.addEventListener('pointerleave', () => { if (!armed) { clearTimer(); hideMarker(); downCol = null; downLen = 0; } }, { passive:true });
                };

                wireSplit();

                try {
                    const obs = new MutationObserver((mutations) => {
                        for (const m of mutations) {
                            if (!m) continue;
                            if (m.type === 'childList') { scheduleRender(); break; }
                            if (m.type === 'attributes' && m.attributeName === 'data-len16') { scheduleRender(); break; }
                        }
                    });
                    obs.observe(root, { childList: true, subtree: true, attributes: true, attributeFilter: ['data-len16'] });
                    window.__xenChordRulerObserver = obs;
                } catch(_){ }

                try { window.addEventListener('resize', scheduleRender, { passive: true }); } catch(_){ }
                scheduleRender();
                return true;
            };
            if (!ensure()) {
                document.addEventListener('DOMContentLoaded', ensure, { once: true });
            }
        })();

        // Section switching (A/B/C...) - per-section chords + patterns + drums
        (function(){
            if (window._sectionSupportWired) return;
            window._sectionSupportWired = true;

            const cloneJson = (v)=>{ try { return JSON.parse(JSON.stringify(v)); } catch(_){ return v; } };

            const mapToObj = (mp)=>{
                const out = {};
                try {
                    if (!mp || typeof mp.forEach !== 'function') return out;
                    mp.forEach((v,k)=>{ out[String(k)] = cloneJson(v); });
                } catch(_){ }
                return out;
            };

            const objToMap = (obj)=>{
                const mp = new Map();
                try {
                    if (!obj || typeof obj !== 'object') return mp;
                    Object.keys(obj).forEach(k=>{ mp.set(parseInt(k,10), cloneJson(obj[k])); });
                } catch(_){ }
                return mp;
            };

            const captureChordExtensionsFromDom = ()=>{
                try {
                    const omni = window.omnichord;
                    const container = document.getElementById('extensionColumns');
                    if (!omni || !container) return Array.isArray(omni?.chordExtensions) ? cloneJson(omni.chordExtensions) : [];
                    const els = Array.from(container.querySelectorAll('.repeat-marker-column, .extension-separator, .extension-column'));
                    if (!els.length) return Array.isArray(omni?.chordExtensions) ? cloneJson(omni.chordExtensions) : [];

                    const src = Array.isArray(omni.chordExtensions) ? omni.chordExtensions : [];
                    const out = [];
                    const present = new Set();

                    const findChordByEl = (el)=>{
                        try {
                            const chordId = el?.dataset?.chordId ? String(el.dataset.chordId) : null;
                            if (chordId) {
                                const byId = src.find(c=> c && c.id != null && String(c.id) === chordId);
                                if (byId) return byId;
                            }
                            const opRaw = el?.dataset?.originalPosition;
                            if (opRaw != null) {
                                const op = parseInt(String(opRaw),10);
                                if (Number.isFinite(op) && op >= 0) {
                                    if (src[op]) return src[op];
                                    const byPos = src.find(c=> c && typeof c.position === 'number' && c.position === op);
                                    if (byPos) return byPos;
                                }
                            }
                        } catch(_){ }
                        return null;
                    };

                    els.forEach((el, idx)=>{
                        try {
                            if (!el) return;
                            if (el.classList.contains('repeat-marker-column') || el.dataset.isRepeatMarker === 'true') {
                                const name = String((el.textContent||'').trim());
                                if (!name) return;
                                const nestLevel = parseInt(String(el.dataset.nestLevel||'0'),10);
                                const rcRaw = el.dataset.repeatCount;
                                const repeatCount = (rcRaw != null && rcRaw !== '') ? parseInt(String(rcRaw),10) : undefined;
                                const marker = {
                                    id: `repeat_${idx}`,
                                    name,
                                    type: 'bracket',
                                    isRepeatMarker: true,
                                    nestLevel: Number.isFinite(nestLevel) ? nestLevel : 0,
                                    position: out.length
                                };
                                if (Number.isFinite(repeatCount)) marker.repeatCount = repeatCount;
                                if (el.dataset.autoOuter === 'true') marker.autoOuter = true;
                                out.push(marker);
                                present.add(String(marker.id));
                                return;
                            }
                            if (el.classList.contains('extension-separator')) {
                                const sep = { id: `sep_${idx}`, name: '|', isSeparator: true, position: out.length };
                                out.push(sep);
                                present.add(String(sep.id));
                                return;
                            }
                            if (el.classList.contains('extension-column')) {
                                const chordExt = findChordByEl(el);
                                const header = el.querySelector('.chord-name');
                                const displayName = header ? String(header.textContent||'').trim() : '';
                                const base = chordExt ? cloneJson(chordExt) : { name: displayName || 'Chord', intervals: [], extensions: [], isCustom: true };

                                try {
                                    const rawLen16 = el?.dataset?.len16;
                                    let v = parseInt(String(rawLen16 || ''), 10);
                                    if (!Number.isFinite(v) || v <= 0) v = (base && base.len16) ? parseInt(String(base.len16),10) : 16;
                                    if (!Number.isFinite(v) || v <= 0) v = 16;
                                    base.len16 = Math.max(1, Math.min(1024, v|0));
                                } catch(_){ }

                                try {
                                    if (el.dataset.localTranspose != null) {
                                        const lt = parseInt(String(el.dataset.localTranspose||'0'),10);
                                        base.localTranspose = Number.isFinite(lt) ? lt : (base.localTranspose||0);
                                    }
                                } catch(_){ }
                                if (displayName) base.name = displayName;
                                if (!base.id) {
                                    const chordId = el?.dataset?.chordId ? String(el.dataset.chordId) : '';
                                    base.id = chordId || `ch_${idx}_${Date.now()}`;
                                }
                                base.position = out.length;
                                out.push(base);
                                present.add(String(base.id));
                            }
                        } catch(_){ }
                    });

                    const fallbackIdForSrc = (c, i)=>{
                        try {
                            if (c && c.id != null) return String(c.id);
                            const nm = c && c.name != null ? String(c.name) : 'chord';
                            return (nm + '_' + i).toLowerCase().replace(/\s+/g, '_');
                        } catch(_){ return `chord_${i}`; }
                    };
                    src.forEach((c, i)=>{
                        try {
                            if (!c || typeof c !== 'object') return;
                            if (c.isRepeatMarker || c.isSeparator || c.name === '|') return;
                            const key = fallbackIdForSrc(c, i);
                            if (present.has(key)) return;
                            const extra = cloneJson(c);
                            if (!extra.id) extra.id = key;
                            extra.position = out.length;
                            out.push(extra);
                            present.add(String(extra.id));
                        } catch(_){ }
                    });

                    return out.length ? out : (Array.isArray(omni.chordExtensions) ? cloneJson(omni.chordExtensions) : []);
                } catch(_){
                    return Array.isArray(window.omnichord?.chordExtensions) ? cloneJson(window.omnichord.chordExtensions) : [];
                }
            };

            const captureSectionState = ()=>{
                const omni = window.omnichord;
                if (!omni) return null;
                try { omni._saveArpPattern && omni._saveArpPattern(); } catch(_){ }
                try { omni._saveArpPatternSynth && omni._saveArpPatternSynth(); } catch(_){ }

                const basePatternNumber = Math.max(1, parseInt(document.getElementById('patternPatternNumber')?.value||'1',10) || 1);
                const patternModal = document.getElementById('patternModal');
                const basePatternEnabled = (patternModal && typeof patternModal._patternEnabled === 'boolean') ? !!patternModal._patternEnabled : true;

                const patternInstances = Array.isArray(window._patternInstances) ? window._patternInstances : [];
                const patternInstancesState = patternInstances.map(info=>{
                    const modal = info && info.modal;
                    const key = info && info.key ? String(info.key) : (modal?.dataset ? String(modal.dataset.patternInstanceKey||'') : '');
                    if (!modal || !key) return null;
                    const patNumEl = modal.querySelector('[data-role="patternPatternNumber"]') || modal.querySelector('#patternPatternNumber');
                    const curNum = Math.max(1, parseInt(patNumEl ? patNumEl.value : '1', 10) || 1);
                    return {
                        key,
                        displayName: modal._patternDisplayName || null,
                        enabled: !!modal._patternEnabled,
                        pendingEnabled: (modal._patternPendingEnabled != null) ? !!modal._patternPendingEnabled : null,
                        patternNumber: curNum
                    };
                }).filter(Boolean);

                return {
                    chordExtensions: captureChordExtensionsFromDom(),
                    basePatternNumber,
                    basePatternEnabled,
                    arpPatterns: mapToObj(omni._arpPatterns instanceof Map ? omni._arpPatterns : null),
                    arpSynthPatterns: mapToObj(omni._arpSynthPatterns instanceof Map ? omni._arpSynthPatterns : null),
                    arpPatternsByInst: (()=>{
                        const out = {};
                        try {
                            const src = omni._arpPatternsByInst || {};
                            Object.keys(src).forEach(k=>{ out[k] = mapToObj(src[k]); });
                        } catch(_){ }
                        return out;
                    })(),
                    arpSynthPatternsByInst: (()=>{
                        const out = {};
                        try {
                            const src = omni._arpSynthPatternsByInst || {};
                            Object.keys(src).forEach(k=>{ out[k] = mapToObj(src[k]); });
                        } catch(_){ }
                        return out;
                    })(),
                    patternInstances: patternInstancesState,
                    drumInstances: cloneJson(window._drumInstances || []),
                    activeDrumInstanceId: window._activeDrumInstanceId || null
                };
            };

            window._storeCurrentSectionState = function(){
                try {
                    const id = window._activeSectionId;
                    const sec = (window._sections||[]).find(s=>s && s.id === id);
                    const st = captureSectionState();
                    if (sec && st) sec.state = cloneJson(ensureSectionState(st));
                } catch(_){ }
            };

            const applySectionState = (state)=>{
                const omni = window.omnichord;
                if (!omni || !state) return;

                if (Array.isArray(state.chordExtensions)) {
                    omni.chordExtensions = cloneJson(state.chordExtensions);
                    try { omni.generateExtensionColumns && omni.generateExtensionColumns(); } catch(_){ }
                    try { omni.saveChordConfiguration && omni.saveChordConfiguration(); } catch(_){ }
                    try { window.requestSequencerRebuild && window.requestSequencerRebuild('section'); } catch(_){ }
                }

                if (state.arpPatterns) omni._arpPatterns = objToMap(state.arpPatterns);
                if (state.arpSynthPatterns) omni._arpSynthPatterns = objToMap(state.arpSynthPatterns);

                if (state.arpPatternsByInst) {
                    omni._arpPatternsByInst = omni._arpPatternsByInst || {};
                    Object.keys(state.arpPatternsByInst).forEach(k=>{
                        omni._arpPatternsByInst[k] = objToMap(state.arpPatternsByInst[k]);
                    });
                }
                if (state.arpSynthPatternsByInst) {
                    omni._arpSynthPatternsByInst = omni._arpSynthPatternsByInst || {};
                    Object.keys(state.arpSynthPatternsByInst).forEach(k=>{
                        omni._arpSynthPatternsByInst[k] = objToMap(state.arpSynthPatternsByInst[k]);
                    });
                }

                const patNumEl = document.getElementById('patternPatternNumber');
                if (patNumEl) {
                    patNumEl.value = String(state.basePatternNumber || 1);
                    try { patNumEl.dispatchEvent(new Event('change', { bubbles: true })); } catch(_){ }
                }
                const patternModal = document.getElementById('patternModal');
                if (patternModal && typeof state.basePatternEnabled === 'boolean') {
                    patternModal._patternEnabled = !!state.basePatternEnabled;
                    try {
                        const speakerBtn = document.getElementById('patternSpeakerBtn');
                        if (speakerBtn) speakerBtn.textContent = patternModal._patternEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
                    } catch(_){ }
                }

                try {
                    const instStates = Array.isArray(state.patternInstances) ? state.patternInstances : [];
                    const byKey = {}; instStates.forEach(s=>{ if (s && s.key) byKey[String(s.key)] = s; });
                    const instances = Array.isArray(window._patternInstances) ? window._patternInstances : [];
                    instances.forEach(info=>{
                        const modal = info && info.modal;
                        const key = info && info.key ? String(info.key) : (modal?.dataset ? String(modal.dataset.patternInstanceKey||'') : '');
                        if (!modal || !key || !byKey[key]) return;
                        const st = byKey[key];
                        if (st.displayName) {
                            modal._patternDisplayName = st.displayName;
                            if (modal._stripBtn) modal._stripBtn.textContent = st.displayName;
                            try { const hdr = modal.querySelector('.modal-header span'); if (hdr) hdr.textContent = `Pattern Sequencer â€” ${st.displayName}`; } catch(_){ }
                        }
                        modal._patternEnabled = !!st.enabled;
                        modal._patternPendingEnabled = null;
                        const patNumEl = modal.querySelector('[data-role="patternPatternNumber"]') || modal.querySelector('#patternPatternNumber');
                        if (patNumEl) {
                            patNumEl.value = String(st.patternNumber || 1);
                            try { patNumEl.dispatchEvent(new Event('change', { bubbles: true })); } catch(_){ }
                        }
                        try { window._updatePatternInstanceButtonVisual && window._updatePatternInstanceButtonVisual(modal); } catch(_){ }
                    });
                } catch(_){ }

                if (Array.isArray(state.drumInstances)) {
                    window._drumInstances = cloneJson(state.drumInstances);
                    try { window._rebuildDrumInstanceButtons && window._rebuildDrumInstanceButtons(); } catch(_){ }
                }
                if (state.activeDrumInstanceId) window._activeDrumInstanceId = state.activeDrumInstanceId;
                try { window._syncDrumEditorToActiveInstance && window._syncDrumEditorToActiveInstance(); } catch(_){ }
            };

            const ensureSectionUI = ()=>{
                const host = document.getElementById('sectionButtons');
                if (!host) return false;
                if (host._sectionsWired) return true;
                host._sectionsWired = true;

                const ensureSectionState = (st)=>{
                    if (!st || typeof st !== 'object') st = {};
                    if (!Array.isArray(st.chordExtensions)) st.chordExtensions = [];
                    return st;
                };

                window._sections = window._sections || [];
                if (!window._sections.length) {
                    const initial = ensureSectionState(captureSectionState());
                    window._sections.push({ id: 'A', name: 'SECTION A', state: initial });
                    window._activeSectionId = 'A';
                }

                const renderButtons = ()=>{
                    host.innerHTML = '';
                    window._sections.forEach(sec=>{
                        const b = document.createElement('button');
                        b.className = 'panel-btn';
                        b.textContent = sec.name || `SECTION ${sec.id}`;
                        b.style.background = '#513072';
                        b.style.borderColor = '#8457b8';
                        b.style.color = '#f1e8ff';
                        b.style.padding = '6px 10px';
                        b.style.fontSize = '12px';
                        b.dataset.sectionId = sec.id;

                        const applyActive = ()=>{
                            const activeId = window._activeSectionId;
                            const pendingId = window._pendingSectionId;
                            if (sec.id === activeId) b.classList.add('active'); else b.classList.remove('active');
                            if (pendingId && sec.id === pendingId) b.classList.add('pending-change'); else b.classList.remove('pending-change');
                        };

                        const doRename = ()=>{
                            if (b._renaming) return;
                            b._renaming = true;
                            const prev = String(sec.name || `SECTION ${sec.id}`);
                            b.textContent = prev;
                            b.setAttribute('contenteditable', 'true');
                            b.setAttribute('role', 'textbox');
                            b.setAttribute('spellcheck', 'false');
                            b.style.outline = '2px solid #caa7ff';
                            b.style.outlineOffset = '1px';
                            const cleanup = ()=>{
                                b.removeAttribute('contenteditable');
                                b.removeAttribute('role');
                                b.removeAttribute('spellcheck');
                                b.style.outline = '';
                                b.style.outlineOffset = '';
                                b._renaming = false;
                            };
                            const finish = (commit)=>{
                                const raw = String(b.textContent || '').trim();
                                cleanup();
                                sec.name = commit && raw ? raw : prev;
                                b.textContent = sec.name;
                                b.removeEventListener('keydown', onKey);
                                b.removeEventListener('blur', onBlur);
                            };
                            const onKey = (e)=>{ if (e.key === 'Enter') { e.preventDefault(); finish(true); } else if (e.key === 'Escape') { e.preventDefault(); finish(false); } };
                            const onBlur = ()=> finish(true);
                            b.addEventListener('keydown', onKey);
                            b.addEventListener('blur', onBlur);
                        };

                        b.addEventListener('dblclick', (e)=>{
                            e.preventDefault();
                            e.stopPropagation();
                            doRename();
                        });

                        b.addEventListener('contextmenu', (e)=>{
                            e.preventDefault();
                            doRename();
                        });

                        b.addEventListener('click', ()=>{
                            if (b._renaming) return;
                            try {
                                const curId = window._activeSectionId;
                                const cur = (window._sections||[]).find(s=>s && s.id === curId);
                                if (cur) {
                                    const st = captureSectionState();
                                    if (st) cur.state = cloneJson(ensureSectionState(st));
                                }
                            } catch(_){ }
                            const id = sec.id;
                            const omni = window.omnichord;
                            const isPlaying = !!(omni && (omni._isSequencing || omni._arpTransport?.running));
                            if (isPlaying) {
                                window._pendingSectionId = id;
                                if (omni) omni._pendingSectionSwitchId = id;
                            } else {
                                window._activeSectionId = id;
                                window._pendingSectionId = null;
                                if (omni) omni._pendingSectionSwitchId = null;
                                applySectionState(sec.state);
                            }
                            applyActive();
                            renderButtons();
                        });

                        applyActive();
                        host.appendChild(b);
                    });
                };

                renderButtons();

                const newBtn = document.getElementById('newSectionBtn');
                if (newBtn && !newBtn._wired) {
                    newBtn._wired = true;
                    newBtn.addEventListener('click', ()=>{
                        const omni = window.omnichord;
                        try {
                            const curId = window._activeSectionId;
                            const cur = (window._sections||[]).find(s=>s && s.id === curId);
                            if (cur) {
                                const st = captureSectionState();
                                if (st) cur.state = cloneJson(ensureSectionState(st));
                            }
                        } catch(_){ }
                        const activeSection = (window._sections||[]).find(s=>s && s.id === window._activeSectionId);
                        let state = null;
                        if (activeSection && activeSection.state) {
                            state = cloneJson(ensureSectionState(activeSection.state));
                        } else {
                            state = cloneJson(ensureSectionState(captureSectionState()));
                            state.chordExtensions = [];
                        }
                        const nextId = String.fromCharCode(65 + (window._sections?.length||0));
                        const id = nextId && nextId.length === 1 ? nextId : `S${(window._sections?.length||0)+1}`;
                        window._sections.push({ id, name: `SECTION ${id}`, state: cloneJson(state) });
                        window._activeSectionId = id;
                        window._pendingSectionId = null;
                        if (omni) omni._pendingSectionSwitchId = null;
                        applySectionState(state);
                        renderButtons();
                    });
                }

                const omni = window.omnichord;
                const applySectionSwitchById = (id)=>{
                    const sec = (window._sections||[]).find(s=>s && s.id === id);
                    if (!sec) return;
                    window._activeSectionId = id;
                    window._pendingSectionId = null;
                    if (omni) omni._pendingSectionSwitchId = null;
                    applySectionState(sec.state);
                    renderButtons();
                };
                window._applySectionSwitchById = applySectionSwitchById;
                if (omni && !omni._applySectionSwitchById) {
                    omni._applySectionSwitchById = applySectionSwitchById;
                }

                return true;
            };

            if (!ensureSectionUI()) {
                document.addEventListener('DOMContentLoaded', ensureSectionUI, { once: true });
                setTimeout(ensureSectionUI, 250);
            }
        })();

        // Modal management - ensure newly opened modals appear on top
        function bringModalToFront(modalId) {
            // Reset all floating modals to base z-index
            document.querySelectorAll('.floating-modal').forEach(modal => {
                modal.classList.remove('modal-active');
                modal.style.zIndex = '10000';
            });
            // Bring specified modal to front with higher z-index
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.add('modal-active');
                modal.style.display = 'block';
                modal.style.zIndex = '10001';
                console.log('Brought modal to front:', modalId, 'z-index:', modal.style.zIndex);

                // Ensure modal is draggable (by header) the first time it is brought to front
                try {
                    if (!modal._draggableSet) {
                        const hasHeader = !!modal.querySelector && modal.querySelector('.modal-header');
                        if (hasHeader && typeof makeDraggable === 'function') {
                            makeDraggable(modal);
                            modal._draggableSet = true;
                        }
                    }
                } catch(_) {}
            }
        }

        // Fix bracket movement - allow ] to move to far right
        function fixBracketMovement() {
            const brackets = document.querySelectorAll('.bracket-marker');
            brackets.forEach(bracket => {
                if (bracket.textContent === ']') {
                    // Allow ] brackets to be dropped after the last chord
                    const extensionColumns = document.getElementById('extensionColumns');
                    if (extensionColumns) {
                        // Add a drop zone at the end for ] brackets
                        const endDropZone = document.createElement('div');
                        endDropZone.className = 'bracket-drop-zone end-zone';
                        endDropZone.style.cssText = 'width: 20px; min-width: 20px; height: 100%; background: transparent; border-left: 2px dashed transparent; transition: all 0.2s;';
                        
                        endDropZone.addEventListener('dragover', (e) => {
                            e.preventDefault();
                            endDropZone.style.borderLeftColor = '#3b82f6';
                            endDropZone.style.background = 'rgba(59, 130, 246, 0.1)';
                        });
                        
                        endDropZone.addEventListener('dragleave', () => {
                            endDropZone.style.borderLeftColor = 'transparent';
                            endDropZone.style.background = 'transparent';
                        });
                        
                        endDropZone.addEventListener('drop', (e) => {
                            e.preventDefault();
                            const draggedBracket = document.querySelector('.bracket-marker.dragging');
                            if (draggedBracket && draggedBracket.textContent === ']') {
                                // Move bracket to end
                                extensionColumns.appendChild(draggedBracket);
                            }
                            endDropZone.style.borderLeftColor = 'transparent';
                            endDropZone.style.background = 'transparent';
                        });
                        
                        if (!extensionColumns.querySelector('.end-zone')) {
                            extensionColumns.appendChild(endDropZone);
                        }
                    }
                }
            });
        }
        
        // Ensure functions are globally available
        window.makeBracketDraggable = makeBracketDraggable;
        window.makeChordColumnsDroppable = makeChordColumnsDroppable;
        window.initChordResize = initChordResize;
        window.initChordBoxDurationResize = initChordBoxDurationResize;
        window.ensureChordVisibility = ensureChordVisibility;
        window.updateStringCompression = updateStringCompression;
        window.bringModalToFront = bringModalToFront;
        window.fixBracketMovement = fixBracketMovement;
        
        // Add click-to-front functionality for all floating modals
        const floatingModals = document.querySelectorAll('.floating-modal');
        floatingModals.forEach(modal => {
            if (modal && !modal._clickToFrontWired) {
                modal._clickToFrontWired = true;
                modal.addEventListener('mousedown', (e) => {
                    // Only bring to front if clicking on the modal itself, not if it's already the top modal
                    if (e.target === modal || modal.contains(e.target)) {
                        bringModalToFront(modal.id);
                    }
                });
            }
        });
        
        // Fix SEQ modal opening
        const seqBtn = document.getElementById('seqPanelBtn');
        if (seqBtn) {
            seqBtn.addEventListener('click', () => {
                bringModalToFront('textChordModal');
            });
        }
        
        const openTextChordParserBtn = document.getElementById('openTextChordParserBtn');
        if (openTextChordParserBtn) {
            openTextChordParserBtn.addEventListener('click', () => {
                bringModalToFront('textChordModal');
            });
        }
        
        // Universal EDO Synchronization System
        function initUniversalEDOSync() {
            const edoInputs = [
                'edoQuickInputTransport',    // Top transport bar
                'edoQuickInput',             // Main panel
                'edoQuickInputKeyboard',     // Keyboard modal
                'seqEdoInput',               // Sequence modal
                'edoDivisions'               // Tuning modal
            ];
            
            // Adjust keyboard modal width based on EDO value
            function adjustKeyboardModalWidth(edo) {
                const modal = document.getElementById('keyboardModal');
                if (!modal) return;
                
                // Calculate width based on EDO
                // 24 EDO: 590px (~1/3 page width on 1920px screen)
                // 48 EDO: ~1180px (~2/3 page width)
                // 53 EDO: ~1400px (nearly full width, leaving margin)
                let newWidth;
                if (edo <= 24) {
                    newWidth = 590;
                } else if (edo <= 36) {
                    // Linear interpolation between 24 and 36 EDO
                    newWidth = 590 + ((edo - 24) / 12) * 400; // 590 to 990px
                } else if (edo <= 48) {
                    // Linear interpolation between 36 and 48 EDO
                    newWidth = 990 + ((edo - 36) / 12) * 290; // 990 to 1280px
                } else {
                    // Linear interpolation between 48 and 53 EDO
                    newWidth = 1280 + ((edo - 48) / 5) * 120; // 1280 to 1400px
                }
                
                modal.style.width = Math.round(newWidth) + 'px';
                if (typeof window.updateCalcScale === 'function') window.updateCalcScale();
            }
            
            // Make function globally accessible
            window.adjustKeyboardModalWidth = adjustKeyboardModalWidth;
            
            function syncAllEDOInputs(newValue, sourceId) {
                const validValue = Math.max(5, Math.min(53, parseInt(newValue) || 24));
                
                // Update all EDO inputs except the source
                edoInputs.forEach(inputId => {
                    const input = document.getElementById(inputId);
                    if (input && inputId !== sourceId) {
                        input.value = String(validValue);
                    }
                });
                
                // Adjust keyboard modal width based on EDO
                adjustKeyboardModalWidth(validValue);
                
                // Check if playback is active - if so, defer EDO change to next cycle
                const isPlaying = window.omnichord && window.omnichord._arpTransport && window.omnichord._arpTransport.isRunning;
                
                if (isPlaying) {
                    // Defer EDO change by 2 beats during playback
                    if (window.scheduleDeferred && typeof window.scheduleDeferred === 'function') {
                        window.scheduleDeferred({ edo: validValue });
                    }
                } else {
                    // Apply immediately if stopped
                    if (window.omnichord && typeof omnichord.updateTuningSystem === 'function') {
                        omnichord.updateTuningSystem(validValue);
                    }
                    
                    // If a sequence is loaded in the SEQ modal, regenerate it with the new EDO
                    const textChordInput = document.getElementById('textChordInput');
                    if (textChordInput && textChordInput.value.trim().length > 0) {
                        // Trigger sequence regeneration by calling the same method the button uses
                        if (window.omnichord && typeof window.omnichord.createSequenceFromTextarea === 'function') {
                            console.log('ðŸ”„ Regenerating chord sequence with new EDO:', validValue);
                            window.omnichord.createSequenceFromTextarea();
                        }
                    }
                }
                
                return validValue;
            }
            
            // Attach listeners to all EDO inputs
            edoInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    // Remove any existing listeners to avoid duplicates
                    input.removeEventListener('change', input._edoSyncHandler);
                    input.removeEventListener('input', input._edoSyncHandler);
                    
                    // Create the sync handler
                    input._edoSyncHandler = function(e) {
                        syncAllEDOInputs(this.value, inputId);
                    };
                    
                    // Listen for both change and input events
                    input.addEventListener('change', input._edoSyncHandler);
                    input.addEventListener('input', input._edoSyncHandler);
                }
            });
            
            // Initialize all inputs to same value (24)
            syncAllEDOInputs(24, null);
        }
        
        window.initUniversalEDOSync = initUniversalEDOSync;
        
        // Add CSS for drop targets
        if (!document.getElementById('bracketDragStyles')) {
            const style = document.createElement('style');
            style.id = 'bracketDragStyles';
            style.textContent = `
                .drop-target {
                    outline: 2px dashed #3b82f6 !important;
                    background: rgba(59, 130, 246, 0.1) !important;
                }
                .dragging {
                    opacity: 0.5;
                }
                .bracket-drop-zone.end-zone {
                    min-width: 20px;
                    height: 100%;
                    transition: all 0.2s;
                }
                .bracket-drop-zone.end-zone:hover,
                .bracket-drop-zone.end-zone.drag-over {
                    border-left: 2px dashed #3b82f6 !important;
                    background: rgba(59, 130, 246, 0.1) !important;
                }
            `;
            document.head.appendChild(style);
        }

        
        // Define sidebar button handler early for onclick access
        window.sidebarBtnClick = function(buttonType) {
            console.log(`${buttonType.toUpperCase()} button clicked`);
            const btn = document.getElementById(buttonType + 'Btn');
            if (!btn) return;
            
            switch(buttonType) {
                case 'keyboard':
                    console.log('Keyboard button clicked, current active state:', btn.classList.contains('active'));
                    btn.classList.toggle('active');
                    if (btn.classList.contains('active')) {
                        console.log('Enabling keyboard and showing modal');
                        // Enable keyboard and show modal
                        showKeyboardModal();
                        bringModalToFront('keyboardModal');
                    } else {
                        console.log('Disabling keyboard and closing modal');
                        // Disable keyboard and close modal
                        closeKeyboardModal();
                    }
                    break;
                    
                case 'strum':
                    btn.classList.toggle('active');
                    if (window.omnichord && typeof omnichord.toggleStrumMode === 'function') {
                        omnichord.toggleStrumMode();
                    }
                    break;
                    
                case 'pattern':
                    btn.classList.toggle('active');
                    if (btn.classList.contains('active')) {
                        // Default PATTERN to NPC16/LEN16 (16x16) on first enable
                        try {
                            if (!window._patternDefault16Applied) {
                                const npcInput = document.getElementById('universalNpc');
                                if (npcInput) {
                                    npcInput.value = '16';
                                    npcInput.dispatchEvent(new Event('input', { bubbles: true }));
                                    npcInput.dispatchEvent(new Event('change', { bubbles: true }));
                                }
                                const pg0 = document.getElementById('patternGrid');
                                if (pg0) {
                                    try { if (typeof pg0._rebuildNpc === 'function') pg0._rebuildNpc(16); } catch(_){ }
                                    try { if (typeof pg0._rebuildLength === 'function') pg0._rebuildLength(16); } catch(_){ }
                                    try { pg0.dataset.length = '16'; } catch(_){ }
                                }
                                try {
                                    const lenValueEl = document.getElementById('patternLenValue');
                                    if (lenValueEl) lenValueEl.textContent = '16';
                                } catch(_){ }
                                window._patternDefault16Applied = true;
                            }
                        } catch(_){ }

                        // Enable pattern and show modal
                        showPatternModal();
                        try { window.ensurePatternTransport && window.ensurePatternTransport(); } catch(_) {}
                        // If PLAY is already running, start pattern playback on the next bar
                        try {
                            const omni = window.omnichord;
                            const isPlaying = !!(omni && omni._arpTransport && omni._arpTransport.running);
                            if (isPlaying) {
                                const pt = window._patternTransport;
                                if (pt && typeof pt.start === 'function') {
                                    // pt.start() already aligns to the NEXT bar when alignToTransport=true
                                    pt.start({ alignToTransport: true, preBufferMs: 80 });
                                } else if (pt) {
                                    // Minimal fallback: mark running; phase will be aligned by pt.start when available
                                    pt.running = true;
                                    if (typeof pt.kick === 'function') pt.kick();
                                }
                            }
                        } catch(_) {}
                        // Make sure pattern grid handlers are attached and overlays donâ€™t block entry
                        try {
                            const pg = document.getElementById('patternGrid');
                            if (pg) {
                                // pattern tie layers already have pointer-events: none in CSS
                                // No-op: just ensure attachHandlers ran at least once
                                if (!pg.dataset.built) { /* builders will attach automatically when building */ }
                            }
                        } catch(_) {}

                        try { window.updatePatternSpeakerIcon && window.updatePatternSpeakerIcon(); } catch(_){ }
                    } else {
                        // Disable pattern and close modal
                        const modal = document.getElementById('patternModal');
                        if (modal) modal.style.display = 'none';

                        // Stop pattern transport when PATTERN is off
                        try {
                            const pt = window._patternTransport;
                            if (pt) {
                                if (typeof pt.stop === 'function') pt.stop(false);
                                pt.running = false;
                                if (typeof pt.stopVoices === 'function') pt.stopVoices();
                            }
                        } catch(_){ }

                        try { window.updatePatternSpeakerIcon && window.updatePatternSpeakerIcon(); } catch(_){ }
                    }
                    break;
                    
                case 'chords':
                    btn.classList.toggle('active');
                    // Toggle chord functionality and sync engine/UI
                    if (window.omnichord) {
                        omnichord.chordsEnabled = btn.classList.contains('active');
                        // CHORDS OFF must be an immediate hard-kill (no release tail, no pending events).
                        try {
                            if (!omnichord.chordsEnabled && typeof omnichord.hardStopChordsNow === 'function') {
                                omnichord.hardStopChordsNow();
                            }
                        } catch(_){ }
                        try { omnichord.syncPlayMode && omnichord.syncPlayMode(); } catch(_) {}
                        try { omnichord.updateModeUI && omnichord.updateModeUI(); } catch(_) {}
                        // Do not auto-start transport when toggling modes; only PLAY should start
                        // try { if (omnichord.chordsEnabled || omnichord.arpEnabled) omnichord._startArpTransport && omnichord._startArpTransport(); } catch(_) {}
                    }
                    break;
                    
                case 'drums':
                    btn.classList.toggle('active');
                    if (btn.classList.contains('active')) {
                        // Enable drums and show modal
                        showDrumModal();
                        if (window.omnichord) omnichord.drumsEnabled = true;
                    } else {
                        // Disable drums and close modal
                        const modal = document.getElementById('drumModal');
                        if (modal) modal.style.display = 'none';
                        if (window.omnichord) omnichord.drumsEnabled = false;
                    }
                    break;
                    
                case 'bass':
                    btn.classList.toggle('active');
                    if (btn.classList.contains('active')) {
                        // Enable bass and show modal
                        if (window.omnichord) {
                            window.omnichord.bassEnabled = true;
                            try { window.omnichord.updateModeUI && window.omnichord.updateModeUI(); } catch(_) {}
                        }
                        showBassModal();
                        // If PLAY is running, ensure transport timing refreshes on the next bar so BASS denominators work
                        try {
                            const omni = window.omnichord;
                            const isPlaying = !!(omni && omni._arpTransport && omni._arpTransport.running);
                            if (isPlaying) {
                                const scheduleDeferred = window.scheduleDeferred;
                                if (typeof scheduleDeferred === 'function') scheduleDeferred({ transport: true });
                            }
                        } catch(_) {}
                    } else {
                        // Disable bass and close modal
                        const modal = document.getElementById('bassModal');
                        if (modal) modal.style.display = 'none';
                        if (window.omnichord) {
                            window.omnichord.bassEnabled = false;
                            try { window.omnichord.updateModeUI && window.omnichord.updateModeUI(); } catch(_) {}
                        }
                    }
                    break;
                    
                case 'midi':
                    // Sidebar MIDI button: ensure loopMIDI present, initialize MIDI, map outputs, mute internal sound.
                    (async ()=>{
                        try {
                            // Ensure guard exists before use
                            if (!window._xenMidiInitGuard) window._xenMidiInitGuard = { prompted:false };
                            // If already enabled, clicking turns it off via existing hidden toggle
                            if (window.midi && window.midi.enabled) {
                                const midiToggle = document.getElementById('midiToggle');
                                if (midiToggle && typeof midiToggle.click === 'function') {
                                    midiToggle.click();
                                } else {
                                    try {
                                        window.midi.enabled = false;
                                        if (window.midi.inputs) {
                                            for (const input of window.midi.inputs.values()) {
                                                input.onmidimessage = null;
                                            }
                                        }
                                        window.midi.inputHandler = null;
                                    } catch(_){ }
                                    try {
                                        const oc = window.omnichord;
                                        if (oc) {
                                            oc.midiBypassOscillators = false;
                                            const restore = (typeof oc._preMidiMasterVolume === 'number') ? oc._preMidiMasterVolume : oc.masterVolume;
                                            oc.masterVolume = restore;
                                            if (oc.gainNode) oc.gainNode.gain.value = oc.volume * oc.masterVolume;
                                            if (oc.dryGainNode) oc.dryGainNode.gain.value = oc.masterVolume;
                                            if (oc.reverbOutGain) oc.reverbOutGain.gain.value = oc.masterVolume;
                                            delete oc._preMidiMasterVolume;
                                        }
                                        if (window.midi) delete window.midi._masterVolumeScale;
                                    } catch(_){ }
                                    try {
                                        const led = document.getElementById('midiStatusLed');
                                        if (led) { led.classList.remove('on'); led.title = 'MIDI Disabled'; }
                                    } catch(_){ }
                                }
                                btn.classList.remove('active');
                                return;
                            }
                            // Attempt init if not enabled
                            if (window.midi && !window.midi.enabled) {
                                if (window.midi._initializing) return; // guard
                                window.midi._initializing = true;
                                const ok = await window.midi.init();
                                window.midi._initializing = false;
                                if (!ok) return;
                                // Detect loopMIDI outputs
                                let hasLoop = false; let firstLoopId = null; let firstLoopName = null;
                                try {
                                    const outsArr = Array.from(window.midi.outputs.values());
                                    for (const o of outsArr) { const nm = String(o.name||o.id||''); if (/loopmidi/i.test(nm)) { hasLoop = true; if (!firstLoopId){ firstLoopId=o.id; firstLoopName=nm; } } }
                                } catch(_) {}
                                if (!hasLoop) {
                                    // Allow enable if any outputs exist (hardware) OR selects already show items.
                                    let anyOutputs = false;
                                    try { anyOutputs = window.midi.outputs && window.midi.outputs.size > 0; } catch(_) {}
                                    if (!anyOutputs) {
                                        let uiVisible = false;
                                        try {
                                            const selIds = ['midiOutputSelect','midiStrumOutput','midiChordOutput','midiArpOutput','midiBassOutput','midiDrumOutput'];
                                            for (const id of selIds) { const el = document.getElementById(id); if (el && el.options && el.options.length > 0) { uiVisible = true; break; } }
                                        } catch(_) {}
                                        if (!uiVisible && !window._xenMidiInitGuard.prompted) {
                                            window._xenMidiInitGuard.prompted = true;
                                            try { window.alert('No MIDI outputs detected yet. (Optional) Install loopMIDI if you need virtual routing:\nhttps://www.tobias-erichsen.de/software/loopmidi.html'); } catch(_) {}
                                        }
                                    }
                                    // Continue enabling regardless; future hot-plug will populate.
                                }
                                // Auto-map if none chosen
                                try {
                                    const haveAny = Object.values(window.midi.outputPortMap||{}).some(v=>!!v);
                                    if (!haveAny && firstLoopId) {
                                        ['strum1','strum2','chord','arp','bass','bells','drum','default'].forEach(sec=>{ window.midi.outputPortMap[sec] = firstLoopId; });
                                        console.log(`[MIDI] (Sidebar) Auto-mapped loopMIDI port '${firstLoopName}' to all sections.`);
                                    }
                                } catch(_) {}
                                // Apply UI population
                                try { window.midi.applySettingsToUI(); } catch(_) {}
                                // Mute internal oscillators while MIDI active
                                try {
                                    const oc = window.omnichord; if (oc) { if (oc._preMidiMasterVolume===undefined) oc._preMidiMasterVolume=oc.masterVolume; oc.masterVolume=0.0001; if (oc.gainNode) oc.gainNode.gain.value = oc.volume * oc.masterVolume; if (oc.dryGainNode) oc.dryGainNode.gain.value = oc.masterVolume; if (oc.reverbOutGain) oc.reverbOutGain.gain.value = oc.masterVolume; }
                                } catch(_) {}
                                btn.classList.add('active');
                                if (window.omnichord) window.omnichord.midiBypassOscillators = true;
                                // Also mark hidden toggle button state if present
                                const midiToggle = document.getElementById('midiToggle');
                                if (midiToggle) midiToggle.classList.add('active');
                            }
                        } catch(e){ console.warn('Sidebar MIDI activation error', e); }
                        try { window.midi && window.midi.markActivity(); } catch(_) {}
                    })();
                    break;
            }
        };
        
        console.log('Sidebar functions and handlers ready');
        
        // Console logging: ENABLED for debugging
        (function(){
            try {
                const flag = (typeof window !== 'undefined' && window.localStorage) ? window.localStorage.getItem('muteConsole') : null;
                // ENABLE CONSOLE LOGGING for debugging
                let shouldMute = false;
                try {
                    const stored = (window.localStorage ? localStorage.getItem('muteConsole') : null);
                    if (stored === null) {
                        shouldMute = true;
                        if (window.localStorage) localStorage.setItem('muteConsole','1');
                    } else {
                        shouldMute = stored === '1';
                    }
                } catch(_){ shouldMute = true; }
                if (shouldMute && window.console) {
                    const methods = ['log','info','debug','warn','error','trace','group','groupCollapsed','groupEnd','time','timeEnd','table'];
                    methods.forEach(function(m){ if (typeof window.console[m] === 'function') window.console[m] = function(){}; });
                }
                // Expose quick toggles
                window.enableLogs = function(){ try{ if (window.localStorage) { localStorage.setItem('muteConsole','0'); location.reload(); } }catch(_){} };
                window.disableLogs = function(){ try{ if (window.localStorage) { localStorage.setItem('muteConsole','1'); location.reload(); } }catch(_){} };
                window.testLogs = function(){ console.log('Console test - if you see this, logs are enabled'); console.warn('Warning test'); console.error('Error test'); };
            } catch(_) {}
        })();
        class MicrotonalOmnichord { 
            constructor() {
                // Debug instrumentation (console-only)
                this._debug = false;
                this._debugLogs = [];
                this._debugMax = 500;
                this._debugUI = false; // keep panel off; use console logs only
                try { /* debug muted by default */ } catch(_){ }
                this.audioContext = null;
                this.gainNode = null;
                // Initialize separate oscillator pools for independent playback
                this.activeOscillators = new Map(); // Default/legacy pool
                this.activeStrumOscillators = new Map(); // STRUM mode during PLAY
                this.activeChordOscillators = new Map(); // CHORD mode  
                this.activeArpOscillators = new Map(); // ARP mode
                this.activeBassOscillators = new Map(); // BASS notes
                this.activeBellsOscillators = new Map(); // BELLS notes
                this.currentTuning = 24;
                this.currentRoot = 0;
                this.currentQuality = 'major';
                this.volume = 0.75; // Max volume at -9dB (matches slider at 100%)
                this.masterVolume = 0.708; // Max at -3dB (0.708 linear gain) instead of -6dB
                this.isPlayingStrings = false;
                this.triggeredStrings = new Set();
                this.activeTouches = new Map();
                // Track last-hit string per pointer (mouse or each touch) to avoid retriggers on the same string while sustaining
                this._pointerLastStringKey = new Map();
                // Track last user interaction time to reset transport phase in touch mode
                this._lastInteractionAt = (performance && performance.now) ? performance.now() : Date.now();
                this.gamelanMode = false;
                // Track the column element that's currently active/last-played for live keyboard edits
                this.currentActiveColumnEl = null;
                // PLAY UX: visual now-playing and LOOP-off final-hold selection
                this._nowPlayingColumnEl = null;
                this._lastPlayGestureColumnEl = null;
                // When true, render chord extensions (9/11/13) in higher octaves (two-octave split).
                // When false, fold all degrees into a single octave.
                // Default to compact one-octave voicing as requested.
                this.splitExtendedChordsAcrossOctaves = false;
                // Keyboard rotation across EDO steps (drag left/right rotates visible order)
                this.keyboardRotation = 0;
                // Global keyboard listener guard/handle
                this._keyboardListenerAttached = false;
                this._keyboardHandler = null;
                // Editing flow flags
                this.isEditingChord = false;
                // Global transpose accumulator (steps from session start)
                this.transposeDelta = 0;
                // Debounced edit/save timers
                this.editArmed = false;
                this._editArmTimer = null;
                this._editSaveTimer = null;
                this.editingOriginalIndex = null;
                
                // ADSR envelope settings
                this.envelope = {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0.7,
                    release: 0.8
                };
                
                // OSC 2 ADSR envelope settings
                this.osc2Envelope = {
                    attack: 0.005,
                    decay: 0.03,
                    sustain: 0.5,
                    release: 1.0
                };
                
                this.oscillatorType = 'sawtooth';
                
                // Dual oscillator settings with proper dB scaling
                this.oscillators = {
                    // pulseWidth (0-1) for 'pulse'; detune in cents; shapeWidth (0-1) controls waveform width/skew:
                    // - sine: phase-skewed sine (narrow = steep peak)
                    // - sawtooth: phase-skewed slope (narrow = fast rise)
                    // - square: PWM duty (narrow = skinny high)
                    osc1: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                    osc2: { type: 'sine', detune: -7, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 }
                }

                // New: four-instrument independent config/state
                // STRUM uses osc1+osc2 as its pair; CHORD and BASS use single-voice configs below
                this.instruments = {
                    strum1: {
                        // mirrors osc1
                        osc: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                        env: { attack: 0.005, decay: 0.5, sustain: 1.0, release: 0.5 },
                        fxSend: true
                    },
                    strum2: {
                        // mirrors osc2
                        osc: { type: 'sine', detune: -7, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                        env: { attack: 0.005, decay: 0.5, sustain: 1.0, release: 0.5 },
                        fxSend: true
                    },
                    chord: {
                        osc: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                        env: { attack: 0.01, decay: 0.2, sustain: 0.9, release: 0.3 },
                        fxSend: false
                    },
                    arp: {
                        osc: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                        env: { attack: 0.01, decay: 0.2, sustain: 0.9, release: 0.3 },
                        fxSend: true
                    },
                    bass: {
                        osc: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                        env: { attack: 0.005, decay: 0.08, sustain: 0.9, release: 0.12 },
                        fxSend: false
                    },
                    bells: {
                        osc: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                        env: { attack: 0.005, decay: 0.25, sustain: 0.85, release: 0.35 },
                        fxSend: true
                    }
                };

                // BELLS glide time override (ms). Null => auto (speed-based).
                this._bellsGlideMs = null;

                // Drum module state
                this._drums = {
                    stepsPerBar: 16,
                    lastStep: -1
                };
                // Track active drum voices so STOP can silence them immediately
                this._activeDrumVoices = new Set();

                // Held bass feature guard and state (follows chord header root; never arpeggiated)
                // Default OFF per request: no fallback/held bass unless explicitly enabled
                this._heldBassEnabled = false; // tied to chord bass toggle
                this._heldBassVoice = null;
                this._heldBassLiveFreq = null;

                // Custom oscillator wavetable cache
                this._customWaveCache = new Map();
                // Touch/click gesture defaults
                this.touchGestures = {
                    longPressDelay: 550,
                    chordNameLongPressDelay: 1000
                };
                
                
                // Store original UI state for piano lock system
                this.originalUIState = null;

                // Piano-lock system state
                // Ensure these are always initialized so the ðŸŽ¹ button works immediately
                this.pianoLockedChords = new Map();
                this.preloadedPresets = new Map();
                this.pianoLockPresetCounter = 0;
                
                // Panning settings
                this.panning = {
                    mode: 'center', // 'center', 'frequency', 'random', 'rotating', 'alternating'
                    width: 0.8, // How wide the stereo field is
                    speed: 2000, // Speed for rotating/alternating modes (ms)
                    rotationAngle: 0, // Current rotation angle
                    alternateState: false // Current side for alternating
                };
                
                // Simple reverb settings
                this.reverb = {
                    wet: 0.00, // 0% reverb by default
                    decay: 0.0, // 0 seconds decay
                    roomSize: 0.5,
                    filterCutoff: 8000
                };

                // Drum FX (dedicated global drum bus; per-lane uses SEND 0..1)
                this.drumFx = {
                    sat: { mix: 0.0, hp: 20, lp: 20000 },
                    comp: { ratio: 4, attack: 0.003, release: 0.25, threshold: -24, output: 0.0 },
                    delay: { timeMs: 180, feedback: 0.25, mix: 0.0 },
                    reverb: { wet: 0.0, decay: 0.5, room: 0.5, lp: 8000, hp: 20 },
                    out: 1.0
                };
                
                // Audio nodes
                this.reverbNode = null;
                this.wetGainNode = null;
                this.dryGainNode = null;
                this.reverbFilterNode = null;
                
                // Global planning pipeline: freeze sequences N bars ahead and apply edits only after horizon
                this._plan = {
                    horizonBars: 4,
                    bars: new Map(),
                    applyFromBar: 0,
                    dirtyMods: { drums:false, bass:false, pattern:false }
                };
                this._currentAbsBar = 0;
                this._lastPlannedBar = -1;
                // Drive state (indexsun variant)
                this.drive = {
                    amount: 0, // 0..100
                    mix: 0     // 0..100 (% wet)
                };
                
                // No default chord extensions - start completely empty unless locked chords exist
                this.defaultChordExtensions = [];
                
                // Load user's chord configuration and locked chords
                const savedChords = this.loadChordConfiguration();
                const lockedChords = this.loadLockedChords();
                
                // Clear unlocked chords from memory on first start - only load pre-locked chords
                console.log('?? Clearing unlocked chords from memory on startup');
                
                // Start with only locked chords (if any exist)
                if (lockedChords && lockedChords.length > 0) {
                    console.log('?? Loading only pre-locked chords from previous session:', lockedChords.length, 'chords');
                    this.chordExtensions = lockedChords.map(locked => ({
                        name: locked.chordName,
                        intervals: locked.intervals,
                        getChordIntervals(extensions = []) {
                            // Return canonical 12-TET semitone intervals; mapping to current EDO happens in mapIntervalToEDO
                            let intervals = [0]; // Root (0 semitones)

                            // Base triad (in semitones)
                            switch (this.currentQuality) {
                                case 'major':
                                    intervals.push(4); // Major third
                                    intervals.push(7); // Perfect fifth
                                    break;
                                case 'minor':
                                    intervals.push(3); // Minor third
                                    intervals.push(7); // Perfect fifth
                                    break;
                                case 'neutral':
                                    intervals.push(3.5); // Neutral third (microtonal)
                                    intervals.push(7);
                                    break;
                            }

                            // Apply extensions (still in semitones)
                            extensions.forEach(ext => {
                                switch (ext) {
                                    case '6':
                                        intervals.push(9);
                                        break;
                                    case '7':
                                        intervals.push(10);
                                        break;
                                    case 'maj7':
                                        intervals.push(11);
                                        break;
                                    case '9':
                                        intervals.push(10); // include 7th
                                        intervals.push(14); // 9th
                                        break;
                                    case 'sus2':
                                        intervals = intervals.filter(i => i !== 4 && i !== 3 && i !== 3.5);
                                        intervals.push(2);
                                        break;
                                    case 'sus4':
                                        intervals = intervals.filter(i => i !== 4 && i !== 3 && i !== 3.5);
                                        intervals.push(5);
                                        break;
                                    case 'add9':
                                        intervals.push(14);
                                        break;
                                    case '13':
                                        intervals.push(10); // 7th
                                        intervals.push(21); // 13th
                                        break;
                                    case '#11':
                                        intervals.push(18);
                                        break;
                                    case '7#9':
                                        intervals.push(10);
                                        intervals.push(15);
                                        break;
                                    case '#9':
                                        intervals.push(15);
                                        break;
                                    case 'n7':
                                        intervals.push(10.5); // neutral 7th
                                        break;
                                    default:
                                        break;
                                }
                            });

                            return intervals;
                        }
                    }));
                } else {
                    // No pre-locked chords; start with an empty palette
                    this.chordExtensions = [];
                }
                this.previewInterval = null;
                this.tempChordAudio = new Map(); // For preview audio
                // Track selection entry order for slash-bass inference
                this.selectedIntervals = [];
                this.selectedIntervalsOrder = [];
                // CALC (Chord Calculator) state
                this.calcState = {
                    stage: 'root',
                    note: null,
                    accSymbol: null,
                    microOffset: 0,
                    quality: 'maj',
                    extensions: [],
                    modifier: null,
                    addMode: false,
                    useCustomIntervals: false,
                    customIntervals: null,
                    customRootStep: null,
                    customName: null,
                    insertIndex: null,
                    _accSelected: false
                };
                this._calcWired = false;
                // Track a newly created blank chord to inherit notes on first external strum
                this.pendingBlankChordId = null;
                this.pendingBlankChordStrumEligible = false;
                
                // Clean up corrupted palette data
                this.cleanupPaletteData();
                
                // Initialize audio immediately (will be suspended until a gesture, then resumed)
                this.initAudio();
                // Also set up resume attempts on common gestures to satisfy autoplay policies
                const tryResume = () => { if (this.audioContext && this.audioContext.state === 'suspended') { this.audioContext.resume().catch(()=>{}); } };
                document.addEventListener('pointerdown', tryResume, { once: false });
                document.addEventListener('keydown', tryResume, { once: false });
                document.addEventListener('click', tryResume, { once: false });
                document.addEventListener('touchstart', tryResume, { once: false, passive: false });
                this.initEventListeners();
                // Always enable global keyboard shortcuts (including +/- for transpose)
                this.setupKeyboardInput();
                this.generateRootButtons();
                this.generateExtensionColumns();
                // Ensure we always have an active column so keyboard taps edit that chord
                try {
                    const firstCol = document.querySelector('.extension-column');
                    if (firstCol) { this.currentActiveColumnEl = firstCol; }
                } catch(_) {}
                
                // Ready for chord creation with New Chord button, but don't auto-enter chord mode
                console.log('?? Ready for chord creation - tuning and root can be changed freely');
                // DO NOT auto-enter chord creation mode - let user click "New Chord" when ready
                // Arm editing after idle
                this._scheduleEditArm();
                
                this.updateChordDisplay();
                this.setupSonicChords();
                this.initChordBuilder();

                // Text â†’ Chords parser wiring
                this.initTextChordParser();

                // Wire instrument presets UI
                this.wireInstrumentPresetsUI();
            }

            // Ensure ARP enabled when pattern is empty; otherwise leave mode unchanged
            checkPatternForArp(){
                try {
                    const pat = document.getElementById('patternGrid');
                    if (!pat) return;
                    const anyActive = !!pat.querySelector('.pattern-step.active');
                    // Spec: PATTERN should not auto-enable ARP.
                    void anyActive;
                } catch(_) {}
            }

            // Backwards-compat alias used by older UI code; delegate to updateModeUI
            updatePlayModeButtons(){
                try { this.updateModeUI && this.updateModeUI(); } catch(_) {}
            }

            // ---- PATTERNS: master transport-driven scheduler (beat-locked; no drift) ----
            _patternsOnTransportTick(){
                try {
                    if (!this._isSequencing) return;
                    if (!this._arpTransport) return;

                    const transport = this._arpTransport;
                    const tpBar = Math.max(1, transport.ticksPerBar || 16);
                    const curTick = transport.tickCounter | 0;
                    const absTick = transport.absTickCounter | 0;
                    const barIndex = Math.floor(absTick / tpBar);
                    const frac = (curTick / tpBar);

                    const drive = (pt, gridEl)=>{
                        try {
                            if (!pt || !pt.running) return;
                            const g = pt._gridEl || gridEl;
                            if (!g) return;
                            const scheduleStep = pt._scheduleStep;
                            if (typeof scheduleStep !== 'function') return;

                            // Detect transport reset (STOP/START) and re-init bar tracking.
                            if (pt._masterBarIndex != null && barIndex < pt._masterBarIndex) {
                                pt._masterBarIndex = null;
                                pt._barLenAtStart = null;
                                pt._barBaseAbsStep = 0;
                                pt._masterLastAbsStep = null;
                            }

                            // If LEN/QUANT rebuild is queued, don't read the grid mid-change.
                            if (pt.waitingForDeferred) {
                                pt._masterLastAbsStep = null;
                                return;
                            }

                            // Use absolute master transport tick for deterministic scheduling.
                            const absStep = absTick;

                            // Arm-on-unmute/create: start only on Beat 1 of the next bar.
                            if (pt._startAtBarIndex != null) {
                                if (barIndex < pt._startAtBarIndex || (barIndex === pt._startAtBarIndex && curTick !== 0)) {
                                    pt._masterLastAbsStep = absStep;
                                    return;
                                }
                                pt._startAtBarIndex = null;
                                pt._masterLastAbsStep = null;
                            }

                            if (pt._masterLastAbsStep === absStep) return;
                            pt._masterLastAbsStep = absStep;
                            // scheduleStep signature: (absTick, barTick, ticksPerBar)
                            scheduleStep(absTick, curTick, tpBar);
                        } catch(_){ }
                    };

                    // Base (built-in) pattern transport
                    drive(window._patternTransport, document.getElementById('patternGrid'));

                    // Spawned pattern instances
                    const instances = window._patternInstances || [];
                    instances.forEach(info=>{
                        const m = info && info.modal;
                        if (!m) return;
                        const g = (m.querySelector('[data-role="patternGrid"]') || m.querySelector('#patternGrid') || m.querySelector('.pattern-grid'));
                        drive(m._patternTransport, g);
                    });
                } catch(_){ }
            }

            // ---- DRUMS: transport-driven scheduler and simple synthesis ----
            _drumsOnTransportTick(){
                try {
                    // Only drive drums while PLAY is active
                    if (!this._isSequencing) return;
                    if (!this._arpTransport) return;
                    const tpBar = this._arpTransport.ticksPerBar || 16;
                    // Derive steps per bar from beatsPerBar (4 steps per beat)
                    const beatsPerBar = this._arpTransport.beatsPerBar || 4;
                    let steps = Math.max(4, Math.round((beatsPerBar||4) * 4));
                    if (tpBar <= 0 || steps <= 0) return;
                    // Map current tick into [0..steps-1]
                    const curTick = this._arpTransport.tickCounter|0;

                    // ---- Multi-instance drums (NEW DRUM): if instances exist, drive them all here ----
                    try {
                        const instances = window._drumInstances || [];
                        if (instances && instances.length) {
                            const absTick = (this._arpTransport.absTickCounter|0);
                            const barIndex = Math.floor(absTick / tpBar);
                            const frac = (curTick / tpBar);
                            const parseLaneQuant = (qStr, fallbackD)=>{
                                let N = fallbackD, D = fallbackD;
                                try {
                                    const s = String(qStr||'').trim();
                                    if (!s) return { N, D };
                                    const m = s.match(/^(\d+)\/(\d+)$/);
                                    if (m){
                                        const n = parseInt(m[1],10);
                                        const d = parseInt(m[2],10);
                                        if (Number.isFinite(d) && d>0) D = d;
                                        if (Number.isFinite(n) && n>0) N = Math.min(n, D);
                                        return { N, D };
                                    }
                                    const mn = s.match(/^(\d+)$/);
                                    if (mn){
                                        const d = parseInt(mn[1],10);
                                        if (Number.isFinite(d) && d>0) { D = d; N = d; }
                                    }
                                } catch(_){ }
                                return { N, D };
                            };

                            const clampLen = (n)=> Math.max(1, Math.min(64, parseInt(n||'16',10) || 16));
                            const applyLenToState = (inst, nextLen)=>{
                                const newLen = clampLen(nextLen);
                                const st = inst.state || { len: inst.len||newLen, lanes: [] };
                                const oldLen = clampLen(st.len||inst.len||newLen);
                                const lanes = Array.isArray(st.lanes) ? st.lanes : [];
                                const remapArr = (arr, toLen, isVel)=>{
                                    const out = new Array(toLen).fill(isVel ? 100 : 0);
                                    const src = Array.isArray(arr) ? arr : [];
                                    const fromLen = src.length || 0;
                                    if (!fromLen) return out;
                                    if (fromLen === toLen) {
                                        for (let i=0;i<toLen;i++) out[i] = src[i];
                                        return out;
                                    }
                                    for (let i=0;i<toLen;i++){
                                        const j = Math.max(0, Math.min(fromLen-1, Math.round((i / Math.max(1,toLen-1)) * (fromLen-1))));
                                        out[i] = src[j];
                                    }
                                    return out;
                                };
                                while (lanes.length < 9) lanes.push({ steps: [], vel: [], quant: String(oldLen), vol: 80, send: 0, midi: '', pitch: 0, atk: 2, dec: 180 });
                                for (let i=0;i<9;i++){
                                    const lane = lanes[i] || (lanes[i] = { steps: [], vel: [], quant: String(oldLen), vol: 80, send: 0, midi: '', pitch: 0, atk: 2, dec: 180 });
                                    const q0 = String((lane.quant != null) ? lane.quant : '').trim();
                                    const isDefault = (!q0) || (q0 === String(oldLen)) || (q0 === `${oldLen}/${oldLen}`);
                                    if (isDefault) lane.quant = String(newLen);
                                    const q = parseLaneQuant(lane.quant, newLen);
                                    const D = Math.max(1, Math.min(64, q.D|0));
                                    lane.steps = remapArr(lane.steps, D, false);
                                    lane.vel = remapArr(lane.vel, D, true);
                                }
                                st.len = newLen;
                                st.lanes = lanes.slice(0,9);
                                inst.state = st;
                                inst.len = newLen;
                            };

                            // If the shared editor has a pending length change, queue it on the active instance.
                            try {
                                const grid = document.getElementById('drumGrid');
                                const activeId = window._activeDrumInstanceId;
                                if (grid && activeId && grid.dataset && grid.dataset.pendingLength) {
                                    const inst = instances.find(x=>x && x.id === activeId);
                                    if (inst) inst.pendingLen = clampLen(grid.dataset.pendingLength);
                                    try { delete grid.dataset.pendingLength; } catch(_){ grid.dataset.pendingLength = ''; }
                                }
                            } catch(_){ }

                            // Strict gating: if DRUMS module is off, do not trigger any drum hits (audio or MIDI)
                            let __DRUMS_ACTIVE__ = true;
                            try {
                                const drumsBtn = document.getElementById('drumsBtn');
                                __DRUMS_ACTIVE__ = !!(drumsBtn && drumsBtn.classList.contains('active'));
                            } catch(_) { __DRUMS_ACTIVE__ = true; }

                            const triggerLane = (rowIdx, lane, laneStepIdx)=>{
                                if (!__DRUMS_ACTIVE__) return;
                                if (!lane || !lane.steps) return;
                                if (!lane.steps[laneStepIdx]) return;
                                const stepVel = Math.max(0, Math.min(127, parseInt((lane.vel && lane.vel[laneStepIdx]) || '100', 10) || 100));
                                const velFactor = stepVel / 127;
                                const vol = Math.max(0, Math.min(1, (parseInt(lane.vol||'80',10)||80) / 100));
                                const finalVol = vol * velFactor;
                                const legacyFx = (typeof lane.fx === 'boolean') ? lane.fx : false;
                                const send = (typeof lane.send === 'number') ? lane.send : (legacyFx ? 1 : 0);
                                const laneParams = {
                                    pitch: parseInt(lane.pitch||0,10) || 0,
                                    attackMs: parseFloat(lane.atk||2) || 2,
                                    decayMs: parseFloat(lane.dec||180) || 180,
                                };
                                try { this._triggerDrumSound(rowIdx|0, finalVol, send, laneParams); } catch(_){ }
                                try {
                                    if (!__DRUMS_ACTIVE__) return;
                                    const midi = window.midi;
                                    if (midi && midi.enabled && rowIdx < 9) {
                                        const midiNote = this._parseMidiNoteName(String(lane.midi||'').trim());
                                        if (Number.isFinite(midiNote)) {
                                            const ch = (midi.channelMap && (midi.channelMap.drum||midi.channelMap.default||6))|0;
                                            const outSel = (typeof midi.outputForSource === 'function') ? midi.outputForSource('drum') : null;
                                            midi.sendNoteOn(midiNote, stepVel, ch, outSel);
                                            setTimeout(()=>{ try { midi.sendNoteOff(midiNote, ch, outSel); } catch(_){} }, 120);
                                        }
                                    }
                                } catch(_){ }
                            };

                            // Drive each drum instance.
                            for (let k=0;k<instances.length;k++){
                                const inst = instances[k];
                                if (!inst) continue;
                                if (!inst.state) inst.state = { len: clampLen(inst.len||16), lanes: [] };
                                if (!Number.isFinite(inst.len)) inst.len = clampLen(inst.state.len||16);
                                if (inst.state && inst.state.len !== inst.len) inst.state.len = inst.len;

                                if (!Array.isArray(inst._lastLaneSteps) || inst._lastLaneSteps.length !== 9) {
                                    inst._lastLaneSteps = new Array(9).fill(-1);
                                }

                                // Arm-on-create/unmute: align to next Beat 1.
                                if (inst.startAtBarIndex != null) {
                                    if (barIndex < inst.startAtBarIndex || (barIndex === inst.startAtBarIndex && curTick !== 0)) {
                                        continue;
                                    }
                                    inst.startAtBarIndex = null;
                                    inst._lastStep = -1;
                                    inst._lastLaneSteps = new Array(9).fill(-1);
                                }

                                // If never started, align cycle start to the next Beat 1.
                                // Beat 1 is king: apply any queued changes only at the next bar boundary.
                                if (curTick === 0) {
                                    if (inst.pendingLen != null) {
                                        applyLenToState(inst, inst.pendingLen);
                                        inst.pendingLen = null;
                                        try { window._updateDrumInstanceButtonVisual && window._updateDrumInstanceButtonVisual(inst); } catch(_){ }
                                        try { if (window._activeDrumInstanceId === inst.id) window._syncDrumEditorToActiveInstance && window._syncDrumEditorToActiveInstance(); } catch(_){ }
                                    }
                                    if (inst.pendingEnabled != null) {
                                        inst.enabled = !!inst.pendingEnabled;
                                        inst.pendingEnabled = null;
                                        // On unmute, re-align this drum to the global Beat 1.
                                        if (inst.enabled) {
                                            inst._lastStep = -1;
                                            inst._lastLaneSteps = new Array(9).fill(-1);
                                        }
                                        try { window._updateDrumInstanceButtonVisual && window._updateDrumInstanceButtonVisual(inst); } catch(_){ }
                                    }
                                }
                                if (!inst.enabled) continue;

                                const st = inst.state;
                                const lanes = (st && Array.isArray(st.lanes)) ? st.lanes : [];
                                for (let rowIdx=0; rowIdx<9; rowIdx++){
                                    const lane = lanes[rowIdx];
                                    if (!lane) continue;
                                    const q = parseLaneQuant(lane.quant, clampLen(inst.len||16));
                                    const D = Math.max(1, Math.min(64, q.D|0));
                                    const N = Math.max(1, Math.min(D, q.N|0));
                                    const laneStepIdx = Math.max(0, Math.min(D-1, Math.floor(frac * D + 1e-9)));

                                    // Fire only when the lane step advances.
                                    if (inst._lastLaneSteps[rowIdx] === laneStepIdx) continue;
                                    inst._lastLaneSteps[rowIdx] = laneStepIdx;

                                    // Enforce N notes across D divisions (evenly spaced), matching legacy DRUMS gating.
                                    let allow = true;
                                    if (N < D) {
                                        const kf = (laneStepIdx * N) / D;
                                        const nearestK = Math.floor(kf + 1e-9);
                                        const idxAllowed = Math.max(0, Math.min(D-1, Math.floor((nearestK * D) / N)));
                                        allow = (idxAllowed === laneStepIdx);
                                    }
                                    if (!allow) continue;

                                    triggerLane(rowIdx, lane, laneStepIdx);

                                    // Visual pulse on the active editor grid only (matches what user is seeing).
                                    try {
                                        if (inst && inst.id && window._activeDrumInstanceId === inst.id) {
                                            const laneEl = document.querySelector(`#drumGrid .drum-lane[data-row="${rowIdx}"]`);
                                            const stepEl = laneEl ? laneEl.querySelector(`.drum-step[data-step="${laneStepIdx}"]`) : null;
                                            if (stepEl) window._pulseStepEl && window._pulseStepEl(stepEl);
                                        }
                                    } catch(_){ }
                                }
                            }

                            // Drive editor playhead for the active instance (visual only).
                            try {
                                const active = instances.find(x=>x && x.id === window._activeDrumInstanceId);
                                const grid = document.getElementById('drumGrid');
                                if (active && grid) {
                                    const lanesEl = grid.querySelectorAll('.drum-lane');
                                    lanesEl.forEach((laneEl, idx)=>{
                                        const ph = laneEl.querySelector('.drum-playhead');
                                        if (!ph) return;
                                        const q = parseLaneQuant(laneEl.dataset.quant, clampLen(active.len||16));
                                        const D = Math.max(1, Math.min(64, q.D|0));
                                        const laneStepIdx = Math.max(0, Math.min(D-1, Math.floor(frac * D + 1e-9)));
                                        ph.style.left = ((laneStepIdx / D) * 100) + '%';
                                    });
                                }
                            } catch(_){ }

                            return; // multi-instance handled
                        }
                    } catch(_){ }

                    // At bar boundary, apply either manual override (highest precedence) or mapped pattern from active column
                    if (curTick === 0) {
                        if (this._drumPendingPattern != null) {
                            try {
                                const n = Math.max(1, parseInt(this._drumPendingPattern,10) || 1);
                                const patEl = document.getElementById('drumPatternNumber');
                                if (patEl) {
                                    patEl.value = String(n);
                                    patEl.dispatchEvent(new Event('change', { bubbles: true }));
                                }
                            } catch(_) {}
                            this._drumPendingPattern = null;
                        } else {
                            // No manual override: use mapped value from the currently active column if present
                            try {
                                const col = (this._arp?.column) || this.currentActiveColumnEl || document.querySelector('.extension-column');
                                const mapped = col ? parseInt(col.dataset.drumPattern || '', 10) : NaN;
                                if (Number.isFinite(mapped)) {
                                    const patEl = document.getElementById('drumPatternNumber');
                                    if (patEl && String(patEl.value) !== String(mapped)) {
                                        patEl.value = String(mapped);
                                        patEl.dispatchEvent(new Event('change', { bubbles: true }));
                                    }
                                }
                            } catch(_) {}
                        }
                        // Pattern transport is now fully independent; do NOT resync at bar boundaries
                        // This preserves free pattern lengths (e.g., LEN=11) so the playhead loops at LEN, not 16.
                        // Intentionally no-op here.
                        try { /* no-op: independence preserved */ } catch(_) {}
                    }
                    const stepIdx = Math.floor((curTick / tpBar) * steps) | 0;
                    if (!this._drums) this._drums = { stepsPerBar: steps, lastStep: -1 };
                    else this._drums.stepsPerBar = steps;

                    // Move playheads per-lane using each lane's D against global bar fraction
                    const lanes = document.querySelectorAll('.drum-lane');
                    if (lanes && lanes.length){
                        const frac = (curTick / tpBar); // 0..1 across bar
                        // Normalize bar width visually to the max denominator among lanes.
                        // When Q introduces odd denominators (e.g. 17), ticksPerBar can be large; avoid per-tick layout work.
                        if (curTick === 0 || this._drums._cachedMaxD == null) {
                            try {
                                let maxD = steps;
                                lanes.forEach(lane => {
                                    const qStr = lane.dataset.quant || '';
                                    let D = steps;
                                    if (qStr){
                                        const m = qStr.match(/^(\d+)\/(\d+)$/);
                                        if (m){ const d = parseInt(m[2],10); if (Number.isFinite(d) && d>0) D = d; }
                                        else { const mn = qStr.match(/^(\d+)$/); if (mn){ const d=parseInt(mn[1],10); if (Number.isFinite(d)&&d>0) D=d; } }
                                    }
                                    if (D > maxD) maxD = D;
                                });
                                if (this._drums._cachedMaxD !== maxD) {
                                    this._drums._cachedMaxD = maxD;
                                    document.querySelectorAll('.drum-grid-container').forEach(c => c.style.setProperty('--bar-steps', String(maxD)));
                                    const pGrid = document.getElementById('patternGrid');
                                    if (pGrid) pGrid.style.setProperty('--bar-steps', String(maxD));
                                    try { this._autoSizePatternModals && this._autoSizePatternModals(maxD); } catch(_) {}
                                }
                            } catch(_) {}
                        }
                        lanes.forEach(lane => {
                            // Determine lane quantization D (fallback to global steps)
                            const qStr = lane.dataset.quant || '';
                            let D = steps;
                            if (qStr){
                                const m = qStr.match(/^(\d+)\/(\d+)$/);
                                if (m) { const d = parseInt(m[2],10); if (Number.isFinite(d) && d>0) D = d; }
                                else { const mn = qStr.match(/^(\d+)$/); if (mn){ const d=parseInt(mn[1],10); if (Number.isFinite(d)&&d>0) D=d; } }
                            }
                            // compute local step and left%
                            const localStep = Math.max(0, Math.min(D-1, Math.floor(frac * D)));
                            try {
                                if (lane._lastD !== D) {
                                    lane.style.setProperty('--steps-per-bar', String(D));
                                    lane._lastD = D;
                                }
                            } catch(_){ }
                            const ph = lane.querySelector('.drum-playhead');
                            if (ph) ph.style.left = ((localStep / D) * 100) + '%';
                        });
                    }

                    // Pattern handling removed from transport tick: pattern transport is fully independent
                    try { /* no-op: pattern loop is driven by independent transport */ } catch(_){}

                    // For each lane, compute lane-local step from N/D and trigger if that lane's step changed; handle BASS separately
                    // Strict gating: if DRUMS not active, do not trigger any drum hits
                    try {
                        const drumsBtn = document.getElementById('drumsBtn');
                        var __DRUMS_ACTIVE__ = !!(drumsBtn && drumsBtn.classList.contains('active'));
                        if (!__DRUMS_ACTIVE__) { /* gated */ }
                    } catch(_) { var __DRUMS_ACTIVE__ = true; }
                    lanes.forEach((lane, rowIdx) => {
                        const qStr = lane.dataset.quant || '';
                        let N = steps, D = steps;
                        if (qStr){ const m = qStr.match(/^(\d+)\/(\d+)$/); if (m){ const n=parseInt(m[1],10), d = parseInt(m[2],10); if (Number.isFinite(d) && d>0) D = d; if (Number.isFinite(n) && n>0) N = Math.min(n, D); } else { const mn=qStr.match(/^(\d+)$/); if (mn){ const d=parseInt(mn[1],10); if(Number.isFinite(d)&&d>0) { D=d; N=d; } } } }
                        const frac = (curTick / tpBar);
                        // Compute lane-local step from continuous bar fraction to support clamped ticksPerBar
                        const laneStepIdx = Math.max(0, Math.min(D-1, Math.floor(frac * D + 1e-9)));
                        // Enforce N notes per bar by only allowing evenly spaced indices
                        let allow = true;
                        if (N < D) {
                            const kf = (laneStepIdx * N) / D; // which segment we're in
                            const nearestK = Math.floor(kf + 1e-9);
                            const idxAllowed = Math.max(0, Math.min(D-1, Math.floor((nearestK * D) / N)));
                            allow = (idxAllowed === laneStepIdx);
                        }
                        // Fire only when the lane's step index changes (one trigger per step)
                        if (lane._lastStep == null) lane._lastStep = -1;
                        if (lane._lastStep === laneStepIdx) return;
                        lane._lastStep = laneStepIdx;
                        if (!__DRUMS_ACTIVE__) return;
                        if (!allow) return;
                        const stepEl = lane.querySelector(`.drum-step[data-step="${laneStepIdx}"]`);
                        const rowEl = lane.closest('.drum-row');
                        const volEl = rowEl ? rowEl.querySelector('.drum-volume') : null;
                        const sendEl = rowEl ? rowEl.querySelector('.drum-send') : null;
                        const fxEl = rowEl ? rowEl.querySelector('.drum-fx input[type="checkbox"]') : null;
                        const vol = volEl ? Math.max(0, Math.min(1, parseInt(volEl.value||'80',10)/100)) : 0.8;
                        const sendPct = sendEl ? (parseInt(sendEl.value||'0',10) || 0) : (fxEl && fxEl.checked ? 100 : 0);
                        const send = Math.max(0, Math.min(1, sendPct/100));

                        // Skip bass processing here - it's now handled separately from bass modal
                        if (stepEl && stepEl.classList.contains('active')){
                            // Get step velocity (0-127), convert to 0-1 range for volume
                            const stepVel = parseInt(stepEl.dataset.vel || '100', 10);
                            const velFactor = stepVel / 127;
                            const finalVol = vol * velFactor;
                            // Fire internal synth with velocity-adjusted volume
                            this._triggerDrumSound(rowIdx|0, finalVol, send);
                            try { window._pulseStepEl && window._pulseStepEl(stepEl); } catch(_){ }
                            // Also mirror per-lane MIDI if provided
                            try {
                                const midi = window.midi; if (midi && midi.enabled && rowIdx < 9) {
                                    const ctrls = lane._controls || {};
                                    const noteStr = (ctrls.midiInput?.value||'').trim();
                                    const midiNote = this._parseMidiNoteName(noteStr);
                                    if (Number.isFinite(midiNote)) {
                                        const vel = stepVel; // Use step velocity directly for MIDI
                                        const ch = (midi.channelMap && (midi.channelMap.drum||midi.channelMap.default||6))|0;
                                        const outSel = (typeof midi.outputForSource === 'function') ? midi.outputForSource('drum') : null;
                                        midi.sendNoteOn(midiNote, vel, ch, outSel);
                                        setTimeout(()=>{ try { midi.sendNoteOff(midiNote, ch, outSel); } catch(_){} }, 120);
                                    }
                                }
                            } catch(_){}
                        }
                    });

                    // *** BASS: Follow bass modal per-lane quantization with bar-synchronous resampling ***
                    try {
                        const bassBtn = document.getElementById('bassBtn');
                        const isBassEnabled = bassBtn && bassBtn.classList.contains('active');
                        // Avoid per-tick logging; it causes audio glitches at high tick rates
                        if (isBassEnabled) {
                            const bassGrid = document.getElementById('bassGrid');
                            if (bassGrid) {
                                const frac = (curTick / tpBar);
                                // Hard bass fence at bar start to prevent stuck notes
                                if (curTick === 0) {
                                    // Cancel any pending bass gate timer before clearing voices
                                    try {
                                        if (this._bassGateTimer) {
                                            clearTimeout(this._bassGateTimer);
                                            this._bassGateTimer = null;
                                        }
                                    } catch(_){ }
                                    try { this.stopAllActiveNotes && this.stopAllActiveNotes('bass'); } catch(_){ }
                                }
                                // Build or update target-resolution tokens at bar start
                                if (curTick === 0 || !bassGrid._tokensTarget) {
                                    try {
                                        const lanes = Array.from(bassGrid.querySelectorAll('.bass-lane'));
                                        // Determine target denominator as LCM of all row denominators for accurate polyrhythms
                                        const gcd = (a,b)=> b ? gcd(b, a % b) : Math.abs(a);
                                        const lcm2 = (a,b)=> Math.abs(a*b) / Math.max(1, gcd(a,b));
                                        let D_max = 1;
                                        let D_target = 1;
                                        lanes.forEach(ln => {
                                            let d = Array.from(ln.querySelectorAll('.bass-step')).length || 16;
                                            const qs = ln.dataset.quant||'';
                                            const m = qs.match(/^(\d+)\/(\d+)$/);
                                            if (m) { const dd = parseInt(m[2],10); if (Number.isFinite(dd) && dd>0) d = dd; }
                                            else { const mn = qs.match(/^(\d+)$/); if (mn){ const dd=parseInt(mn[1],10); if (Number.isFinite(dd) && dd>0) d = dd; } }
                                            d = Math.max(1, Math.min(64, d|0));
                                            D_max = Math.max(D_max, d);
                                            D_target = lcm2(D_target, d);
                                        });
                                        // Cap target resolution to avoid huge arrays; gracefully degrade to nearest feasible under 64
                                        const CAP = 64;
                                        if (D_target > CAP) {
                                            // Prefer highest single-row D if it fits, else fall back to CAP
                                            D_target = (D_max <= CAP) ? D_max : CAP;
                                        }
                                        // Resample all rows into target tokens using each row's own D
                                        const tokensTarget = new Array(D_target).fill('x');
                                        for (let row=0; row<lanes.length; row++){
                                            const stepsRow = Array.from(lanes[row].querySelectorAll('.bass-step'));
                                            const D_row = Math.max(1, stepsRow.length || 16);
                                            let i = 0;
                                            while (i < D_row) {
                                                const cell = stepsRow[i];
                                                if (cell && cell.classList.contains('active')){
                                                    const npc = (9 - row);
                                                    let len = parseInt(cell.dataset.len||'1',10)||1;
                                                    if (!cell.dataset.len){
                                                        let j = i + 1; while (j < D_row && stepsRow[j] && stepsRow[j].dataset.tie==='1'){ j++; }
                                                        len = Math.max(1, j - i);
                                                    }
                                                    const startFrac = i / D_row;
                                                    const endFrac = Math.min(D_row, i + len) / D_row;
                                                    const k0 = Math.floor(startFrac * D_target);
                                                    const k1 = Math.max(k0 + 1, Math.floor(endFrac * D_target));
                                                    if (tokensTarget[k0] === 'x' || tokensTarget[k0] === '-') tokensTarget[k0] = String(npc);
                                                    for (let k = k0 + 1; k < k1; k++) { if (tokensTarget[k] === 'x') tokensTarget[k] = '-'; }
                                                    i += len; // skip over this sustained region
                                                } else {
                                                    i++;
                                                }
                                            }
                                        }
                                        bassGrid._tokensTarget = tokensTarget;
                                        bassGrid._Dtarget = D_target;
                                        bassGrid._lastLocalStep = -1; // resync
                                        try { console.log('[BASS] Built tokens at bar start: D_target=', D_target, 'tokens=', tokensTarget.join('')); } catch(_){ }
                                    } catch(_) { /* ignore */ }
                                }
                                const tokens = Array.isArray(bassGrid._tokensTarget) ? bassGrid._tokensTarget : [];
                                const D_bass = Number.isFinite(bassGrid._Dtarget) ? bassGrid._Dtarget : Math.max(1, tokens.length||16);
                                // Advance and trigger on target step changes
                                const localStep = Math.max(0, Math.min(D_bass-1, Math.floor(frac * D_bass + 1e-9)));
                                if (bassGrid._lastLocalStep == null) bassGrid._lastLocalStep = -1;
                                if (bassGrid._lastLocalStep !== localStep) {
                                    bassGrid._lastLocalStep = localStep;
                                    const bassToken = tokens[localStep];
                                    try { console.log('[BASS] step', localStep, '/', D_bass, 'token=', bassToken); } catch(_){ }
                                    if (bassToken && bassToken !== 'x' && bassToken !== '-') {
                                        const npc = parseInt(bassToken, 10);
                                        if (Number.isFinite(npc) && npc >= 1 && npc <= 9) {
                                            const col = (this._arp?.column) || this.currentActiveColumnEl || document.querySelector('.extension-column');
                                            const edo = this.currentTuning||12;
                                            const norm = (x)=> ((x%edo)+edo)%edo;
                                            const rootAbs = (typeof this._getEffectiveColumnRootStep === 'function' && col) ? this._getEffectiveColumnRootStep(col) : (this.currentRoot||0);
                                            let rel = [];
                                            try {
                                                const rows = Array.from(col.querySelectorAll('.strings-column .string'));
                                                const steps = rows.map(r=> parseInt(r.dataset.noteIndex,10)).filter(n=>Number.isFinite(n));
                                                const uniqRel = Array.from(new Set(steps.map(st=> norm(st - rootAbs))));
                                                if (typeof this.stepToSemitone === 'function') {
                                                    rel = uniqRel.sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo));
                                                } else { rel = uniqRel.sort((a,b)=> a-b); }
                                            } catch(_) { rel = []; }
                                            const step = this._npcToChordStep(npc, rel);
                                            if (Number.isFinite(step)) {
                                                const uniq = Array.isArray(rel) ? rel.map(norm).sort((a,b)=>a-b).filter((v,i,a)=> i===0 || a[i-1]!==v) : [];
                                                const cycle = (uniq.length>0) ? Math.floor((Math.max(1,npc)-1)/uniq.length) : 0;
                                                const abs = norm(rootAbs + step);
                                                const baseOct = Math.max(1, Math.min(3, 1 + cycle));
                                                const f = this.getFrequency(abs, baseOct, edo);
                                                // Count sustain dashes from current target index
                                                let noteLength = 1; for (let j = localStep + 1; j < tokens.length; j++){ if (tokens[j] === '-') noteLength++; else break; }
                                                // Before starting a new bass note at this step, stop any existing bass voices to avoid persistence
                                                try {
                                                    if (this._bassGateTimer) {
                                        					clearTimeout(this._bassGateTimer);
                                        					this._bassGateTimer = null;
                                        				}
                                                } catch(_){ }
                                                try { this.stopAllActiveNotes && this.stopAllActiveNotes('bass'); } catch(_){ }
                                                // Optionally duck as well for residual tails
                                                try { this._duckExistingBassVoices(f, 25, 0.12); } catch(_){ }
                                                this.playFrequency(f, null, 'bass');
                                                const barMs = (this._arpTransport.beatMs||500) * (this._arpTransport.beatsPerBar||4);
                                                const gateMs = Math.max(10, Math.floor((barMs / D_bass) * noteLength * 0.95));
                                                try { console.log('[BASS] play f=', f.toFixed ? f.toFixed(2) : f, 'lenSteps=', noteLength, 'gateMs=', gateMs); } catch(_){ }
                                                // Monophonic bass: use a single shared gate timer that always stops the current bass voice
                                                try {
                                                    if (this._bassGateTimer) {
                                                        clearTimeout(this._bassGateTimer);
                                                        this._bassGateTimer = null;
                                                    }
                                                } catch(_){ }
                                                try {
                                                    this._bassGateTimer = setTimeout(()=>{
                                                        try {
                                                            this._bassGateTimer = null;
                                                            this.stopAllActiveNotes && this.stopAllActiveNotes('bass');
                                                            console.log('[BASS] gate timeout  stopAllActiveNotes(bass)');
                                                        } catch(_){ }
                                                    }, gateMs);
                                                } catch(_){ }
                                            }
                                        }
                                    }
                                }
                                // '-' and 'x' do nothing
                            }
                        }
                        else {
                            // If bass is disabled, ensure no running bass voices (and timers) persist
                            try {
                                if (this._bassGateTimer) {
                                    clearTimeout(this._bassGateTimer);
                                    this._bassGateTimer = null;
                                }
                            } catch(_){ }
                            try { this.stopAllActiveNotes && this.stopAllActiveNotes('bass'); console.log('[BASS] Disabled: stopped all bass voices'); } catch(_){ }
                        }
                    } catch(_) { /* ignore bass errors */ }
                } catch(_) { /* ignore */ }
            }

            // Map NPC number (1=root, 2=third, 3=fifth, etc.) to chord relative step
            _npcToChordStep(npc, chordRelSteps){
                try {
                    const rel = Array.isArray(chordRelSteps) ? chordRelSteps.slice() : [];
                    if (!rel.length || !Number.isFinite(npc) || npc <= 0) return null;
                    // Sort by ascending within octave, unique by value
                    const edo = this.currentTuning || 12;
                    const norm = (x)=> ((x%edo)+edo)%edo;
                    const uniq = [];
                    rel.map(norm).sort((a,b)=>a-b).forEach(v=>{ if (!uniq.includes(v)) uniq.push(v); });
                    if (!uniq.length) return null;
                    // Map 1â†’0th, 2â†’1st, 3â†’2nd... wrap around for numbers beyond chord size
                    const idx = (npc - 1) % uniq.length;
                    return uniq[idx];
                } catch(_) { return null; }
            }

            _isDrumPreviewAllowed(){
                try {
                    // If DRUMS module is off, never preview.
                    const drumsBtn = document.getElementById('drumsBtn');
                    if (drumsBtn && !drumsBtn.classList.contains('active')) return false;

                    // If multi-instance drums exist, honor the active instance enabled state.
                    const insts = window._drumInstances || [];
                    if (insts && insts.length) {
                        const activeId = window._activeDrumInstanceId;
                        const inst = activeId ? insts.find(x=>x && x.id === activeId) : null;
                        if (inst) {
                            const effectiveEnabled = (inst.pendingEnabled != null) ? !!inst.pendingEnabled : !!inst.enabled;
                            if (!effectiveEnabled) return false;
                        }
                    }
                } catch(_){ return true; }
                return true;
            }

            // Read per-lane drum parameters (pitch semis, attack/decay ms)
            _getDrumLaneParams(rowIdx){
                try {
                    const lane = document.querySelector(`.drum-lane[data-row="${rowIdx}"]`);
                    const ctrls = lane ? (lane._controls||{}) : {};
                    const pitch = Math.max(-24, Math.min(24, parseInt(ctrls.pPitch?.value)||0));
                    const attackMs = Math.max(0, Math.min(200, parseInt(ctrls.pAtk?.value)||2));
                    const decayMs = Math.max(5, Math.min(2000, parseInt(ctrls.pDec?.value)||180));
                    return { pitch, attackMs, decayMs };
                } catch(_) { return { pitch:0, attackMs:2, decayMs:180 }; }
            }

            async _triggerDrumSound(rowIdx, volume=0.8, send=0, laneParams=null){
                try {
                    const ok = await this.ensureAudioContext(); if (!ok) return;
                    const ac = this.audioContext; if (!ac) return;

                    // Output mixer for this hit
                    const outGain = ac.createGain();
                    const mainVol = (this.volume || 1);
                    const master = (this.masterVolume || 1);
                    outGain.gain.value = Math.max(0, Math.min(1, volume)) * mainVol * master;

                    // Voice tracking container so STOP can silence immediately
                    const voice = { env: null, out: outGain, sources: [] };

                    // Voice graph per lane type
                    let sourceNode = null;
                    let postNode = outGain; // final node before routing

                    const now = ac.currentTime;
                    const env = ac.createGain(); env.gain.value = 0; env.connect(outGain);
                    voice.env = env;

                    const makeNoise = () => this.createNoiseSource();

                    // Per-lane parameters
                    const lp = laneParams && typeof laneParams === 'object' ? laneParams : null;
                    const p0 = lp && Number.isFinite(lp.pitch) ? lp.pitch : null;
                    const a0 = lp && Number.isFinite(lp.attackMs) ? lp.attackMs : null;
                    const d0 = lp && Number.isFinite(lp.decayMs) ? lp.decayMs : null;
                    const fromUI = this._getDrumLaneParams(rowIdx);
                    const pitch = (p0 != null) ? p0 : fromUI.pitch;
                    const attackMs = (a0 != null) ? a0 : fromUI.attackMs;
                    const decayMs = (d0 != null) ? d0 : fromUI.decayMs;
                    const att = Math.max(0.001, attackMs/1000);
                    const dec = Math.max(0.03, decayMs/1000);
                    const ratio = Math.pow(2, (pitch||0)/12);
                    const endAt = (extra=0)=> now + att + dec + extra;

                    if (rowIdx === 0){
                        // KICK: decaying sine with quick pitch drop
                        const osc = ac.createOscillator();
                        osc.type = 'sine';
                        const startF = 120 * ratio; const endF = 45 * ratio; const dur = Math.min(dec, 0.25);
                        osc.frequency.setValueAtTime(startF, now);
                        osc.frequency.exponentialRampToValueAtTime(Math.max(20, endF), now + dur);
                        const g = ac.createGain(); g.gain.value = 1;
                        osc.connect(g); g.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = osc; postNode = outGain;
                        voice.sources.push(osc);
                        osc.start(now); osc.stop(endAt(0.1));
                    } else if (rowIdx === 1){
                        // SNARE: noise burst + faint tone
                        const noise = makeNoise();
                        const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1800; bp.Q.value=0.6;
                        noise.connect(bp); bp.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = noise; voice.sources.push(noise); sourceNode.start(); noise.stop(endAt(0.1));
                        // add a quiet body
                        const osc = ac.createOscillator(); osc.type='sine'; osc.frequency.setValueAtTime(180 * ratio, now);
                        const g = ac.createGain(); g.gain.value = 0.25; osc.connect(g); g.connect(env);
                        voice.sources.push(osc);
                        osc.start(now); osc.stop(endAt(0.05));
                    } else if (rowIdx === 2){
                        // CLOSED HAT: highpassed noise short
                        const noise = makeNoise();
                        const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=8000; hp.Q.value=0.7;
                        noise.connect(hp); hp.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = noise; voice.sources.push(noise); sourceNode.start(); noise.stop(endAt(0.05));
                    } else if (rowIdx === 3){
                        // OPEN HAT: longer noise
                        const noise = makeNoise();
                        const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000; hp.Q.value=0.7;
                        noise.connect(hp); hp.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = noise; voice.sources.push(noise); sourceNode.start(); noise.stop(endAt(0.1));
                    } else if (rowIdx === 4 || rowIdx === 5){
                        // TOM 1/2: pitch depends slightly on row
                        const base = (rowIdx===4? 220: 160) * ratio;
                        const osc = ac.createOscillator(); osc.type='sine';
                        osc.frequency.setValueAtTime(base*1.3, now);
                        osc.frequency.exponentialRampToValueAtTime(base, now + Math.min(dec, 0.24));
                        const g = ac.createGain(); g.gain.value=1; osc.connect(g); g.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = osc; voice.sources.push(osc); osc.start(now); osc.stop(endAt(0.1));
                    } else if (rowIdx === 6){
                        // CLAP: short wideband noise with quick pre-echo feel
                        const noise = makeNoise();
                        const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1600; bp.Q.value=0.9;
                        noise.connect(bp); bp.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = noise; voice.sources.push(noise); sourceNode.start(); noise.stop(endAt(0.05));
                    } else if (rowIdx === 7){
                        // CRASH: noisy, bright, long decay
                        const noise = makeNoise();
                        const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=4000; hp.Q.value=0.6;
                        noise.connect(hp); hp.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = noise; voice.sources.push(noise); sourceNode.start(); noise.stop(endAt(0.2));
                    } else if (rowIdx === 8){
                        // CLAVE: very short click
                        const osc = ac.createOscillator(); osc.type='square'; osc.frequency.setValueAtTime(1200 * ratio, now);
                        const g = ac.createGain(); g.gain.value = 0.4; osc.connect(g); g.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = osc; voice.sources.push(osc); osc.start(now); osc.stop(endAt(0.05));
                    }

                    // Insert a gentle DC-blocking highpass to avoid clicks/pops on abrupt loop boundaries
                    const dcBlock = ac.createBiquadFilter();
                    dcBlock.type = 'highpass';
                    dcBlock.frequency.value = 12; // ~12 Hz to remove DC/very low drift without thinning lows
                    outGain.connect(dcBlock);

                    // Route output: always dry â†’ drums out, plus optional SEND â†’ drum FX chain
                    const sendAmt = (typeof send === 'boolean')
                        ? (send ? 1 : 0)
                        : Math.max(0, Math.min(1, Number(send) || 0));

                    // Prefer dedicated drum bus; fallback to legacy routing if unavailable
                    const drumBus = this._drumBus;
                    if (drumBus && drumBus.drySum && drumBus.sendSum) {
                        // Dry always
                        dcBlock.connect(drumBus.drySum);
                        // Send is additive
                        const sendGain = ac.createGain();
                        sendGain.gain.value = sendAmt;
                        dcBlock.connect(sendGain);
                        sendGain.connect(drumBus.sendSum);
                        voice._sendGain = sendGain;
                    } else {
                        // Fallback: dry â†’ destination, send â†’ master FX input
                        if (!this.dryGainNode) {
                            this.dryGainNode = ac.createGain();
                            this.dryGainNode.connect(ac.destination);
                            this.dryGainNode.gain.value = this.masterVolume || 1;
                        }
                        dcBlock.connect(this.dryGainNode);
                        if (sendAmt > 0.0001 && this.gainNode) {
                            const sendGain = ac.createGain();
                            sendGain.gain.value = sendAmt;
                            dcBlock.connect(sendGain);
                            sendGain.connect(this.gainNode);
                            voice._sendGain = sendGain;
                        }
                    }

                    // Register voice and clean it up when all sources end
                    try {
                        const cleanup = () => {
                            try { env.disconnect(); } catch(_){}
                            try { outGain.disconnect(); } catch(_){}
                            try { dcBlock.disconnect(); } catch(_){ }
                            try { if (voice._sendGain) voice._sendGain.disconnect(); } catch(_){ }
                        };
                        let pending = voice.sources.length;
                        if (pending === 0) {
                            // No sources? nothing to track
                            return;
                        }
                        const onEnded = () => {
                            pending = Math.max(0, pending - 1);
                            if (pending === 0) {
                                this._activeDrumVoices.delete(voice);
                                cleanup();
                            }
                        };
                        voice.sources.forEach(s => { try { s.onended = onEnded; } catch(_){} });
                        this._activeDrumVoices.add(voice);
                    } catch(_) {}
                } catch(_) { /* ignore */ }
            }

            // Force-stop all drum voices immediately (used by STOP)
            stopAllDrums(){
                try {
                    const ac = this.audioContext;
                    const now = ac ? ac.currentTime : 0;
                    const voices = Array.from(this._activeDrumVoices || []);
                    voices.forEach(v => {
                        try {
                            if (v && v.env && v.env.gain) {
                                try { v.env.gain.cancelScheduledValues(now); } catch(_){ }
                                try { v.env.gain.setValueAtTime(v.env.gain.value || 0, now); } catch(_){ }
                                try { v.env.gain.linearRampToValueAtTime(0.0001, now + 0.01); } catch(_){ }
                            }
                            if (v && v.out && v.out.gain) {
                                try { v.out.gain.cancelScheduledValues(now); } catch(_){ }
                                try { v.out.gain.setValueAtTime(v.out.gain.value || 0, now); } catch(_){ }
                                try { v.out.gain.linearRampToValueAtTime(0.0001, now + 0.01); } catch(_){ }
                            }
                            (v.sources||[]).forEach(s => {
                                try { if (typeof s.stop === 'function') s.stop(now + 0.01); } catch(_){}
                                try { if (typeof s.disconnect === 'function') s.disconnect(); } catch(_){}
                                try { s.onended = null; } catch(_){}
                            });
                            try { if (v.env && typeof v.env.disconnect === 'function') v.env.disconnect(); } catch(_){}
                            try { if (v.out && typeof v.out.disconnect === 'function') v.out.disconnect(); } catch(_){}
                        } catch(_){}
                        try { this._activeDrumVoices.delete(v); } catch(_){}
                    });
                } catch(_) { }
            }

            _resetDrumPlayhead(){
                try {
                    if (this._drums) this._drums.lastStep = -1;
                    document.querySelectorAll('.drum-playhead').forEach(ph => { ph.style.left = '0%'; });
                } catch(_) { }
            }

            // After 500ms idle, arm editing so the next keyboard taps go into chordbox
            _scheduleEditArm() {
                clearTimeout(this._editArmTimer);
                this._editArmTimer = setTimeout(() => { this.editArmed = true; }, 500);
            }

            // After any change, debounce save by 500ms; saving here just refreshes header/strings
            _scheduleEditSave(column) {
                clearTimeout(this._editSaveTimer);
                this._editSaveTimer = setTimeout(() => {
                    try {
                        if (column) this.highlightKeyboardForColumn(column);
                    } catch {}
                }, 500);
            }

            // Compute a subtle vibration period in ms for a given frequency and step index
            // Uses audio period (1/f) clamped to sensible range and snaps roots to wavelength series 1,2,4,8,16,32,64,128 as slower pulses
            computeVibrationPeriod(freq, stepIndex = 0) {
                const baseMs = Math.max(12, Math.min(90, 1000 / Math.max(1, freq))); // 12â€“90ms
                // Treat exact roots (interval 0) specially if the EDO step index equals currentRoot
                // We can't know the interval reliably here in all contexts; as a proxy: if stepIndex % currentTuning == currentRoot treat as root
                try {
                    const isRootish = ((stepIndex % this.currentTuning) === (this.currentRoot % this.currentTuning));
                    if (isRootish) {
                        // Map to one of 1..128 multipliers but cap to a gentle 32x to avoid too slow visuals
                        const multipliers = [1,2,4,8,16,32];
                        const idx = Math.min(multipliers.length - 1, Math.floor((freq || 1) / 110));
                        return Math.round(baseMs * multipliers[idx]);
                    }
                } catch {}
                return Math.round(baseMs);
            }

            // Initialize standard chord types with proper musical symbols
            initializeStandardChordTypes() {
                return [
                    // Triads
                    { name: '', symbol: '', intervals: [0, 4, 7], description: 'Major triad' },
                    { name: 'm', symbol: 'm', intervals: [0, 3, 7], description: 'Minor triad' },
                    { name: 'Â°', symbol: 'Â°', intervals: [0, 3, 6], description: 'Diminished triad' },
                    { name: '+', symbol: '+', intervals: [0, 4, 8], description: 'Augmented triad' },
                    { name: 'sus2', symbol: 'sus2', intervals: [0, 2, 7], description: 'Suspended 2nd' },
                    { name: 'sus4', symbol: 'sus4', intervals: [0, 5, 7], description: 'Suspended 4th' },
                    
                    // Seventh chords
                    { name: '7', symbol: '7', intervals: [0, 4, 7, 10], description: 'Dominant 7th' },
                    { name: 'M7', symbol: 'Î”7', intervals: [0, 4, 7, 11], description: 'Major 7th' },
                    { name: 'm7', symbol: 'm7', intervals: [0, 3, 7, 10], description: 'Minor 7th' },
                    { name: 'mM7', symbol: 'mÎ”7', intervals: [0, 3, 7, 11], description: 'Minor major 7th' },
                    { name: 'Â°7', symbol: 'Â°7', intervals: [0, 3, 6, 9], description: 'Diminished 7th' },
                    { name: 'Ã¸7', symbol: 'Ã¸7', intervals: [0, 3, 6, 10], description: 'Half-diminished 7th' },
                    { name: '+7', symbol: '+7', intervals: [0, 4, 8, 10], description: 'Augmented 7th' },
                    
                    // Extended chords
                    { name: '9', symbol: '9', intervals: [0, 4, 7, 10, 14], description: 'Dominant 9th' },
                    { name: 'M9', symbol: 'Î”9', intervals: [0, 4, 7, 11, 14], description: 'Major 9th' },
                    { name: 'm9', symbol: 'm9', intervals: [0, 3, 7, 10, 14], description: 'Minor 9th' },
                    { name: '11', symbol: '11', intervals: [0, 4, 7, 10, 14, 17], description: 'Dominant 11th' },
                    { name: 'M11', symbol: 'Î”11', intervals: [0, 4, 7, 11, 14, 17], description: 'Major 11th' },
                    { name: 'm11', symbol: 'm11', intervals: [0, 3, 7, 10, 14, 17], description: 'Minor 11th' },
                    { name: '13', symbol: '13', intervals: [0, 4, 7, 10, 14, 17, 21], description: 'Dominant 13th' },
                    { name: 'M13', symbol: 'Î”13', intervals: [0, 4, 7, 11, 14, 17, 21], description: 'Major 13th' },
                    { name: 'm13', symbol: 'm13', intervals: [0, 3, 7, 10, 14, 17, 21], description: 'Minor 13th' },
                    
                    // Altered dominants
                    { name: '7â™­5', symbol: '7â™­5', intervals: [0, 4, 6, 10], description: 'Dominant 7 flat 5' },
                    { name: '7#5', symbol: '7â™¯5', intervals: [0, 4, 8, 10], description: 'Dominant 7 sharp 5' },
                    { name: '7â™­9', symbol: '7â™­9', intervals: [0, 4, 7, 10, 13], description: 'Dominant 7 flat 9' },
                    { name: '7#9', symbol: '7â™¯9', intervals: [0, 4, 7, 10, 15], description: 'Dominant 7 sharp 9' },
                    { name: '7â™­5â™­9', symbol: '7â™­5â™­9', intervals: [0, 4, 6, 10, 13], description: 'Dominant 7 flat 5 flat 9' },
                    { name: '7#5#9', symbol: '7â™¯5â™¯9', intervals: [0, 4, 8, 10, 15], description: 'Dominant 7 sharp 5 sharp 9' },
                    
                    // Add chords (no 3rd)
                    { name: 'add9', symbol: 'add9', intervals: [0, 4, 7, 14], description: 'Major add 9' },
                    { name: 'madd9', symbol: 'madd9', intervals: [0, 3, 7, 14], description: 'Minor add 9' },
                    { name: 'add11', symbol: 'add11', intervals: [0, 4, 7, 17], description: 'Major add 11' },
                    { name: 'madd11', symbol: 'madd11', intervals: [0, 3, 7, 17], description: 'Minor add 11' },
                    
                    // Slash chords (bass notes)
                    { name: '/3', symbol: '/3', intervals: [4, 0, 7], description: 'Major first inversion' },
                    { name: '/5', symbol: '/5', intervals: [7, 0, 4], description: 'Major second inversion' },
                    { name: 'm/â™­3', symbol: 'm/â™­3', intervals: [3, 0, 7], description: 'Minor first inversion' },
                    { name: 'm/5', symbol: 'm/5', intervals: [7, 0, 3], description: 'Minor second inversion' }
                ];
            }
            
            // Generate standard chord progressions for practice
            generateStandardChordProgression(rootNote = 'C', progressionType = 'ii-V-I') {
                const progressions = {
                    'ii-V-I': ['m7', '7', 'M7'],
                    'vi-IV-I-V': ['m', '', '', '7'],
                    'I-vi-IV-V': ['', 'm', '', '7'],
                    'blues': ['7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '7'],
                    'jazz-blues': ['M7', '7', 'M7', 'M7', '7', '7', 'M7', 'm7', 'm7', '7', 'M7', '7']
                };
                
                const progression = progressions[progressionType] || progressions['ii-V-I'];
                const chords = [];
                
                progression.forEach((chordSymbol, index) => {
                    const chordType = this.standardChordTypes.find(type => type.symbol === chordSymbol);
                    if (chordType) {
                        chords.push({
                            root: rootNote,
                            type: chordType,
                            symbol: rootNote + chordSymbol
                        });
                    }
                });
                
                return chords;
            }
            
            // Create basic chord set for beginners
            createBasicChordSet() {
                // User-requested basic chord set (only these, no others)
                const basicChords = [
                    { name: 'Major',        symbol: '',   intervals: [0,4,7],          description: 'Major triad' },
                    { name: 'Minor',        symbol: 'm',  intervals: [0,3,7],          description: 'Minor triad' },
                    { name: '7th',          symbol: '7',  intervals: [0,4,7,10],       description: 'Dominant 7th' },
                    { name: 'minor 7th',    symbol: 'm7', intervals: [0,3,7,10],       description: 'Minor 7th' },
                    { name: 'Major 7th',    symbol: 'M7', intervals: [0,4,7,11],       description: 'Major 7th' },
                    { name: '6th',          symbol: '6',  intervals: [0,4,7,9],        description: 'Major 6th' },
                    { name: '9th',          symbol: '9',  intervals: [0,4,7,10,14],    description: 'Dominant 9th' },
                    { name: 'sus4',         symbol: 'sus4', intervals:[0,5,7],         description: 'Suspended 4th' },
                    { name: 'sus2',         symbol: 'sus2', intervals:[0,2,7],         description: 'Suspended 2nd' },
                    { name: 'Diminished',   symbol: 'dim', intervals:[0,3,6],          description: 'Diminished triad' },
                    { name: 'Augmented',    symbol: 'aug', intervals:[0,4,8],          description: 'Augmented triad' }
                ];

                this.chordExtensions = basicChords.map(chord => ({
                    name: chord.name,
                    intervals: chord.intervals,
                    description: chord.description,
                    symbol: chord.symbol,
                    isCustom: false
                }));

                console.log('âœ“ Created requested basic chord set:', this.chordExtensions.length, 'chords');
                this.updateChordDisplay();
                this.generateExtensionColumns();
            }

            cleanupPaletteData() {
                // Clean up any corrupted palette chord data
                if (this.paletteChords && Array.isArray(this.paletteChords)) {
                    const originalLength = this.paletteChords.length;
                    this.paletteChords = this.paletteChords.filter(chord => {
                        return chord && typeof chord === 'object' && chord.name && chord.intervals;
                    });
                    
                    if (this.paletteChords.length !== originalLength) {
                        console.log('?? Cleaned up corrupted palette data:', originalLength, '->', this.paletteChords.length);
                    }
                } else {
                    console.log('?? Resetting corrupted palette data');
                    this.paletteChords = [];
                }
            }

            

            // =============================================================================
            // UNIFIED CHORD BUILDER MODULE - Single source of truth for all chord creation
            // =============================================================================
            
            initChordBuilder() {
                
                // New chord creation button â†’ WYSIWYG: spawn a blank editable column immediately
                document.getElementById('createNewChordBtn').addEventListener('click', () => {
                    try { this.createBlankChordColumn(); } catch (e) { console.error('Create blank chord failed:', e); }
                });
                // Insert [ and ] markers quickly
                const leftBtn = document.getElementById('insertLeftBracketBtn');
                if (leftBtn) leftBtn.addEventListener('click', () => {
                    const lvl = Math.max(0, parseInt(prompt('Nest level (0=outer, 1=inner,...):','0')||'0',10));
                    this.chordExtensions.push({
                        name: '[', isCustom: true, isRepeatMarker: true,
                        nestLevel: lvl, id: 'bracket_start_L'+lvl+'_'+Date.now(), position: this.chordExtensions.length
                    });
                    this.generateExtensionColumns();
                });
                const rightBtn = document.getElementById('insertRightBracketBtn');
                if (rightBtn) rightBtn.addEventListener('click', () => {
                    const lvl = Math.max(0, parseInt(prompt('Nest level to close (0=outer,1=inner,...):','0')||'0',10));
                    const countStr = prompt('Repeat count: 0 = infinite; leave blank for single (no repeat label)','2');
                    let count = null;
                    if (countStr !== null && countStr.trim() !== '') count = Math.max(0, parseInt(countStr,10)||0);
                    const marker = {
                        name: (count==null ? ']' : (count===0?']':`]x${count}`)),
                        isCustom: true, isRepeatMarker: true,
                        nestLevel: lvl, id: 'bracket_end_L'+lvl+'_'+Date.now(), position: this.chordExtensions.length
                    };
                    if (count!=null) marker.repeatCount = count;
                    this.chordExtensions.push(marker);
                    this.generateExtensionColumns();
                });
                
                
                // Reset chords button
                document.getElementById('resetChordsBtn').addEventListener('click', () => {
                    if (confirm('Clear all unlocked chords? This will remove only unlocked chords, preserving all locked chords.')) {
                        this.clearUnlockedChords();
                    }
                });
                
                // Save session button
                document.getElementById('saveSessionBtn').addEventListener('click', () => {
                    this.saveSessionToFile();
                });
                
                // Load session button
                document.getElementById('loadSessionBtn').addEventListener('click', () => {
                    document.getElementById('loadSessionInput').click();
                });
                
                // File input for loading sessions
                document.getElementById('loadSessionInput').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadSessionFromFile(file)
                            .then(() => {
                                alert('Session loaded successfully!');
                            })
                            .catch((error) => {
                                alert('Error loading session: ' + error.message);
                            });
                    }
                });
                
                // New transpose button event listeners
                document.getElementById('transposeUpBtn').addEventListener('click', () => {
                    try { this.applyTransposeStep(1); } catch(e) { console.error('Transpose up failed:', e); }
                });
                
                document.getElementById('transposeDownBtn').addEventListener('click', () => {
                    try { this.applyTransposeStep(-1); } catch(e) { console.error('Transpose down failed:', e); }
                });
                
                // Keyboard toggle functionality + Drum view toggle
                const keyboardToggle = document.getElementById('keyboardToggle');
                const keyboardToggleMenu = document.getElementById('keyboardToggleMenu');
                const drumsToggle = document.getElementById('drumsToggle');
                const drumsBtn = document.getElementById('drumsModuleBtn');
                const drumGridContainer = document.getElementById('drumGridContainer');
                const rootGrid = document.getElementById('rootGrid');
                
                const toggleKeyboard = (show) => {
                    const rootNotesArea = document.querySelector('.root-notes-area');
                    if (rootNotesArea) {
                        rootNotesArea.style.display = show ? 'block' : 'none';
                    }
                    // Sync both toggles
                    if (keyboardToggle) keyboardToggle.checked = show;
                    if (keyboardToggleMenu) keyboardToggleMenu.checked = show;
                };

                const showDrums = (on) => {
                    if (!drumGridContainer || !rootGrid) return;
                    if (on) {
                        // Ensure the section is visible when entering drums view
                        try { toggleKeyboard(true); } catch {}
                        try { if (this._drums) this._drums.lastStep = -1; } catch {}
                    }
                    drumGridContainer.style.display = on ? 'block' : 'none';
                    if (drumsToggle) drumsToggle.checked = on;
                    try {
                        document.body.classList.toggle('drums-mode', !!on);
                        if (on) {
                            // After render, scroll drum container to bottom so BASS row is visible
                            requestAnimationFrame(() => {
                                try {
                                    drumGridContainer.scrollTop = drumGridContainer.scrollHeight;
                                } catch(_) {}
                            });
                        }
                    } catch (_){ }
                };
                
                if (keyboardToggle) {
                    keyboardToggle.addEventListener('change', (e) => {
                        toggleKeyboard(e.target.checked);
                    });
                }
                
                if (keyboardToggleMenu) {
                    keyboardToggleMenu.addEventListener('change', (e) => {
                        toggleKeyboard(e.target.checked);
                    });
                }

                if (drumsToggle && !drumsToggle._wired) {
                    drumsToggle._wired = true;
                    drumsToggle.addEventListener('change', (e) => {
                        showDrums(!!e.target.checked);
                    });
                }

                if (drumsBtn && !drumsBtn._wired) {
                    drumsBtn._wired = true;
                    drumsBtn.addEventListener('click', () => {
                        // Toggle drums view on button click
                        const next = !(drumsToggle && drumsToggle.checked);
                        showDrums(next);
                    });
                }

                // PATTERN button toggling (shows pattern grid to the right without hiding drums)
                try {
                    const patternBtn = document.getElementById('patternModuleBtn');
                    const patternContainer = document.getElementById('patternGridContainer');
                    const drumsContainer = document.getElementById('drumGridContainer');
                    const wrapper = document.getElementById('rhythmGridsWrapper');
                    if (patternBtn && patternContainer && !patternBtn._wired) {
                        patternBtn._wired = true;
                        patternBtn.addEventListener('click', () => {
                            // Toggle pattern visibility
                            const visible = patternContainer.style.display !== 'none';
                            if (visible) {
                                patternContainer.style.display = 'none';
                                patternBtn.classList.remove('active');
                            } else {
                                patternContainer.style.display = 'block';
                                patternBtn.classList.add('active');
                                // Ensure drums visible too
                                try { showDrums(true); } catch(_){ }
                                // Scroll horizontally to show pattern grid if wrapper scrolls
                                try {
                                    if (wrapper) {
                                        requestAnimationFrame(()=>{
                                            wrapper.scrollTo({ left: wrapper.scrollWidth, behavior: 'smooth' });
                                        });
                                    }
                                } catch(_){ }
                            }
                        });
                        // Start hidden to keep original layout
                        patternContainer.style.display = 'none';
                    }
                } catch(_){ }

                // Derive pattern text from pattern grid (NPC rows 1-9) and keep universalPatternText updated (respect current LEN, hide tail)
                try {
                    const patternGrid = document.getElementById('patternGrid');
                    const patternTextEl = document.getElementById('universalPatternText');
                    if (patternGrid && patternTextEl && !patternGrid._patternSync) {
                        patternGrid._patternSync = true;
                        const recompute = () => {
                            try {
                                // Always populate pattern text when CUSTOM mode is selected
                                const universalPattern = document.getElementById('universalPattern');
                                if (!universalPattern || universalPattern.value !== 'custom') {
                                    // For non-CUSTOM modes, still update internal pattern but don't show in text field
                                    // This ensures pattern dots work correctly in all modes
                                }
                                
                                const lanes = Array.from(patternGrid.querySelectorAll('.pattern-lane'));
                                if (lanes.length < 9) return;
                                const npcLanes = lanes.slice(0,9);
                                const steps = Array.from(npcLanes[0].querySelectorAll('.pattern-step'));
                                const maxVisible = Math.max(1, Math.min(steps.length, parseInt(patternGrid.dataset.length||String(steps.length),10)||steps.length));
                                const tokens = [];
                                
                                // Track per-row note lengths for proper gate calculation
                                const rowNoteLengths = []; // rowNoteLengths[step][row] = length from this step
                                
                                for (let i=0;i<maxVisible;i++){
                                    const activeNums = [];
                                    const noteLengths = {}; // npc -> length
                                    let hasTieOnly = false;
                                    
                                    // Check all lanes for this step
                                    for (let idx=0; idx<npcLanes.length; idx++){
                                        const npcNum = 9-idx;
                                        const cell = npcLanes[idx].querySelector(`.pattern-step[data-step="${i}"]`);
                                        if (cell) {
                                            if (cell.classList.contains('active')) {
                                                // Found active note head - calculate its length
                                                const len = parseInt(cell.dataset.len || '1', 10);
                                                activeNums.push(npcNum);
                                                noteLengths[npcNum] = len;
                                            } else if (cell.dataset.tie === '1') {
                                                // Found tie (sustained note from previous step)
                                                // Don't add to activeNums - this note shouldn't be in the token
                                                hasTieOnly = true;
                                                noteLengths[npcNum] = 0; // Mark as tie for metadata
                                            }
                                        }
                                    }
                                    
                                    // Store note length info for this step
                                    rowNoteLengths[i] = noteLengths;
                                    
                                    // Output tokens: only active heads, NOT ties
                                    if (activeNums.length > 0) {
                                        // Has note heads
                                        if (activeNums.length === 1) {
                                            tokens.push(String(activeNums[0]));
                                        } else {
                                            tokens.push('['+activeNums.join(' ')+']');
                                        }
                                    } else if (hasTieOnly && activeNums.length === 0) {
                                        // Only ties, no heads - output 'x' or '-'
                                        // For tied steps, we output 'x' so the pattern length matches grid length
                                        // The playback will ignore these since there are no active heads
                                        tokens.push('x');
                                    } else {
                                        // Rest: output 'x'
                                        tokens.push('x');
                                    }
                                }
                                
                                // Store pattern internally for all modes
                                patternGrid._computedPattern = tokens.join(' ');
                                // Also store the length data for playback
                                patternGrid._noteLengthData = rowNoteLengths;
                                
                                // Only show in text field for CUSTOM mode
                                if (universalPattern && universalPattern.value === 'custom') {
                                    patternTextEl.value = tokens.join(' ');
                                } else {
                                    patternTextEl.value = ''; // Clear text field for non-CUSTOM modes
                                }
                            } catch(_){ }
                        };
                        patternGrid._recomputePatternText = recompute;
                        patternGrid.addEventListener('click', (e)=>{ 
                            if (e.target?.classList?.contains('pattern-step')) {
                                recompute();
                                // Autosave to current pattern slot
                                try { this._saveArpPattern && this._saveArpPattern(); } catch(_){}
                            }
                        });
                        patternBtn?.addEventListener('click', ()=> setTimeout(recompute,50));
                    }
                } catch(_){ }

                // Drum pattern number: clone on increment
                try {
                    const patNum = document.getElementById('drumPatternNumber');
                    if (patNum && !patNum._wired){
                        patNum._wired = true;
                        // Simple in-memory pattern store keyed by number
                        this._drumPatterns = this._drumPatterns || new Map();
                        const captureGrid = ()=>{
                            const lanes = Array.from(document.querySelectorAll('.drum-row:not(.bass-row) .drum-lane'));
                            return lanes.map(lane=>{
                                const steps = Array.from(lane.querySelectorAll('.drum-step')).map(s=> s.classList.contains('active') ? 1 : 0);
                                return steps;
                            });
                        };
                        const applyGrid = (gridArr)=>{
                            if (!Array.isArray(gridArr)) return;
                            const lanes = Array.from(document.querySelectorAll('.drum-row:not(.bass-row) .drum-lane'));
                            lanes.forEach((lane, i)=>{
                                const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                const row = gridArr[i] || [];
                                steps.forEach((s, j)=>{ if (row[j]) s.classList.add('active'); else s.classList.remove('active'); });
                            });
                        };
                        // Helper: immediate autosave to current slot
                        this._saveDrumPattern = () => {
                            try {
                                const n = Math.max(1, parseInt(document.getElementById('drumPatternNumber')?.value||'1',10));
                                this._drumPatterns.set(n, captureGrid());
                            } catch(_) {}
                        };
                        // Helper: duplicate current pattern to next empty slot and select it
                        this._duplicateCurrentDrumPattern = () => {
                            try {
                                const cur = Math.max(1, parseInt(document.getElementById('drumPatternNumber')?.value||'1',10));
                                this._drumPatterns.set(cur, captureGrid());
                                let target = null;
                                for (let k = cur+1; k <= 128; k++) { if (!this._drumPatterns.has(k)) { target = k; break; } }
                                if (!target) return;
                                const src = this._drumPatterns.get(cur) || captureGrid();
                                const cloned = JSON.parse(JSON.stringify(src));
                                this._drumPatterns.set(target, cloned);
                                const patEl = document.getElementById('drumPatternNumber');
                                if (patEl) {
                                    patEl.value = String(target);
                                    patEl.dispatchEvent(new Event('change', { bubbles: true }));
                                    patEl.title = `Duplicated â†’ ${target}`;
                                    patEl.style.outline = '2px solid #00d1b2';
                                    setTimeout(()=>{ try { patEl.style.outline=''; } catch(_){} }, 260);
                                }
                            } catch(_) {}
                        };
                        // Wire duplicate button
                        try {
                            const dupBtn = document.getElementById('drumDuplicateBtn');
                            if (dupBtn && !dupBtn._wired) { dupBtn._wired = true; dupBtn.addEventListener('click', (e)=>{ e.preventDefault(); try{ this._duplicateCurrentDrumPattern(); } catch(_){} }); }
                        } catch(_){}
                        // Initialize pattern 1 from current grid if empty
                        if (!this._drumPatterns.has(1)) this._drumPatterns.set(1, captureGrid());
                        patNum.addEventListener('change', (e)=>{
                            let v = parseInt(e.target.value,10); if(!Number.isFinite(v) || v<1) v=1; e.target.value=String(v);
                            const prev = this._lastDrumPatternNumber || 1;
                            // If increasing and new slot empty, clone from previous
                            if (v>prev && !this._drumPatterns.has(v)){
                                this._drumPatterns.set(v, JSON.parse(JSON.stringify(this._drumPatterns.get(prev) || captureGrid())));
                            } else {
                                // Before switching away, save current
                                this._drumPatterns.set(prev, captureGrid());
                            }
                            // Apply selected pattern
                            const patt = this._drumPatterns.get(v);
                            if (patt) applyGrid(patt);
                            this._lastDrumPatternNumber = v;
                        });
                        this._lastDrumPatternNumber = parseInt(patNum.value,10) || 1;
                    }
                } catch(_){ }

                // Pattern Editor pattern number: clone on increment (similar to drum pattern bank)
                try {
                    const patNum = document.getElementById('patternPatternNumber');
                    if (patNum && !patNum._wiredPatternBank){
                        patNum._wiredPatternBank = true;
                        // Simple in-memory pattern store keyed by number
                        this._arpPatterns = this._arpPatterns || new Map();
                        // Per-pattern ARP synth settings store keyed by number
                        this._arpSynthPatterns = this._arpSynthPatterns || new Map();
                        const pg = document.getElementById('patternGrid');

                        const LS_KEY = 'xen_arpSynthPatterns_v1';
                        const loadSynthBank = ()=>{
                            try {
                                const raw = localStorage.getItem(LS_KEY);
                                if (!raw) return;
                                const obj = JSON.parse(raw);
                                if (!obj || typeof obj !== 'object') return;
                                Object.keys(obj).forEach(k=>{
                                    const n = parseInt(k,10);
                                    if (!Number.isFinite(n) || n < 1) return;
                                    const st = obj[k];
                                    if (st && typeof st === 'object') this._arpSynthPatterns.set(n, st);
                                });
                            } catch(_){ }
                        };
                        const saveSynthBank = ()=>{
                            try {
                                const out = {};
                                this._arpSynthPatterns.forEach((v,k)=>{ if (k>=1 && k<=128) out[String(k)] = v; });
                                localStorage.setItem(LS_KEY, JSON.stringify(out));
                            } catch(_){ }
                        };
                        loadSynthBank();

                        const captureArpSynthUIState = ()=>{
                            try {
                                const host = document.getElementById('tab-arp');
                                const activeBtn = host ? host.querySelector('.osc-btn[data-inst="arp"].active') : null;
                                const wave = activeBtn ? String(activeBtn.dataset.wave||'sine') : 'sine';
                                const num = (id, fallback)=>{
                                    const el = document.getElementById(id);
                                    const v = el ? parseFloat(el.value) : NaN;
                                    return Number.isFinite(v) ? v : fallback;
                                };
                                const str = (id, fallback)=>{
                                    const el = document.getElementById(id);
                                    const v = el ? String(el.value||'').trim() : '';
                                    return v || fallback;
                                };
                                const chk = (id, fallback)=>{
                                    const el = document.getElementById(id);
                                    return el ? !!el.checked : !!fallback;
                                };
                                return {
                                    wave,
                                    arpPulseWidth: num('arpPulseWidth', 50),
                                    arpShapeWidth: num('arpShapeWidth', 50),
                                    arpLevel: num('arpLevel', 5),
                                    arpDetune: num('arpDetune', 0),
                                    arpOctave: num('arpOctave', 0),
                                    arpCoarse: num('arpCoarse', 0),
                                    arpAttackSlider: num('arpAttackSlider', 10),
                                    arpDecaySlider: num('arpDecaySlider', 200),
                                    arpSustainSlider: num('arpSustainSlider', 70),
                                    arpReleaseSlider: num('arpReleaseSlider', 500),
                                    arpFxSend: chk('arpFxSend', true),
                                    midiInArp: num('midiIn-arp', 1),
                                    midiOutArp: str('midiOut-arp', ''),
                                    midiOctArp: str('midiOct-arp', '0'),
                                    midiVelArp: num('midiVel-arp', 100),
                                };
                            } catch(_){ return null; }
                        };

                        const applyArpSynthUIState = (state)=>{
                            try {
                                if (!state || typeof state !== 'object') return;
                                const host = document.getElementById('tab-arp');
                                if (host) {
                                    const wave = String(state.wave||'').trim();
                                    if (wave) {
                                        const btn = host.querySelector(`.osc-btn[data-inst="arp"][data-wave="${wave}"]`);
                                        if (btn && typeof btn.click === 'function') btn.click();
                                    }
                                }
                                const setInput = (id, val, evtName='input')=>{
                                    const el = document.getElementById(id);
                                    if (!el) return;
                                    el.value = String(val);
                                    try { el.dispatchEvent(new Event(evtName, { bubbles:true })); } catch(_){ }
                                };
                                const setSelect = (id, val)=>setInput(id, val, 'change');
                                const setCheck = (id, val)=>{
                                    const el = document.getElementById(id);
                                    if (!el) return;
                                    el.checked = !!val;
                                    try { el.dispatchEvent(new Event('change', { bubbles:true })); } catch(_){ }
                                };

                                if ('arpPulseWidth' in state) setInput('arpPulseWidth', state.arpPulseWidth);
                                if ('arpShapeWidth' in state) setInput('arpShapeWidth', state.arpShapeWidth);
                                if ('arpLevel' in state) setInput('arpLevel', state.arpLevel);
                                if ('arpDetune' in state) setInput('arpDetune', state.arpDetune);
                                if ('arpOctave' in state) setInput('arpOctave', state.arpOctave);
                                if ('arpCoarse' in state) setInput('arpCoarse', state.arpCoarse);
                                if ('arpAttackSlider' in state) setInput('arpAttackSlider', state.arpAttackSlider);
                                if ('arpDecaySlider' in state) setInput('arpDecaySlider', state.arpDecaySlider);
                                if ('arpSustainSlider' in state) setInput('arpSustainSlider', state.arpSustainSlider);
                                if ('arpReleaseSlider' in state) setInput('arpReleaseSlider', state.arpReleaseSlider);
                                if ('arpFxSend' in state) setCheck('arpFxSend', state.arpFxSend);

                                if ('midiInArp' in state) setInput('midiIn-arp', state.midiInArp, 'change');
                                if ('midiOutArp' in state) setSelect('midiOut-arp', state.midiOutArp);
                                if ('midiOctArp' in state) setSelect('midiOct-arp', state.midiOctArp);
                                if ('midiVelArp' in state) setInput('midiVel-arp', state.midiVelArp, 'change');
                            } catch(_){ }
                        };

                        // Expose helpers for deferred apply
                        this._captureArpSynthUIState = captureArpSynthUIState;
                        this._applyArpSynthUIState = applyArpSynthUIState;

                        const capturePatternGrid = ()=>{
                            if (!pg) return [];
                            const lanes = Array.from(pg.querySelectorAll('.pattern-lane'));
                            return lanes.map(lane=>{
                                const steps = Array.from(lane.querySelectorAll('.pattern-step')).map(s=> {
                                    if (!s.classList.contains('active')) return null;
                                    const obj = { active: 1 };
                                    if (s.dataset.len) obj.len = s.dataset.len;
                                    if (s.dataset.tie === '1') obj.tie = 1;
                                    if (s.dataset.npc) obj.npc = s.dataset.npc;
                                    return obj;
                                });
                                return steps;
                            });
                        };
                        const applyPatternGrid = (gridArr)=>{
                            if (!Array.isArray(gridArr) || !pg) return;
                            const lanes = Array.from(pg.querySelectorAll('.pattern-lane'));
                            lanes.forEach((lane, i)=>{
                                const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                                const row = gridArr[i] || [];
                                steps.forEach((s, j)=>{
                                    const data = row[j];
                                    if (data && data.active) {
                                        s.classList.add('active');
                                        if (data.len) s.dataset.len = data.len;
                                        else delete s.dataset.len;
                                        if (data.tie) s.dataset.tie = '1';
                                        else delete s.dataset.tie;
                                        if (data.npc) s.dataset.npc = data.npc;
                                    } else {
                                        s.classList.remove('active');
                                        delete s.dataset.len;
                                        delete s.dataset.tie;
                                    }
                                });
                                try { window.rebuildPatternTieOverlays && window.rebuildPatternTieOverlays(lane); } catch(_){}
                            });
                            try { if (pg._recomputePatternText) pg._recomputePatternText(); } catch(_){}
                        };

                        // Expose pattern apply helper for deferred apply
                        this._applyArpPatternNumber = (n)=>{
                            try {
                                const num = Math.max(1, parseInt(n,10)||1);
                                const patt = this._arpPatterns.get(num);
                                if (patt) applyPatternGrid(patt);
                            } catch(_){ }
                        };
                        // Helper: immediate autosave to current slot
                        this._saveArpPattern = () => {
                            try {
                                const n = Math.max(1, parseInt(document.getElementById('patternPatternNumber')?.value||'1',10));
                                this._arpPatterns.set(n, capturePatternGrid());
                            } catch(_) {}
                        };
                        // Helper: immediate autosave synth UI state to current slot
                        this._saveArpPatternSynth = () => {
                            try {
                                const n = Math.max(1, parseInt(document.getElementById('patternPatternNumber')?.value||'1',10));
                                const st = captureArpSynthUIState();
                                if (st) this._arpSynthPatterns.set(n, st);
                                saveSynthBank();
                            } catch(_){ }
                        };

                        // Wire synth drawer gear toggle (Pattern modal) - scoped per modal to support multiple instances
                        try {
                            const gearBtns = Array.from(document.querySelectorAll('#patternSynthToggleBtn, [data-role="patternSynthToggleBtn"]'));
                            gearBtns.forEach((gearBtn)=>{
                                if (!gearBtn || gearBtn._wired) return;
                                const modal = gearBtn.closest('.floating-modal') || document;
                                const panel = modal.querySelector
                                    ? (modal.querySelector('[data-role="tab-arp"]') || modal.querySelector('#tab-arp'))
                                    : document.getElementById('tab-arp');
                                if (!panel) return;
                                gearBtn._wired = true;
                                gearBtn.addEventListener('click', (ev)=>{
                                    try { ev.preventDefault(); ev.stopPropagation(); } catch(_){ }
                                    const root = gearBtn.closest('.floating-modal') || document;
                                    const p = root.querySelector
                                        ? (root.querySelector('[data-role="tab-arp"]') || root.querySelector('#tab-arp'))
                                        : document.getElementById('tab-arp');
                                    const open = (p && p.style.display !== 'none');
                                    if (p) p.style.display = open ? 'none' : 'block';
                                    // Hide the grid while editing synth controls (no overlay)
                                    try {
                                        const grid = root.querySelector
                                            ? (root.querySelector('[data-role="patternGrid"]') || root.querySelector('#patternGrid'))
                                            : document.getElementById('patternGrid');
                                        const handle = root.querySelector
                                            ? (root.querySelector('[data-role="patternResizeHandle"]') || root.querySelector('#patternResizeHandle'))
                                            : document.getElementById('patternResizeHandle');
                                        const showGrid = open; // if panel was open, we're closing it
                                        if (grid) grid.style.display = showGrid ? '' : 'none';
                                        if (handle) handle.style.display = showGrid ? '' : 'none';
                                    } catch(_){ }
                                });
                            });
                        } catch(_){ }

                        // Speaker on/off button (always visible)
                        try {
                            const speakerBtn = document.getElementById('patternSpeakerBtn');
                            const sidebarBtn = document.getElementById('patternBtn');
                            const updateIcon = ()=>{
                                try {
                                    const on = !!(sidebarBtn && sidebarBtn.classList.contains('active'));
                                    if (speakerBtn) speakerBtn.textContent = on ? 'ðŸ”Š' : 'ðŸ”‡';
                                } catch(_){ }
                            };
                            window.updatePatternSpeakerIcon = updateIcon;
                            updateIcon();
                            if (speakerBtn && !speakerBtn._wired) {
                                speakerBtn._wired = true;
                                speakerBtn.addEventListener('click', (ev)=>{
                                    try { ev.preventDefault(); ev.stopPropagation(); } catch(_){ }
                                    const btn = document.getElementById('patternBtn');
                                    if (!btn) return;
                                    const enabling = !btn.classList.contains('active');
                                    if (enabling) {
                                        btn.classList.add('active');
                                        try { window.ensurePatternTransport && window.ensurePatternTransport(); } catch(_){ }
                                        // If PLAY is already running, align pattern start to next bar
                                        try {
                                            const omni = window.omnichord;
                                            const isPlaying = !!(omni && omni._arpTransport && omni._arpTransport.running);
                                            const pt = window._patternTransport;
                                            if (pt) {
                                                if (isPlaying && typeof pt.start === 'function') pt.start({ alignToTransport: true, preBufferMs: 80 });
                                                else {
                                                    pt.running = true;
                                                    if (typeof pt.kick === 'function') pt.kick();
                                                }
                                            }
                                        } catch(_){ }
                                    } else {
                                        btn.classList.remove('active');
                                        // Stop pattern transport when PATTERN is off
                                        try {
                                            const pt = window._patternTransport;
                                            if (pt) {
                                                if (typeof pt.stop === 'function') pt.stop(false);
                                                pt.running = false;
                                                if (typeof pt.stopVoices === 'function') pt.stopVoices();
                                            }
                                        } catch(_){ }
                                    }
                                    updateIcon();
                                });
                            }
                        } catch(_){ }

                        // Persist synth changes per-pattern (delegated)
                        try {
                            const host = document.getElementById('tab-arp');
                            if (host && !host._wiredPatternSynthSave) {
                                host._wiredPatternSynthSave = true;
                                let t = null;
                                const scheduleSave = ()=>{
                                    try { if (t) clearTimeout(t); } catch(_){ }
                                    t = setTimeout(()=>{ try { this._saveArpPatternSynth && this._saveArpPatternSynth(); } catch(_){ } }, 120);
                                };
                                host.addEventListener('input', scheduleSave);
                                host.addEventListener('change', scheduleSave);
                            }
                        } catch(_){ }

                        // Initialize pattern 1 from current grid if empty
                        if (!this._arpPatterns.has(1)) this._arpPatterns.set(1, capturePatternGrid());
                        // Initialize synth slot 1 from current UI if empty
                        if (!this._arpSynthPatterns.has(1)) {
                            const st0 = captureArpSynthUIState();
                            if (st0) this._arpSynthPatterns.set(1, st0);
                            saveSynthBank();
                        }
                        patNum.addEventListener('change', (e)=>{
                            let v = parseInt(e.target.value,10); if(!Number.isFinite(v) || v<1) v=1; e.target.value=String(v);
                            const prev = this._lastArpPatternNumber || 1;
                            // Before switching away, save current grid + synth settings
                            this._arpPatterns.set(prev, capturePatternGrid());
                            try {
                                const stPrev = captureArpSynthUIState();
                                if (stPrev) this._arpSynthPatterns.set(prev, stPrev);
                                saveSynthBank();
                            } catch(_){ }
                            // If new slot is empty, clone from previous
                            if (!this._arpPatterns.has(v)){
                                this._arpPatterns.set(v, JSON.parse(JSON.stringify(this._arpPatterns.get(prev) || capturePatternGrid())));
                            }
                            if (!this._arpSynthPatterns.has(v)){
                                // Clone synth state from previous slot if available
                                const src = this._arpSynthPatterns.get(prev) || captureArpSynthUIState();
                                if (src) this._arpSynthPatterns.set(v, JSON.parse(JSON.stringify(src)));
                                saveSynthBank();
                            }

                            // If transport is running and PATTERN is enabled, defer switching to next bar/cycle
                            let shouldDefer = false;
                            try {
                                const omni = window.omnichord;
                                const t = omni && omni._arpTransport;
                                const running = !!(t && t.running);
                                const patternBtn = document.getElementById('patternBtn');
                                const patternEnabled = !!(patternBtn && patternBtn.classList.contains('active'));
                                shouldDefer = running && patternEnabled;
                            } catch(_){ }

                            if (shouldDefer) {
                                try {
                                    const pending = window._patternPendingChanges = window._patternPendingChanges || {};
                                    pending.slot = v;
                                    pending.applyArpSynth = true;
                                } catch(_){ }
                                try {
                                    e.target.dataset.pending = '1';
                                    e.target.dataset.pendingValue = String(v);
                                    e.target.classList.add('pending-change');
                                    e.target.title = `Queued â†’ ${v} (switches next cycle)`;
                                    // Keep UI consistent: revert the displayed number back to the currently-active slot.
                                    e.target.value = String(prev);
                                } catch(_){ }
                                try { this._pendingArpPatternNumber = v; } catch(_){ }
                                try {
                                    const scheduleDeferred = window.scheduleDeferred;
                                    if (typeof scheduleDeferred === 'function') {
                                        scheduleDeferred({ pattern: { slot:true, synth:true } });
                                    }
                                } catch(_){ }
                            } else {
                                // Apply selected pattern immediately
                                const patt = this._arpPatterns.get(v);
                                if (patt) applyPatternGrid(patt);
                                try {
                                    const st = this._arpSynthPatterns.get(v);
                                    if (st) applyArpSynthUIState(st);
                                } catch(_){ }
                                try { delete e.target.dataset.pending; e.target.classList.remove('pending-change'); } catch(_){ }
                                try { delete e.target.dataset.pendingValue; e.target.title = ''; } catch(_){ }
                                try { this._pendingArpPatternNumber = null; } catch(_){ }
                                this._lastArpPatternNumber = v;
                            }
                        });
                        this._lastArpPatternNumber = parseInt(patNum.value,10) || 1;
                    }
                } catch(_){ }

                // Wire DRUM mini TIME controls to universal transport (mirror both ways)
                try {
                    const miniIds = ['drumBpmMini','drumTSMini','drumQuantMini'];
                    const exists = miniIds.some(id => document.getElementById(id));
                    if (exists) {
                        const link = (miniId, uniId, eventName='change') => {
                            const m = document.getElementById(miniId);
                            const u = document.getElementById(uniId);
                            if (!m) return;
                            // Mini â†’ Universal
                            if (!m._wiredMini) {
                                m._wiredMini = true;
                                m.addEventListener('change', () => {
                                    try { if (u) { u.value = String(m.value); u.dispatchEvent(new Event(eventName, { bubbles:true })); } } catch(_){}
                                    // Persist mini as default too
                                    try { localStorage.setItem(miniId, String(m.value)); } catch(_){ }
                                });
                                m.addEventListener('input', () => { try { localStorage.setItem(miniId, String(m.value)); } catch(_){ } });
                            }
                            // Universal â†’ Mini
                            if (u && !u._wiredUniToMini) {
                                u._wiredUniToMini = true;
                                u.addEventListener('change', () => { try { m.value = String(u.value); } catch(_){} });
                                u.addEventListener('input',  () => { try { m.value = String(u.value); } catch(_){} });
                            }
                            // Seed from universal on first wire, else from localStorage
                            try {
                                const ls = localStorage.getItem(miniId);
                                if (u) { m.value = String(u.value); }
                                else if (ls != null) { m.value = String(ls); }
                            } catch(_){ }
                        };
                        // Map: mini â†’ universal ids
                        link('drumBpmMini',   'universalBpm', 'input');
                        link('drumTSMini',    'universalTimeSignature', 'change');
                        link('drumQuantMini', 'universalQuant', 'change');
                        // Removed drumNpcMini & drumSwingMini (single NPC & Swing now elsewhere)
                    }
                } catch(_){ }
                
                // EDO inputs are now handled by universal sync system
                // Individual handlers removed to prevent conflicts

                // Build initial drum grid skeleton once
                const drumNames = [
                    'KICK','SNARE','CH HAT','OP HAT','TOM 1','TOM 2','CLAP','CRASH','CLAVE'
                ];
                const grid = document.getElementById('drumGrid');
                if (grid && !grid.dataset.built) {
                    grid.dataset.built = '1';
                    // Expose a cycle length (in 16ths) for DRUMS; default 16
                    if (!grid.dataset.length) grid.dataset.length = '16';
                    // Helpers for per-lane QUANT (N/D) and remapping
                        const parseRowQuant = (str, fallbackSteps)=>{
                        try {
                            const s = String(str||'').trim();
                            if (!s) return { N: fallbackSteps, D: fallbackSteps, str: String(fallbackSteps) };
                            // Support either N/D or a single D
                            const mf = s.match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
                            if (mf){
                                const N = Math.max(1, parseInt(mf[1],10)||fallbackSteps);
                                const D = Math.max(1, parseInt(mf[2],10)||fallbackSteps);
                                // Preserve full N/D for dataset so both values round-trip
                                return { N, D, str: `${N}/${D}` };
                            }
                            const mn = s.match(/^\s*(\d+)\s*$/);
                            if (mn){ const d = Math.max(1, parseInt(mn[1],10)||fallbackSteps); return { N: d, D: d, str: `${d}/${d}` }; }
                            return { N: fallbackSteps, D: fallbackSteps, str: String(fallbackSteps) };
                        } catch(_){ return { N: fallbackSteps, D: fallbackSteps, str: String(fallbackSteps) }; }
                    };
                    const getLaneQuant = (lane, fallbackSteps)=>{
                        const def = { N: fallbackSteps, D: fallbackSteps, str: String(fallbackSteps), isDefault: true };
                        if (!lane) return def;
                        const raw = lane.dataset.quant || '';
                        if (!raw) return def;
                        const q = parseRowQuant(raw, fallbackSteps);
                        const isDefault = (q.N===fallbackSteps && q.D===fallbackSteps);
                        return Object.assign({ isDefault }, q);
                    };
                    const remapDrumLaneState = (snapshot, oldD, newD, isBass)=>{
                        // snapshot: Array of {active, npc, len, tie}
                        const next = new Array(newD).fill(null).map(()=> ({ active:false, npc:'', len:null, tie:null }));
                        if (!Array.isArray(snapshot) || oldD<=0 || newD<=0) return next;
                        if (!isBass){
                            // For each active old cell, map proportionally to new index
                            for (let i=0;i<snapshot.length;i++){
                                if (snapshot[i]?.active){
                                    const j = Math.max(0, Math.min(newD-1, Math.round((i * newD) / oldD)));
                                    next[j].active = true;
                                }
                            }
                        } else {
                            // Bass: find heads (cells with npc not empty/x and not tie or has len)
                            for (let i=0;i<snapshot.length;i++){
                                const cell = snapshot[i];
                                if (!cell) continue;
                                const npc = String(cell.npc||'').trim();
                                const isRest = /^x$/i.test(npc);
                                const isHead = (!!npc && !isRest && (!cell.tie || cell.tie!=='1'));
                                if (isHead){
                                    const oldLen = Math.max(1, parseInt(cell.len||'1',10)||1);
                                    const newHead = Math.max(0, Math.min(newD-1, Math.round((i * newD) / oldD)));
                                    const newLen = Math.max(1, Math.round((oldLen * newD) / oldD));
                                    next[newHead].npc = npc;
                                    next[newHead].len = String(newLen);
                                    // Mark ties for continuation
                                    for (let k=1;k<newLen;k++){
                                        const idx = newHead + k;
                                        if (idx>=newD) break;
                                        next[idx].tie = '1';
                                    }
                                }
                            }
                            // Set active flag for heads (visual)
                            for (let i=0;i<newD;i++){
                                const c = next[i];
                                if (c.npc && !/^x$/i.test(String(c.npc))) c.active = true;
                            }
                        }
                        return next;
                    };
                    // Determine steps per bar from time signature (4 steps per beat)
                    (function(){ /* placeholder to keep section collapsed in some editors */ })();
                    let tsNum=4, tsDen=4; try{
                        const tsRaw = String(document.getElementById('universalTimeSignature')?.value||'4/4');
                        const parts = tsRaw.split('/');
                        const a=parseInt(parts[0],10); const b=parseInt(parts[1],10);
                        if(Number.isFinite(a)&&a>0) tsNum=a; if(Number.isFinite(b)&&b>0) tsDen=b;
                    }catch(_){}
                    const beatsPerBar = (tsNum*4)/tsDen;
                    // Visual step count per lane is its denominator D; default to grid.dataset.length
                    const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                    const defaultLen16 = Math.max(1, Math.min(maxLen, parseInt(grid.dataset.length||'16',10)||16));
                    const stepsPerBar = Math.max(4, Math.round(beatsPerBar * 4));
                    // GM defaults for channel 10 per common mapping
                    const gmNotes = ['C2','D2','F#2','A#2','D3','C3','E2','C#3','G#2'];
                    drumNames.forEach((name, rowIdx) => {
                        const row = document.createElement('div');
                        row.className = 'drum-row' + (name==='BASS' ? ' bass-row' : '');

                        const rowMain = document.createElement('div');
                        rowMain.className = 'drum-row-main';

                        const gearBtn = document.createElement('button');
                        gearBtn.className = 'drum-gear';
                        gearBtn.type = 'button';
                        gearBtn.title = 'Lane controls';
                        gearBtn.textContent = 'âš™';
                        gearBtn.setAttribute('aria-expanded', 'false');
                        gearBtn.addEventListener('click', (ev)=>{
                            try { ev.preventDefault(); ev.stopPropagation(); } catch(_){ }
                            const open = row.classList.toggle('expanded');
                            try { gearBtn.setAttribute('aria-expanded', open ? 'true' : 'false'); } catch(_){ }
                        });
                        rowMain.appendChild(gearBtn);

                        const label = document.createElement('div');
                        label.className = 'drum-label';
                        label.textContent = name;
                        rowMain.appendChild(label);

                        const lane = document.createElement('div');
                        lane.className = 'drum-lane';
                        lane.dataset.row = String(rowIdx);
                        try { lane.style.setProperty('--steps-per-bar', String(stepsPerBar)); } catch(_){ }

                        // Beat dividers at each beat boundary
                        const fullBeats = Math.max(0, Math.floor(beatsPerBar));
                        for (let b=1; b<fullBeats; b++){
                            const div = document.createElement('div');
                            div.className = 'beat-divider';
                            div.style.left = `${(b/beatsPerBar)*100}%`;
                            lane.appendChild(div);
                        }
                        // Steps
                        for (let i=0;i<stepsPerBar;i++){
                            const s = document.createElement('div');
                            s.className = 'drum-step' + ((i%4===0)?' beat-accent':'');
                            s.dataset.step = String(i);
                            s.title = `${name} â€¢ Step ${i+1}`;
                            if (name === 'BASS') {
                                s.dataset.npc = '';
                                // Drag-to-extend sustain (ties) on mousedown
                                s.addEventListener('mousedown', (e) => {
                                    if (e.button !== 0) return;
                                    e.preventDefault();
                                    const startIdx = i;
                                    const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                    const applyLen = (toIdx) => {
                                        const len = Math.max(1, (toIdx|0) - startIdx + 1);
                                        s.dataset.len = String(len);
                                        for (let k = 0; k < steps.length; k++) {
                                            if (k > startIdx && k <= startIdx + len - 1) steps[k].dataset.tie = '1';
                                            else if (k > startIdx) delete steps[k].dataset.tie;
                                        }
                                    };
                                    const onMove = (ev) => {
                                        const rect = lane.getBoundingClientRect();
                                        const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
                                        const idx = Math.max(0, Math.min(stepsPerBar-1, Math.floor((x / rect.width) * stepsPerBar)));
                                        applyLen(idx);
                                        try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                                    };
                                    const onUp = () => {
                                        document.removeEventListener('mousemove', onMove);
                                        document.removeEventListener('mouseup', onUp);
                                        try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                                        try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                    };
                                    document.addEventListener('mousemove', onMove);
                                    document.addEventListener('mouseup', onUp);
                                });
                                // Touch drag-to-extend sustain (ties)
                                s.addEventListener('touchstart', (e) => {
                                    if (s._touchDragActive) return; // prevent duplicate via synthetic mouse
                                    s._touchDragActive = true;
                                    try { e.preventDefault(); } catch(_) {}
                                    const touch = e.touches && e.touches[0] ? e.touches[0] : null;
                                    if (!touch) { s._touchDragActive = false; return; }
                                    const activeId = touch.identifier;
                                    const startIdx = i;
                                    const startX = touch.clientX;
                                    const startY = touch.clientY;
                                    const startVel = parseInt(s.dataset.vel || '100', 10);
                                    const wasActive = s.classList.contains('active');
                                    let isDragging = false;
                                    let dragStarted = false;
                                    let isVelMode = false;
                                    let isLenMode = false;
                                    const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                    const applyLen = (toIdx) => {
                                        const len = Math.max(1, (toIdx|0) - startIdx + 1);
                                        s.dataset.len = String(len);
                                        for (let k = 0; k < steps.length; k++) {
                                            if (k > startIdx && k <= startIdx + len - 1) steps[k].dataset.tie = '1';
                                            else if (k > startIdx) delete steps[k].dataset.tie;
                                        }
                                    };
                                    const applyVel = (clientY) => {
                                        const deltaY = startY - clientY; // Drag up = louder
                                        const deltaVel = Math.round(deltaY / 1.5);
                                        const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                                        s.dataset.vel = String(newVel);
                                        try { window.updateStepVelocityClass(s); } catch(_){ }
                                    };
                                    const onMove = (ev) => {
                                        try { ev.preventDefault(); } catch(_) {}
                                        if (!dragStarted) { dragStarted = true; isDragging = true; }
                                        const tlist = ev.touches || [];
                                        let t = null; for (let j=0;j<tlist.length;j++){ if (tlist[j].identifier === activeId) { t = tlist[j]; break; } }
                                        if (!t) return;

                                        const dx = Math.abs(t.clientX - startX);
                                        const dy = Math.abs(t.clientY - startY);

                                        // Determine drag mode: horizontal = length, vertical = velocity
                                        if (!isVelMode && !isLenMode) {
                                            if (dy > dx * 2 && dy > 10) {
                                                isVelMode = true;
                                                s.classList.add('vel-dragging');
                                                if (!wasActive) {
                                                    s.classList.add('active');
                                                    s.dataset.npc = s.dataset.npc || '1';
                                                    if (!s.dataset.len) s.dataset.len = '1';
                                                }
                                            } else if (dx > 3) {
                                                isLenMode = true;
                                                if (!wasActive) {
                                                    s.classList.add('active');
                                                    s.dataset.npc = s.dataset.npc || '1';
                                                    if (!s.dataset.len) s.dataset.len = '1';
                                                }
                                            }
                                        }

                                        if (isVelMode) {
                                            applyVel(t.clientY);
                                        } else if (isLenMode) {
                                            const rect = lane.getBoundingClientRect();
                                            const x = Math.max(0, Math.min(rect.width, t.clientX - rect.left));
                                            const idx = Math.max(0, Math.min(stepsPerBar-1, Math.floor((x / rect.width) * stepsPerBar)));
                                            applyLen(idx);
                                            try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                                        }
                                    };
                                    const onEnd = (ev) => {
                                        const changed = ev.changedTouches || [];
                                        let ended = false; for (let j=0;j<changed.length;j++){ if (changed[j].identifier === activeId) { ended = true; break; } }
                                        if (!ended) return;
                                        document.removeEventListener('touchmove', onMove, { passive: false });
                                        document.removeEventListener('touchend', onEnd);
                                        document.removeEventListener('touchcancel', onEnd);
                                        try { s.classList.remove('vel-dragging'); } catch(_){ }
                                        s._touchDragActive = false;

                                        // Tap: fall back to existing click behavior (NPC prompt)
                                        if (!isDragging) {
                                            try { s.click(); } catch(_){ }
                                        }

                                        try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                                        try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                    };
                                    document.addEventListener('touchmove', onMove, { passive: false });
                                    document.addEventListener('touchend', onEnd);
                                    document.addEventListener('touchcancel', onEnd);
                                }, { passive: false });

                                // Click: quick root on empty, second click opens change, rest  root
                                s.addEventListener('click', (e) => {
                                    e.preventDefault();
                                    try { const bassBtn=document.getElementById('bassBtn'); if(!(bassBtn&&bassBtn.classList.contains('active'))){ console.log('[BASS] Audition gated (button off)'); return; } } catch(_){}
                                    const prev = (s.dataset.npc||'');
                                    if (prev === '') {
                                        s.dataset.npc = '1'; s.classList.add('active'); if (!s.dataset.len) s.dataset.len = '1';
                                    } else if (prev && prev.toLowerCase() !== 'x') {
                                        s.classList.add('selected');
                                        const valIn = window.prompt('Bass NPC (1â€“9) or x for rest', String(prev).toLowerCase());
                                        s.classList.remove('selected');
                                        if (valIn == null) return;
                                        const val = String(valIn).trim();
                                        if (val === '') { s.dataset.npc=''; s.classList.remove('active'); delete s.dataset.len; return; }
                                        if (/^x$/i.test(val)) { s.dataset.npc='x'; s.classList.remove('active'); delete s.dataset.len; return; }
                                        if (/^[1-9]$/.test(val)) { s.dataset.npc=val; s.classList.add('active'); if (!s.dataset.len) s.dataset.len='1'; }
                                    } else {
                                        s.dataset.npc = '1'; s.classList.add('active'); if (!s.dataset.len) s.dataset.len = '1';
                                    }

                                    // Audition current selection (monophonic bass with a shared preview gate)
                                    try {
                                        const col = (this._arp?.column) || this.currentActiveColumnEl || document.querySelector('.extension-column');
                                        const edo = this.currentTuning||12; const norm=(x)=>((x%edo)+edo)%edo;
                                        const rootAbs = (typeof this._getEffectiveColumnRootStep === 'function' && col) ? this._getEffectiveColumnRootStep(col) : (this.currentRoot||0);
                                        let rel = [];
                                        try {
                                            const rows = Array.from(col.querySelectorAll('.strings-column .string'));
                                            const steps = rows.map(r=> parseInt(r.dataset.noteIndex,10)).filter(n=>Number.isFinite(n));
                                            const uniqRel = Array.from(new Set(steps.map(st=> norm(st - rootAbs))));
                                            rel = (typeof this.stepToSemitone === 'function') ? uniqRel.sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo)) : uniqRel.sort((a,b)=>a-b);
                                        } catch(_) { rel = []; }
                                        const npc = parseInt(s.dataset.npc||'1',10);
                                        const step = this._npcToChordStep(npc, rel);
                                        if (Number.isFinite(step)){
                                            const uniq = Array.isArray(rel) ? rel.map(norm).sort((a,b)=>a-b).filter((v,i,a)=> i===0 || a[i-1]!==v) : [];
                                            const cycle = (uniq.length>0) ? Math.floor((Math.max(1,npc)-1)/uniq.length) : 0;
                                            const abs = norm(rootAbs + step);
                                            const baseOct = Math.max(1, Math.min(3, 2 + cycle));
                                            const f = this.getFrequency(abs, baseOct, edo);
                                            try {
                                                // Cancel any prior preview gate and stop existing bass before audition
                                                if (this._bassPreviewTimer) {
                                                    clearTimeout(this._bassPreviewTimer);
                                                    this._bassPreviewTimer = null;
                                                }
                                            } catch(_){ }
                                            try { this.stopAllActiveNotes && this.stopAllActiveNotes('bass'); } catch(_){ }
                                            this.playFrequency(f, null, 'bass');
                                            try {
                                                const bpmEl = document.getElementById('universalBpm');
                                                const bpm = Math.max(20, parseInt(bpmEl?.value||this._arpTransport?.bpm||120,10));
                                                const quantStr = (document.getElementById('universalQuant')?.value) || this._arpTransport?.quant || '1/16';
                                                const quantMs = Math.max(5, this._parseQuantToMs(quantStr, bpm) || 0);
                                                const holdSpec = (document.getElementById('universalHold')?.value) || (document.getElementById('chordHold')?.value) || 'bar:1';
                                                const [kind, valStr] = String(holdSpec).split(':');
                                                const n = Math.max(1, parseInt(valStr||'1',10));
                                                const tsRaw = String(document.getElementById('universalTimeSignature')?.value||'4/4');
                                                let tsNum=4, tsDen=4; try{ const parts = tsRaw.split('/'); const a=parseInt(parts[0],10); const b=parseInt(parts[1],10); if(Number.isFinite(a)&&a>0) tsNum=a; if(Number.isFinite(b)&&b>0) tsDen=b; }catch(_){ }
                                                const beatMs = 60000/Math.max(20,bpm);
                                                const beatsPerBar = (tsNum*4)/tsDen;
                                                const barMs = beatMs * beatsPerBar;
                                                const holdMs = (kind==='beat') ? n*beatMs : n*barMs;
                                                const gateMs = Math.max(5, Math.min(holdMs, quantMs));
                                                try {
                                                    if (this._bassPreviewTimer) {
                                                        clearTimeout(this._bassPreviewTimer);
                                                        this._bassPreviewTimer = null;
                                                    }
                                                } catch(_){ }
                                                this._bassPreviewTimer = setTimeout(()=>{
                                                    try {
                                                        this._bassPreviewTimer = null;
                                                        this.stopAllActiveNotes && this.stopAllActiveNotes('bass');
                                                    } catch(_){ }
                                                }, gateMs);
                                            } catch(_){ }
                                        }
                                    } catch(_){ }
                                    // After change, update tie overlays
                                    try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                                    // Autosave bass edits to current pattern
                                    try { if (typeof this._saveDrumPattern==='function') this._saveDrumPattern(); } catch(_){}
                                });

                                    // Right-click to delete/rest and clear ties from this head
                                    s.addEventListener('contextmenu', (e) => {
                                        e.preventDefault();
                                        try {
                                            const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                            const idx = parseInt(s.dataset.step||'0',10) || 0;
                                            if (s.dataset.tie === '1') {
                                                // Find head before this index with a len
                                                let headIdx = -1;
                                                for (let k = idx - 1; k >= 0; k--) {
                                                    if (steps[k].dataset.len) { headIdx = k; break; }
                                                }
                                                if (headIdx >= 0) {
                                                    const newLen = Math.max(1, idx - headIdx);
                                                    steps[headIdx].dataset.len = String(newLen);
                                                }
                                                // Remove tie mark from this and onward
                                                for (let k = idx; k < steps.length; k++) { delete steps[k].dataset.tie; }
                                                // Clear any npc on this continuation cell (usually none)
                                                s.dataset.npc = '';
                                                s.classList.remove('active');
                                            } else {
                                                // Head or standalone: clear ties after it and its own len
                                                for (let k = idx + 1; k < steps.length; k++) { delete steps[k].dataset.tie; }
                                                delete s.dataset.len;
                                                s.dataset.npc = '';
                                                s.classList.remove('active');
                                            }
                                            // Rebuild overlays
                                            this.rebuildBassTieOverlays(lane);
                                        } catch(_) { }
                                        // Autosave after delete/rest adjustments
                                        try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                    });
                            } else {
                                // Drum step: mousedown for toggle + velocity drag
                                s.addEventListener('mousedown', (e) => {
                                    if (e.button !== 0) return;
                                    e.preventDefault();
                                    
                                    const wasActive = s.classList.contains('active');
                                    const startY = e.clientY;
                                    const startVel = parseInt(s.dataset.vel || '100', 10);
                                    let isDragging = false;
                                    let isVelMode = false;
                                    
                                    const applyVel = (clientY) => {
                                        const deltaY = startY - clientY; // Drag up = louder
                                        const deltaVel = Math.round(deltaY / 1.5);
                                        const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                                        s.dataset.vel = String(newVel);
                                        try { window.updateStepVelocityClass(s); } catch(_){}
                                    };
                                    
                                    const onMove = (ev) => {
                                        const dy = Math.abs(ev.clientY - startY);
                                        if (dy > 5 && !isVelMode) {
                                            isDragging = true;
                                            isVelMode = true;
                                            // Activate if not already
                                            if (!wasActive) {
                                                s.classList.add('active');
                                            }
                                            s.classList.add('vel-dragging');
                                        }
                                        if (isVelMode) {
                                            applyVel(ev.clientY);
                                        }
                                    };
                                    
                                    const onUp = () => {
                                        document.removeEventListener('mousemove', onMove);
                                        document.removeEventListener('mouseup', onUp);
                                        s.classList.remove('vel-dragging');
                                        
                                        // If not dragging (velocity mode), do normal toggle
                                        if (!isDragging) {
                                            const nowActive = !wasActive;
                                            if (nowActive) s.classList.add('active'); else s.classList.remove('active');
                                            // Click-audition: if turning on, preview the hit
                                            try {
                                                if (nowActive){
                                                    const row = s.closest('.drum-row');
                                                    const lane = s.closest('.drum-lane');
                                                    const rowIdx = lane ? parseInt(lane.dataset.row||'0',10):0;
                                                    const volEl = row ? row.querySelector('.drum-volume') : null;
                                                    const sendEl = row ? row.querySelector('.drum-send') : null;
                                                    const fxEl = row ? row.querySelector('.drum-fx input[type="checkbox"]') : null;
                                                    const vol = volEl ? Math.max(0, Math.min(1, parseInt(volEl.value||'80',10)/100)) : 0.8;
                                                    const sendPct = sendEl ? (parseInt(sendEl.value||'0',10) || 0) : (fxEl && fxEl.checked ? 100 : 0);
                                                    const send = Math.max(0, Math.min(1, sendPct/100));
                                                    if (this._isDrumPreviewAllowed()) {
                                                        this._triggerDrumSound(rowIdx|0, vol, send);
                                                        try { window._pulseStepEl && window._pulseStepEl(s); } catch(_){ }
                                                    }
                                                }
                                            } catch(_){}
                                        }
                                        // Autosave drum grid after toggle
                                        try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                    };
                                    
                                    document.addEventListener('mousemove', onMove);
                                    document.addEventListener('mouseup', onUp);
                                });

                                // Touch: tap toggle + vertical drag velocity
                                s.addEventListener('touchstart', (e) => {
                                    if (s._touchDragActive) return; // prevent duplicate via synthetic mouse
                                    s._touchDragActive = true;
                                    try { e.preventDefault(); } catch(_) {}
                                    const touch = e.touches && e.touches[0] ? e.touches[0] : null;
                                    if (!touch) { s._touchDragActive = false; return; }
                                    const activeId = touch.identifier;

                                    const wasActive = s.classList.contains('active');
                                    const startY = touch.clientY;
                                    const startVel = parseInt(s.dataset.vel || '100', 10);
                                    let isDragging = false;
                                    let isVelMode = false;

                                    const applyVel = (clientY) => {
                                        const deltaY = startY - clientY; // Drag up = louder
                                        const deltaVel = Math.round(deltaY / 1.5);
                                        const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                                        s.dataset.vel = String(newVel);
                                        try { window.updateStepVelocityClass(s); } catch(_){ }
                                    };

                                    const onMove = (ev) => {
                                        try { ev.preventDefault(); } catch(_) {}
                                        const tlist = ev.touches || [];
                                        let t = null; for (let j=0;j<tlist.length;j++){ if (tlist[j].identifier === activeId) { t = tlist[j]; break; } }
                                        if (!t) return;
                                        const dy = Math.abs(t.clientY - startY);
                                        if (!isVelMode && dy > 10) {
                                            isDragging = true;
                                            isVelMode = true;
                                            if (!wasActive) s.classList.add('active');
                                            s.classList.add('vel-dragging');
                                        }
                                        if (isVelMode) applyVel(t.clientY);
                                    };

                                    const onEnd = (ev) => {
                                        const changed = ev.changedTouches || [];
                                        let ended = false; for (let j=0;j<changed.length;j++){ if (changed[j].identifier === activeId) { ended = true; break; } }
                                        if (!ended) return;
                                        document.removeEventListener('touchmove', onMove, { passive: false });
                                        document.removeEventListener('touchend', onEnd);
                                        document.removeEventListener('touchcancel', onEnd);
                                        s.classList.remove('vel-dragging');

                                        if (!isDragging) {
                                            const nowActive = !wasActive;
                                            if (nowActive) s.classList.add('active'); else s.classList.remove('active');
                                            // Tap-audition: if turning on, preview the hit
                                            try {
                                                if (nowActive){
                                                    const row = s.closest('.drum-row');
                                                    const lane = s.closest('.drum-lane');
                                                    const rowIdx = lane ? parseInt(lane.dataset.row||'0',10):0;
                                                    const volEl = row ? row.querySelector('.drum-volume') : null;
                                                    const sendEl = row ? row.querySelector('.drum-send') : null;
                                                    const fxEl = row ? row.querySelector('.drum-fx input[type="checkbox"]') : null;
                                                    const vol = volEl ? Math.max(0, Math.min(1, parseInt(volEl.value||'80',10)/100)) : 0.8;
                                                    const sendPct = sendEl ? (parseInt(sendEl.value||'0',10) || 0) : (fxEl && fxEl.checked ? 100 : 0);
                                                    const send = Math.max(0, Math.min(1, sendPct/100));
                                                    if (this._isDrumPreviewAllowed()) {
                                                        this._triggerDrumSound(rowIdx|0, vol, send);
                                                        try { window._pulseStepEl && window._pulseStepEl(s); } catch(_){ }
                                                    }
                                                }
                                            } catch(_){ }
                                        }

                                        try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                        s._touchDragActive = false;
                                    };

                                    document.addEventListener('touchmove', onMove, { passive: false });
                                    document.addEventListener('touchend', onEnd);
                                    document.addEventListener('touchcancel', onEnd);
                                }, { passive: false });
                            }
                            // Default velocity and attach velocity drag (for drums AND bass in drum grid)
                            s.dataset.vel = '100';
                            try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(s); } catch(_) {}
                            try { if (window.attachVelocityDrag) window.attachVelocityDrag(s); } catch(_) {}
                            lane.appendChild(s);
                        }
                        // Playhead element (only for true drum lanes; skip BASS to reduce CPU/render)
                        if (name !== 'BASS') {
                            const ph = document.createElement('div');
                            ph.className = 'drum-playhead';
                            ph.style.left = '0%';
                            lane.appendChild(ph);
                        }

                        // For bass lane, add an overlay layer for tie visuals
                        if (name === 'BASS') {
                            const layer = document.createElement('div');
                            layer.className = 'bass-tie-layer';
                            lane.insertBefore(layer, lane.firstChild);
                            try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                        }

                        // MIDI out field per lane (always visible per spec)
                        const midiWrap = document.createElement('div');
                        midiWrap.className = 'drum-midi';
                        midiWrap.style.cssText = 'display:inline-flex;align-items:center;gap:4px;';
                        const midiInput = document.createElement('input');
                        midiInput.type = 'text';
                        midiInput.value = (name!=='BASS' ? (gmNotes[rowIdx]||'C2') : '');
                        midiInput.title = 'Send this GM note on Ch10 when step hits (e.g., C2, D#2)';
                        midiInput.addEventListener('change', ()=>{
                            try {
                                const pref = this._getAccidentalPreference(midiInput.value);
                                if (pref) midiInput.dataset.accidentalPref = pref;
                            } catch(_){ }
                            try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                            try { if (window.omnichord && omnichord._arpTransport && omnichord._arpTransport.isRunning) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: true }); } } catch(_){ }
                        });

                        if (name !== 'BASS') {
                            const defaultMidiName = (gmNotes[rowIdx] || 'C2');
                            const defaultMidi = this._parseMidiNoteName(defaultMidiName) ?? 36;
                            const getPref = () => {
                                const fromData = midiInput.dataset.accidentalPref;
                                const pref = fromData || this._getAccidentalPreference(midiInput.value) || this._getAccidentalPreference(defaultMidiName);
                                return pref === 'flat' ? 'flat' : 'sharp';
                            };
                            const applyMidi = (midi, pref) => {
                                const usePref = (pref === 'flat') ? 'flat' : 'sharp';
                                midiInput.value = this._formatMidiNoteName(midi, usePref !== 'flat');
                                midiInput.dataset.accidentalPref = usePref;
                                midiInput.dispatchEvent(new Event('change', { bubbles: true }));
                            };
                            const bumpMidi = (delta, pref) => {
                                const current = this._parseMidiNoteName(midiInput.value);
                                const base = Number.isFinite(current) ? current : defaultMidi;
                                const next = Math.max(0, Math.min(127, base + delta));
                                applyMidi(next, pref);
                            };

                            midiInput.addEventListener('keydown', (e) => {
                                const key = e.key;
                                if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'PageUp' || key === 'PageDown') {
                                    e.preventDefault();
                                    const dir = (key === 'ArrowUp' || key === 'PageUp') ? 1 : -1;
                                    const step = e.shiftKey ? 12 : 1;
                                    bumpMidi(dir * step, getPref());
                                }
                            });

                            let dragState = null;
                            const startDrag = (clientY) => {
                                dragState = {
                                    startY: clientY,
                                    startMidi: Number.isFinite(this._parseMidiNoteName(midiInput.value)) ? this._parseMidiNoteName(midiInput.value) : defaultMidi,
                                    pref: getPref(),
                                    lastDelta: 0
                                };
                            };
                            const updateDrag = (clientY, shiftKey) => {
                                if (!dragState) return;
                                const dy = dragState.startY - clientY;
                                const baseDelta = Math.round(dy / 6);
                                const step = shiftKey ? 12 : 1;
                                const delta = baseDelta * step;
                                if (delta === dragState.lastDelta) return;
                                dragState.lastDelta = delta;
                                const next = Math.max(0, Math.min(127, dragState.startMidi + delta));
                                applyMidi(next, dragState.pref);
                            };
                            const endDrag = () => { dragState = null; };

                            midiInput.addEventListener('mousedown', (e) => {
                                if (e.button !== 0) return;
                                const startY = e.clientY;
                                startDrag(startY);
                                let dragging = false;
                                const onMove = (ev) => {
                                    const dy = Math.abs(ev.clientY - startY);
                                    if (!dragging && dy > 5) dragging = true;
                                    if (dragging) {
                                        ev.preventDefault();
                                        updateDrag(ev.clientY, ev.shiftKey);
                                    }
                                };
                                const onUp = () => {
                                    document.removeEventListener('mousemove', onMove);
                                    document.removeEventListener('mouseup', onUp);
                                    endDrag();
                                };
                                document.addEventListener('mousemove', onMove);
                                document.addEventListener('mouseup', onUp);
                            });

                            midiInput.addEventListener('touchstart', (e) => {
                                const t = e.touches && e.touches[0];
                                if (!t) return;
                                const startY = t.clientY;
                                startDrag(startY);
                                let dragging = false;
                                const onMove = (ev) => {
                                    const tt = ev.touches && ev.touches[0];
                                    if (!tt) return;
                                    const dy = Math.abs(tt.clientY - startY);
                                    if (!dragging && dy > 5) dragging = true;
                                    if (dragging) {
                                        ev.preventDefault();
                                        updateDrag(tt.clientY, false);
                                    }
                                };
                                const onEnd = () => {
                                    document.removeEventListener('touchmove', onMove, { passive: false });
                                    document.removeEventListener('touchend', onEnd);
                                    document.removeEventListener('touchcancel', onEnd);
                                    endDrag();
                                };
                                document.addEventListener('touchmove', onMove, { passive: false });
                                document.addEventListener('touchend', onEnd);
                                document.addEventListener('touchcancel', onEnd);
                            }, { passive: false });
                        }
                        midiWrap.appendChild(midiInput);

                        rowMain.appendChild(midiWrap);
                        rowMain.appendChild(lane);
                        row.appendChild(rowMain);

                        const drawer = document.createElement('div');
                        drawer.className = 'drum-drawer';

                        const vol = document.createElement('input');
                        vol.type = 'range';
                        vol.min = '0'; vol.max = '100'; vol.value = '80';
                        vol.className = 'drum-volume';
                        vol.title = `${name} Volume`;
                        vol.style.cssText = 'margin:0; vertical-align:middle;';
                        vol.addEventListener('input', ()=>{ try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ } try { if (window.omnichord && omnichord._arpTransport && omnichord._arpTransport.isRunning) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: true }); } } catch(_){ } });
                        drawer.appendChild(vol);

                        const sendWrap = document.createElement('label');
                        sendWrap.className = 'drum-send-wrap';
                        sendWrap.style.cssText = 'display:inline-flex;align-items:center;gap:6px;';
                        const sendSpan = document.createElement('span');
                        sendSpan.textContent = 'SEND';
                        sendSpan.style.cssText = 'font-size:10px;color:#9db6c8;';
                        sendWrap.appendChild(sendSpan);
                        const sendEl = document.createElement('input');
                        sendEl.type = 'range';
                        sendEl.min = '0'; sendEl.max = '100'; sendEl.value = '0';
                        sendEl.className = 'drum-send';
                        sendEl.title = `${name} Send to Drum FX (0â€“100%)`;
                        sendEl.addEventListener('input', ()=>{ try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ } try { if (window.omnichord && omnichord._arpTransport && omnichord._arpTransport.isRunning) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: true }); } } catch(_){ } });
                        sendWrap.appendChild(sendEl);
                        drawer.appendChild(sendWrap);

                        // Per-lane params: Pitch offset (semitones), Attack, Decay
                        const params = document.createElement('div');
                        params.className = 'drum-params';
                        params.style.cssText = 'display:inline-flex;align-items:center;gap:6px;margin-left:8px;';
                        const pPitch = document.createElement('input'); pPitch.type='range'; pPitch.min='-12'; pPitch.max='12'; pPitch.value='0'; pPitch.className='mini'; pPitch.title=`${name} Pitch`; params.appendChild(pPitch);
                        pPitch.addEventListener('input', ()=>{ try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ } try { if (window.omnichord && omnichord._arpTransport && omnichord._arpTransport.isRunning) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: true }); } } catch(_){ } });
                        const pAtk = document.createElement('input'); pAtk.type='range'; pAtk.min='0'; pAtk.max='100'; pAtk.value='2'; pAtk.className='mini'; pAtk.title=`${name} Attack`; params.appendChild(pAtk);
                        pAtk.addEventListener('input', ()=>{ try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ } try { if (window.omnichord && omnichord._arpTransport && omnichord._arpTransport.isRunning) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: true }); } } catch(_){ } });
                        const pDec = document.createElement('input'); pDec.type='range'; pDec.min='5'; pDec.max='1000'; pDec.value='180'; pDec.className='mini'; pDec.title=`${name} Decay`; params.appendChild(pDec);
                        pDec.addEventListener('input', ()=>{ try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ } try { if (window.omnichord && omnichord._arpTransport && omnichord._arpTransport.isRunning) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: true }); } } catch(_){ } });

                        // Per-lane QUANT (N/D) inside params for layout stability
                        const qWrap = document.createElement('label');
                        qWrap.style.cssText = 'display:inline-flex;align-items:center;gap:4px;margin-left:6px;';
                        const qSpan = document.createElement('span'); qSpan.textContent = 'Q:'; qSpan.title = `${name} Quant (N/D per-bar)`; qWrap.appendChild(qSpan);
                        const qInput = document.createElement('input');
                        qInput.type = 'text'; qInput.placeholder = 'N/D'; qInput.style.cssText = 'width:60px;';
                        // default quant = stepsPerBar
                        try { lane.dataset.quant = String(stepsPerBar); } catch(_){ }
                        qInput.value = lane.dataset.quant;
                        qInput.addEventListener('change', ()=>{
                            const oldD = Array.from(lane.querySelectorAll('.drum-step')).length || stepsPerBar;
                            const q = parseRowQuant(qInput.value, stepsPerBar);
                            const newStr = q.str;
                            // If PLAY is running, defer quant changes to the next bar to avoid glitches
                            let isPlaying = false;
                            try { isPlaying = !!(window.omnichord && window.omnichord._isSequencing); } catch(_){ isPlaying = false; }
                            if (isPlaying) {
                                lane.dataset.pendingQuant = newStr;
                                lane._pendingQuant = { N: q.N, D: q.D, str: newStr };
                            } else {
                                // Apply immediately when stopped
                                lane.dataset.quant = newStr;
                                lane._quant = { N: q.N, D: q.D, str: newStr };
                                try { delete lane.dataset.pendingQuant; } catch(_){ }
                                try { delete lane._pendingQuant; } catch(_){ }
                                try { this._updateDrumGridForTimeSignature && this._updateDrumGridForTimeSignature(); } catch(_){ }
                                try { this._refreshArpTransportTiming && this._refreshArpTransportTiming(); } catch(_){ }
                            }
                            try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                            try { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: { laneQuant: true } }); } catch(_){ }
                        });
                        qWrap.appendChild(qInput);
                        params.appendChild(qWrap);
                        drawer.appendChild(params);

                        row.appendChild(drawer);

                        // Store handles for playback
                        lane._controls = { vol, sendEl, midiInput, pPitch, pAtk, pDec, name };
                        // Initialize lane quant cache
                        lane._quant = getLaneQuant(lane, stepsPerBar);

                        grid.appendChild(row);

                        // Bass lane: click anywhere maps to nearest step prompt
                        if (name === 'BASS') {
                            lane.addEventListener('click', (e) => {
                                if (e.target && e.target.classList && e.target.classList.contains('drum-step')) return; // step handler already does prompt
                                const rect = lane.getBoundingClientRect();
                                const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
                                const idx = Math.max(0, Math.min(stepsPerBar-1, Math.floor((x / rect.width) * stepsPerBar)));
                                const targetStep = lane.querySelector(`.drum-step[data-step="${idx}"]`);
                                if (targetStep) targetStep.click();
                            });
                            // Bass label: run 16-step prompt sequence (default 1)
                            label.addEventListener('click', (e) => {
                                e.preventDefault();
                                const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                const clearTiesFrom = (fromIdx) => {
                                    for (let k = fromIdx + 1; k < steps.length; k++) { delete steps[k].dataset.tie; }
                                    delete steps[fromIdx].dataset.len;
                                };
                                for (let i = 0; i < steps.length; i++) {
                                    const s = steps[i];
                                    s.classList.add('selected');
                                    const prev = (s.dataset.npc||'').toLowerCase();
                                    const deflt = prev !== '' ? prev : '1';
                                    let val = window.prompt(`BASS NPC for step ${i+1} (1â€“9, x=rest)`, deflt);
                                    s.classList.remove('selected');
                                    if (val == null) break; // cancel ends the sequence
                                    val = String(val).trim();
                                    if (val === '') { s.dataset.npc=''; s.classList.remove('active'); clearTiesFrom(i); continue; }
                                    if (/^x$/i.test(val)) { s.dataset.npc='x'; s.classList.remove('active'); clearTiesFrom(i); continue; }
                                    if (/^[1-9]$/.test(val)) { s.dataset.npc=val; s.classList.add('active'); if (!s.dataset.len) s.dataset.len='1'; }
                                    try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                                }
                            });
                        }
                    });
                }

                // DRUM FX panel (global bus): wire UI -> this.drumFx -> updateDrumFx
                try {
                    if (!this._wireDrumFxPanel) {
                        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
                        const defaults = {
                            sat: { mix: 0.0, hp: 140, lp: 12000 },
                            comp: { threshold: -18, ratio: 4, attack: 0.003, release: 0.25, output: 0 },
                            delay: { timeMs: 180, feedback: 0.25, mix: 0.18 },
                            reverb: { wet: 0.15, decay: 0.12, room: 0.55, hp: 120, lp: 12000 },
                            out: 1.0
                        };

                        const mergeDefaults = (obj, def) => {
                            const o = (obj && typeof obj === 'object') ? obj : {};
                            return {
                                sat: { ...def.sat, ...(o.sat||{}) },
                                comp: { ...def.comp, ...(o.comp||{}) },
                                delay: { ...def.delay, ...(o.delay||{}) },
                                reverb: { ...def.reverb, ...(o.reverb||{}) },
                                out: (o.out != null ? o.out : def.out)
                            };
                        };

                        const setText = (id, text) => {
                            const el = document.getElementById(id);
                            if (el) el.textContent = String(text);
                        };

                        this._applyDrumFxPanel = () => {
                            try {
                                const panel = document.getElementById('drumFxPanel');
                                if (!panel) return;
                                this.drumFx = mergeDefaults(this.drumFx, defaults);

                                const sat = this.drumFx.sat;
                                const comp = this.drumFx.comp;
                                const dly = this.drumFx.delay;
                                const rv = this.drumFx.reverb;

                                const setRange = (id, v) => {
                                    const el = document.getElementById(id);
                                    if (!el) return;
                                    el.value = String(v);
                                };

                                setRange('drumFxSatMix', Math.round(clamp(Number(sat.mix)||0, 0, 1) * 100));
                                setText('drumFxSatMixValue', `${Math.round(clamp(Number(sat.mix)||0,0,1)*100)}%`);

                                setRange('drumFxSatHp', Math.round(clamp(Number(sat.hp)||140, 20, 2000)));
                                setText('drumFxSatHpValue', `${Math.round(clamp(Number(sat.hp)||140,20,2000))}Hz`);

                                setRange('drumFxSatLp', Math.round(clamp(Number(sat.lp)||12000, 200, 20000)));
                                setText('drumFxSatLpValue', `${Math.round(clamp(Number(sat.lp)||12000,200,20000))}Hz`);

                                setRange('drumFxCompThr', Math.round(clamp(Number(comp.threshold)||-18, -60, 0)));
                                setText('drumFxCompThrValue', `${Math.round(clamp(Number(comp.threshold)||-18,-60,0))}dB`);

                                setRange('drumFxCompRatio', Math.round(clamp(Number(comp.ratio)||4, 1, 20)));
                                setText('drumFxCompRatioValue', `${Math.round(clamp(Number(comp.ratio)||4,1,20))}:1`);

                                setRange('drumFxCompAtk', Math.round(clamp((Number(comp.attack)||0.003) * 1000, 1, 100)));
                                setText('drumFxCompAtkValue', `${Math.round(clamp((Number(comp.attack)||0.003)*1000,1,100))}ms`);

                                setRange('drumFxCompRel', Math.round(clamp((Number(comp.release)||0.25) * 1000, 10, 1000)));
                                setText('drumFxCompRelValue', `${Math.round(clamp((Number(comp.release)||0.25)*1000,10,1000))}ms`);

                                setRange('drumFxCompOut', Math.round(clamp(Number(comp.output)||0, -24, 24)));
                                setText('drumFxCompOutValue', `${Math.round(clamp(Number(comp.output)||0,-24,24))}dB`);

                                setRange('drumFxDelayTime', Math.round(clamp(Number(dly.timeMs)||180, 10, 1200)));
                                setText('drumFxDelayTimeValue', `${Math.round(clamp(Number(dly.timeMs)||180,10,1200))}ms`);

                                setRange('drumFxDelayFb', Math.round(clamp(Number(dly.feedback)||0.25, 0, 0.95) * 100));
                                setText('drumFxDelayFbValue', `${Math.round(clamp(Number(dly.feedback)||0.25,0,0.95)*100)}%`);

                                setRange('drumFxDelayMix', Math.round(clamp(Number(dly.mix)||0.18, 0, 1) * 100));
                                setText('drumFxDelayMixValue', `${Math.round(clamp(Number(dly.mix)||0.18,0,1)*100)}%`);

                                setRange('drumFxReverbWet', Math.round(clamp(Number(rv.wet)||0.15, 0, 1) * 100));
                                setText('drumFxReverbWetValue', `${Math.round(clamp(Number(rv.wet)||0.15,0,1)*100)}%`);

                                setRange('drumFxReverbDecay', Math.round(clamp((Number(rv.decay)||0.12) * 1000, 10, 600)));
                                setText('drumFxReverbDecayValue', `${(clamp((Number(rv.decay)||0.12),0.01,1.0)).toFixed(2)}s`);

                                setRange('drumFxReverbRoom', Math.round(clamp(Number(rv.room)||0.55, 0, 1) * 100));
                                setText('drumFxReverbRoomValue', `${Math.round(clamp(Number(rv.room)||0.55,0,1)*100)}%`);

                                setRange('drumFxOut', Math.round(clamp(Number(this.drumFx.out)||1.0, 0, 2.0) * 100));
                                setText('drumFxOutValue', `${Math.round(clamp(Number(this.drumFx.out)||1.0,0,2.0)*100)}%`);
                            } catch(_){ }
                        };

                        this._wireDrumFxPanel = () => {
                            try {
                                const panel = document.getElementById('drumFxPanel');
                                if (!panel || panel._wired) return;
                                panel._wired = true;

                                this.drumFx = mergeDefaults(this.drumFx, defaults);

                                const read = () => {
                                    try {
                                        const get = (id) => {
                                            const el = document.getElementById(id);
                                            const v = el ? parseFloat(el.value) : NaN;
                                            return Number.isFinite(v) ? v : NaN;
                                        };
                                        this.drumFx = mergeDefaults(this.drumFx, defaults);

                                        const satMix = get('drumFxSatMix');
                                        const satHp = get('drumFxSatHp');
                                        const satLp = get('drumFxSatLp');
                                        const thr = get('drumFxCompThr');
                                        const ratio = get('drumFxCompRatio');
                                        const atkMs = get('drumFxCompAtk');
                                        const relMs = get('drumFxCompRel');
                                        const outDb = get('drumFxCompOut');
                                        const dTime = get('drumFxDelayTime');
                                        const dFbPct = get('drumFxDelayFb');
                                        const dMixPct = get('drumFxDelayMix');
                                        const rWetPct = get('drumFxReverbWet');
                                        const rDecayMs = get('drumFxReverbDecay');
                                        const rRoomPct = get('drumFxReverbRoom');
                                        const outPct = get('drumFxOut');

                                        if (Number.isFinite(satMix)) this.drumFx.sat.mix = clamp(satMix / 100, 0, 1);
                                        if (Number.isFinite(satHp)) this.drumFx.sat.hp = clamp(satHp, 20, 2000);
                                        if (Number.isFinite(satLp)) this.drumFx.sat.lp = clamp(satLp, 200, 20000);

                                        if (Number.isFinite(thr)) this.drumFx.comp.threshold = clamp(thr, -60, 0);
                                        if (Number.isFinite(ratio)) this.drumFx.comp.ratio = clamp(ratio, 1, 20);
                                        if (Number.isFinite(atkMs)) this.drumFx.comp.attack = clamp(atkMs / 1000, 0.001, 1.0);
                                        if (Number.isFinite(relMs)) this.drumFx.comp.release = clamp(relMs / 1000, 0.01, 1.0);
                                        if (Number.isFinite(outDb)) this.drumFx.comp.output = clamp(outDb, -24, 24);

                                        if (Number.isFinite(dTime)) this.drumFx.delay.timeMs = clamp(dTime, 10, 1200);
                                        if (Number.isFinite(dFbPct)) this.drumFx.delay.feedback = clamp(dFbPct / 100, 0, 0.95);
                                        if (Number.isFinite(dMixPct)) this.drumFx.delay.mix = clamp(dMixPct / 100, 0, 1);

                                        if (Number.isFinite(rWetPct)) this.drumFx.reverb.wet = clamp(rWetPct / 100, 0, 1);
                                        if (Number.isFinite(rDecayMs)) this.drumFx.reverb.decay = clamp(rDecayMs / 1000, 0.01, 1.0);
                                        if (Number.isFinite(rRoomPct)) this.drumFx.reverb.room = clamp(rRoomPct / 100, 0, 1);

                                        if (Number.isFinite(outPct)) this.drumFx.out = clamp(outPct / 100, 0, 2.0);

                                        try { this.updateDrumFx && this.updateDrumFx(); } catch(_){ }
                                        try { this._applyDrumFxPanel && this._applyDrumFxPanel(); } catch(_){ }
                                    } catch(_){ }
                                };

                                panel.addEventListener('input', (e)=>{
                                    const t = e && e.target;
                                    if (!t || !t.id) return;
                                    read();
                                });
                                panel.addEventListener('change', ()=> read());

                                const resetBtn = document.getElementById('drumFxReset');
                                if (resetBtn && !resetBtn._wired) {
                                    resetBtn._wired = true;
                                    resetBtn.addEventListener('click', (ev)=>{
                                        try { ev.preventDefault(); ev.stopPropagation(); } catch(_){ }
                                        this.drumFx = JSON.parse(JSON.stringify(defaults));
                                        try { this.updateDrumFx && this.updateDrumFx(); } catch(_){ }
                                        try { this._applyDrumFxPanel && this._applyDrumFxPanel(); } catch(_){ }
                                    });
                                }

                                // Initial sync
                                this._applyDrumFxPanel && this._applyDrumFxPanel();
                            } catch(_){ }
                        };
                    }
                } catch(_){ }
                // Build PATTERN grid (harmonic/arpeggio + bass) once
                (function(){
                    const patternGrid = document.getElementById('patternGrid');
                    if (!patternGrid || patternGrid.dataset.built) return;
                    patternGrid.dataset.built = '1';
                    // Pattern length independent from time signature; defaults to 16, user adjustable 1-64
                    const getMaxLen = () => {
                        try {
                            if (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') {
                                return window.omnichord._getMaxCycleSteps();
                            }
                        } catch(_){ }
                        return 64;
                    };
                    let stepsPerBar = Math.max(1, Math.min(getMaxLen(), parseInt(patternGrid.dataset.length||'16',10) || 16));
                    const beatsPerBar = 4; // only used for visual beat dividers (every 4 steps baseline)
                    // Dynamic NPC: get from universalNpc input, default 3
                    const getNpc = () => {
                        const npcEl = document.getElementById('universalNpc');
                        return Math.max(1, Math.min(64, parseInt(npcEl?.value || '3', 10) || 3));
                    };
                    // Generate row labels dynamically based on NPC (NOTE N at top, NOTE 1 at bottom)
                    const generateRowLabels = (npc) => {
                        const labels = [];
                        for (let i = npc; i >= 1; i--) {
                            labels.push(`NOTE ${i}`);
                        }
                        return labels;
                    };
                    let rowLabels = generateRowLabels(getNpc());
                    // Shadow state (persistent up to max 64) so shortening LEN hides, not destroys
                    const shadowState = { // rowIdx -> stepIdx -> data
                        // structure: { [row]: { [step]: { active:1, len, tie, npc } } }
                    };
                    // Shared handler attachment so rebuild can rewire events
                    const attachHandlers = () => {
                        const lanes = Array.from(patternGrid.querySelectorAll('.pattern-lane'));
                        lanes.forEach((lane, rIdx) => {
                            const currentNpc = getNpc();
                            const isBass = false; // No bass row in pattern grid anymore
                            const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                            steps.forEach(st => {
                                if (st._wiredPattern) return; st._wiredPattern = true;
                                // Bass already had specialized logic at creation; skip here if bass
                                if (isBass) return;
                                
                                // LEFT CLICK toggle/prepare drag length
                                st.addEventListener('mousedown', (e)=>{
                                    if (e.button!==0) return;
                                    e.preventDefault();
                                    const stepsLocal = Array.from(lane.querySelectorAll('.pattern-step'));
                                    const pickStepAt = (clientX, clientY) => {
                                        try {
                                            let best = null;
                                            for (let i = 0; i < stepsLocal.length; i++) {
                                                const el = stepsLocal[i];
                                                const r = el.getBoundingClientRect();
                                                if (clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom) return el;
                                                // fallback: nearest center in X
                                                const cx = (r.left + r.right) * 0.5;
                                                const dist = Math.abs(clientX - cx);
                                                if (!best || dist < best.dist) best = { el, dist };
                                            }
                                            return best ? best.el : null;
                                        } catch(_) { return null; }
                                    };
                                    const head = pickStepAt(e.clientX, e.clientY) || st;

                                    // Disabled cells are not interactive (matches DRUM behavior)
                                    if (head.classList && head.classList.contains('disabled')) {
                                        return;
                                    }

                                    // *** PREVENT clicking on tied/sustained dots ***
                                    if (head.dataset.tie === '1') {
                                        return; // Tied dots are not viable - ignore clicks
                                    }

                                    const startIdx = parseInt(head.dataset.step||'0',10) || 0;
                                    const laneLen = Math.max(1, Math.min(getMaxLen(), parseInt((document.getElementById('patternLenValue')?.textContent)||patternGrid.dataset.length||'16',10)||16));
                                    
                                    let isDragging = false;
                                    let dragStarted = false;
                                    const wasActive = head.classList.contains('active');
                                    const startX = e.clientX;
                                    const startY = e.clientY;
                                    const startVel = parseInt(head.dataset.vel || '100', 10);
                                    let isVelMode = false; // true if vertical drag dominates
                                    let isLenMode = false; // true if horizontal drag dominates
                                    
                                    // *** DRAG behavior: Horizontal = pill length, Vertical = velocity ***
                                    const applyLen = (toIdx) => {
                                        const maxIdx = Math.max(0, Math.min(laneLen - 1, stepsLocal.length - 1));
                                        const endIdx = Math.max(startIdx, Math.min(maxIdx, (toIdx|0)));
                                        const len = Math.max(1, endIdx - startIdx + 1);
                                        head.classList.add('active');
                                        head.dataset.len = String(len);
                                        
                                        // Set ties for continuation steps (sustain)
                                        for (let k=0;k<stepsLocal.length;k++){
                                            if (k>startIdx && k<=startIdx+len-1 && k < laneLen) {
                                                stepsLocal[k].dataset.tie='1';
                                                stepsLocal[k].classList.remove('active'); // Ties are not active
                                            } else if (k>startIdx) {
                                                delete stepsLocal[k].dataset.tie;
                                            }
                                        }
                                        // Update shadow state ties
                                        persistRow(rIdx);
                                        // Rebuild visual pill overlay
                                        try { rebuildPatternTieOverlays(lane); } catch(_){}
                                    };
                                    
                                    const applyVel = (clientY) => {
                                        const deltaY = startY - clientY; // Drag up = louder
                                        const deltaVel = Math.round(deltaY / 1.5);
                                        const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                                        head.dataset.vel = String(newVel);
                                        try { window.updateStepVelocityClass(head); } catch(_){ }
                                    };
                                    
                                    const move = (ev)=>{
                                        if (!dragStarted) {
                                            dragStarted = true;
                                            isDragging = true;
                                        }
                                        
                                        const dx = Math.abs(ev.clientX - startX);
                                        const dy = Math.abs(ev.clientY - startY);
                                        
                                        // Determine drag mode: horizontal = length (pills), vertical = velocity
                                        // Favor horizontal: only go velocity mode if dy > dx*2 AND dy > 10
                                        if (!isVelMode && !isLenMode) {
                                            if (dy > dx * 2 && dy > 10) {
                                                // Strong vertical movement = velocity mode
                                                isVelMode = true;
                                                head.classList.add('vel-dragging');
                                                if (!wasActive) {
                                                    head.classList.add('active');
                                                    head.dataset.len = '1';
                                                }
                                            } else if (dx > 3) {
                                                // Any horizontal movement = length mode
                                                isLenMode = true;
                                                if (!wasActive) {
                                                    head.classList.add('active');
                                                    head.dataset.len = '1';
                                                }
                                            }
                                        }
                                        
                                        if (isVelMode) {
                                            applyVel(ev.clientY);
                                        } else if (isLenMode) {
                                            const rect = lane.getBoundingClientRect();
                                            const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
                                            const idx = Math.max(startIdx, Math.min(laneLen-1, Math.floor((x/Math.max(1,rect.width))*laneLen)));
                                            applyLen(idx);
                                        }
                                    };
                                    
                                    const up=()=>{
                                        document.removeEventListener('mousemove', move);
                                        document.removeEventListener('mouseup', up);
                                        head.classList.remove('vel-dragging');
                                        // *** CLICK behavior for non-drag actions ***
                                        if (!isDragging) {
                                            const nowActive = !wasActive;
                                            if (wasActive) {
                                                // Click active cell = delete note
                                                head.classList.remove('active');
                                                delete head.dataset.len;
                                                // Clear any ties
                                                for (let k=startIdx+1;k<stepsLocal.length;k++) { delete stepsLocal[k].dataset.tie; }
                                            } else {
                                                // Click empty cell = 1 step note
                                                head.classList.add('active');
                                                head.dataset.len = '1';
                                            }

                                            // Click-audition when turning on (mute gating is inside _playPatternNote).
                                            try {
                                                if (nowActive && window.omnichord && typeof window.omnichord._playPatternNote === 'function') {
                                                    const D = Math.max(1, stepsLocal.length || 16);
                                                    const stepIdx = Math.max(0, Math.min(D-1, startIdx|0));
                                                    const lenSteps = Math.max(1, Math.min(D - stepIdx, parseInt(head.dataset.len||'1',10)||1));
                                                    const vel = (window.getStepVelocity ? (window.getStepVelocity(head) ?? 100) : (parseInt(head.dataset.vel||'100',10)||100));
                                                    const pt = (window._patternTransport || { stepMs: 120 });
                                                    const stopFn = window.omnichord._playPatternNote(rIdx|0, lenSteps, stepIdx, vel, {
                                                        gridEl: patternGrid,
                                                        instrumentKey: 'arp',
                                                        transport: pt,
                                                        gateMs: Math.max(30, Math.min(800, Math.floor((pt.stepMs||120) * 1.0))),
                                                        maxSteps: D,
                                                    });
                                                    if (stopFn) { try { window._pulseStepEl && window._pulseStepEl(head); } catch(_){ } }
                                                }
                                            } catch(_){ }
                                        }
                                        
                                        persistRow(rIdx);
                                        try { rebuildPatternTieOverlays(lane); } catch(_){}
                                        try { if (typeof window.omnichord?._saveDrumPattern==='function') window.omnichord._saveDrumPattern(); } catch(_){ }
                                        try { if (patternGrid._recomputePatternText) patternGrid._recomputePatternText(); } catch(_){ }
                                        isDragging = false;
                                        dragStarted = false;
                                        isVelMode = false;
                                        isLenMode = false;
                                    };
                                    
                                    document.addEventListener('mousemove', move);
                                    document.addEventListener('mouseup', up);
                                });
                                // Touch drag for pattern non-bass rows
                                st.addEventListener('touchstart', (e)=>{
                                    if (st._touchDragActive) return; // avoid duplicate via synthetic mouse
                                    st._touchDragActive = true;
                                    try { e.preventDefault(); } catch(_) {}
                                    const stepsLocal = Array.from(lane.querySelectorAll('.pattern-step'));
                                    const pickStepAt = (clientX, clientY) => {
                                        try {
                                            let best = null;
                                            for (let i = 0; i < stepsLocal.length; i++) {
                                                const el = stepsLocal[i];
                                                const r = el.getBoundingClientRect();
                                                if (clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom) return el;
                                                const cx = (r.left + r.right) * 0.5;
                                                const dist = Math.abs(clientX - cx);
                                                if (!best || dist < best.dist) best = { el, dist };
                                            }
                                            return best ? best.el : null;
                                        } catch(_) { return null; }
                                    };
                                    const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                                    const laneLen = Math.max(1, Math.min(maxLen, parseInt((document.getElementById('patternLenValue')?.textContent)||patternGrid.dataset.length||'16',10)||16));
                                    let isDragging = false; let dragStarted = false;
                                    let isVelMode = false;
                                    let isLenMode = false;
                                    const touch = e.touches && e.touches[0] ? e.touches[0] : null; if (!touch) { st._touchDragActive=false; return; }
                                    const activeId = touch.identifier;
                                    const head = pickStepAt(touch.clientX, touch.clientY) || st;
                                    if (head.classList && head.classList.contains('disabled')) { st._touchDragActive = false; return; }
                                    if (head.dataset.tie === '1') { st._touchDragActive = false; return; }
                                    const startIdx = parseInt(head.dataset.step||'0',10) || 0;
                                    const startX = touch.clientX;
                                    const startY = touch.clientY;
                                    const startVel = parseInt(head.dataset.vel || '100', 10);
                                    const wasActive = head.classList.contains('active');
                                    const applyLen = (toIdx) => {
                                        const maxIdx = Math.max(0, Math.min(laneLen - 1, stepsLocal.length - 1));
                                        const endIdx = Math.max(startIdx, Math.min(maxIdx, (toIdx|0)));
                                        const len = Math.max(1, endIdx - startIdx + 1);
                                        head.classList.add('active');
                                        head.dataset.len = String(len);
                                        for (let k=0;k<stepsLocal.length;k++){
                                            if (k>startIdx && k<=startIdx+len-1 && k < laneLen) { stepsLocal[k].dataset.tie='1'; stepsLocal[k].classList.remove('active'); }
                                            else if (k>startIdx) { delete stepsLocal[k].dataset.tie; }
                                        }
                                        persistRow(rIdx);
                                        try { rebuildPatternTieOverlays(lane); } catch(_){}
                                    };
                                    const applyVel = (clientY) => {
                                        const deltaY = startY - clientY; // Drag up = louder
                                        const deltaVel = Math.round(deltaY / 1.5);
                                        const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                                        head.dataset.vel = String(newVel);
                                        try { window.updateStepVelocityClass(head); } catch(_){ }
                                    };
                                    const move = (ev)=>{
                                        try { ev.preventDefault(); } catch(_) {}
                                        if (!dragStarted) { dragStarted = true; isDragging = true; }
                                        const tlist = ev.touches || [];
                                        let t=null; for (let j=0;j<tlist.length;j++){ if (tlist[j].identifier===activeId){ t=tlist[j]; break; } }
                                        if (!t) return;
                                        const dx = Math.abs(t.clientX - startX);
                                        const dy = Math.abs(t.clientY - startY);

                                        // Determine drag mode: horizontal = length (pills), vertical = velocity
                                        // Favor horizontal: only go velocity mode if dy > dx*2 AND dy > 10
                                        if (!isVelMode && !isLenMode) {
                                            if (dy > dx * 2 && dy > 10) {
                                                isVelMode = true;
                                                head.classList.add('vel-dragging');
                                                if (!wasActive) {
                                                    head.classList.add('active');
                                                    head.dataset.len = '1';
                                                }
                                            } else if (dx > 3) {
                                                isLenMode = true;
                                                if (!wasActive) {
                                                    head.classList.add('active');
                                                    head.dataset.len = '1';
                                                }
                                            }
                                        }

                                        if (isVelMode) {
                                            applyVel(t.clientY);
                                        } else if (isLenMode) {
                                            const rect = lane.getBoundingClientRect();
                                            const x = Math.max(0, Math.min(rect.width, t.clientX - rect.left));
                                            const idx = Math.max(startIdx, Math.min(laneLen-1, Math.floor((x/Math.max(1,rect.width))*laneLen)));
                                            applyLen(idx);
                                        }
                                    };
                                    const end = (ev)=>{
                                        const changed = ev.changedTouches || [];
                                        let ended=false; for (let j=0;j<changed.length;j++){ if (changed[j].identifier===activeId){ ended=true; break; } }
                                        if (!ended) return;
                                        document.removeEventListener('touchmove', move, { passive: false });
                                        document.removeEventListener('touchend', end);
                                        document.removeEventListener('touchcancel', end);
                                        try { head.classList.remove('vel-dragging'); } catch(_){ }
                                        // Click behavior if no drag
                                        if (!isDragging) {
                                            const nowActive = !wasActive;
                                            if (wasActive) {
                                                head.classList.remove('active');
                                                delete head.dataset.len;
                                                for (let k=startIdx+1;k<stepsLocal.length;k++) { delete stepsLocal[k].dataset.tie; }
                                            } else {
                                                head.classList.add('active');
                                                head.dataset.len = '1';
                                            }

                                            // Tap-audition when turning on (mute gating is inside _playPatternNote).
                                            try {
                                                if (nowActive && window.omnichord && typeof window.omnichord._playPatternNote === 'function') {
                                                    const D = Math.max(1, stepsLocal.length || 16);
                                                    const stepIdx = Math.max(0, Math.min(D-1, startIdx|0));
                                                    const lenSteps = Math.max(1, Math.min(D - stepIdx, parseInt(head.dataset.len||'1',10)||1));
                                                    const vel = (window.getStepVelocity ? (window.getStepVelocity(head) ?? 100) : (parseInt(head.dataset.vel||'100',10)||100));
                                                    const pt = (window._patternTransport || { stepMs: 120 });
                                                    const stopFn = window.omnichord._playPatternNote(rIdx|0, lenSteps, stepIdx, vel, {
                                                        gridEl: patternGrid,
                                                        instrumentKey: 'arp',
                                                        transport: pt,
                                                        gateMs: Math.max(30, Math.min(800, Math.floor((pt.stepMs||120) * 1.0))),
                                                        maxSteps: D,
                                                    });
                                                    if (stopFn) { try { window._pulseStepEl && window._pulseStepEl(head); } catch(_){ } }
                                                }
                                            } catch(_){ }
                                        }
                                        persistRow(rIdx);
                                        try { rebuildPatternTieOverlays(lane); } catch(_){}
                                        try { if (typeof window.omnichord?._saveDrumPattern==='function') window.omnichord._saveDrumPattern(); } catch(_){ }
                                        try { if (patternGrid._recomputePatternText) patternGrid._recomputePatternText(); } catch(_){ }
                                        isDragging = false; dragStarted = false; isVelMode = false; isLenMode = false; st._touchDragActive = false;
                                    };
                                    document.addEventListener('touchmove', move, { passive: false });
                                    document.addEventListener('touchend', end);
                                    document.addEventListener('touchcancel', end);
                                }, { passive: false });
                                
                                // RIGHT CLICK remove note and ties
                                st.addEventListener('contextmenu',(e)=>{
                                    e.preventDefault();
                                    if (st.classList && st.classList.contains('disabled')) return;
                                    const idx = parseInt(st.dataset.step||'0',10) || 0;
                                    const stepsLocal = Array.from(lane.querySelectorAll('.pattern-step'));
                                    if (st.dataset.tie==='1'){
                                        // Find head
                                        let headIdx=-1; for (let k=idx-1;k>=0;k--){ if (stepsLocal[k].dataset.len){ headIdx=k; break; } }
                                        if (headIdx>=0){ const newLen=Math.max(1, idx-headIdx); stepsLocal[headIdx].dataset.len=String(newLen); }
                                        for (let k=idx;k<stepsLocal.length;k++){ delete stepsLocal[k].dataset.tie; }
                                    } else {
                                        // Clear head and ties
                                        const len = parseInt(st.dataset.len||'1',10)||1;
                                        for (let k=idx+1;k<=idx+len-1;k++){ if (stepsLocal[k]) delete stepsLocal[k].dataset.tie; }
                                        delete st.dataset.len;
                                        st.classList.remove('active');
                                    }
                                    persistRow(rIdx);
                                    try { rebuildPatternTieOverlays(lane); } catch(_){}
                                    try { if (typeof window.omnichord?._saveDrumPattern==='function') window.omnichord._saveDrumPattern(); } catch(_){ }
                                    try { if (patternGrid._recomputePatternText) patternGrid._recomputePatternText(); } catch(_){ }
                                });
                            });
                        });
                    };
                    // Expose for external rebuilds to rewire events
                    patternGrid._attachHandlers = attachHandlers;
                    function persistRow(rIdx){
                        const lane = patternGrid.querySelector(`.pattern-lane[data-row="${rIdx}"]`);
                        if (!lane) return;
                        const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                        shadowState[rIdx] = shadowState[rIdx] || {};
                        steps.forEach(st=>{
                            const si = parseInt(st.dataset.step||'0',10)||0;
                            if (st.classList.contains('active')){
                                const obj = { active:1 };
                                if (st.dataset.len) obj.len=st.dataset.len;
                                if (st.dataset.tie==='1') obj.tie=1;
                                if (rIdx===9 && st.dataset.npc) obj.npc=st.dataset.npc; // bass
                                shadowState[rIdx][si]=obj;
                            } else {
                                // Keep shadow data if beyond current visible length; remove if within and cleared
                                if (si < stepsPerBar && shadowState[rIdx][si]) delete shadowState[rIdx][si];
                            }
                        });
                    }
                    function restoreVisibleFromShadow(){
                        Array.from(patternGrid.querySelectorAll('.pattern-lane')).forEach(lane=>{
                            const rIdx = parseInt(lane.dataset.row||'0',10)||0;
                            const rowState = shadowState[rIdx]; if (!rowState) return;
                            Array.from(lane.querySelectorAll('.pattern-step')).forEach(st=>{
                                const si = parseInt(st.dataset.step||'0',10)||0;
                                const saved = rowState[si];
                                if (!saved) return;
                                st.classList.add('active');
                                if (saved.len) st.dataset.len=saved.len; else st.dataset.len='1';
                                if (saved.tie) st.dataset.tie='1'; else delete st.dataset.tie;
                                if (rIdx===9 && saved.npc){ st.dataset.npc=saved.npc; }
                            });
                        });
                    }
                    // Helper to create a row
                    rowLabels.forEach((labelName, rowIdx) => {
                        const row = document.createElement('div');
                        row.className = 'drum-row pattern-row' + (labelName==='BASS' ? ' bass-row' : '');
                        const label = document.createElement('div');
                        label.className = 'drum-label';
                        label.textContent = labelName;
                        row.appendChild(label);
                        const lane = document.createElement('div');
                        lane.className = 'drum-lane pattern-lane';
                        lane.dataset.row = String(rowIdx);
                        try { lane.style.setProperty('--steps-per-bar', String(stepsPerBar)); } catch(_){ }
                        // Add per-row QUANT controls (N/D) for polyrhythms
                        const params = document.createElement('div');
                        params.className = 'drum-params';
                        const qWrap = document.createElement('div');
                        qWrap.className = 'drum-quant';
                        const qLbl = document.createElement('label'); qLbl.textContent = 'Q:'; qLbl.style.marginRight='4px'; qLbl.style.fontSize='10px'; qLbl.style.opacity='0.8';
                        const qInput = document.createElement('input');
                        qInput.type = 'text';
                        qInput.placeholder='Q';
                        qInput.value = String(stepsPerBar);
                        qInput.size = 6; qInput.style.width='56px';
                        qInput.title = 'Row subdivisions (Q per bar). Example: 7 = septuplets. â€œ7/16â€ is treated as 7.';
                        qInput.addEventListener('focus', (e)=> e.target && e.target.select && e.target.select());
                        qInput.addEventListener('change', ()=>{
                            const raw = String(qInput.value||'').trim();
                            // PATTERN rows use true time subdivision: Q = number of equal slices across the bar.
                            // Accept "7" and also "7/16" (treated as 7).
                            let D = stepsPerBar;
                            const mf = raw.match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
                            if (mf) {
                                const n = parseInt(mf[1], 10);
                                if (Number.isFinite(n) && n > 0) D = n;
                            } else {
                                const mn = raw.match(/^\s*(\d+)\s*$/);
                                if (mn) {
                                    const n = parseInt(mn[1], 10);
                                    if (Number.isFinite(n) && n > 0) D = n;
                                }
                            }
                            D = Math.max(1, Math.min(256, D|0));
                            const N = D;
                            const str = String(D);
                            try { qInput.value = String(D); } catch(_){ }
                            // While playing, do NOT change the active quant mid-cycle; queue for next bar.
                            const isPlaying = !!(window.omnichord && window.omnichord._isSequencing);
                            if (isPlaying) {
                                lane.dataset.pendingQuant = str;
                                lane._pendingQuant = { str, N, D };
                            } else {
                                lane.dataset.quant = str;
                                lane._quant = { str, N, D };
                                try { delete lane.dataset.pendingQuant; } catch(_){ }
                                try { delete lane._pendingQuant; } catch(_){ }
                                // Immediate when stopped: row subdivides into D dots now.
                                try { window.rebuildPatternLaneForQuant && window.rebuildPatternLaneForQuant(lane, patternGrid); } catch(_){ }
                                try { if (typeof patternGrid._attachHandlers === 'function') patternGrid._attachHandlers(); } catch(_){ }
                                try { if (patternGrid._recomputePatternText) patternGrid._recomputePatternText(); } catch(_){ }
                            }
                            // Update CSS vars immediately to keep hit-testing aligned before deferred rebuild
                            try {
                                const dNow = (lane._pendingQuant ? lane._pendingQuant.D : (lane._quant && lane._quant.D)) || stepsPerBar;
                                lane.style.setProperty('--steps-per-bar', String(dNow));
                                const container = lane.closest('.drum-grid-container');
                                if (container) {
                                    const lanes = Array.from(container.querySelectorAll('.pattern-lane, .drum-lane'));
                                    const maxD = lanes.reduce((mx,ln)=>{
                                        const qs = ln.dataset.quant||''; let d = stepsPerBar; const mm=qs.match(/^(\d+)\/(\d+)$/); if (mm){ const dd=parseInt(mm[2],10); if(Number.isFinite(dd)&&dd>0) d=dd; } else { const mn=qs.match(/^(\d+)$/); if (mn){ const dd=parseInt(mn[1],10); if(Number.isFinite(dd)&&dd>0) d=dd; } }
                                        return Math.max(mx, d);
                                    }, stepsPerBar);
                                    container.style.setProperty('--bar-steps', String(maxD));
                                }
                            } catch(_){ }
                            try { if (isPlaying) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ pattern: { laneQuant: true } }); } } catch(_){ }
                        });
                        qWrap.appendChild(qLbl); qWrap.appendChild(qInput); params.appendChild(qWrap);
                        row.appendChild(params);
                        // Initialize lane quant cache
                        lane.dataset.quant = lane.dataset.quant || String(stepsPerBar);
                        lane._quant = { str: lane.dataset.quant, N: stepsPerBar, D: stepsPerBar };
                        // Beat dividers
                        const fullBeats = Math.max(0, Math.floor(stepsPerBar/4));
                        for (let b=1; b<fullBeats; b++) {
                            const div = document.createElement('div');
                            div.className = 'beat-divider';
                            div.style.left = `${(b/fullBeats)*100}%`;
                            lane.appendChild(div);
                        }
                        // Steps creation
                        for (let sIdx=0; sIdx<stepsPerBar; sIdx++) {
                            const st = document.createElement('div');
                            st.className = 'drum-step pattern-step' + ((sIdx%4===0)?' beat-accent':'');
                            st.dataset.step = String(sIdx);
                            st.title = `${labelName} â€¢ Step ${sIdx+1}`;
                            if (labelName === 'BASS') {
                                // Bass behaves similarly to removed drum bass lane (drag length + npc selection)
                                st.dataset.npc = '';
                                st.addEventListener('mousedown', (e) => {
                                    if (e.button !== 0) return; e.preventDefault();
                                    const startIdx = sIdx;
                                    const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                                    const applyLen = (toIdx) => {
                                        const len = Math.max(1, (toIdx|0) - startIdx + 1);
                                        st.dataset.len = String(len);
                                        for (let k=0;k<steps.length;k++) {
                                            if (k>startIdx && k<= startIdx+len-1) steps[k].dataset.tie='1'; else if (k>startIdx) delete steps[k].dataset.tie;
                                        }
                                    };
                                    const onMove = (ev) => {
                                        const rect = lane.getBoundingClientRect();
                                        const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
                                        const idx = Math.max(0, Math.min(stepsPerBar-1, Math.floor((x/rect.width)*stepsPerBar)));
                                        applyLen(idx);
                                        try { if (typeof window.omnichord?.rebuildBassTieOverlays === 'function') window.omnichord.rebuildBassTieOverlays(lane); } catch(_){ }
                                    };
                                    const onUp = () => { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); try { if (typeof window.omnichord?.rebuildBassTieOverlays === 'function') window.omnichord.rebuildBassTieOverlays(lane); } catch(_){ } try { if (typeof window.omnichord?._saveDrumPattern==='function') window.omnichord._saveDrumPattern(); } catch(_){ } };
                                    document.addEventListener('mousemove', onMove);
                                    document.addEventListener('mouseup', onUp);
                                });
                                // Touch drag for pattern bass lane
                                st.addEventListener('touchstart', (e) => {
                                    if (st._touchDragActive) return;
                                    st._touchDragActive = true;
                                    try { e.preventDefault(); } catch(_) {}
                                    const touch = e.touches && e.touches[0] ? e.touches[0] : null;
                                    if (!touch) { st._touchDragActive=false; return; }
                                    const activeId = touch.identifier;
                                    const startIdx = sIdx;
                                    const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                                    const applyLen = (toIdx) => {
                                        const len = Math.max(1, (toIdx|0) - startIdx + 1);
                                        st.dataset.len = String(len);
                                        for (let k=0;k<steps.length;k++) {
                                            if (k>startIdx && k<= startIdx+len-1) steps[k].dataset.tie='1'; else if (k>startIdx) delete steps[k].dataset.tie;
                                        }
                                    };
                                    const onMove = (ev) => {
                                        try { ev.preventDefault(); } catch(_) {}
                                        const tlist = ev.touches || [];
                                        let t=null; for (let j=0;j<tlist.length;j++){ if (tlist[j].identifier===activeId){ t=tlist[j]; break; } }
                                        if (!t) return;
                                        const rect = lane.getBoundingClientRect();
                                        const x = Math.max(0, Math.min(rect.width, t.clientX - rect.left));
                                        const idx = Math.max(0, Math.min(stepsPerBar-1, Math.floor((x/rect.width)*stepsPerBar)));
                                        applyLen(idx);
                                        try { if (typeof window.omnichord?.rebuildBassTieOverlays === 'function') window.omnichord.rebuildBassTieOverlays(lane); } catch(_){ }
                                    };
                                    const onEnd = (ev) => {
                                        const changed = ev.changedTouches || [];
                                        let ended=false; for (let j=0;j<changed.length;j++){ if (changed[j].identifier===activeId){ ended=true; break; } }
                                        if (!ended) return;
                                        document.removeEventListener('touchmove', onMove, { passive: false });
                                        document.removeEventListener('touchend', onEnd);
                                        document.removeEventListener('touchcancel', onEnd);
                                        st._touchDragActive = false;
                                        try { if (typeof window.omnichord?.rebuildBassTieOverlays === 'function') window.omnichord.rebuildBassTieOverlays(lane); } catch(_){ }
                                        try { if (typeof window.omnichord?._saveDrumPattern==='function') window.omnichord._saveDrumPattern(); } catch(_){ }
                                    };
                                    document.addEventListener('touchmove', onMove, { passive: false });
                                    document.addEventListener('touchend', onEnd);
                                    document.addEventListener('touchcancel', onEnd);
                                }, { passive: false });
                                st.addEventListener('click', (e) => {
                                    e.preventDefault();
                                    const prev = (st.dataset.npc||'');
                                    if (prev === '') { st.dataset.npc='1'; st.classList.add('active'); if (!st.dataset.len) st.dataset.len='1'; }
                                    else if (prev && prev.toLowerCase() !== 'x') {
                                        st.classList.add('selected');
                                        const valIn = window.prompt('Bass NPC (1â€“9) or x for rest', String(prev).toLowerCase());
                                        st.classList.remove('selected');
                                        if (valIn == null) return; const val = String(valIn).trim();
                                        if (val === '') { st.dataset.npc=''; st.classList.remove('active'); delete st.dataset.len; }
                                        else if (/^x$/i.test(val)) { st.dataset.npc='x'; st.classList.remove('active'); delete st.dataset.len; }
                                        else if (/^[1-9]$/.test(val)) { st.dataset.npc=val; st.classList.add('active'); if (!st.dataset.len) st.dataset.len='1'; }
                                    } else { st.dataset.npc='1'; st.classList.add('active'); if (!st.dataset.len) st.dataset.len='1'; }
                                    try { if (typeof window.omnichord?._saveDrumPattern==='function') window.omnichord._saveDrumPattern(); } catch(_){ }
                                });
                                st.addEventListener('contextmenu', (e) => {
                                    e.preventDefault();
                                    try {
                                        const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                                        const idx = parseInt(st.dataset.step||'0',10) || 0;
                                        if (st.dataset.tie === '1') {
                                            let headIdx=-1; for (let k=idx-1;k>=0;k--){ if (steps[k].dataset.len){ headIdx=k; break; } }
                                            if (headIdx>=0){ const newLen=Math.max(1, idx-headIdx); steps[headIdx].dataset.len=String(newLen); }
                                            for (let k=idx;k<steps.length;k++){ delete steps[k].dataset.tie; }
                                            st.dataset.npc=''; st.classList.remove('active');
                                        } else {
                                            for (let k=idx+1;k<steps.length;k++){ delete steps[k].dataset.tie; }
                                            delete st.dataset.len; st.dataset.npc=''; st.classList.remove('active');
                                        }
                                    } catch(_){ }
                                    try { if (typeof window.omnichord?._saveDrumPattern==='function') window.omnichord._saveDrumPattern(); } catch(_){ }
                                });
                            } else {
                                st.addEventListener('click', (e) => { e.preventDefault(); /* drag handles main behavior */ });
                            }
                            // Default velocity and attach velocity drag
                            st.dataset.vel = '100';
                            try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(st); } catch(_) {}
                            try { if (window.attachVelocityDrag) window.attachVelocityDrag(st); } catch(_) {}
                            lane.appendChild(st);
                        }
                        // No pattern playhead (yellow) to reduce CPU and clutter; drums retain playheads only
                        // Tie overlay layer for visual pills (both bass and pattern rows)
                        if (labelName==='BASS') {
                            const layer = document.createElement('div'); layer.className='bass-tie-layer'; lane.insertBefore(layer, lane.firstChild);
                        } else {
                            // Add pattern tie layer for non-bass rows
                            const layer = document.createElement('div'); layer.className='pattern-tie-layer'; lane.insertBefore(layer, lane.firstChild);
                        }
                        row.appendChild(lane);
                        patternGrid.appendChild(row);
                    });
                    // Expose update function (without new global section) to rebuild steps when length changes
                    patternGrid._rebuildLength = (newLen)=>{
                        const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                        newLen = Math.max(1, Math.min(maxLen, newLen|0));
                        if (parseInt(patternGrid.dataset.length||'0',10) === newLen) return;
                        patternGrid.dataset.length = String(newLen);
                        // Capture existing active state per (row, step)
                        const state = {};
                        Array.from(patternGrid.querySelectorAll('.pattern-lane')).forEach((lane, rIdx)=>{
                            Array.from(lane.querySelectorAll('.pattern-step')).forEach(st=>{
                                const si = parseInt(st.dataset.step||'0',10);
                                if (!state[rIdx]) state[rIdx] = {};
                                if (st.classList.contains('active')) state[rIdx][si] = st.dataset.npc ? { npc: st.dataset.npc, len: st.dataset.len, tie: st.dataset.tie } : { active:1 };
                            });
                        });
                        // Clear rows (keep labels)
                        Array.from(patternGrid.querySelectorAll('.pattern-lane')).forEach(l=>{
                            // remove old steps & any playheads & beat dividers but keep tie layer if bass
                            Array.from(l.querySelectorAll('.pattern-step,.beat-divider,.drum-playhead,.pattern-playhead')).forEach(n=>n.remove());
                        });
                        // Rebuild with new length
                        stepsPerBar = newLen;
                        Array.from(patternGrid.querySelectorAll('.pattern-lane')).forEach((lane)=>{
                            const rowIdx = parseInt(lane.dataset.row||'0',10);
                            const isBass = rowIdx===9;
                            const fullBeats = Math.max(0, Math.floor(newLen/4));
                            for (let b=1; b<fullBeats; b++) {
                                const div = document.createElement('div');
                                div.className='beat-divider';
                                div.style.left = `${(b/fullBeats)*100}%`;
                                lane.appendChild(div);
                            }
                            for (let i=0;i<newLen;i++){
                                const st = document.createElement('div');
                                st.className='drum-step pattern-step'+((i%4===0)?' beat-accent':'');
                                st.dataset.step=String(i);
                                if (isBass){ st.dataset.npc=''; }
                                // Restore state
                                const saved = state[rowIdx] && state[rowIdx][i];
                                if (saved){
                                    st.classList.add('active');
                                    if (saved.npc){ st.dataset.npc=saved.npc; if (saved.len) st.dataset.len=saved.len; if (saved.tie) st.dataset.tie='1'; }
                                }
                                // Reattach event handlers (simplified: reuse click logic via delegation below)
                                lane.appendChild(st);
                            }
                            // No pattern playhead on rebuild
                        });
                        // Reattach handlers and restore any shadow state for visible region
                        try { attachHandlers(); } catch(_){ }
                        try { restoreVisibleFromShadow(); } catch(_){ }
                        try { if (patternGrid._recomputePatternText) patternGrid._recomputePatternText(); } catch(_){ }
                        try { const valSpan=document.getElementById('patternLenValue'); if (valSpan) valSpan.textContent=String(newLen); } catch(_){ }
                        try { if (typeof window.refreshPatternTransportTiming === 'function') window.refreshPatternTransportTiming(); } catch(_){ }
                    };
                    // Rebuild pattern grid rows when NPC changes (dynamic number of NOTE rows)
                    patternGrid._rebuildNpc = (newNpc)=>{
                        newNpc = Math.max(1, Math.min(64, newNpc|0));
                        const currentNpc = patternGrid.querySelectorAll('.drum-row.pattern-row').length;
                        if (currentNpc === newNpc) return;
                        
                        // Save current state before clearing
                        const state = {};
                        Array.from(patternGrid.querySelectorAll('.pattern-lane')).forEach((lane, rIdx)=>{
                            Array.from(lane.querySelectorAll('.pattern-step')).forEach(st=>{
                                const si = parseInt(st.dataset.step||'0',10);
                                if (!state[rIdx]) state[rIdx] = {};
                                if (st.classList.contains('active')) {
                                    state[rIdx][si] = { active:1, len: st.dataset.len, tie: st.dataset.tie, vel: st.dataset.vel };
                                }
                            });
                        });
                        
                        // Clear all rows
                        patternGrid.innerHTML = '';
                        
                        // Generate new row labels (NOTE N at top, NOTE 1 at bottom)
                        rowLabels = generateRowLabels(newNpc);
                        const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                        const currentLen = Math.max(1, Math.min(maxLen, parseInt(patternGrid.dataset.length||'16',10)||16));
                        
                        // Update grid template rows CSS (keep rows tight; do not stretch to fill height)
                        patternGrid.style.gridTemplateRows = `repeat(${newNpc}, auto)`;
                        
                        // Create new rows
                        rowLabels.forEach((labelName, rowIdx) => {
                            const row = document.createElement('div');
                            row.className = 'drum-row pattern-row';
                            const lane = document.createElement('div');
                            lane.className = 'drum-lane pattern-lane';
                            lane.dataset.row = String(rowIdx);
                            lane.dataset.quant = String(currentLen);
                            lane._quant = { str: String(currentLen), N: currentLen, D: currentLen };
                            
                            // Steps creation (no beat dividers for tight pixel grid)
                            for (let sIdx=0; sIdx<currentLen; sIdx++) {
                                const st = document.createElement('div');
                                st.className = 'drum-step pattern-step' + ((sIdx%4===0)?' beat-accent':'');
                                st.dataset.step = String(sIdx);
                                st.title = `${labelName} â€¢ Step ${sIdx+1}`;
                                
                                // Restore state if available
                                // Keep NOTE 1 anchored at the bottom: map rows from the bottom when NPC changes
                                const savedRowIdx = (currentNpc - newNpc) + rowIdx;
                                const saved = (savedRowIdx >= 0 && state[savedRowIdx]) ? state[savedRowIdx][sIdx] : null;
                                if (saved && saved.active) {
                                    st.classList.add('active');
                                    if (saved.len) st.dataset.len = saved.len;
                                    if (saved.tie) st.dataset.tie = '1';
                                }
                                
                                // Default velocity and attach velocity drag
                                st.dataset.vel = (saved && saved.vel != null) ? String(saved.vel) : '100';
                                try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(st); } catch(_) {}
                                try { if (window.attachVelocityDrag) window.attachVelocityDrag(st); } catch(_) {}
                                
                                lane.appendChild(st);
                            }
                            
                            // Add pattern tie layer
                            const layer = document.createElement('div'); 
                            layer.className='pattern-tie-layer'; 
                            lane.insertBefore(layer, lane.firstChild);
                            
                            row.appendChild(lane);
                            patternGrid.appendChild(row);
                        });
                        
                        // Reattach handlers
                        try { attachHandlers(); } catch(_){ }
                        try { if (patternGrid._recomputePatternText) patternGrid._recomputePatternText(); } catch(_){ }
                    };
                    // Wire universalNpc input to rebuild grid when changed
                    const npcInput = document.getElementById('universalNpc');
                    if (npcInput && !npcInput._wiredPatternRebuild) {
                        npcInput._wiredPatternRebuild = true;
                        npcInput.addEventListener('input', ()=>{
                            const newNpc = Math.max(1, Math.min(64, parseInt(npcInput.value||'3',10)||3));
                            const omni = window.omnichord;
                            const running = !!(omni && omni._isSequencing);
                            const patternBtn = document.getElementById('patternBtn');
                            const patternEnabled = !!(patternBtn && patternBtn.classList.contains('active'));
                            if (running && patternEnabled) {
                                try {
                                    const pending = window._patternPendingChanges = window._patternPendingChanges || {};
                                    pending.npc = newNpc;
                                    npcInput.dataset.pending = '1';
                                    npcInput.dataset.pendingValue = String(newNpc);
                                    try { npcInput.classList.add('pending-change'); } catch(_){ }
                                    npcInput.title = `Queued â†’ ${newNpc} (applies next cycle)`;
                                    const scheduleDeferred = window.scheduleDeferred;
                                    if (typeof scheduleDeferred === 'function') scheduleDeferred({ pattern: { npc:true } });
                                } catch(_){ }
                                return;
                            }
                            try {
                                npcInput.classList.remove('pending-change');
                                delete npcInput.dataset.pending;
                                delete npcInput.dataset.pendingValue;
                                npcInput.title = '';
                            } catch(_){ }
                            if (patternGrid._rebuildNpc) patternGrid._rebuildNpc(newNpc);
                        });
                    }
                    if (!window.queuePatternTransportResync) {
                        window.queuePatternTransportResync = function(change){
                            try {
                                const pt = window._patternTransport;
                                const pending = window._patternPendingChanges = window._patternPendingChanges || {};
                                if (change && typeof change === 'object') {
                                    if ('len' in change) pending.len = change.len;
                                    if ('quant' in change) pending.quant = change.quant;
                                    if ('len' in change) {
                                        const lenValueEl = document.getElementById('patternLenValue');
                                        if (lenValueEl) lenValueEl.dataset.pending = '1';
                                    }
                                    if ('quant' in change) {
                                        const patternQuantEl = document.getElementById('patternQuant');
                                        if (patternQuantEl) {
                                            patternQuantEl.dataset.pending = '1';
                                            try { patternQuantEl.classList.add('pending-change'); } catch(_){ }
                                        }
                                    }
                                }
                                const flags = {};
                                if (pending.len != null) flags.len = true;
                                if (pending.quant != null) flags.quant = true;
                                if (Object.keys(flags).length === 0) flags.requested = true;
                                if (pt) {
                                    const omni = window.omnichord;
                                    const transportRunning = !!(omni && omni._arpTransport && omni._arpTransport.running);
                                    const alreadyWaiting = !!pt.waitingForDeferred;
                                    const wasRunning = !!pt.running;
                                    // Do NOT stop pattern transport; mark as waiting and apply at a safe boundary
                                    pt.waitingForDeferred = true;
                                    pt.resumeAfterDeferred = wasRunning || transportRunning || pt.resumeAfterDeferred;
                                    pt.preRollUntil = null;
                                }
                                const scheduleDeferred = window.scheduleDeferred;
                                if (typeof scheduleDeferred === 'function') {
                                    scheduleDeferred({ pattern: flags });
                                } else {
                                    // Minimal fallback: define a deferred applier that runs at bar boundaries
                                    window.scheduleDeferred = function(req){
                                        try {
                                            const omni = window.omnichord;
                                            const pt = window._patternTransport;
                                            const pg = document.getElementById('patternGrid');
                                            if (!pg) return;
                                            window._patternPendingChanges = window._patternPendingChanges || {};
                                            if (req && req.pattern) {
                                                Object.assign(window._patternPendingChanges, pending || {});
                                            }
                                            if (window._patternDeferredTimer) return; // already watching
                                            window._patternDeferredTimer = setInterval(()=>{
                                                try {
                                                    const transport = omni && omni._arpTransport;
                                                    if (!transport || !transport.running) return;
                                                    const atBarStart = ((transport.tickCounter|0) === 0);
                                                    if (!atBarStart) return;
                                                    const todo = window._patternPendingChanges || {};
                                                    let changed = false;
                                                    if (todo.len != null) {
                                                        const newLen = Math.max(1, Math.min(64, parseInt(todo.len,10)||16));
                                                        if (typeof pg._rebuildLength === 'function') pg._rebuildLength(newLen);
                                                        try {
                                                            pg.dataset.length = String(newLen);
                                                            const lenValueEl = document.getElementById('patternLenValue');
                                                            if (lenValueEl) { lenValueEl.textContent = String(newLen); delete lenValueEl.dataset.pending; }
                                                        } catch(_){}
                                                        delete todo.len; changed = true;
                                                    }
                                                    if (todo.quant != null) {
                                                        const q = String(todo.quant).trim();
                                                        pg.dataset.quant = q;
                                                        const patternQuantEl = document.getElementById('patternQuant');
                                                        if (patternQuantEl) { delete patternQuantEl.dataset.pending; try{ patternQuantEl.classList.remove('pending-change'); }catch(_){} }
                                                        if (typeof window.refreshPatternTransportTiming === 'function') window.refreshPatternTransportTiming();
                                                        delete todo.quant; changed = true;
                                                    }
                                                    if (todo.npc != null) {
                                                        const newNpc = Math.max(1, Math.min(64, parseInt(todo.npc,10) || 3));
                                                        try { if (typeof pg._rebuildNpc === 'function') pg._rebuildNpc(newNpc); } catch(_){ }
                                                        try {
                                                            const npcEl = document.getElementById('universalNpc');
                                                            if (npcEl) {
                                                                npcEl.value = String(newNpc);
                                                                npcEl.classList.remove('pending-change');
                                                                delete npcEl.dataset.pending;
                                                                delete npcEl.dataset.pendingValue;
                                                                npcEl.title = '';
                                                            }
                                                        } catch(_){ }
                                                        if (typeof window.refreshPatternTransportTiming === 'function') window.refreshPatternTransportTiming();
                                                        delete todo.npc; changed = true;
                                                    }
                                                    if (changed) {
                                                        // Clear waiting state and optionally resume
                                                        if (pt) {
                                                            pt.waitingForDeferred = false;
                                                            if (pt.resumeAfterDeferred) {
                                                                pt.resumeAfterDeferred = false;
                                                                if (typeof pt.start === 'function') pt.start({ alignToTransport: true });
                                                                else { pt.running = true; pt.kick && pt.kick(); }
                                                            }
                                                        }
                                                        // Stop watcher if nothing pending
                                                        if (!Object.keys(todo).length) {
                                                            clearInterval(window._patternDeferredTimer);
                                                            window._patternDeferredTimer = null;
                                                        }
                                                    }
                                                } catch(_){}
                                            }, 25);
                                        } catch(_){}
                                    };
                                    try { window.scheduleDeferred({ pattern: flags }); } catch(_){ }
                                }
                            } catch(_) { /* noop */ }
                        };
                    }

                    const patternQuantSelect = document.getElementById('patternQuant');
                    if (patternQuantSelect && !patternQuantSelect._patternWired) {
                        patternQuantSelect._patternWired = true;
                        patternQuantSelect.addEventListener('change', ()=>{
                            const val = String(patternQuantSelect.value || '1/16').trim();
                            patternQuantSelect.dataset.pending = '1';
                            try { patternQuantSelect.classList.add('pending-change'); } catch(_){ }
                            try { const pg = document.getElementById('patternGrid'); if (pg) pg.dataset.quant = val; } catch(_){ }
                            try { window.queuePatternTransportResync && window.queuePatternTransportResync({ quant: val }); } catch(_){ }
                        });
                    }

                    // Initial handler attach
                    try { attachHandlers(); restoreVisibleFromShadow(); } catch(_){ }
                    
                    // *** Visual pill rendering for pattern sustained notes ***
                    window.rebuildPatternTieOverlays = function(lane) {
                        try {
                            if (!lane) return;
                            const row = lane.closest('.pattern-row') || lane.closest('.drum-row');
                            if (row && row.classList.contains('bass-row')) return; // Skip bass rows

                            const modal = lane.closest('.floating-modal') || lane.closest('.pattern-modal') || document;
                            
                            // Find or create tie layer
                            let tieLayer = lane.querySelector('.pattern-tie-layer');
                            if (!tieLayer) {
                                tieLayer = document.createElement('div');
                                tieLayer.className = 'pattern-tie-layer';
                                lane.insertBefore(tieLayer, lane.firstChild);
                            }
                            
                            // Clear existing pills
                            tieLayer.innerHTML = '';
                            
                            const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                            const laneD = Math.max(1, (parseInt(lane.style.getPropertyValue('--steps-per-bar') || '', 10) || steps.length || 16));
                            const pg = (modal.querySelector && (modal.querySelector('[data-role="patternGrid"]') || modal.querySelector('.pattern-grid') || modal.querySelector('#patternGrid'))) || document.getElementById('patternGrid');
                            const lenValueEl = (modal.querySelector && (modal.querySelector('[data-role="patternLenValue"]') || modal.querySelector('#patternLenValue'))) || document.getElementById('patternLenValue');
                            const lenFromUi = parseInt((lenValueEl?.textContent || '').trim(), 10);
                            const lenFromPg = parseInt(pg?.dataset?.length || '', 10);
                            const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                            // LEN (cycle) can be different from D (visual subdivision). We cap rendering to LEN,
                            // but geometry is based on D so pills align with dot spacing.
                            const cycleSteps = Math.max(1, Math.min(maxLen, (Number.isFinite(lenFromUi) && lenFromUi>0 ? lenFromUi : (Number.isFinite(lenFromPg) && lenFromPg>0 ? lenFromPg : laneD))));
                            const visibleCount = Math.max(1, Math.min(cycleSteps, steps.length));
                            const visible = steps.slice(0, visibleCount);
                            
                            // Find all sustained note sequences
                            for (let i = 0; i < visible.length; i++) {
                                const step = visible[i];
                                if (step.classList.contains('active') && step.dataset.len) {
                                    const len = parseInt(step.dataset.len || '1', 10);
                                    if (len > 1) {
                                        // Create visual pill for sustained note
                                        const pill = document.createElement('div');
                                        pill.className = 'pattern-tie-pill';
                                        // Preserve velocity coloring from the head step
                                        try {
                                            ['vel-quiet','vel-low','vel-mid','vel-high'].forEach(c=>{
                                                if (step.classList.contains(c)) pill.classList.add(c);
                                            });
                                        } catch(_){ }
                                        
                                        // Calculate pill position and width
                                        // Geometry is based on laneD so it aligns with dot spacing (per-row Q).
                                        // But we clip sustain to the visible cycle length.
                                        const si = Math.max(0, Math.min(visibleCount-1, i));
                                        const startPercent = (si / laneD) * 100;
                                        const widthPercent = (Math.min(len, visibleCount - si) / laneD) * 100;
                                        
                                        pill.style.left = `${startPercent}%`;
                                        pill.style.width = `${widthPercent}%`;
                                        
                                        tieLayer.appendChild(pill);
                                    }
                                }
                            }
                        } catch(e) {
                            console.error('Error rebuilding pattern tie overlays:', e);
                        }
                    };

                    // Rebuild a single PATTERN lane to match its per-row Q (N/D) setting.
                    // When D changes, the lane must contain D dots or playback/indexing will be wrong.
                    window.rebuildPatternLaneForQuant = function(lane, gridEl){
                        try {
                            if (!lane) return;
                            const grid = gridEl || lane.closest('[data-role="patternGrid"], .pattern-grid, #patternGrid');
                            if (!grid) return;

                            const rowIdx = parseInt(lane.dataset.row||'0',10)||0;
                            const isBass = !!(lane.closest('.drum-row')?.classList?.contains('bass-row'));
                            const isBassRow = isBass || (rowIdx === 9);

                            const oldSteps = Array.from(lane.querySelectorAll('.pattern-step'));
                            const fromD = oldSteps.length || Math.max(1, parseInt(grid.dataset.length||'16',10)||16);
                            const snap = oldSteps.map((s, i) => ({
                                i,
                                active: s.classList.contains('active'),
                                len: s.dataset.len,
                                tie: s.dataset.tie,
                                npc: s.dataset.npc,
                                vel: s.dataset.vel,
                            }));

                            const fallbackD = Math.max(1, parseInt(grid.dataset.length||'16',10)||16);
                            let toD = fallbackD;
                            let toN = fallbackD;
                            try {
                                const qStr = String(lane.dataset.quant||'').trim();
                                if (qStr) {
                                    const mf = qStr.match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
                                    if (mf) {
                                        const n = parseInt(mf[1],10);
                                        const d = parseInt(mf[2],10);
                                        if (Number.isFinite(d) && d > 0) toD = d;
                                        if (Number.isFinite(n) && n > 0) toN = Math.min(n, toD);
                                    } else {
                                        const mn = qStr.match(/^\s*(\d+)\s*$/);
                                        if (mn) {
                                            const d = parseInt(mn[1],10);
                                            if (Number.isFinite(d) && d > 0) { toD = d; toN = d; }
                                        }
                                    }
                                }
                            } catch(_){ }
                            toD = Math.max(1, toD|0);
                            toN = Math.max(1, Math.min(toN|0, toD));

                            // Remove only step geometry; keep tie layer + row params.
                            Array.from(lane.querySelectorAll('.pattern-step,.beat-divider,.drum-playhead')).forEach(n=>{ try { n.remove(); } catch(_){ } });
                            try { lane.style.setProperty('--steps-per-bar', String(toD)); } catch(_){ }

                            // Beat dividers baseline: quarters of toD
                            const fullBeats = Math.max(0, Math.floor(toD/4));
                            for (let b=1;b<fullBeats;b++){
                                const div=document.createElement('div');
                                div.className='beat-divider';
                                div.style.left=`${(b/fullBeats)*100}%`;
                                lane.appendChild(div);
                            }

                            // Remap state
                            const dest = new Array(toD).fill(null).map(()=>({}));
                            if (!isBassRow) {
                                snap.forEach(o=>{
                                    if (!o || !o.active) return;
                                    const j = Math.max(0, Math.min(toD-1, Math.round((o.i / Math.max(1, fromD-1)) * (toD-1))));
                                    dest[j].active = 1;
                                    if (o.len) dest[j].len = String(o.len);
                                    if (o.vel != null) dest[j].vel = String(o.vel);
                                });
                            } else {
                                const heads = snap.filter((o, idx)=>{
                                    const npc = String(o?.npc||'').toLowerCase();
                                    if (!npc || npc === 'x') return false;
                                    const prev = snap[idx-1];
                                    return !(prev && prev.tie === '1');
                                });
                                heads.forEach(h=>{
                                    const j = Math.max(0, Math.min(toD-1, Math.round((h.i / Math.max(1, fromD-1)) * (toD-1))));
                                    const len = Math.max(1, parseInt(h.len||'1',10)||1);
                                    dest[j].npc = h.npc;
                                    dest[j].len = String(len);
                                    dest[j].head = 1;
                                });
                            }

                            // Allowed indices for N notes across D divisions (evenly distributed)
                            const allowed = new Set();
                            if (toN >= toD) {
                                for (let k=0;k<toD;k++) allowed.add(k);
                            } else {
                                for (let k=0;k<toN;k++){
                                    const idx = Math.max(0, Math.min(toD-1, Math.floor((k*toD)/toN)));
                                    allowed.add(idx);
                                }
                            }

                            const created = [];
                            for (let i=0;i<toD;i++){
                                const st = document.createElement('div');
                                st.className='drum-step pattern-step'+((i%4===0)?' beat-accent':'');
                                st.dataset.step=String(i);
                                const prev = dest[i] || null;
                                if (isBassRow) st.dataset.npc='';
                                if (prev) {
                                    if (!isBassRow) {
                                        if (prev.active) st.classList.add('active');
                                        if (prev.len) st.dataset.len = String(prev.len);
                                    } else {
                                        if (prev.npc && String(prev.npc).toLowerCase() !== 'x') { st.dataset.npc = String(prev.npc); st.classList.add('active'); }
                                        if (prev.len) st.dataset.len = String(prev.len);
                                    }
                                }
                                if (!isBassRow) {
                                    st.dataset.vel = (prev && prev.vel != null) ? String(prev.vel) : '100';
                                    try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(st); } catch(_){ }
                                    try { if (window.attachVelocityDrag) window.attachVelocityDrag(st); } catch(_){ }
                                }
                                if (!isBassRow && !allowed.has(i)) st.classList.add('disabled');
                                lane.appendChild(st);
                                created.push(st);
                            }

                            // Recreate tie markers from head len so editing rules still work.
                            try {
                                for (let i=0;i<created.length;i++){
                                    const head = created[i];
                                    if (!head || !head.classList.contains('active')) continue;
                                    const len = Math.max(1, parseInt(head.dataset.len||'1',10)||1);
                                    for (let k=1;k<len;k++){
                                        const idx = i + k;
                                        if (idx >= created.length) break;
                                        created[idx].dataset.tie = '1';
                                        created[idx].classList.remove('active');
                                    }
                                }
                            } catch(_){ }

                            // Rebuild overlays
                            try {
                                if (!isBassRow) {
                                    window.rebuildPatternTieOverlays && window.rebuildPatternTieOverlays(lane);
                                } else {
                                    const omni = window.omnichord;
                                    if (omni && typeof omni.rebuildBassTieOverlays === 'function') omni.rebuildBassTieOverlays(lane);
                                }
                            } catch(_){ }
                        } catch(_){ }
                    };
                    
                    // Wire length buttons
                    try {
                        // Clear buttons for Pattern / Drums / Bass
                        (function(){
                            const patternClear = document.getElementById('patternClearBtn');
                            if (patternClear && !patternClear._wired){
                                patternClear._wired = true;
                                patternClear.addEventListener('click', ()=>{
                                    try {
                                        const pg = document.getElementById('patternGrid');
                                        if (!pg) return;
                                        const lanes = Array.from(pg.querySelectorAll('.pattern-lane'));
                                        lanes.forEach(lane => {
                                            const steps = Array.from(lane.querySelectorAll('.pattern-step, .drum-step'));
                                            steps.forEach(st => {
                                                // Skip bass in pattern grid: it has an 'npc' dataset key (even if empty)
                                                if (st.dataset && Object.prototype.hasOwnProperty.call(st.dataset, 'npc')) return;
                                                st.classList.remove('active');
                                                delete st.dataset.len;
                                                delete st.dataset.tie;
                                            });
                                            try { window.rebuildPatternTieOverlays && window.rebuildPatternTieOverlays(lane); } catch(_){}
                                        });
                                        try { if (pg._recomputePatternText) pg._recomputePatternText(); } catch(_){}
                                        try { if (typeof window.queuePatternTransportResync === 'function') window.queuePatternTransportResync({ requested: true }); } catch(_){}
                                        // Autosave to current pattern slot after clearing
                                        try { window.omnichord && window.omnichord._saveArpPattern && window.omnichord._saveArpPattern(); } catch(_){}
                                    } catch(_){}
                                });
                            }
                            const drumClear = document.getElementById('drumClearBtn');
                            if (drumClear && !drumClear._wired){
                                drumClear._wired = true;
                                drumClear.addEventListener('click', ()=>{
                                    try {
                                        const dg = document.getElementById('drumGrid');
                                        if (!dg) return;
                                        const lanes = Array.from(dg.querySelectorAll('.drum-row'));
                                        lanes.forEach(row => {
                                            if (row.classList.contains('bass-row')) return; // keep bass lane intact here
                                            const steps = Array.from(row.querySelectorAll('.drum-step'));
                                            steps.forEach(st => { st.classList.remove('active'); delete st.dataset.len; delete st.dataset.tie; });
                                        });
                                        try { window.omnichord && window.omnichord._saveDrumPattern && window.omnichord._saveDrumPattern(); } catch(_){}
                                    } catch(_){}
                                });
                            }
                            const bassClear = document.getElementById('bassClearBtn');
                            if (bassClear && !bassClear._wired){
                                bassClear._wired = true;
                                bassClear.addEventListener('click', ()=>{
                                    try {
                                        const bg = document.getElementById('bassGrid');
                                        if (!bg) return;
                                        const lanes = Array.from(bg.querySelectorAll('.drum-row, .pattern-row, .pattern-lane'));
                                        if (lanes.length === 0) {
                                            // If lanes are not semantically grouped, operate directly on steps
                                            const steps = Array.from(bg.querySelectorAll('.drum-step, .pattern-step'));
                                            steps.forEach(st => { st.classList.remove('active'); delete st.dataset.len; delete st.dataset.tie; if (st.dataset) st.dataset.npc = ''; });
                                        } else {
                                            lanes.forEach(lane => {
                                                const steps = Array.from(lane.querySelectorAll('.drum-step, .pattern-step'));
                                                steps.forEach(st => { st.classList.remove('active'); delete st.dataset.len; delete st.dataset.tie; if (st.dataset) st.dataset.npc = ''; });
                                                try { window.omnichord && window.omnichord.rebuildBassTieOverlays && window.omnichord.rebuildBassTieOverlays(lane); } catch(_){}
                                            });
                                        }
                                        try { window.omnichord && window.omnichord._saveDrumPattern && window.omnichord._saveDrumPattern(); } catch(_){}
                                    } catch(_){}
                                });
                            }
                        })();
                        const inc=document.getElementById('patternLenInc');
                        const dec=document.getElementById('patternLenDec');
                        const valSpan=document.getElementById('patternLenValue');
                        if (valSpan) valSpan.textContent=patternGrid.dataset.length||'16';
                        if (inc && !inc._wired){
                            inc._wired=true;
                            inc.addEventListener('click',()=>{
                                const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                                const cur = Math.max(1, Math.min(maxLen, parseInt(patternGrid.dataset.length||'16',10)||16));
                                const nextLen = Math.min(maxLen, cur + 1);
                                if (nextLen === cur) return;
                                // Do not rebuild immediately; defer to next cycle
                                try { const valSpan=document.getElementById('patternLenValue'); if (valSpan) { valSpan.textContent=String(nextLen); valSpan.dataset.pending='1'; } } catch(_){}
                                try { window.queuePatternTransportResync && window.queuePatternTransportResync({ len: nextLen }); } catch(_){ }
                            });
                        }
                        if (dec && !dec._wired){
                            dec._wired=true;
                            dec.addEventListener('click',()=>{
                                const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                                const cur = Math.max(1, Math.min(maxLen, parseInt(patternGrid.dataset.length||'16',10)||16));
                                const nextLen = Math.max(1, cur - 1);
                                if (nextLen === cur) return;
                                // Do not rebuild immediately; defer to next cycle
                                try { const valSpan=document.getElementById('patternLenValue'); if (valSpan) { valSpan.textContent=String(nextLen); valSpan.dataset.pending='1'; } } catch(_){}
                                try { window.queuePatternTransportResync && window.queuePatternTransportResync({ len: nextLen }); } catch(_){ }
                            });
                        }
                        const handle=document.getElementById('patternResizeHandle');
                        if (handle && !handle._wired){
                            handle._wired=true;
                            handle.style.touchAction = 'none'; // Enable touch handling
                            
                            // Mouse events
                            handle.addEventListener('mousedown',(e)=>{
                                e.preventDefault();
                                const startX=e.clientX; const startLen=parseInt(patternGrid.dataset.length||'16',10)||16;
                                const move=(ev)=>{
                                    const dx=ev.clientX-startX; // ~8px per step heuristic
                                    const delta=Math.round(dx/8);
                                    const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                                    const newLen=Math.min(maxLen, Math.max(1, startLen+delta));
                                    // Live preview only updates displayed LEN; no rebuild until boundary
                                    try { const valSpan=document.getElementById('patternLenValue'); if (valSpan) { valSpan.textContent=String(newLen); valSpan.dataset.pending='1'; } } catch(_){}
                                };
                                const up=()=>{
                                    document.removeEventListener('mousemove',move);
                                    document.removeEventListener('mouseup',up);
                                    const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                                    const finalLen = Math.max(1, Math.min(maxLen, parseInt((document.getElementById('patternLenValue')?.textContent)||patternGrid.dataset.length||'16',10)||16));
                                    try { window.queuePatternTransportResync && window.queuePatternTransportResync({ len: finalLen }); } catch(_){ }
                                };
                                document.addEventListener('mousemove',move); document.addEventListener('mouseup',up);
                            });
                            
                            // Touch events
                            handle.addEventListener('touchstart',(e)=>{
                                e.preventDefault();
                                const touch = e.touches[0];
                                const startX=touch.clientX; const startLen=parseInt(patternGrid.dataset.length||'16',10)||16;
                                const move=(ev)=>{
                                    ev.preventDefault();
                                    const touch = ev.touches[0];
                                    const dx=touch.clientX-startX; // ~8px per step heuristic
                                    const delta=Math.round(dx/8);
                                    const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                                    const newLen=Math.min(maxLen, Math.max(1, startLen+delta));
                                    // Live preview only updates displayed LEN; no rebuild until boundary
                                    try { const valSpan=document.getElementById('patternLenValue'); if (valSpan) { valSpan.textContent=String(newLen); valSpan.dataset.pending='1'; } } catch(_){}
                                };
                                const up=()=>{
                                    document.removeEventListener('touchmove',move);
                                    document.removeEventListener('touchend',up);
                                    const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                                    const finalLen = Math.max(1, Math.min(maxLen, parseInt((document.getElementById('patternLenValue')?.textContent)||patternGrid.dataset.length||'16',10)||16));
                                    try { window.queuePatternTransportResync && window.queuePatternTransportResync({ len: finalLen }); } catch(_){ }
                                };
                                document.addEventListener('touchmove',move); document.addEventListener('touchend',up);
                            });
                        }
                    } catch(_){ }
                })();
            }

            // Build or refresh bass tie overlay pills for a lane
            rebuildBassTieOverlays(lane){
                try {
                    if (!lane || !lane.closest('.bass-row')) return;
                    let layer = lane.querySelector('.bass-tie-layer');
                    if (!layer) {
                        layer = document.createElement('div');
                        layer.className = 'bass-tie-layer';
                        lane.insertBefore(layer, lane.firstChild);
                    }
                    while (layer.firstChild) layer.removeChild(layer.firstChild);
                    const steps = Array.from(lane.querySelectorAll('.drum-step'));
                    const total = steps.length;
                    const laneRect = lane.getBoundingClientRect();
                    const stepW = total > 0 ? (laneRect.width / total) : 0;
                    for (let i=0;i<total;i++){
                        const head = steps[i];
                        const npc = (head.dataset.npc||'').toLowerCase();
                        const len = parseInt(head.dataset.len||'1',10);
                        if (!npc || npc==='x') continue;
                        if (!Number.isFinite(len) || len<=1) continue;
                        const left = (i/total)*100;
                        const widthPct = (Math.min(total, i+len) - i) / total * 100;
                        const pill = document.createElement('div');
                        pill.className = 'bass-tie-pill';
                        pill.style.left = left + '%';
                        pill.style.width = widthPct + '%';
                        layer.appendChild(pill);
                    }
                } catch(_) { }
            }
            
            // ============= NEW CHORD CREATION SYSTEM =============
            
            enterChordCreationMode() {
                console.log('?? Entering chord creation mode');
                this.chordCreationMode = true;
                // When entering fresh creation mode (not from edit), clear edit flags
                if (!this.isEditingChord) {
                    this.editingOriginalIndex = null;
                }
                // Start blank: no notes pre-selected
                this.selectedIntervals = [];
                this.previewInterval = null;
                
                // Change UI to creation mode
                document.body.classList.add('chord-creation-mode');
                
                // Add a preview chord column immediately
                this.addPreviewChordColumn();
                
                // Update create button to save mode
                const createBtn = document.getElementById('createNewChordBtn');
                createBtn.textContent = 'Save Chord';
                createBtn.style.background = '#e74c3c';
                createBtn.style.borderColor = '#c0392b';
                
                // Update root button behavior for interval selection
                if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
                this.setupIntervalSelection();
            }

            // Parse MIDI note name like C2, D#2, Gb1 to MIDI number (12-TET only)
            _parseMidiNoteName(name){
                try {
                    if (name == null) return null;
                    const s = String(name).trim();
                    if (/^-?\d+$/.test(s)) {
                        const d = parseInt(s, 10);
                        if (!Number.isFinite(d)) return null;
                        return Math.max(0, Math.min(127, d));
                    }
                    const m = s.match(/^([A-Ga-g])([#bâ™¯â™­]?)(-?\d{1,2})$/);
                    if (!m) return null;
                    const letters = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };
                    let semi = letters[m[1].toUpperCase()];
                    const acc = m[2]||'';
                    if (acc === '#' || acc === 'â™¯') semi += 1;
                    if (acc === 'b' || acc === 'â™­') semi -= 1;
                    const octave = parseInt(m[3],10);
                    const midi = (octave + 1) * 12 + ((semi % 12) + 12) % 12;
                    return Math.max(0, Math.min(127, midi));
                } catch(_) { return null; }
            }

            _formatMidiNoteName(midi, preferSharps = true) {
                const n = Math.max(0, Math.min(127, Math.round(Number(midi))));
                if (!Number.isFinite(n)) return 'C2';
                const namesSharp = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const namesFlat  = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
                const name = (preferSharps ? namesSharp : namesFlat)[((n % 12) + 12) % 12] || 'C';
                const octave = Math.floor(n / 12) - 1;
                return `${name}${octave}`;
            }
            
            exitChordCreationMode() {
                console.log('?? Exiting chord creation mode');
                this.chordCreationMode = false;
                this.isEditingChord = false;
                this.editingOriginalIndex = null;
                // Return to blank state
                this.selectedIntervals = [];
                this.previewInterval = null;
                
                // Stop any preview audio
                this.stopPreviewAudio();
                
                // Remove preview column if it exists
                this.removePreviewChordColumn();
                
                // Restore UI
                document.body.classList.remove('chord-creation-mode');
                
                // Restore create button
                const createBtn = document.getElementById('createNewChordBtn');
                createBtn.textContent = '+';
                createBtn.style.background = '';
                createBtn.style.borderColor = '';
                
                // Restore normal root button behavior
                this.restoreNormalRootButtons();
            }
            
            setupIntervalSelection() {
                // Target all elements with data-step (keys + micro dots)
                const interactive = document.querySelectorAll('#rootGrid [data-step]');
                interactive.forEach(el => {
                    const step = parseInt(el.dataset.step,10);
                    // Replace node to remove previous listeners (root selection)
                    const clone = el.cloneNode(true);
                    el.parentNode.replaceChild(clone, el);
                    clone.classList.remove('preview');
                    // Maintain root highlight separately (active) but allow selection highlighting (selected)
                    // Consider selection across any octave layer: highlight base key if any selected iv maps to this step mod EDO
                    const edo = this.currentTuning || 12;
                    const isSelected = (this.selectedIntervals||[]).some(iv => ((iv % edo)+edo)%edo === step);
                    if (isSelected) clone.classList.add('selected'); else clone.classList.remove('selected');
                    clone.addEventListener('click', (e)=>{
                        e.stopPropagation();
                        // Clear any hover preview so the clicked element's state updates immediately
                        this.previewInterval = null;
                        try {
                            document.querySelectorAll('#rootGrid [data-step].preview').forEach(x=> x.classList.remove('preview'));
                        } catch {}
                        this.toggleInterval(step);
                    });
                    clone.addEventListener('mouseenter', ()=> this.previewInterval(step));
                    clone.addEventListener('mouseleave', ()=> this.clearPreview());
                });
            }
            
            toggleInterval(interval) {
                
                // dataset.step is already the absolute step; pan offset was applied during generation
                const absStep = interval;
                const index = this.selectedIntervals.indexOf(absStep);
                if (index > -1) {
                    // Remove interval
                    this.selectedIntervals.splice(index, 1);
                    const oi = this.selectedIntervalsOrder.indexOf(absStep);
                    if (oi > -1) this.selectedIntervalsOrder.splice(oi, 1);
                } else {
                    // Add interval
                    this.selectedIntervals.push(absStep);
                    this.selectedIntervals.sort((a, b) => a - b);
                    // Preserve entry order separately (no sorting)
                    if (!this.selectedIntervalsOrder.includes(absStep)) this.selectedIntervalsOrder.push(absStep);
                }
                
                // Update button states
                this.updateIntervalButtons();

                // Do not force any note if empty; allow blank state
                // Update the preview chord column immediately
                this.updatePreviewChordColumn();
                // Immediate name update (lowest note as root)
                try {
                    const header = document.querySelector('#previewChordColumn .chord-name');
                    if (header) {
                        if (this.selectedIntervals.length>1) {
                            const edo = this.currentTuning || 12;
                            const absSteps = this.selectedIntervals.map(iv => ((iv % edo) + edo) % edo);
                            const preferredBass = (this.selectedIntervalsOrder && this.selectedIntervalsOrder.length>0)
                                ? ((this.selectedIntervalsOrder[0] % edo)+edo)%edo : null;
                            header.textContent = this.computeFullChordNameFromAbsoluteSteps(absSteps, edo, preferredBass) || 'New Chord';
                        } else {
                            header.textContent = 'Select notesâ€¦';
                        }
                    }
                } catch {}
                
                console.log('ðŸŽµ Selected intervals (steps):', this.selectedIntervals);
                console.log('ðŸŽµ Button clicked (step -> abs):', interval, '->', absStep);
            }
            
            previewInterval(interval) {
                // In chord creation mode, intervals are direct microtonal steps
                if (this.selectedIntervals.includes(interval)) return;
                
                this.previewInterval = interval;
                this.updateIntervalButtons();
                
                // Play single note preview using microtonal interval
                this.playNotePreview(interval);
            }

            // Create a brand-new blank chord column (no carry-over), set it active, and arm editing
            // Optional: { insertAfterId } inserts immediately to the right of that chord.
            createBlankChordColumn(opts) {
                const options = (opts && typeof opts === 'object') ? opts : {};
                const insertAfterId = (options.insertAfterId != null) ? String(options.insertAfterId) : null;
                // Ensure chord extensions array exists
                if (!Array.isArray(this.chordExtensions)) this.chordExtensions = [];
                
                // Check if this is the first chord - if so, add loop brackets
                const isFirstChord = this.chordExtensions.length === 0;
                
                if (isFirstChord) {
                    // Add opening bracket with proper moveable attributes
                    const startBracket = {
                        name: '[', type: 'bracket', isRepeatMarker: true,
                        nestLevel: 1, id: 'bracket_start_L1_' + Date.now(), position: this.chordExtensions.length,
                        bracketType: 'open', moveable: true, isLoopMarker: true
                    };
                    this.chordExtensions.push(startBracket);
                }
                
                // Find the position to insert the new chord.
                // Default behavior: insert before any closing brackets at the right edge.
                let insertPositionBeforeClosing = this.chordExtensions.length;
                if (!isFirstChord) {
                    for (let i = this.chordExtensions.length - 1; i >= 0; i--) {
                        const ext = this.chordExtensions[i];
                        if (ext && ext.isRepeatMarker && (ext.name === ']' || /^\]x\d+$/.test(ext.name))) {
                            insertPositionBeforeClosing = i;
                        } else {
                            break;
                        }
                    }
                }

                // TAB behavior: insert immediately after the chord being edited.
                let insertPosition = insertPositionBeforeClosing;
                if (insertAfterId) {
                    const idx = (this.chordExtensions || []).findIndex(e => e && e.id === insertAfterId);
                    if (idx >= 0) insertPosition = idx + 1;
                }
                // Never insert past the right-edge closing bracket group.
                if (insertPosition > insertPositionBeforeClosing) insertPosition = insertPositionBeforeClosing;
                
                const id = `custom_${Date.now()}_${Math.floor(Math.random()*1e6)}`;
                const newChord = {
                    id,
                    name: 'New',
                    intervals: [], // start blank; user taps to add
                    isCustom: true,
                    quality: 'custom',
                    len16: 16,
                    position: insertPosition
                };
                
                // Insert the chord at the calculated position
                this.chordExtensions.splice(insertPosition, 0, newChord);
                
                // Update positions for all elements after the insertion
                for (let i = insertPosition + 1; i < this.chordExtensions.length; i++) {
                    this.chordExtensions[i].position = i;
                }
                
                if (isFirstChord) {
                    // Add closing bracket with proper moveable attributes
                    const endBracket = {
                        name: ']', type: 'bracket', isRepeatMarker: true,
                        nestLevel: 1, id: 'bracket_end_L1_' + Date.now(), position: this.chordExtensions.length,
                        bracketType: 'close', moveable: true, isLoopMarker: true
                    };
                    this.chordExtensions.push(endBracket);
                }
                // Track this as a pending blank chord eligible for inheritance on next external strum
                this.pendingBlankChordId = id;
                this.pendingBlankChordStrumEligible = true;
                if (typeof this.saveChordConfiguration === 'function') {
                    try { this.saveChordConfiguration(); } catch (_) {}
                }
                // Regenerate grid and focus the new column
                this.generateExtensionColumns();

                // If we're currently sequencing (PLAY active), defer sequence/plan rebuild until the next cycle.
                try {
                    if (this._isSequencing && this._arpTransport) {
                        this._arpTransport._seqRebuildRequested = true;
                    }
                } catch(_) {}
                
                // Find the column by data-chord-id
                const column = document.querySelector(`.extension-column[data-chord-id='${id}']`);
                if (column) {
                    // Check for modal collisions and auto-close if they overlap the new chord column
                    try { this.closeModalsOverlappingRect(column.getBoundingClientRect()); } catch(_){ }

                    // Initialize per-column state
                    column.dataset.localTranspose = '0';
                    // Replace strings with a blank prompt area
                    try { this.generateStringsForColumn(column, [], true); } catch (_) {}
                    // Make it the active column and clear keyboard highlights
                    this.currentActiveColumnEl = column;
                    this.editArmed = true; // ready to capture key taps
                    try { this.highlightKeyboardForColumn(column); } catch(_) {}
                    // Scroll into view slightly
                    try { column.scrollIntoView({behavior:'smooth', block:'nearest', inline:'center'}); } catch(_){ }
                    // Immediately focus the chord name for typing a symbol (e.g., Dm, Em7)
                    try {
                        const nameEl = column.querySelector('.extension-header .chord-name');
                        if (nameEl) {
                            nameEl.setAttribute('contenteditable', 'true');
                            nameEl.setAttribute('spellcheck', 'false');
                            nameEl.focus();
                            // Select all text for quick overwrite
                            const sel = window.getSelection && window.getSelection();
                            if (sel && document.createRange) {
                                const range = document.createRange();
                                range.selectNodeContents(nameEl);
                                sel.removeAllRanges();
                                sel.addRange(range);
                            }
                        }
                    } catch (_) {}
                }
            }

            // Create a chord from a dragged root note (single-note chord)
            _createChordFromRootAbsStep(absStep, tuning, opts) {
                try {
                    const edo = tuning || this.currentTuning || 12;
                    const rootStep = ((absStep % edo) + edo) % edo;
                    const rootName = this.getRootNameForStep(rootStep, edo);

                    this.createBlankChordColumn(opts);
                    const id = this.pendingBlankChordId;
                    if (!id) return;
                    const idx = (this.chordExtensions || []).findIndex(c => c && String(c.id) === String(id));
                    const model = (idx >= 0) ? this.chordExtensions[idx] : null;
                    if (!model) return;

                    try {
                        if (this.pendingBlankChordId && String(chordId) === String(this.pendingBlankChordId)) {
                            this.pendingBlankChordStrumEligible = false;
                        }
                    } catch(_) {}

                    model.isCustom = true;
                    model.quality = 'custom';
                    model.intervals = [0];
                    model.fixedRootStepAbs = rootStep;
                    model.fixedRootTuning = edo;
                    model.lastTuning = edo;
                    model.name = rootName;
                    model.preferredRootName = rootName;
                    this.pendingBlankChordId = null;

                    const column = document.querySelector(`.extension-column[data-chord-id='${id}']`);
                    if (column) {
                        const nameEl = column.querySelector('.extension-header .chord-name');
                        if (nameEl) {
                            nameEl.textContent = rootName;
                            nameEl.dataset.lockedName = rootName;
                        }
                        const oldContainer = column.querySelector('.strings-column');
                        if (oldContainer) oldContainer.remove();
                        this.generateStringsForColumn(column, model.intervals, true);
                        try { this.highlightKeyboardForColumn(column); } catch(_) {}
                        this.currentActiveColumnEl = column;
                    }
                    try { this.saveChordConfiguration?.(); } catch(_){ }
                    try { this.updateChordDisplay?.(); } catch(_){ }
                } catch(_){ }
            }

            _handleRootKeyDrop(evt, absStep, tuning) {
                try {
                    if (!Number.isFinite(absStep)) return;
                    const x = evt?.clientX;
                    const y = evt?.clientY;
                    if (!Number.isFinite(x) || !Number.isFinite(y)) return;
                    const el = document.elementFromPoint(x, y);
                    if (!el) return;
                    const container = document.getElementById('extensionColumns');
                    const strumArea = document.getElementById('strumArea');
                    const isDropTarget = (el.closest && (el.closest('#extensionColumns') || el.closest('#strumArea')));
                    if (!isDropTarget) return;

                    const existingCols = container
                        ? Array.from(container.querySelectorAll('.extension-column'))
                            .filter(c => c && !c.classList.contains('repeat-marker-column') && c.dataset.isSpacer !== 'true')
                        : [];
                    if (existingCols.length === 0) {
                        this._createChordFromRootAbsStep(absStep, tuning);
                        return;
                    }
                } catch(_){ }
            }
            
            // Auto-close modals that overlap the chord area when creating new chords
            closeModalsOverlappingChordArea() {
                try {
                    const chordArea = document.getElementById('extensionColumns');
                    if (!chordArea) return;
                    
                    this.closeModalsOverlappingRect(chordArea.getBoundingClientRect());
                } catch (e) {
                    console.warn('Modal collision detection failed:', e);
                }
            }

            // Auto-close floating modals that overlap a specific rect (used when adding new chords)
            closeModalsOverlappingRect(targetRect) {
                try {
                    if (!targetRect) return;

                    const rect = targetRect;
                    const overlaps = (a, b) => !(
                        a.right < b.left ||
                        a.left > b.right ||
                        a.bottom < b.top ||
                        a.top > b.bottom
                    );

                    // Prefer catching all floating modals (including Pattern/Drum clones), not just a fixed list.
                    const modals = Array.from(document.querySelectorAll('.floating-modal'));

                    // Some modals may not have the class; keep legacy IDs as a safety net.
                    ['fxModal', 'oscModal', 'tuningModal', 'keyboardModal', 'textChordModal'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el && !modals.includes(el)) modals.push(el);
                    });

                    modals.forEach(modal => {
                        try {
                            if (!modal) return;
                            if (modal.style && modal.style.display === 'none') return;
                            const mrect = modal.getBoundingClientRect();
                            if (!overlaps(mrect, rect)) return;
                            // Hide/minimize any modal that is covering the newly created chord.
                            modal.style.display = 'none';
                        } catch(_) { }
                    });
                } catch (e) {
                    console.warn('Modal collision detection failed:', e);
                }
            }
            
            clearPreview() {
                this.previewInterval = null;
                this.updateIntervalButtons();
                this.stopPreviewAudio();
            }
            
        updateIntervalButtons() {
                const all = document.querySelectorAll('#rootGrid [data-step]');
                all.forEach(el=>{
                    const step = parseInt(el.dataset.step,10);
                    el.classList.remove('selected','preview');
            const edo = this.currentTuning || 12;
            const isSelected = (this.selectedIntervals||[]).some(iv => ((iv % edo)+edo)%edo === step);
            if (isSelected) {
                        el.classList.add('selected');
                    } else if (this.previewInterval === step) {
                        el.classList.add('preview');
                    }
                });
            }
            
            async playNotePreview(interval) {
                this.stopPreviewAudio();
                
                const audioReady = await this.ensureAudioContext();
                if (!audioReady) return;
                
                // Use current tuning and audition around middle octave for audibility
                // In chord-creation mode, the interval is already an absolute EDO step.
                // Otherwise, treat it as relative to the current root.
                const edo = this.currentTuning || 12;
                const absStep = this.chordCreationMode
                    ? ((interval % edo) + edo) % edo
                    : (((this.currentRoot || 0) + (interval % edo)) % edo + edo) % edo;
                const frequency = this.getFrequency(absStep, 4, this.currentTuning);
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.05);
                
                oscillator.connect(gainNode);
                // Route through master chain (global wet/dry + reverb)
                gainNode.connect(this.gainNode);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.3);
                
                this.tempChordAudio.set('preview', { oscillator, gainNode });
            }
            
            async playChordPreview() {
                this.stopPreviewAudio();
                
                const audioReady = await this.ensureAudioContext();
                if (!audioReady || this.selectedIntervals.length === 0) return;
                
                // Play all selected intervals as a chord
                this.selectedIntervals.forEach((interval, index) => {
                    const edo = this.currentTuning || 12;
                    const absStep = this.chordCreationMode
                        ? ((interval % edo) + edo) % edo
                        : (((this.currentRoot || 0) + (interval % edo)) % edo + edo) % edo;
                    const frequency = this.getFrequency(absStep, 4, this.currentTuning);
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.05, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 1.0);
                    
                    oscillator.connect(gainNode);
                    // Route through master chain (global wet/dry + reverb)
                    gainNode.connect(this.gainNode);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 1.0);
                    
                    this.tempChordAudio.set(`chord-${index}`, { oscillator, gainNode });
                });
            }
            
            stopPreviewAudio() {
                this.tempChordAudio.forEach(({ oscillator, gainNode }) => {
                    try {
                        gainNode.gain.setValueAtTime(gainNode.gain.value, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.05);
                        oscillator.stop(this.audioContext.currentTime + 0.05);
                    } catch(e) { /* ignore stop errors */ }
                });
                this.tempChordAudio.clear();
            }
            
            saveNewChordAutomatic() {
                if (this.selectedIntervals.length < 2) {
                    alert('Please select at least 2 intervals (including root)');
                    return;
                }
                
                // Always compute name with the lowest note as root
                this.finalizePreviewChord(null);
                
                console.log(`?? Auto-saved new chord from lowest note root`, this.selectedIntervals);
                
                // Exit creation mode
                this.exitChordCreationMode();
            }
            
            saveNewChord() {
                let chordName = document.getElementById('chordNameInput').value.trim();
                
                if (!chordName) {
                    // Fall back to computed root+quality from preview
                    if (this.selectedIntervals.length >= 2) {
                        this.finalizePreviewChord(null);
                        this.exitChordCreationMode();
                        return;
                    } else {
                        alert('Please select at least 2 intervals (including root)');
                        return;
                    }
                }
                
                if (this.selectedIntervals.length < 2) {
                    alert('Please select at least 2 intervals (including root)');
                    return;
                }
                // Prefer the provided name but we still re-root by lowest tone when saving
                this.finalizePreviewChord(chordName);
                console.log(`?? Saved new chord with provided name (re-rooted by lowest tone): ${chordName}`, this.selectedIntervals);
                
                // Exit creation mode
                this.exitChordCreationMode();
            }
            
            addPreviewChordColumn() {
                // Create a temporary preview chord column at the end
                const extensionColumns = document.getElementById('extensionColumns');
                if (!extensionColumns) return;
                
                const previewColumn = document.createElement('div');
                previewColumn.className = 'extension-column preview-chord-column';
                previewColumn.id = 'previewChordColumn';
                previewColumn.style.border = '3px dashed #2E8B57';
                previewColumn.style.background = 'rgba(46, 139, 87, 0.1)';
                
                // Add header
                const header = document.createElement('div');
                header.className = 'extension-header';
                header.style.background = 'rgba(46, 139, 87, 0.8)';
                header.innerHTML = '<span class="chord-name">New Chord</span>';
                previewColumn.appendChild(header);
                
                // Add strings container
                const stringsContainer = document.createElement('div');
                stringsContainer.className = 'strings-column';
                stringsContainer.id = 'previewStringsContainer';
                previewColumn.appendChild(stringsContainer);
                
                // Add note labels
                const noteLabels = document.createElement('div');
                noteLabels.className = 'note-labels';
                noteLabels.id = 'previewNoteLabels';
                previewColumn.appendChild(noteLabels);
                
                extensionColumns.appendChild(previewColumn);
                
                // Add touch gesture support for strumming the preview chord
                this.addTouchGestureToElement(previewColumn, 'chord');
                this.addClickGestureToElement(previewColumn, 'chord');
                
                // Initial update with root note
                this.updatePreviewChordColumn();
            }
            
            updatePreviewChordColumn() {
                const stringsContainer = document.getElementById('previewStringsContainer');
                const noteLabels = document.getElementById('previewNoteLabels');
                const header = document.querySelector('#previewChordColumn .chord-name');
                
                if (!stringsContainer || !noteLabels || !header) return;
                
                // Clear existing strings
                stringsContainer.innerHTML = '';
                
                // Name from lowest absolute steps for consistency with main columns.
                // Prefer the first-selected tone as the bass to avoid accidental C injection.
                if (this.selectedIntervals && this.selectedIntervals.length > 1) {
                    const edo = this.currentTuning || 12;
                    const absSteps = this.selectedIntervals.map(iv => ((iv % edo) + edo) % edo);
                    const preferredBass = (this.selectedIntervalsOrder && this.selectedIntervalsOrder.length>0)
                        ? ((this.selectedIntervalsOrder[0] % edo) + edo) % edo
                        : null;
                    const label = this.computeFullChordNameFromAbsoluteSteps(absSteps, edo, preferredBass);
                    header.textContent = label || 'New Chord';
                } else {
                    header.textContent = 'Select notesâ€¦';
                }
                
                // Use the same string generation as the main fretboard
                this.generateStringsForPreviewColumn(stringsContainer, this.selectedIntervals);
                
                // Update note labels
                const noteNames = this.selectedIntervals.map(interval => {
                    const edo = this.currentTuning || 12;
                    const absStep = ((interval % edo) + edo) % edo;
                    return this.getMicrotonalNoteName(absStep);
                });
                noteLabels.textContent = noteNames.join(' ');
            }
            
            generateStringsForPreviewColumn(container, intervals, previewColumnOverride = null) {
                // Clear any existing content
                container.innerHTML = '';
                const tuningSize = this.currentTuning || this.getTuningStepsPerOctave();
                // Nothing to show until we have at least 2 tones (root + one)
                const nonRoot = (intervals||[]).filter(iv => iv !== 0);
                if (!intervals || intervals.length < 2 || nonRoot.length === 0) {
                    return;
                }
                
                // Use the EXACT same system as generateStringsForColumn 
                const noteNames = this.getNoteNames();
                // Optionally duplicate selected intervals up one octave for quick two-octave entries
                let ivs = [...intervals];
                
                // Generate string frequencies for full C1-C8 octave range (8 full octaves)
                const stringFreqs = [];
                for (let octave = 1; octave <= 8; octave++) {
                    ivs.forEach(interval => {
                        // In creation preview, intervals are absolute EDO steps
                        const step = ((interval % tuningSize) + tuningSize) % tuningSize;
                        const freq = this.getFrequency(step, octave, this.currentTuning);
                        stringFreqs.push({ freq, step, octave, interval });
                    });
                }
                
                // Sort for preview based on Play Mode: low-high => low at top; else high at top
                try {
                    const __pm = (this.playMode || 'high-low');
                    const __desc = (__pm === 'low-high') ? false : true;
                    stringFreqs.sort((a,b)=> __desc ? (b.freq - a.freq) : (a.freq - b.freq));
                } catch(_) {
                    // Fallback to a stable order if playMode is not available
                    // Avoid recursion: fall back directly to immediate chord play
                    try { this.playChordChordsMode(columnElement, clientY); } catch(_){ }
                }
                
                // Calculate string sizing to MATCH main column behavior (fill height uniformly)
                const previewColumn = previewColumnOverride || document.getElementById('previewChordColumn');
                const availableHeight = (previewColumn ? previewColumn.offsetHeight : 500);
                const headerHeight = 40;
                const stringsHeight = availableHeight - headerHeight - 2; // minimal padding
                const numStrings = stringFreqs.length || 1;
                const stringHeight = Math.max(1, Math.floor(stringsHeight / numStrings) - 0.5);
                const stringMargin = 0.2; // minimal margin for tight packing
                
                // Style the container exactly like main columns
                container.style.cssText = `
                    flex: 1;
                    overflow: hidden;
                    padding: 1px;
                    height: calc(100% - ${headerHeight}px);
                    display: flex;
                    flex-direction: column;
                    justify-content: space-evenly;
                `;
                // Subtle root tint for preview using detected root from selected intervals
                try {
                    const edo = this.currentTuning || 12;
                    const t = (this.transposeDelta || 0) % edo;
                    const steps = (intervals||[]).map(s => (((s + t) % edo) + edo) % edo).sort((a,b)=> this.stepToSemitone(a, edo)-this.stepToSemitone(b, edo));
                    const bass = steps[0];
                    const semi = this.stepToSemitone(bass, edo);
                    const accent = this.getChromaticColorForSemitone(semi) || '#000000';
                    const tint = (hex => {
                        const m = /^#?([0-9a-f]{6})$/i.exec(hex || '');
                        if (!m) return 'rgba(0,0,0,0)';
                        const n = parseInt(m[1], 16);
                        let r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                        r = Math.max(6, Math.floor(r * 0.08));
                        g = Math.max(6, Math.floor(g * 0.08));
                        b = Math.max(6, Math.floor(b * 0.08));
                        return `linear-gradient(to bottom, rgba(${r},${g},${b},0.12), rgba(${r},${g},${b},0.08))`;
                    })(accent);
                    container.style.setProperty('--root-tint-gradient', tint);
                } catch (_) {}
                
                stringFreqs.forEach((stringData, stringIndex) => {
                    const stringEl = document.createElement('div');
                    stringEl.className = 'string';
                    stringEl.dataset.index = stringIndex;
                    stringEl.dataset.column = 'preview';
                    stringEl.dataset.frequency = stringData.freq;
                    stringEl.dataset.noteIndex = stringData.step;
                    stringEl.dataset.octave = String(stringData.octave);
                    // Highlight mid octaves (3â€“4)
                    try {
                        const oct = parseInt(stringEl.dataset.octave, 10);
                        if (oct === 3 || oct === 4) stringEl.classList.add('mid-octave');
                    } catch(_) {}

                    // Universal pitch color and glow
                        const uni = this.getUniversalPitchColorForStep(stringData.step, tuningSize);
                        const baseColor = uni.color;
                    const glowColor = (baseColor && baseColor.toLowerCase() === '#000000') ? '#555555' : baseColor;
                    stringEl.dataset.glowColor = glowColor;

                    // Visible core
                    const core = document.createElement('div');
                    core.className = 'string-core';
                    core.style.background = baseColor;
                    core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;

                    // Tooltip
                    stringEl.title = `${noteNames[stringData.step] || `Note ${stringData.step}`} - Oct${stringData.octave} - ${stringData.freq.toFixed(1)}Hz`;

                    // Hover effects
                    stringEl.addEventListener('mouseenter', () => {
                        core.style.transform = 'scaleY(1.25)';
                        core.style.boxShadow = `0 0 6px ${glowColor}, 0 0 14px ${glowColor}CC, 0 0 28px ${glowColor}88`;
                    });
                    stringEl.addEventListener('mouseleave', () => {
                        core.style.transform = 'scaleY(1)';
                        core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;
                    });

                    // Click handlers
                    stringEl.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        this.playPreviewString(stringEl, stringData.freq, stringData.interval);
                    });
                    stringEl.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.playPreviewString(stringEl, stringData.freq, stringData.interval);
                    });

                    // Attach core and row
                    stringEl.appendChild(core);
                    container.appendChild(stringEl);

                    // Precompute vibration period and store on core
                    const period = this.computeVibrationPeriod(stringData.freq, stringData.step);
                    core.style.setProperty('--vib-period', period + 'ms');
                });
                // Ensure all generated octave strings fit within visible area (rescale heights if needed)
                this.ensureStringsFullyVisible(container);
            }
            
            playPreviewString(stringElement, frequency, interval) {
                // Neon active feedback using per-string glow color
                const glow = stringElement.dataset.glowColor || this.getUniversalPitchColorForStep(parseInt(stringElement.dataset.noteIndex||'0',10), this.currentTuning||12).color || '#FFFFFF';
                const core = stringElement.querySelector('.string-core');
                if (core) {
                    core.style.transform = 'scaleY(1.3)';
                    core.style.boxShadow = `0 0 6px ${glow}, 0 0 16px ${glow}B3, 0 0 24px ${glow}80`;
                    core.style.filter = 'brightness(1.15)';
                    // Start vibration briefly for preview
                    const period = this.computeVibrationPeriod(frequency, parseInt(stringElement.dataset.noteIndex||'0',10));
                    core.style.setProperty('--vib-period', period + 'ms');
                    core.classList.add('vibrating');
                    setTimeout(()=> core.classList.remove('vibrating'), 220);
                }

                // Play the note using the same system as main strings
                this.playStringNote(frequency, interval);

                // Reset visual state after a delay
                setTimeout(() => {
                    if (core) {
                        core.style.transform = 'scaleY(1)';
                        core.style.boxShadow = `0 0 4px ${glow}, 0 0 10px ${glow}AA, 0 0 18px ${glow}66`;
                        core.style.filter = 'brightness(1)';
                    }
                }, 200);
            }
            
            async playStringNote(frequency, interval) {
                const ready = await this.ensureAudioContext();
                if (!ready) return;
                
                // Use the current oscillator and envelope settings
                let source;
                const gainNode = this.audioContext.createGain();
                
                // Apply current oscillator settings
                const t = this.oscillators.osc1.type;
                if (t === 'noise') {
                    // Brown noise preview with a peaking EQ centered at the played frequency
                    const noise = this.createNoiseSource();
                    const peak = this.audioContext.createBiquadFilter();
                    peak.type = 'peaking';
                    peak.frequency.setValueAtTime(Math.max(10, Math.min(this.audioContext.sampleRate/2, frequency)), this.audioContext.currentTime);
                    // Map Shape Width (0..1) to Q (0.5..60) exponentially for musical feel
                    {
                        const sw = Math.max(0, Math.min(1, this.oscillators.osc1.shapeWidth ?? 0.5));
                        const minQ = 0.5, maxQ = 60;
                        const q = minQ * Math.pow(maxQ / minQ, sw);
                        peak.Q.setValueAtTime(q, this.audioContext.currentTime);
                    }
                    // Level controls resonance gain: 0..+48 dB; 0 dB yields plain brown noise
                    const lvlNorm = Math.max(0, Math.min(1, (this.oscillators.osc1.level || 0) / 0.125));
                    peak.gain.setValueAtTime(lvlNorm * 48, this.audioContext.currentTime);
                    source = peak;
                    // Start/stop the buffer source based on envelope timing
                    // We'll capture the underlying buffer source to stop later
                    source.__noiseSource = noise;
                } else {
                    source = this.audioContext.createOscillator();
                    if (['sine','sawtooth','square','pulse','fullrect','halfrect','parabolic','stair'].includes(t)) {
                        source.setPeriodicWave(this.getCustomPeriodicWave(t, this.oscillators.osc1.pulseWidth, this.oscillators.osc1.shapeWidth));
                    } else { source.type = t; }
                    source.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                }
                
                // Apply current ADSR envelope
                const now = this.audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                // Let master gainNode handle global volume; keep per-note envelope in a musical range
                gainNode.gain.linearRampToValueAtTime(1.0, now + this.envelope.attack);
                gainNode.gain.exponentialRampToValueAtTime(Math.max(0, Math.min(1, this.envelope.sustain)), now + this.envelope.attack + this.envelope.decay);
                // Release to zero after decay completes
                gainNode.gain.linearRampToValueAtTime(0, now + this.envelope.attack + this.envelope.decay + this.envelope.release);
                
                // Connect through reverb if enabled
                source.connect(gainNode);
                // Always route into master gainNode so global wet/dry split handles reverb
                gainNode.connect(this.gainNode);
                
                // Start/stop respecting noise vs oscillator
                if (t === 'noise' && source.__noiseSource) {
                    try { source.__noiseSource.start(); } catch(_) {}
                    try { source.__noiseSource.stop(now + this.envelope.attack + this.envelope.decay + this.envelope.release); } catch(_) {}
                } else {
                    source.start();
                    source.stop(now + this.envelope.attack + this.envelope.decay + this.envelope.release);
                }
                
                // Store for cleanup
                this.tempChordAudio.set(`preview-${Date.now()}`, { oscillator: source, gainNode });
            }

            // ============= CALC (Chord Calculator) =============
            initCalcModalUI() {
                if (this._calcWired) return;
                const modal = document.getElementById('keyboardModal');
                if (!modal) return;
                const clearBtn = document.getElementById('calcClearBtn');
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        this.resetCalcState();
                        this.refreshCalcUI();
                    });
                }

                const addBtn = document.getElementById('calcAddBtn');
                if (addBtn) {
                    addBtn.addEventListener('click', () => {
                        if (!this.calcState) this.resetCalcState();
                        this.calcState.addMode = !this.calcState.addMode;
                        this.refreshCalcUI();
                    });
                }

                const equalsBtn = document.getElementById('calcEqualsBtn');
                if (equalsBtn) {
                    equalsBtn.addEventListener('click', () => {
                        this.insertCalcChordFromState({ replace: false });
                    });
                }

                const changeBtn = document.getElementById('calcChangeBtn');
                if (changeBtn) {
                    changeBtn.addEventListener('click', () => {
                        const replacing = !!(this.isEditingChord && typeof this.editingOriginalIndex === 'number' && this.editingOriginalIndex >= 0);
                        if (!replacing) return;
                        this.insertCalcChordFromState({ replace: true });
                    });
                }

                const grid = document.getElementById('calcKeypadGrid');
                if (grid && !grid._wired) {
                    grid._wired = true;
                    grid.addEventListener('click', (e) => {
                        const btn = e.target && e.target.closest ? e.target.closest('[data-calc-key]') : null;
                        if (!btn) return;
                        if (!this.calcState) this.resetCalcState();
                        const key = btn.dataset.calcKey;
                        const type = btn.dataset.calcType;
                        const clearCustom = () => {
                            if (!this.calcState) return;
                            this.calcState.useCustomIntervals = false;
                            this.calcState.customIntervals = null;
                            this.calcState.customRootStep = null;
                            this.calcState.customName = null;
                        };
                        clearCustom();

                        if (type === 'note') {
                            const acc = btn.dataset.calcAcc;
                            this.calcState.note = key;
                            this.calcState.accSymbol = (acc === 'b' || acc === '#') ? acc : null;
                            this.calcState._accSelected = true;
                            if (typeof this.calcState.microOffset !== 'number') this.calcState.microOffset = 0;
                            this.calcState.stage = 'quality';
                        } else if (type === 'micro') {
                            const delta = (key === 'down') ? -1 : 1;
                            this.calcState.microOffset = (this.calcState.microOffset || 0) + delta;
                            this.calcState._accSelected = true;
                        } else if (this.calcState.stage !== 'root') {
                            if (type === 'quality') {
                                this.calcState.quality = key;
                            } else if (type === 'ext') {
                                const mod = this.calcState.modifier || null;
                                const add = !!this.calcState.addMode;
                                const entry = { label: key, mod, add };
                                this.calcState.extensions = Array.isArray(this.calcState.extensions) ? this.calcState.extensions : [];
                                this.calcState.extensions.push(entry);
                                this.calcState.modifier = null;
                                this.calcState.addMode = false;
                            } else if (type === 'mod') {
                                this.calcState.modifier = (this.calcState.modifier === key) ? null : key;
                            }
                        }
                        this.refreshCalcUI();
                    });
                }

                const calcPreview = document.getElementById('calcPreviewColumn');
                const calcPreviewHeader = document.getElementById('calcPreviewHeader');
                if (calcPreview && calcPreviewHeader) {
                    calcPreviewHeader.setAttribute('draggable', 'true');
                    let headerDragStart = null;
                    let headerDragged = false;

                    calcPreviewHeader.addEventListener('dragstart', (e) => {
                        calcPreview.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', 'calc-chord');
                    });
                    calcPreviewHeader.addEventListener('dragend', () => {
                        calcPreview.classList.remove('dragging');
                        headerDragStart = null;
                        headerDragged = false;
                    });
                    calcPreviewHeader.addEventListener('pointerdown', (e) => {
                        if (e.pointerType === 'mouse' && e.button !== 0) return;
                        headerDragStart = { x: e.clientX, y: e.clientY };
                        headerDragged = false;
                    });
                    calcPreviewHeader.addEventListener('pointermove', (e) => {
                        if (!headerDragStart) return;
                        const dx = Math.abs(e.clientX - headerDragStart.x);
                        const dy = Math.abs(e.clientY - headerDragStart.y);
                        if (dx > 6 || dy > 6) headerDragged = true;
                    });
                    calcPreviewHeader.addEventListener('pointerup', (e) => {
                        if (e.pointerType === 'mouse' && e.button !== 0) return;
                        const now = Date.now();
                        if (calcPreviewHeader._calcInsertGuard && (now - calcPreviewHeader._calcInsertGuard) < 250) return;
                        if (!headerDragged) {
                            calcPreviewHeader._calcInsertGuard = now;
                            this.insertCalcChordFromState({ replace: false });
                        }
                        headerDragStart = null;
                        headerDragged = false;
                    });

                    // Rely on pointer events for touch to avoid double inserts

                    // Strum preview on the strings area (drag up/down)
                    let strumStart = null;
                    const isHeaderTarget = (ev) => {
                        const t = ev.target;
                        return t && (t === calcPreviewHeader || calcPreviewHeader.contains(t));
                    };
                    const startStrum = (x, y) => {
                        strumStart = { x, y };
                    };
                    const endStrum = (x, y) => {
                        if (!strumStart) return;
                        const calcChord = this._computeCalcChord();
                        this.playChordStrum(calcPreview, { name: calcChord.name || 'CALC' }, strumStart.y, y);
                        strumStart = null;
                    };

                    calcPreview.addEventListener('pointerdown', (e) => {
                        if (isHeaderTarget(e)) return;
                        if (e.pointerType === 'mouse' && e.button !== 0) return;
                        e.preventDefault();
                        e.stopPropagation();
                        startStrum(e.clientX, e.clientY);
                    });
                    calcPreview.addEventListener('pointerup', (e) => {
                        if (!strumStart) return;
                        e.preventDefault();
                        e.stopPropagation();
                        endStrum(e.clientX, e.clientY);
                    });
                    calcPreview.addEventListener('pointercancel', () => { strumStart = null; });

                    calcPreview.addEventListener('touchstart', (e) => {
                        if (isHeaderTarget(e)) return;
                        const t = e.touches && e.touches[0];
                        if (!t) return;
                        e.preventDefault();
                        e.stopPropagation();
                        startStrum(t.clientX, t.clientY);
                    }, { passive: false });
                    calcPreview.addEventListener('touchend', (e) => {
                        const t = e.changedTouches && e.changedTouches[0];
                        if (!t || !strumStart) return;
                        e.preventDefault();
                        e.stopPropagation();
                        endStrum(t.clientX, t.clientY);
                    }, { passive: false });
                }

                this._calcWired = true;
            }

            resetCalcState() {
                this.calcState = {
                    stage: 'root',
                    note: null,
                    accSymbol: null,
                    microOffset: 0,
                    quality: 'maj',
                    extensions: [],
                    modifier: null,
                    addMode: false,
                    useCustomIntervals: false,
                    customIntervals: null,
                    customRootStep: null,
                    customName: null,
                    insertIndex: null,
                    _accSelected: false
                };
            }

            openCalcModal(opts = {}) {
                this.initCalcModalUI();
                const modal = document.getElementById('keyboardModal');
                if (modal) {
                    modal.style.display = 'block';
                    bringModalToFront('keyboardModal');
                    if (!modal._draggableSet) {
                        makeDraggable(modal);
                        modal._draggableSet = true;
                    }
                }
                const btn = document.getElementById('keyboardBtn');
                if (btn) btn.classList.add('active');

                if (!this.calcState) this.resetCalcState();
                this.calcState.insertIndex = null;

                if (opts && opts.column) {
                    this._loadCalcFromColumn(opts.column);
                } else if (opts && opts.chord) {
                    this._loadCalcFromChord(opts.chord);
                } else {
                    this.isEditingChord = false;
                    this.editingOriginalIndex = null;
                    if (!this.calcState) this.resetCalcState();
                }
                this.refreshCalcUI();
            }

            closeCalcModal() {
                const modal = document.getElementById('keyboardModal');
                if (modal) modal.style.display = 'none';
                const btn = document.getElementById('keyboardBtn');
                if (btn) btn.classList.remove('active');
            }

            _loadCalcFromColumn(column) {
                if (!column) return;
                const chordId = column.dataset && column.dataset.chordId ? String(column.dataset.chordId) : null;
                let chord = null;
                if (chordId && Array.isArray(this.chordExtensions)) {
                    chord = this.chordExtensions.find(ext => String(ext.id) === chordId);
                }
                if (!chord) {
                    const pos = column.dataset && column.dataset.originalPosition != null ? parseInt(column.dataset.originalPosition, 10) : -1;
                    if (pos >= 0 && Array.isArray(this.chordExtensions) && this.chordExtensions[pos]) chord = this.chordExtensions[pos];
                }
                if (!chord) return;

                this._loadCalcFromChord(chord);
                // Capture editing index for replace
                const idx = (typeof chord.position === 'number') ? chord.position : (this.chordExtensions || []).indexOf(chord);
                if (idx >= 0) {
                    this.isEditingChord = true;
                    this.editingOriginalIndex = idx;
                }
            }

            _loadCalcFromChord(chord) {
                if (!chord) return;
                if (!this.calcState) this.resetCalcState();
                this.calcState.useCustomIntervals = true;
                this.calcState.customIntervals = Array.isArray(chord.intervals) ? chord.intervals.slice() : [];
                this.calcState.customRootStep = (typeof chord.fixedRootStepAbs === 'number') ? chord.fixedRootStepAbs : (this.currentRoot || 0);
                this.calcState.customName = chord.name || null;
                this.calcState.stage = 'root';
                this.calcState.note = null;
                this.calcState.accSymbol = null;
                this.calcState.microOffset = 0;
                this.calcState._accSelected = false;
            }

            _calcBuildName(state) {
                if (!state || !state.note) return 'â€”';
                const accMap = { b: 'â™­', '#': 'â™¯', n: '' };
                const acc = accMap[state.accSymbol] || '';
                let micro = '';
                try {
                    const m = state.microOffset || 0;
                    if (m < 0) micro = 'v'.repeat(Math.min(4, Math.abs(m)));
                    if (m > 0) micro = '^'.repeat(Math.min(4, Math.abs(m)));
                } catch(_){ }
                const root = `${state.note}${acc}${micro}`;
                const qual = (state.quality === 'min') ? 'min'
                    : (state.quality === 'sus2') ? 'sus2'
                    : (state.quality === 'sus4') ? 'sus4'
                    : '';
                const exts = (state.extensions || []).map(ext => {
                    const mod = ext.mod ? ext.mod : '';
                    const label = ext.label || '';
                    if (String(label).startsWith('Maj')) return label; // Maj7/Maj9
                    return `${ext.add ? 'add' : ''}${mod}${label}`;
                }).join('');
                return `${root}${qual}${exts}`.trim();
            }

            _renderCalcKeypad() {
                const grid = document.getElementById('calcKeypadGrid');
                if (!grid || !this.calcState) return;
                const state = this.calcState;
                grid.innerHTML = '';
                grid.classList.toggle('root', state.stage === 'root');
                grid.classList.toggle('quality', state.stage !== 'root');

                if (state.stage === 'root') {
                    const notes = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
                    notes.forEach(note => {
                        const row = document.createElement('div');
                        row.className = 'calc-note-row';

                        const makeSeg = (label, acc, isCenter) => {
                            const btn = document.createElement('button');
                            btn.className = 'calc-btn calc-note-seg' + (isCenter ? ' center' : ' acc');
                            if (acc === 'b') btn.classList.add('flat');
                            if (acc === '#') btn.classList.add('sharp');
                            btn.textContent = label;
                            btn.dataset.calcType = 'note';
                            btn.dataset.calcKey = note;
                            if (acc) btn.dataset.calcAcc = acc;
                            const isActive = (state.note === note) && ((acc == null && !state.accSymbol) || (acc && state.accSymbol === acc));
                            if (isActive) btn.classList.add('active');
                            return btn;
                        };

                        row.appendChild(makeSeg('â™­', 'b', false));
                        row.appendChild(makeSeg(note, null, true));
                        row.appendChild(makeSeg('â™¯', '#', false));
                        grid.appendChild(row);
                    });

                    const microRow = document.createElement('div');
                    microRow.className = 'calc-micro-row';
                    const downBtn = document.createElement('button');
                    downBtn.className = 'calc-btn calc-micro-btn';
                    downBtn.textContent = 'v';
                    downBtn.dataset.calcKey = 'down';
                    downBtn.dataset.calcType = 'micro';
                    if ((state.microOffset || 0) < 0) downBtn.classList.add('active');
                    const upBtn = document.createElement('button');
                    upBtn.className = 'calc-btn calc-micro-btn';
                    upBtn.textContent = '^';
                    upBtn.dataset.calcKey = 'up';
                    upBtn.dataset.calcType = 'micro';
                    if ((state.microOffset || 0) > 0) upBtn.classList.add('active');
                    microRow.appendChild(downBtn);
                    microRow.appendChild(upBtn);
                    grid.appendChild(microRow);
                } else {
                    const items = [
                        { label: 'sus2', type: 'quality', key: 'sus2' },
                        { label: 'min', type: 'quality', key: 'min' },
                        { label: 'sus4', type: 'quality', key: 'sus4' },
                        { label: '6', type: 'ext', key: '6' },
                        { label: '7', type: 'ext', key: '7' },
                        { label: '9', type: 'ext', key: '9' },
                        { label: 'Maj7', type: 'ext', key: 'Maj7' },
                        { label: 'Maj9', type: 'ext', key: 'Maj9' },
                        { label: '11', type: 'ext', key: '11' },
                        { label: '13', type: 'ext', key: '13' },
                        { label: 'â™­', type: 'mod', key: 'b' },
                        { label: 'â™¯', type: 'mod', key: '#' }
                    ];

                    items.forEach(item => {
                        const btn = document.createElement('button');
                        btn.className = 'calc-btn';
                        btn.textContent = item.label;
                        btn.dataset.calcKey = item.key;
                        btn.dataset.calcType = item.type;
                        if (item.type === 'quality' && state.quality === item.key) btn.classList.add('active');
                        if (item.type === 'mod' && state.modifier === item.key) btn.classList.add('active');
                        grid.appendChild(btn);
                    });

                    const microRow = document.createElement('div');
                    microRow.className = 'calc-micro-row';
                    const downBtn = document.createElement('button');
                    downBtn.className = 'calc-btn calc-micro-btn';
                    downBtn.textContent = 'v';
                    downBtn.dataset.calcKey = 'down';
                    downBtn.dataset.calcType = 'micro';
                    if ((state.microOffset || 0) < 0) downBtn.classList.add('active');
                    const upBtn = document.createElement('button');
                    upBtn.className = 'calc-btn calc-micro-btn';
                    upBtn.textContent = '^';
                    upBtn.dataset.calcKey = 'up';
                    upBtn.dataset.calcType = 'micro';
                    if ((state.microOffset || 0) > 0) upBtn.classList.add('active');
                    microRow.appendChild(downBtn);
                    microRow.appendChild(upBtn);
                    grid.appendChild(microRow);
                }
            }

            _computeCalcChord() {
                const edo = this.currentTuning || 12;
                const state = this.calcState || {};
                let rootStep = 0;
                let intervals = [];

                if (state.useCustomIntervals && Array.isArray(state.customIntervals)) {
                    rootStep = (typeof state.customRootStep === 'number') ? state.customRootStep : (this.currentRoot || 0);
                    intervals = state.customIntervals.slice();
                } else {
                    const noteMap = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 };
                    const note = state.note || 'C';
                    const baseSemi = noteMap[note] ?? 0;
                    const semitoneStep = this.mapIntervalToEDO(1, edo) || 1;
                    const accSemi = (state.accSymbol === 'b') ? -1 : (state.accSymbol === '#') ? 1 : 0;
                    const baseStep = this.mapIntervalToEDO(baseSemi, edo);
                    rootStep = ((baseStep + (accSemi * semitoneStep) + (state.microOffset || 0)) % edo + edo) % edo;

                    let baseSemis = [0, 4, 7];
                    if (state.quality === 'min') baseSemis = [0, 3, 7];
                    else if (state.quality === 'sus2') baseSemis = [0, 2, 7];
                    else if (state.quality === 'sus4') baseSemis = [0, 5, 7];

                    const extToSemis = (label, add) => {
                        if (label === '6') return [9];
                        if (label === '7') return [10];
                        if (label === '9') return add ? [14] : [10, 14];
                        if (label === '11') return add ? [17] : [10, 14, 17];
                        if (label === '13') return add ? [21] : [10, 14, 17, 21];
                        if (label === 'Maj7') return [11];
                        if (label === 'Maj9') return add ? [11, 14] : [11, 14];
                        return [];
                    };

                    const extSemis = [];
                    (state.extensions || []).forEach(ext => {
                        const add = !!ext.add;
                        const base = extToSemis(ext.label, add).slice();
                        if (base.length && ext.mod) {
                            const delta = ext.mod === 'b' ? -1 : ext.mod === '#' ? 1 : 0;
                            base[base.length - 1] = base[base.length - 1] + delta;
                        }
                        extSemis.push(...base);
                    });

                    intervals = [...baseSemis, ...extSemis];
                }

                // Normalize intervals to steps and ensure root 0
                const mapToStep = (state.useCustomIntervals && Array.isArray(state.customIntervals))
                    ? (iv => iv)
                    : (iv => this.mapIntervalToEDO(iv, edo));
                const degreeSteps = Array.from(new Set([0, ...intervals.map(iv => ((mapToStep(iv) % edo) + edo) % edo)]));
                const sortedDegrees = degreeSteps.sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo));
                const absSteps = Array.from(new Set(sortedDegrees.map(iv => ((rootStep + iv) % edo + edo) % edo)))
                    .sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo));

                const name = (state.useCustomIntervals && state.customName)
                    ? state.customName
                    : (this._calcBuildName(state) || 'Chord');

                const noteNames = absSteps.map(step => this.getMicrotonalNoteName(step));

                return { rootStep, intervals: sortedDegrees, absSteps, name, noteNames };
            }

            refreshCalcUI() {
                if (!this.calcState) this.resetCalcState();
                const calc = this._computeCalcChord();

                const nameEl = document.getElementById('calcChordName');
                if (nameEl) nameEl.textContent = calc.name || 'â€”';
                const previewName = document.getElementById('calcPreviewName');
                if (previewName) previewName.textContent = calc.name || 'â€”';

                const tokensEl = document.getElementById('calcChordTokens');
                if (tokensEl) {
                    tokensEl.textContent = this.calcState.useCustomIntervals
                        ? (this.calcState.customName || 'Custom intervals')
                        : (calc.name || 'â€”');
                }

                const notesEl = document.getElementById('calcPreviewNotes');
                if (notesEl) notesEl.textContent = calc.noteNames.join(' ');

                const stringsEl = document.getElementById('calcPreviewStrings');
                if (stringsEl) {
                    const previewColumn = document.getElementById('calcPreviewColumn');
                    this.generateStringsForPreviewColumn(stringsEl, calc.absSteps, previewColumn);
                }

                this._renderCalcKeypad();

                const addBtn = document.getElementById('calcAddBtn');
                if (addBtn) addBtn.classList.toggle('active', !!this.calcState.addMode);

                const changeBtn = document.getElementById('calcChangeBtn');
                const isEditing = !!(this.isEditingChord && typeof this.editingOriginalIndex === 'number' && this.editingOriginalIndex >= 0);
                if (changeBtn) {
                    changeBtn.style.display = isEditing ? 'inline-flex' : 'none';
                    changeBtn.disabled = !isEditing;
                }
            }

            _playCalcChordPreview(calcChord) {
                if (!calcChord || !Array.isArray(calcChord.absSteps)) return;
                this.stopPreviewAudio();
                this.ensureAudioContext().then((ready) => {
                    if (!ready) return;
                    calcChord.absSteps.forEach((step, index) => {
                        const frequency = this.getFrequency(step, 4, this.currentTuning);
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();

                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);

                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.07, this.audioContext.currentTime + 0.05);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.9);

                        oscillator.connect(gainNode);
                        gainNode.connect(this.gainNode);

                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.9);

                        this.tempChordAudio.set(`calc-${index}`, { oscillator, gainNode });
                    });
                });
            }

            insertCalcChordFromState({ replace = false } = {}) {
                const calc = this._computeCalcChord();
                const edo = this.currentTuning || 12;
                if (!calc || !Array.isArray(calc.intervals) || calc.intervals.length < 2) {
                    console.warn('CALC insert skipped: no chord selected');
                    return;
                }

                const normalized = calc.intervals.map(iv => ((iv % edo) + edo) % edo).sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo));
                const baseRootAbs = ((calc.rootStep % edo) + edo) % edo;

                const replacing = !!replace && typeof this.editingOriginalIndex === 'number' && this.editingOriginalIndex >= 0;
                let insertPosition = replacing
                    ? this.editingOriginalIndex
                    : (typeof this.calcState.insertIndex === 'number' ? this.calcState.insertIndex : this.chordExtensions.length);

                // Insert before closing brackets if needed
                if (!replacing) {
                    for (let i = this.chordExtensions.length - 1; i >= 0; i--) {
                        const ext = this.chordExtensions[i];
                        if (ext && ext.isRepeatMarker && (ext.name === ']' || /^\]x\d+$/.test(ext.name))) {
                            insertPosition = i;
                        } else {
                            break;
                        }
                    }
                }

                // Preserve existing chord metadata if replacing
                let preserved = {};
                if (replacing && this.chordExtensions[insertPosition]) {
                    const oldChord = this.chordExtensions[insertPosition];
                    preserved = {
                        id: oldChord.id,
                        createdAt: oldChord.createdAt,
                        headerColor: oldChord.headerColor,
                        originalTuning: oldChord.originalTuning,
                        originalGamelanMode: oldChord.originalGamelanMode,
                        lastTuning: oldChord.lastTuning,
                        originalIntervals: oldChord.originalIntervals
                    };
                }

                let headerAccentColor = '#14b8a6';
                try {
                    const c = this.getIntervalColor(0)?.color;
                    headerAccentColor = (!c || c.toLowerCase() === '#000000') ? '#333333' : c;
                } catch {}

                const newChord = {
                    name: calc.name || 'New Chord',
                    extensions: [],
                    intervals: normalized,
                    isCustom: true,
                    id: preserved.id || ('custom_' + Date.now()),
                    createdAt: preserved.createdAt || Date.now(),
                    position: insertPosition,
                    originalRoot: this.currentRoot,
                    originalTuning: preserved.originalTuning || this.currentTuning,
                    originalGamelanMode: preserved.originalGamelanMode ?? this.gamelanMode,
                    lastTuning: this.currentTuning,
                    headerColor: preserved.headerColor || headerAccentColor,
                    fixedRootStepAbs: baseRootAbs,
                    fixedRootTuning: edo,
                    originalIntervals: preserved.originalIntervals || normalized.slice()
                };

                if (replacing) {
                    this.chordExtensions.splice(insertPosition, 1, newChord);
                } else {
                    this.chordExtensions.splice(insertPosition, 0, newChord);
                }

                this.normalizeChordPositions();
                this.saveChordConfiguration();
                this.regenerateColumnsWithoutVariants();

                this.isEditingChord = false;
                this.editingOriginalIndex = null;
                this.calcState.insertIndex = null;
                this.calcState.useCustomIntervals = false;

                // Update active column to the inserted chord
                try {
                    const col = document.querySelector(`.extension-column[data-chord-id='${newChord.id}']`);
                    if (col) this.currentActiveColumnEl = col;
                } catch(_){ }

                this.resetCalcState();
                this.refreshCalcUI();
            }

            insertCalcChordAtIndex(index) {
                this.calcState.insertIndex = index;
                this.insertCalcChordFromState({ replace: false });
            }

            insertCalcChordAtTarget(target, clientX = null) {
                const container = document.getElementById('extensionColumns');
                if (!container) return;
                const elements = Array.from(container.children).filter(el =>
                    el.classList.contains('extension-column') || el.classList.contains('repeat-marker-column')
                );

                let insertIndex = elements.length;
                if (target && elements.includes(target)) {
                    insertIndex = elements.indexOf(target);
                } else if (clientX != null) {
                    const rect = container.getBoundingClientRect();
                    const x = clientX - rect.left;
                    let insertBefore = null;
                    let minDistance = Infinity;
                    elements.forEach(el => {
                        const r = el.getBoundingClientRect();
                        const centerX = r.left + r.width / 2 - rect.left;
                        const distance = Math.abs(x - centerX);
                        if (x < centerX && distance < minDistance) {
                            minDistance = distance;
                            insertBefore = el;
                        }
                    });
                    if (insertBefore) insertIndex = elements.indexOf(insertBefore);
                }

                this.insertCalcChordAtIndex(Math.max(0, insertIndex));
            }
            
            removePreviewChordColumn() {
                const previewColumn = document.getElementById('previewChordColumn');
                if (previewColumn) {
                    previewColumn.remove();
                }
            }
            
            finalizePreviewChord(chordName) {
                // Remove the preview column
                this.removePreviewChordColumn();
                
                // Compute lowest interval as chord root anchor and normalize intervals
                const edo = this.currentTuning || 12;
                const ivs = [...this.selectedIntervals];
                // Do not save truly blank or single-note chords
                const nonRootCount = ivs.filter(v=> v !== 0).length;
                if (!ivs.length || nonRootCount === 0) {
                    console.warn('Skipping save: blank chord has no tones beyond root.');
                    return;
                }
                const minIv = Math.min(...ivs);
                const normalized = ivs.map(iv => ((iv - minIv) % edo + edo) % edo).sort((a,b)=>{
                    const sa = this.stepToSemitone(a, edo); const sb = this.stepToSemitone(b, edo); return sa - sb;
                });
                // Compute absolute step for the chord root from lowest note (rootless)
                const baseRootAbs = ((minIv % edo) + edo) % edo;
                // Build a musically sensible label (root + quality + optional slash-bass)
                const absForLabel = ivs.map(iv => ((iv % edo) + edo) % edo);
                // Prefer the first-selected tone as preferred bass to preserve user intent (e.g., EGB â†’ Em)
                const preferredBassFinalize = (this.selectedIntervalsOrder && this.selectedIntervalsOrder.length>0)
                    ? ((this.selectedIntervalsOrder[0] % edo) + edo) % edo
                    : null;
                const computedLabel = this.computeFullChordNameFromAbsoluteSteps(absForLabel, edo, preferredBassFinalize);
                // If user typed a name, keep it; otherwise use computedLabel
                let finalName = (chordName && chordName.trim()) ? chordName.trim() : (computedLabel || 'New Chord');
                
                // Decide target position
                const replacing = !!this.isEditingChord && typeof this.editingOriginalIndex === 'number' && this.editingOriginalIndex >= 0;
                const position = replacing ? this.editingOriginalIndex : this.chordExtensions.length;

                // Decide a persistent header accent color for this chord (per-chord color)
                // Use the current root neon color as the chord's header accent, with a safe fallback
                let headerAccentColor = '#14b8a6';
                try {
                    const c = this.getIntervalColor(0)?.color;
                    headerAccentColor = (!c || c.toLowerCase() === '#000000') ? '#333333' : c;
                } catch {}
                
                // Preserve existing chord metadata if editing in place
                let preserved = {};
                if (replacing && this.chordExtensions[position]) {
                    const oldChord = this.chordExtensions[position];
                    preserved = {
                        id: oldChord.id,
                        createdAt: oldChord.createdAt,
                        headerColor: oldChord.headerColor,
                        originalTuning: oldChord.originalTuning,
                        originalGamelanMode: oldChord.originalGamelanMode,
                        lastTuning: oldChord.lastTuning,
                        originalIntervals: oldChord.originalIntervals
                    };
                }

                // Create new chord extension with exact intervals and position tracking
                const newChord = {
                    name: finalName,
                    extensions: [],
                    intervals: normalized,
                    isCustom: true,
                    id: preserved.id || ('custom_' + Date.now()),
                    createdAt: preserved.createdAt || Date.now(),
                    position: position, // Track exact position in array
                    // Keep the original root for reference but don't auto-lock
                    originalRoot: this.currentRoot,
                    // Track tuning metadata to support future remaps between EDOs
                    originalTuning: preserved.originalTuning || this.currentTuning,
                    originalGamelanMode: preserved.originalGamelanMode ?? this.gamelanMode,
                    lastTuning: this.currentTuning,
                    // Persist a header color so saved chords can keep distinct colors
                    headerColor: preserved.headerColor || headerAccentColor,
                    // Per-chord fixed root lock (abs step in its tuning)
                    fixedRootStepAbs: baseRootAbs,
                    fixedRootTuning: edo,
                    // Capture the original intervals at creation/edit baseline for future EDO remaps
                    originalIntervals: preserved.originalIntervals || normalized.slice()
                };
                
                console.log('ðŸ”§ finalizePreviewChord - saving chord:', {
                    name: chordName,
                    intervals: [...this.selectedIntervals],
                    isCustom: true,
                    currentTuning: this.currentTuning,
                    selectedIntervals: this.selectedIntervals
                });
                
                // Add to chord extensions: replace original index when editing, else append
                if (replacing) {
                    // Replace in place to preserve column position and identity
                    this.chordExtensions.splice(position, 1, newChord);
                } else {
                    this.chordExtensions.push(newChord);
                }

                // Normalize positions to keep exact ordering stable
                this.normalizeChordPositions();
                
                // Save and regenerate without creating variants
                this.saveChordConfiguration();
                this.regenerateColumnsWithoutVariants();
                
                // Clear selection and exit chord creation mode
                this.selectedIntervals = [];
                this.isChordCreationMode = false;
                this.isEditingChord = false;
                this.editingOriginalIndex = null;
                // Clear pending flag since notes were saved
                this.pendingBlankChordId = null;
                
                // Restore normal root button functionality
                this.restoreNormalRootButtons();
                
                console.log(`? Created chord: ${finalName} at position ${position} with intervals:`, normalized);
            }

            // Keep chord.position fields in sync with array order
            normalizeChordPositions() {
                if (!Array.isArray(this.chordExtensions)) return;
                for (let i = 0; i < this.chordExtensions.length; i++) {
                    const c = this.chordExtensions[i];
                    if (c && c.position !== i) c.position = i;
                }
            }
            
            regenerateColumnsWithoutVariants() {
                // Regenerate only the exact chords without creating maj/min/neu variants
                this.generateExactChordColumns();
                this.updateChordDisplay();
            }
            
            generateExactChordColumns(opts = null) {
                // During PLAY, defer heavy DOM rebuilds to a bar boundary for audio stability
                try {
                    const force = !!(opts && opts.force);
                    const t = this._arpTransport;
                    const playing = !!(t && (t.running || t.isRunning));
                    if (!force && playing) {
                        const scheduleDeferred = window.scheduleDeferred;
                        if (typeof scheduleDeferred === 'function') {
                            scheduleDeferred({ chordGrid: 'exact' });
                            return;
                        }
                    }
                } catch(_){ }
                console.log('ðŸŽ¨ðŸŽ¨ðŸŽ¨ generateExactChordColumns CALLED - chordExtensions.length =', this.chordExtensions.length);
                if (this.chordExtensions.length > 0) {
                    console.log('ðŸŽ¨ First chord:', this.chordExtensions[0].name, '| fixedRootStepAbs =', this.chordExtensions[0].fixedRootStepAbs, '| intervals =', this.chordExtensions[0].intervals);
                }
                console.log('Generating exact chord columns (no variants)');
                const container = document.getElementById('extensionColumns');
                
                // Clear container completely to remove any leftover columns
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.gap = '0px';
                container.style.width = '100%';
                container.style.height = '100%';
                // Reset to one row by default; we may split into two rows below
                container.style.flexDirection = 'row';
                
                // Initialize hiddenColumns if not exists
                if (!this.hiddenColumns) {
                    this.hiddenColumns = [];
                }
                
                // Sort chordExtensions by position to maintain exact order
                const sortedExtensions = [...this.chordExtensions].sort((a, b) => {
                    const posA = a.position !== undefined ? a.position : this.chordExtensions.indexOf(a);
                    const posB = b.position !== undefined ? b.position : this.chordExtensions.indexOf(b);
                    return posA - posB;
                });
                
                // Map chord extensions to per-instance identifiers for hiding
                const chordIds = sortedExtensions.map((chord, index) => {
                    return (chord.id || (chord.name + '_' + index)).toLowerCase().replace(/\s+/g, '_');
                });
                
                // Filter visible chord extensions (maintain original order)
                const visibleExtensions = sortedExtensions.filter((chordExt, index) => {
                    const chordId = chordIds[index];
                    const isVisible = !this.hiddenColumns.includes(chordId);
                    return isVisible;
                });
                
                console.log('Creating exact chord columns:', visibleExtensions.length);
                
                // Layout: if >16, split into 2 rows. We'll create a wrapper for rows and append columns to row containers.
                const useTwoRows = visibleExtensions.length > 16;
                let rowTop, rowBottom;
                if (useTwoRows) {
                    container.style.flexDirection = 'column';
                    rowTop = document.createElement('div');
                    rowBottom = document.createElement('div');
                    // Use flex growth instead of fixed 50% height, and allow shrinking (minHeight:0) to avoid clipping
                    Object.assign(rowTop.style, { display:'flex', gap:'0px', width:'100%', flex:'1 1 0', minHeight:'0' });
                    Object.assign(rowBottom.style, { display:'flex', gap:'0px', width:'100%', flex:'1 1 0', minHeight:'0' });
                    container.appendChild(rowTop);
                    container.appendChild(rowBottom);
                }

                // Auto-insert an outer loop bracket at the very start and end of the grid
                const appendRepeatMarker = (target, name, opts={}) => {
                    const repeatCol = document.createElement('div');
                    repeatCol.className = 'repeat-marker-column';
                    try { if (opts && (opts.autoOuter || opts.loopBracket)) repeatCol.classList.add('loop-bracket'); } catch(_){ }
                    repeatCol.style.width = '50px';
                    repeatCol.style.minWidth = '50px';
                    repeatCol.style.maxWidth = '50px';
                    repeatCol.style.height = '100%';
                    repeatCol.style.flex = '0 0 50px';
                    // Apply themed styling (GREEN = outer loop)
                    const theme = opts.colorTheme || { bg: 'linear-gradient(135deg, rgba(46,204,113,0.22) 0%, rgba(39,174,96,0.28) 100%)', border: 'rgba(46,204,113,0.7)', color: '#2ecc71' };
                    repeatCol.style.background = theme.bg;
                    repeatCol.style.border = `2px solid ${theme.border}`;
                    repeatCol.style.color = theme.color;
                    repeatCol.style.borderRadius = '8px';
                    repeatCol.style.display = 'flex';
                    repeatCol.style.alignItems = 'center';
                    repeatCol.style.justifyContent = 'center';
                    repeatCol.style.fontSize = '16px';
                    repeatCol.style.fontWeight = 'bold';
                    repeatCol.style.textShadow = '0 1px 2px rgba(0,0,0,0.3)';
                    repeatCol.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
                    repeatCol.style.cursor = 'default';
                    repeatCol.textContent = name; // "[", "]" or "]xN"
                    repeatCol.title = `Repeat marker: ${name} (Level 0) - auto outer loop`;
                    repeatCol.dataset.isRepeatMarker = 'true';
                    repeatCol.dataset.nestLevel = '0';
                    if (opts.autoOuter) repeatCol.dataset.autoOuter = 'true';
                    if (typeof opts.repeatCount === 'number') repeatCol.dataset.repeatCount = String(opts.repeatCount);
                    // End marker count editing (0 = infinite)
                    repeatCol.addEventListener('click', () => {
                        const txt = repeatCol.textContent.trim();
                        const isEnd = (txt === ']' || /^\]x\d+$/.test(txt));
                        if (!isEnd) return;
                        const cur = parseInt(repeatCol.dataset.repeatCount||'0',10);
                        const val = prompt('Repeat count (0 = infinite):', isNaN(cur)? '0' : String(cur));
                        if (val == null) return;
                        let n = Math.max(0, parseInt(val,10)||0);
                        if (n > 64) n = 64;
                        repeatCol.dataset.repeatCount = String(n);
                        repeatCol.textContent = (n === 0 ? ']' : `]x${n}`);
                    });
                    // Make bracket markers draggable for section rearrangement
                    if (typeof window.makeBracketDraggable === 'function') {
                        window.makeBracketDraggable(repeatCol);
                    }
                    target.appendChild(repeatCol);
                    return repeatCol;
                };

                // Detect explicit outer brackets coming from SEQ (level 0 at extremes)
                const firstIdx = visibleExtensions.findIndex(ext => !(ext.isSeparator || ext.name === '|'));
                const lastIdx = (function(){
                    for (let i = visibleExtensions.length - 1; i >= 0; i--) {
                        const ext = visibleExtensions[i];
                        if (!(ext.isSeparator || ext.name === '|')) return i;
                    }
                    return -1;
                })();
                // Wire OSC1/OSC2 sliders to MIDI tuning (coarse/fine+octave)
                (function(){
                    try {
                        const g = (id)=> document.getElementById(id);
                        const ch1 = ()=> (window.midi?.channelMap?.osc1) || 1;
                        const ch2 = ()=> (window.midi?.channelMap?.osc2) || 1;
                        const send1 = ()=>{
                            if (!window.midi || !window.midi.enabled) return;
                            const oct = parseInt(g('osc1Octave')?.value||'0',10)||0;
                            const coarse = parseInt(g('osc1Coarse')?.value||'0',10)||0;
                            const fine = parseFloat(g('osc1Detune')?.value||'0')||0;
                            window.midi.setCoarseTune((oct*12)+coarse, ch1());
                            window.midi.setFineTune(fine, ch1());
                        };
                        const send2 = ()=>{
                            if (!window.midi || !window.midi.enabled) return;
                            const oct = parseInt(g('osc2Octave')?.value||'0',10)||0;
                            const coarse = parseInt(g('osc2Coarse')?.value||'0',10)||0;
                            const fine = parseFloat(g('osc2Detune')?.value||'0')||0;
                            window.midi.setCoarseTune((oct*12)+coarse, ch2());
                            window.midi.setFineTune(fine, ch2());
                        };
                        ['osc1Octave','osc1Coarse','osc1Detune'].forEach(id=>{ const el=g(id); if (el && !el._wiredMidi){ el._wiredMidi=true; el.addEventListener('input', send1); }});
                        ['osc2Octave','osc2Coarse','osc2Detune'].forEach(id=>{ const el=g(id); if (el && !el._wiredMidi){ el._wiredMidi=true; el.addEventListener('input', send2); }});
                    } catch(_){}
                })();
                const hasExplicitOuterStart = (firstIdx >= 0) && !!visibleExtensions[firstIdx].isRepeatMarker && (visibleExtensions[firstIdx].name === '[') && ((visibleExtensions[firstIdx].nestLevel || 0) === 0);
                const hasExplicitOuterEnd = (lastIdx >= 0) && !!visibleExtensions[lastIdx].isRepeatMarker && ((visibleExtensions[lastIdx].name === ']') || (/^\]x\d+$/.test(visibleExtensions[lastIdx].name || ''))) && ((visibleExtensions[lastIdx].nestLevel || 0) === 0);

                // Prepend auto outer start marker on the first row (only if not explicitly provided by SEQ)
                const startRow = useTwoRows ? rowTop : container;
                if (!hasExplicitOuterStart) {
                    appendRepeatMarker(startRow, '[', { autoOuter: true });
                }

                

                // Create ONE column per chord extension (no variants) - maintain exact order
                visibleExtensions.forEach((chordExt, extensionIndex) => {
                    // Render repeat marker as a special thin column
                    if (chordExt.isRepeatMarker) {
                        const repeatCol = document.createElement('div');
                        repeatCol.className = 'repeat-marker-column';
                        try {
                            const nm = String(chordExt.name||'').trim();
                            const lvl = (chordExt.nestLevel || 0);
                            if (lvl === 0 && (nm === '[' || nm === ']' || /^\]x\d+$/.test(nm))) repeatCol.classList.add('loop-bracket');
                        } catch(_){ }
                        repeatCol.style.width = '50px';
                        repeatCol.style.minWidth = '50px';
                        repeatCol.style.maxWidth = '50px';
                        repeatCol.style.height = '100%';
                        repeatCol.style.flex = '0 0 50px';
                        
                        // Apply color theme if available
                        if (chordExt.colorTheme) {
                            const theme = chordExt.colorTheme;
                            repeatCol.style.background = theme.bg;
                            repeatCol.style.border = `2px solid ${theme.border}`;
                            repeatCol.style.color = theme.color;
                        } else {
                            // Default styling for legacy repeat markers
                            repeatCol.style.background = 'linear-gradient(135deg, rgba(255,215,0,0.3) 0%, rgba(255,140,0,0.4) 100%)';
                            repeatCol.style.border = '2px solid rgba(255,215,0,0.6)';
                            repeatCol.style.color = '#FFD700';
                        }
                        
                        repeatCol.style.borderRadius = '8px';
                        repeatCol.style.display = 'flex';
                        repeatCol.style.alignItems = 'center';
                        repeatCol.style.justifyContent = 'center';
                        repeatCol.style.fontSize = '16px';
                        repeatCol.style.fontWeight = 'bold';
                        repeatCol.style.textShadow = '0 1px 2px rgba(0,0,0,0.3)';
                        repeatCol.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
                        repeatCol.style.cursor = 'default';
                        repeatCol.textContent = chordExt.name; // e.g., "x4", "[", "]", "]x4"
                        repeatCol.title = `Repeat marker: ${chordExt.name} (Level ${chordExt.nestLevel || 0}) - NO chord strings, just visual indicator`;
                        
                        // Mark as repeat marker so it gets filtered out during playback
                        repeatCol.dataset.isRepeatMarker = 'true';
                        repeatCol.dataset.nestLevel = chordExt.nestLevel || 0;
                        if (typeof chordExt.repeatCount === 'number') {
                            repeatCol.dataset.repeatCount = String(chordExt.repeatCount);
                        } else if (/^\]x(\d+)$/.test(chordExt.name||'')) {
                            repeatCol.dataset.repeatCount = String((chordExt.name.match(/^\]x(\d+)$/)||[])[1]||'');
                        }
                        
                        if (useTwoRows) {
                            const half = Math.ceil(visibleExtensions.length / 2);
                            const targetRow = extensionIndex < half ? rowTop : rowBottom;
                            targetRow.appendChild(repeatCol);
                        } else {
                            container.appendChild(repeatCol);
                        }
                        
                        // Make ALL bracket markers draggable for section rearrangement
                        if (typeof window.makeBracketDraggable === 'function') {
                            window.makeBracketDraggable(repeatCol);
                        }
                        
                        // Allow clicking repeat end markers to edit count (0 = infinite)
                        repeatCol.addEventListener('click', ()=>{
                            const txt = repeatCol.textContent.trim();
                            const isEnd = (txt === ']' || /^\]x\d+$/.test(txt));
                            if (!isEnd) return;
                            const cur = parseInt(repeatCol.dataset.repeatCount||'0',10);
                            const val = prompt('Repeat count (0 = infinite):', isNaN(cur)? '0': String(cur));
                            if (val == null) return;
                            let n = Math.max(0, parseInt(val,10)||0);
                            if (n > 64) n = 64;
                            repeatCol.dataset.repeatCount = String(n);
                            repeatCol.textContent = (n === 0 ? ']' : `]x${n}`);
                        });
                        return; // IMPORTANT: Return early - no chord processing!
                    }
                    
                    // Special case: separator â†’ 30px spacer without strings
                    if (chordExt.isSeparator || chordExt.name === '|') {
                        const sepCol = document.createElement('div');
                        sepCol.className = 'extension-separator';
                        sepCol.style.width = '30px';
                        sepCol.style.minWidth = '30px';
                        sepCol.style.maxWidth = '30px';
                        sepCol.style.height = '100%';
                        sepCol.style.flex = '0 0 30px';
                        sepCol.style.background = 'transparent';
                        sepCol.style.borderLeft = '2px solid rgba(255,255,255,0.15)';
                        sepCol.style.boxShadow = 'inset 0 0 12px rgba(255,255,255,0.08)';
                        if (useTwoRows) {
                            const half = Math.ceil(visibleExtensions.length / 2);
                            const targetRow = extensionIndex < half ? rowTop : rowBottom;
                            targetRow.appendChild(sepCol);
                        } else {
                            container.appendChild(sepCol);
                        }
                        return; // next item
                    }
                    const column = document.createElement('div');
                    column.className = 'extension-column';
                    column.dataset.chordType = chordIds[extensionIndex];
                    // Persist absolute index back to the original array for precise operations
                    const absoluteIndex = (typeof chordExt.position === 'number') ? chordExt.position : (this.findChordIndex ? this.findChordIndex(chordExt) : extensionIndex);
                    column.dataset.originalPosition = absoluteIndex;
                    column.dataset.chordId = chordExt.id || chordIds[extensionIndex];
                    // Assign a unique DOM instance id for this box if missing
                    if (!column.dataset.instanceId) {
                        column.dataset.instanceId = `${column.dataset.chordId}__${Date.now()}_${Math.floor(Math.random()*1e6)}`;
                    }
                    column.style.flex = '1'; // Each column takes equal width
                    column.style.height = '100%';
                    column.style.border = 'none';
                    column.style.borderRadius = '0';
                    column.style.margin = '0';
                    column.style.padding = '0';
                    
                    // Make chord columns draggable for rearrangement
                    if (typeof window.makeBracketDraggable === 'function') {
                        window.makeBracketDraggable(column);
                    }
                    
                    // Create header with chord name and lock button
                    const header = document.createElement('div');
                    header.className = 'extension-header';
                    
                    // Create chord name span (inline-editable)
                    const chordName = document.createElement('span');
                    chordName.className = 'chord-name';
                    chordName.setAttribute('contenteditable', 'true');
                    chordName.setAttribute('spellcheck', 'false');
                    
                    // Check if this chord extension is locked and preserve its locked name
                    if (chordExt.isLocked && chordExt.lockedData) {
                        const lockedData = chordExt.lockedData;
                        const rootName = this.getNoteNames()[lockedData.lockedRoot] || lockedData.lockedRoot;
                        
                        // Use the locked name exactly as it was when locked
                        if (lockedData.chordName.match(/^[A-G][#b]?/)) {
                            chordName.textContent = lockedData.chordName;
                        } else {
                            chordName.textContent = `${rootName}${lockedData.chordName}`;
                        }
                        
                        chordName.style.color = '#4CAF50';
                        chordName.style.fontWeight = 'bold';
                        chordName.dataset.isLocked = 'true';
                        chordName.dataset.lockedName = chordName.textContent;
                        chordName.title = `?? LOCKED: ${rootName} root, ${lockedData.lockedTuning}TET, ${lockedData.lockedOsc1.type}/${lockedData.lockedOsc2.type} waves`;
                    } else {
                        // Regular unlocked chord - use current name
                        chordName.textContent = chordExt.name;
                    }
                    
                    
                    
                    // Create buttons container
                    const buttonsContainer = document.createElement('div');
                    buttonsContainer.className = 'header-buttons';

                    
                    // Add buttons to container
                    // Per-column transpose controls
                    const downBtn = document.createElement('button');
                    downBtn.className = 'chord-action-button transpose-down';
                    downBtn.title = 'Transpose this chord down one step';
                    downBtn.textContent = 'â–¼';
                    const upBtn = document.createElement('button');
                    upBtn.className = 'chord-action-button transpose-up';
                    upBtn.title = 'Transpose this chord up one step';
                    upBtn.textContent = 'â–²';
                    // Prevent double-fire on touch (touchstart + synthetic click)
                    let _pressGuard = false;
                    const norm = (v, m)=> ((v % m) + m) % m;
                    const applyLocalTranspose = (delta)=>{
                        if (_pressGuard) return; // avoid accidental double-fire on first tap
                        _pressGuard = true;
                        const edoNow = chordExt.fixedRootTuning || this.currentTuning || 24; // use column/root tuning

                        // Non-baking model: update local offset only
                        const prevLocal = parseInt(column.dataset.localTranspose || '0', 10) || 0;
                        const nextLocal = norm(prevLocal + delta, edoNow);
                        column.dataset.localTranspose = String(nextLocal);
                        chordExt.localTranspose = nextLocal; // persist for regeneration

                        // Recompute label from absolute steps, mirroring global path
                        try {
                            // Prefer locked semantics for naming if this column is locked
                            const locked = (this.lockedChords?.get(column)) || chordExt.lockedData || null;
                            const hasFixed = (typeof chordExt.fixedRootStepAbs === 'number') && !!chordExt.fixedRootTuning;
                            const modelEdo = locked ? (locked.lockedTuning || edoNow) : (hasFixed ? (chordExt.fixedRootTuning || edoNow) : edoNow);
                            const mapStep = (step, srcEdo, dstEdo) => {
                                const cents = ((step % srcEdo + srcEdo) % srcEdo) * (1200 / srcEdo);
                                const dst = Math.round(cents / (1200 / dstEdo));
                                return ((dst % dstEdo) + dstEdo) % dstEdo;
                            };
                            const localDeltaModel = (modelEdo === edoNow) ? nextLocal : mapStep(nextLocal, edoNow, modelEdo);
                            if (locked) {
                                // For locked chords: name within locked tuning; do not add global transpose into the text
                                const baseRootModel = ((locked.lockedRoot ?? 0) % modelEdo + modelEdo) % modelEdo;
                                const effRootModel = (((baseRootModel) + localDeltaModel) % modelEdo + modelEdo) % modelEdo;
                                const rootName = this.getRootNameForStep(effRootModel, modelEdo);
                                const rawLockedName = (locked.chordName || '').trim();
                                const rest = rawLockedName.replace(/^[A-G][#b]?\s*/, '');
                                const label = `${rootName}${rest}`;
                                chordName.textContent = label;
                                chordName.dataset.lockedName = label;
                                chordExt.name = label;
                            } else {
                                // Unlocked or fixed-root chords: compute abs steps and let naming apply global delta exactly once
                                const baseRootModel = hasFixed
                                    ? (chordExt.fixedRootStepAbs || 0)
                                    : (((this.currentRoot || 0) % modelEdo) + modelEdo) % modelEdo;
                                const effRootModel = (((baseRootModel) + localDeltaModel) % modelEdo + modelEdo) % modelEdo;
                                const degreeStepsModel = chordExt.isCustom
                                    ? chordExt.intervals.map(iv => ((iv % modelEdo) + modelEdo) % modelEdo)
                                    : chordExt.intervals.map(iv => this.mapIntervalToEDO(iv, modelEdo));
                                // Build absolute steps: transposed root + each interval from the transposed root
                                const absModel = [effRootModel, ...degreeStepsModel.map(d => (effRootModel + d) % modelEdo)];
                                const absNow = (modelEdo === edoNow) ? absModel.map(s => ((s%edoNow)+edoNow)%edoNow)
                                                                    : absModel.map(s => mapStep(s, modelEdo, edoNow));
                                const shiftNow = (modelEdo === edoNow) ? localDeltaModel : mapStep(localDeltaModel, modelEdo, edoNow);
                                const prefName = (chordExt && chordExt.preferredRootName)
                                    ? this._transposePreferredRootName(chordExt.preferredRootName, shiftNow, edoNow)
                                    : null;
                                const recomputed = this.computeFullChordNameFromAbsoluteSteps(
                                    absNow,
                                    edoNow,
                                    null,
                                    prefName,
                                    (chordExt && chordExt.preferredBassRel != null) ? chordExt.preferredBassRel : null
                                );
                                chordName.textContent = recomputed;
                                chordName.dataset.lockedName = recomputed;
                                chordExt.name = recomputed;
                            }
                        } catch(_) {}

                        // Do not mutate chord intervals or fixed root; regenerate strings using new local transpose
                        const oldContainer = column.querySelector('.strings-column');
                        if (oldContainer) oldContainer.remove();
                        
                        // Regenerate this column using the same logic as regenerateAllColumnsPreservingLocks
                        const isLocked = this.lockedChords && this.lockedChords.has(column);
                        if (isLocked) {
                            const lockedChord = this.lockedChords.get(column);
                            this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals, lockedChord);
                        } else {
                            // For unlocked columns, regenerate using current global settings and the chord model
                            console.log('ðŸ”§ DEBUG ACTIVE PATH: About to call generateStringsForColumn with intervals:', chordExt.intervals, 'isCustom:', chordExt.isCustom, 'chordName:', chordExt.name);
                            this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom || false);
                        }

                        // Update keyboard highlighting
                        try { this.highlightKeyboardForColumn(column); } catch {}
                        // release guard on next microtask to collapse duplicate events
                        Promise.resolve().then(()=>{ _pressGuard = false; });
                    };
                    const onPointer = (delta)=> (e)=>{ e.preventDefault(); e.stopPropagation(); applyLocalTranspose(delta); try{ this.highlightKeyboardForColumn(column);}catch{} };
                    upBtn.addEventListener('pointerdown', onPointer(+1));
                    downBtn.addEventListener('pointerdown', onPointer(-1));

                    buttonsContainer.appendChild(downBtn);
                    buttonsContainer.appendChild(upBtn);
                    
                    // Initialize per-column local transpose from model (default 0)
                    const initLocalTranspose = (typeof chordExt.localTranspose === 'number') ? chordExt.localTranspose : 0;
                    column.dataset.localTranspose = String(initLocalTranspose);

                    header.appendChild(chordName);
                    header.appendChild(buttonsContainer);
                    
                    // Root-based header color (no greys)
                    try {
                        let accent = null;
                        const isBlank = !!(chordExt && chordExt.isCustom && (!Array.isArray(chordExt.intervals) || chordExt.intervals.length === 0));
                        if (isBlank) {
                            header.style.background = '#000000';
                            header.style.backgroundImage = 'none';
                            header.style.borderBottom = '1px solid #222222';
                            header.style.boxShadow = 'none';
                            header.style.color = '#9db6c8';
                            header.style.border = '1px solid #222222';
                            accent = null;
                        } else {
                        const isGreyish = (hex)=>{
                            try {
                                const m = String(hex||'').trim().match(/^#?([0-9a-f]{6})$/i);
                                if (!m) return false;
                                const n = parseInt(m[1], 16);
                                const r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                                return (Math.max(r,g,b) - Math.min(r,g,b)) < 12;
                            } catch(_) { return false; }
                        };
                        const safeColor = (c)=>{
                            if (!c || typeof c !== 'string') return null;
                            const v = c.trim();
                            if (!v) return null;
                            if (v.toLowerCase() === '#000000') return null;
                            if (isGreyish(v)) return null;
                            return v;
                        };

                        const stored = safeColor(chordExt.headerColor);
                        if (stored) {
                            accent = stored;
                        } else {
                            const isLocked = !!chordExt.isLocked && !!chordExt.lockedData;
                            const hasFixed = (typeof chordExt.fixedRootStepAbs === 'number') && !!chordExt.fixedRootTuning;
                            let rootStep;
                            let edoForRoot = this.currentTuning || 12;
                            if (isLocked) {
                                edoForRoot = chordExt.lockedData.lockedTuning || edoForRoot;
                                const localDelta = ((+column.dataset.localTranspose || 0) % edoForRoot + edoForRoot) % edoForRoot;
                                rootStep = ((chordExt.lockedData.lockedRoot ?? 0) + localDelta + edoForRoot) % edoForRoot;
                            } else if (hasFixed) {
                                edoForRoot = chordExt.fixedRootTuning || edoForRoot;
                                const localDelta = ((+column.dataset.localTranspose || 0) % edoForRoot + edoForRoot) % edoForRoot;
                                rootStep = ((chordExt.fixedRootStepAbs ?? 0) + localDelta + edoForRoot) % edoForRoot;
                            } else if (typeof chordExt.originalRoot === 'number') {
                                rootStep = ((chordExt.originalRoot % edoForRoot) + edoForRoot) % edoForRoot;
                            } else {
                                const label = (chordName.dataset.lockedName || chordName.textContent || '').trim();
                                const normLabel = this._normalizeChordSymbolsForParse ? this._normalizeChordSymbolsForParse(label) : label;
                                const m = normLabel.match(/^([A-Ga-g])([#b\-d]?)([\^v]*)/);
                                if (m) {
                                    const semi = this.rootToSemitone(m[1].toUpperCase(), m[2]||'');
                                    let step = Math.round((semi * edoForRoot) / 12);
                                    const ups = (m[3].match(/\^/g) || []).length;
                                    const downs = (m[3].match(/v/g) || []).length;
                                    rootStep = ((step + ups - downs) % edoForRoot + edoForRoot) % edoForRoot;
                                } else {
                                    rootStep = this.currentRoot ?? 0;
                                }
                            }
                            const semi = this.stepToSemitone(rootStep, edoForRoot);
                            accent = safeColor(this.getChromaticColorForSemitone(semi)) || '#ff0000';
                        }
                        const text = this.pickTextColor(accent);
                        header.style.background = accent;
                        header.style.backgroundImage = 'none';
                        header.style.borderBottom = `2px solid ${accent}`;
                        header.style.boxShadow = `0 0 10px ${accent}55`;
                        header.style.color = text;
                        header.style.border = `1px solid ${accent}`;
                        }
                    } catch {}
                    
                    // Editing behavior: Enter to apply, Escape to cancel selection
                    const applyTypedName = () => {
                        try {
                            const rawInput = (chordName.textContent || '').trim();
                            if (!rawInput) return;

                            // Support duration multiplier syntax in-place, e.g. "Am x4" -> one chordbox len16 = 64.
                            // (This is different from SEQ repeat markers: here it means duration, not repeating chords.)
                            let chordText = rawInput;
                            let barsMult = null;
                            try {
                                const m = rawInput.match(/^(.*\S)\s+[xX]\s*(\d+)\s*$/);
                                if (m) {
                                    chordText = String(m[1] || '').trim();
                                    const n = Math.max(1, parseInt(m[2], 10) || 1);
                                    barsMult = n;
                                }
                            } catch(_){ }

                            const existingLen16 = (()=>{
                                try {
                                    const v = parseInt((column?.dataset?.len16) || (chordExt && chordExt.len16) || '16', 10);
                                    return (Number.isFinite(v) && v > 0) ? v : 16;
                                } catch(_){ return 16; }
                            })();
                            const targetLen16 = (barsMult != null)
                                ? Math.max(1, Math.min(1024, (barsMult * 16) | 0))
                                : existingLen16;

                            const added = (typeof this.addChordFromName === 'function') ? this.addChordFromName(chordText) : null;
                            if (!added || !added.chord) {
                                const prevOutline = chordName.style.outline;
                                chordName.style.outline = '2px solid #e74c3c';
                                setTimeout(()=> { chordName.style.outline = prevOutline; }, 600);
                                return;
                            }

                            const parsed = added.chord;
                            // addChordFromName appends; remove the appended copy and use it to replace in place
                            try {
                                const arr = this.chordExtensions || [];
                                if (arr[arr.length - 1] === parsed) arr.pop();
                                else {
                                    const k = arr.findIndex(c => c && parsed && c.id && c.id === parsed.id);
                                    if (k >= 0) arr.splice(k, 1);
                                }
                            } catch(_){ }

                            // Find the correct target chord (stable across reorders)
                            let idx = -1;
                            try {
                                const colId = column.dataset.chordId;
                                if (colId) idx = (this.chordExtensions || []).findIndex(c => c && c.id === colId);
                            } catch(_){ }
                            if (idx < 0) idx = (this.chordExtensions || []).indexOf(chordExt);
                            if (idx < 0) {
                                const maybe = parseInt(column.dataset.originalPosition || '-1', 10);
                                if (!isNaN(maybe) && maybe >= 0 && maybe < (this.chordExtensions || []).length) idx = maybe;
                            }
                            if (idx < 0) return;

                            // Rename = replace chord identity and RESET per-chord transpose/locks
                            parsed.position = chordExt.position;
                            parsed.localTranspose = 0;
                            parsed.len16 = targetLen16;
                            try {
                                parsed.isLocked = false;
                                parsed.lockedData = null;
                            } catch(_){ }
                            try {
                                if (this.lockedChords && this.lockedChords.has(column)) this.lockedChords.delete(column);
                            } catch(_){ }

                            (this.chordExtensions || []).splice(idx, 1, parsed);

                            column.dataset.chordId = parsed.id || column.dataset.chordId;
                            column.dataset.originalPosition = String(idx);
                            column.dataset.localTranspose = '0';

                            // Apply duration to DOM (drives visual width + SAVE)
                            try {
                                column.dataset.len16 = String(targetLen16);
                                column.style.setProperty('--len16', String(targetLen16));
                                column.style.flexGrow = String(targetLen16);
                                column.style.flexShrink = '1';
                                column.style.flexBasis = '0px';
                            } catch(_){ }

                            chordName.textContent = parsed.name;
                            chordName.dataset.lockedName = parsed.name;
                            try { column.dataset.lastIntervals = JSON.stringify(parsed.intervals || []); } catch(_){ }

                            const old = column.querySelector('.strings-column');
                            if (old) old.remove();
                            this.generateStringsForColumn(column, parsed.intervals, parsed.isCustom || false);
                            try { this.currentActiveColumnEl = column; } catch(_){ }
                            try { this.highlightKeyboardForColumn(column); } catch(_){ }
                            try { this.saveChordConfiguration?.(); } catch(_){ }
                            try { this.updateChordDisplay?.(); } catch(_){ }
                        } catch (err) { console.error('applyTypedName error:', err); }
                    };
                    chordName.addEventListener('keydown', (ev)=>{
                        if (ev.key === 'Enter') {
                            // ENTER = confirm only
                            ev.preventDefault();
                            applyTypedName();
                            chordName.blur();
                            return;
                        }

                        if (ev.key === 'Tab') {
                            // TAB = confirm + move/create
                            ev.preventDefault();
                            applyTypedName();

                            const cols = Array.from(document.querySelectorAll('#extensionColumns .extension-column'));
                            const idx = cols.indexOf(column);
                            const focusChordName = (colEl)=>{
                                try {
                                    const el = colEl && colEl.querySelector && colEl.querySelector('.extension-header .chord-name');
                                    if (!el || typeof el.focus !== 'function') return false;
                                    el.focus();
                                    const sel = window.getSelection && window.getSelection();
                                    if (sel && document.createRange) {
                                        const r = document.createRange();
                                        r.selectNodeContents(el);
                                        sel.removeAllRanges();
                                        sel.addRange(r);
                                    }
                                    return true;
                                } catch(_){ return false; }
                            };

                            if (ev.shiftKey) {
                                if (idx > 0) focusChordName(cols[idx - 1]);
                                return;
                            }

                            // If there's already a blank "New" chord immediately to the right, just focus it.
                            try {
                                const nextCol = (idx >= 0 && idx < cols.length - 1) ? cols[idx + 1] : null;
                                if (nextCol) {
                                    const nextId = nextCol?.dataset?.chordId ? String(nextCol.dataset.chordId) : null;
                                    const nextExt = nextId ? (this.chordExtensions || []).find(c => c && String(c.id) === nextId) : null;
                                    const isBlank = !!(nextExt && nextExt.isCustom && (!nextExt.intervals || nextExt.intervals.length === 0) && String(nextExt.name || '').trim().toLowerCase() === 'new');
                                    if (isBlank) {
                                        focusChordName(nextCol);
                                        return;
                                    }
                                }
                            } catch(_){ }
                            try {
                                const afterId = (column && column.dataset && column.dataset.chordId) ? String(column.dataset.chordId) : null;
                                if (afterId) this.createBlankChordColumn({ insertAfterId: afterId });
                                else this.createBlankChordColumn();
                            } catch(_){ }
                            return;
                        }

                        if (ev.key === 'Escape') { ev.preventDefault(); chordName.blur(); }
                    });
                    // Allow short tap on chord name to bubble so header can play; only long-press enters edit
                    chordName.addEventListener('click', (e)=>{ /* allow bubble for playback */ });
                    chordName.addEventListener('mousedown', (e)=>{ /* allow bubble for playback */ });
                    chordName.addEventListener('touchstart', (e)=>{ /* allow bubble for playback */ }, {passive:true});
                    
                    // Apply the same per-column root accent logic again (post-append)
                    try {
                        const isLocked = !!chordExt.isLocked && !!chordExt.lockedData;
                        let rootStep;
                        if (isLocked) {
                            const edo = chordExt.lockedData.lockedTuning || this.currentTuning || 12;
                            const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                            rootStep = ((chordExt.lockedData.lockedRoot ?? 0) + localDelta + edo) % edo;
            } else {
                            const label = (chordName.dataset.lockedName || chordName.textContent || '').trim();
                            const normLabel = this._normalizeChordSymbolsForParse ? this._normalizeChordSymbolsForParse(label) : label;
                            const m = normLabel.match(/^([A-Ga-g])([#b\-d]?)([\^v]*)/);
                            if (m) {
                                const semi = this.rootToSemitone(m[1].toUpperCase(), m[2]||'');
                                let step = Math.round((semi * (this.currentTuning||12)) / 12);
                                const ups = (m[3].match(/\^/g) || []).length;
                                const downs = (m[3].match(/v/g) || []).length;
                rootStep = ((step + ups - downs) % (this.currentTuning||12) + (this.currentTuning||12)) % (this.currentTuning||12);
                            } else {
                                rootStep = this.currentRoot ?? 0;
                            }
                        }
                        const semi = this.stepToSemitone(rootStep, this.currentTuning || 12);
                        const accent = this.getChromaticColorForSemitone(semi);
                        const text = this.pickTextColor(accent);
                        header.style.background = accent;
                        header.style.backgroundImage = 'none';
                        header.style.borderBottom = `2px solid ${accent}`;
                        header.style.boxShadow = `0 0 10px ${accent}55`;
                        header.style.color = text;
                    } catch {}

                    column.appendChild(header);
                    
                    // Generate chord intervals and strings
                    const intervals = chordExt.intervals || this.getBaseTriadForQuality(chordExt.name.toLowerCase());
                    
                    // If this chord is locked, generate strings using its locked settings
                    if (chordExt.isLocked && chordExt.lockedData) {
                        console.log('?? Generating strings with locked settings for:', chordExt.name);
                        // Update header to effective root (locked root + local transpose)
                        try {
                            const edo = chordExt.lockedData.lockedTuning || this.currentTuning || 12;
                            const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                            const effRoot = ((chordExt.lockedData.lockedRoot ?? 0) + localDelta + edo) % edo;
                            const effRootName = this.getRootNameForStep(effRoot, edo);
                            const header = column.querySelector('.extension-header');
                            const nameEl = header?.querySelector('.chord-name');
                            if (nameEl) {
                                const rest = (chordExt.lockedData.chordName || '').replace(/^[A-G][#b]?\s*/, '');
                                nameEl.textContent = `${effRootName}${rest}`;
                                nameEl.dataset.lockedName = nameEl.textContent;
                            }
                        } catch {}
                        this.generateStringsForColumnWithLockedSettings(column, intervals, chordExt.lockedData);
                    } else {
                        // Regular chord - use current global settings
                        this.generateStringsForColumn(column, intervals, chordExt.isCustom);
                    }
                    
                    // Ensure columns generated via the exact path are draggable
                    if (this.attachColumnDragHandlers) {
                        this.attachColumnDragHandlers(column);
                    }
                    if (useTwoRows) {
                        const half = Math.ceil(visibleExtensions.length / 2);
                        const targetRow = extensionIndex < half ? rowTop : rowBottom;
                        targetRow.appendChild(column);
                        // If strings exist already, scale their container height to half
                        const sc = column.querySelector('.strings-column');
                        if (sc) {
                            const headerEl = column.querySelector('.extension-header');
                            const headerPx = Math.max(56, headerEl ? headerEl.offsetHeight : 56);
                            sc.style.height = `calc(100% - ${headerPx}px)`;
                        }
                    } else {
                        container.appendChild(column);
                    }
                });

                // Append auto outer end marker on the last row (only if not explicitly provided by SEQ)
                const endRow = useTwoRows ? rowBottom : container;
                // repeatCount 0 = infinite; actual looping is gated by LOOP checkbox at runtime
                if (!hasExplicitOuterEnd) {
                    appendRepeatMarker(endRow, ']', { autoOuter: true, repeatCount: 0 });
                }

                // Keep ruler in sync after regeneration
                try { if (typeof window.renderChordRuler === 'function') window.renderChordRuler(); } catch(_){ }
                
                // Add click handlers and restore locked chord states after rendering
                setTimeout(() => {
                    this.addSimpleClickHandlers();
                    this.restoreLockedChordStates(); // Restore locked chord states
                }, 100);
            }

            _getColumnHeaderEl(columnElement) {
                if (!columnElement || !columnElement.querySelector) return null;
                return columnElement.querySelector('.extension-header') || columnElement.querySelector('.extension-column-header');
            }

            _setNowPlayingColumn(columnElement, opts={}) {
                try {
                    const prev = this._nowPlayingColumnEl;
                    if (prev && prev !== columnElement) {
                        const hp = this._getColumnHeaderEl(prev);
                        if (hp) { hp.classList.remove('now-playing'); hp.classList.remove('pulse'); }
                    }
                    this._nowPlayingColumnEl = columnElement || null;
                    const h = this._getColumnHeaderEl(this._nowPlayingColumnEl);
                    if (h) {
                        h.classList.add('now-playing');
                        if (opts && opts.pulse) {
                            h.classList.remove('pulse');
                            void h.offsetWidth;
                            h.classList.add('pulse');
                            setTimeout(()=>{ try{ h.classList.remove('pulse'); } catch(_){ } }, 260);
                        }
                    }
                } catch(_){ }
            }

            _clearNowPlaying() {
                try { this._setNowPlayingColumn(null); } catch(_){ }
            }
            
            generateStringsForColumnWithLockedSettings(column, intervals, lockedData) {
                // Check if we have exact frequencies captured - use those for perfect reproduction
                if (lockedData.exactFrequencies && lockedData.exactFrequencies.length > 0 && !this._transposing) {
                    this.generateStringsWithExactFrequencies(column, lockedData);
                    return; // Skip the rest of this method
                }
                
                // Store current settings to restore later
                const originalSettings = {
                    currentRoot: this.currentRoot,
                    currentTuning: this.currentTuning,
                    gamelanMode: this.gamelanMode,
                    volume: this.volume,
                    masterVolume: this.masterVolume
                };
                
                // Temporarily apply locked settings for string generation (with per-column local transpose in conjunction)
                const edo = lockedData.lockedTuning || this.currentTuning || 12;
                const globalDelta = (this.transposeDelta || 0) % edo;
                const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                this.currentRoot = ((lockedData.lockedRoot ?? 0) + (this._transposing ? globalDelta : 0) + localDelta + edo) % edo;
                this.currentTuning = lockedData.lockedTuning;
                this.gamelanMode = lockedData.lockedGamelanMode;
                this.volume = lockedData.lockedVolume.main;
                this.masterVolume = lockedData.lockedVolume.master;
                
                // Generate strings with locked settings
                this.generateStringsForColumn(column, intervals, lockedData.isCustom);
                
                // Store the display/effective root in the column's data attribute for reference during playback
                column.dataset.lockedRoot = String(this.currentRoot);
                
                // Add a visual indicator that this column is locked to a specific root
                const header = column.querySelector('.extension-header');
                if (header) {
                    const rootName = this.getRootNameForStep(this.currentRoot, lockedData.lockedTuning || this.currentTuning || 12);
                    const chordName = header.querySelector('.chord-name');
                    if (chordName) {
                        // Update the header to show it's locked to a specific root
                        chordName.textContent = `${rootName}${(lockedData.chordName||'').replace(/^[A-G][#b]?\s*/, '')}`;
                        chordName.dataset.lockedName = chordName.textContent;
                        chordName.style.color = '#ffcc00'; // Make it gold to indicate locked root
                        chordName.title = `LOCKED: ${rootName} root, ${lockedData.lockedTuning}TET tuning`;
                    }
                }
                
                // Restore original global settings
                this.currentRoot = originalSettings.currentRoot;
                this.currentTuning = originalSettings.currentTuning;
                this.gamelanMode = originalSettings.gamelanMode;
                this.volume = originalSettings.volume;
                this.masterVolume = originalSettings.masterVolume;
                
                console.log('?? Generated strings with locked settings and restored global settings');
                
                // Find the lock button and ensure it shows the correct state
                const lockButton = column.querySelector('.lock-button');
                if (lockButton) {
                    lockButton.innerHTML = 'ðŸ”’';
                    lockButton.classList.add('locked');
                    lockButton.title = `Locked to ${this.getNoteNames()[this.currentRoot] || this.currentRoot} root with all settings`;
                }
            }
            
            generateChordName(intervals) {
                if (!intervals || intervals.length === 0) return '';
                if (intervals.length === 1) return '';
                
                // Use the new proper chord symbol system
                return this.getProperChordSymbol(intervals);
            }

            
            
            // Helper function to check if intervals match (accounting for octave wrapping)
            intervalsMatch(intervals1, intervals2) {
                if (intervals1.length !== intervals2.length) return false;
                
                // Normalize intervals to within one octave
                const normalize = (intervals) => intervals.map(i => i % 12).sort((a, b) => a - b);
                const norm1 = normalize(intervals1);
                const norm2 = normalize(intervals2);
                
                return norm1.every((interval, index) => interval === norm2[index]);
            }
            
            async playStringPreview(interval) {
                const ready = await this.ensureAudioContext();
                if (!ready) return;
                
                // Interpret interval as an absolute step plus global transpose (rootless)
                const absStep = (((interval % this.currentTuning) + (this.transposeDelta||0)) % this.currentTuning + this.currentTuning) % this.currentTuning;
                const frequency = this.getFrequency(absStep, 4, this.currentTuning);
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.8);
                
                oscillator.connect(gainNode);
                // Route through master chain (global wet/dry + reverb)
                gainNode.connect(this.gainNode);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.8);
            }
            
            restoreNormalRootButtons() {
                // Restore original root button functionality
                this.generateRootButtons();
            }

            // Apply a global transpose by n EDO steps; rootless: rename headers from absolute steps when possible and retune
            applyTransposeStep(n = 0) {
                console.log('=== TRANSPOSE DEBUG ===');
                console.log('applyTransposeStep called with n =', n);
                console.log('Before: this.transposeDelta =', this.transposeDelta);
                if (!n) return;
                const edo = this.currentTuning || 12;
                this.transposeDelta = (((this.transposeDelta || 0) + n) % edo + edo) % edo;
                console.log('After: this.transposeDelta =', this.transposeDelta);
                console.log('Current active column element:', this.currentActiveColumnEl);
                console.log('=== TRANSPOSE DEBUG END ===');
                // Refresh keyboard labels and chord-tone highlights
                try { this.generateRootButtons(); } catch (_) {}
                // Rename headers (build from each chord's fixed-root baseline; include LOCAL transpose only here; map via nearest-neighbor)
                // Note: computeFullChordNameFromAbsoluteSteps will apply the GLOBAL transpose when forming the label,
                // so we must NOT bake the global delta into abs steps here to avoid double application.
                document.querySelectorAll('.extension-column').forEach(col => {
                    const nameEl = col.querySelector('.extension-header .chord-name');
                    if (!nameEl) return;
                    const locked = !!col.querySelector('.lock-button')?.classList.contains('locked');
                    const labelRaw = (nameEl.dataset.lockedName || nameEl.textContent || '').trim().replace(/^ðŸ”’\s*/, '');
                    let model = null;
                    try {
                        let idx = col.dataset.originalPosition != null ? parseInt(col.dataset.originalPosition,10) : -1;
                        if (isNaN(idx) || idx < 0) {
                            const id = col.dataset.chordId;
                            idx = (this.chordExtensions || []).findIndex(c => (c.id===id));
                        }
                        model = (idx>=0)? this.chordExtensions[idx] : null;
                    } catch (_) { model = null; }

                    const edoNow = this.currentTuning || 12;
                    const localDeltaNow = ((+col.dataset.localTranspose || 0) % edoNow + edoNow) % edoNow;
                    const globalDeltaNow = ((this.transposeDelta || 0) % edoNow + edoNow) % edoNow;

                    if (model && typeof model.fixedRootStepAbs === 'number' && Array.isArray(model.intervals) && model.intervals.length>0) {
                        const modelEdo = model.fixedRootTuning || edoNow;
                        // Map a step between EDOs by cents (nearest neighbor)
                        const mapStep = (step, srcEdo, dstEdo) => {
                            const cents = ((step % srcEdo + srcEdo) % srcEdo) * (1200 / srcEdo);
                            const dst = Math.round(cents / (1200 / dstEdo));
                            return ((dst % dstEdo) + dstEdo) % dstEdo;
                        };
                        // Convert deltas if model EDO differs
                        const localDeltaModel = (modelEdo === edoNow) ? localDeltaNow : mapStep(localDeltaNow, edoNow, modelEdo);
                        const globalDeltaModel = (modelEdo === edoNow) ? globalDeltaNow : mapStep(globalDeltaNow, edoNow, modelEdo);
                        // Include both local and global transpose in the effective root for naming
                        const effRootModel = (((model.fixedRootStepAbs || 0) + localDeltaModel + globalDeltaModel) % modelEdo + modelEdo) % modelEdo;
                        // Build degree steps in model's EDO
                        const degreeStepsModel = model.isCustom
                            ? model.intervals.map(iv => ((iv % modelEdo) + modelEdo) % modelEdo)
                            : model.intervals.map(iv => this.mapIntervalToEDO(iv, modelEdo));
                        // Ensure root (0) included and sorted unique
                        const uniqDegrees = Array.from(new Set([0, ...degreeStepsModel])).sort((a,b)=>a-b);
                        const absModel = [effRootModel, ...uniqDegrees.filter(d=>d!==0).map(d => (effRootModel + d) % modelEdo)];
                        // Map to current EDO if needed
                        const absNow = (modelEdo === edoNow) ? absModel.map(s => ((s%edoNow)+edoNow)%edoNow)
                                                            : absModel.map(s => mapStep(s, modelEdo, edoNow));
                        const shiftNow = (localDeltaNow + globalDeltaNow) % edoNow;
                        const prefName = (model && model.preferredRootName)
                            ? this._transposePreferredRootName(model.preferredRootName, shiftNow, edoNow)
                            : null;
                        const recomputed = this.computeFullChordNameFromAbsoluteSteps(
                            absNow,
                            edoNow,
                            null,
                            prefName,
                            (model && model.preferredBassRel != null) ? model.preferredBassRel : null
                        );
                        nameEl.textContent = locked ? `ðŸ”’ ${recomputed}` : recomputed;
                        nameEl.dataset.lockedName = nameEl.textContent;
                    } else {
                        // Fallback: parse current root and rotate by n, keep tail suffix
                        const m = labelRaw.match(/^([A-G])([#b]?)(.*)$/);
                        if (m) {
                            const semi = this.rootToSemitone(m[1], m[2]||'');
                            let step = this.semitoneToStep(semi, edoNow);
                            step = (((step + (this.transposeDelta||0) + localDeltaNow) % edoNow) + edoNow) % edoNow;
                            const pref = (model && model.preferredAccidental) || this._getAccidentalPreference(labelRaw);
                            const newRoot = this.getRootNameForStepWithPreference(step, edoNow, pref);
                            nameEl.textContent = locked ? `ðŸ”’ ${newRoot}${m[3]||''}` : `${newRoot}${m[3]||''}`;
                            nameEl.dataset.lockedName = nameEl.textContent;
                        }
                    }
                });
                // Retune all strings/columns to reflect transpose
                this._transposing = true;
                try { this.regenerateAllColumnsPreservingLocks(); } finally { this._transposing = false; }
                // After transpose, warm all visible pianolocked columns for instant response
                try {
                    // Warm columns marked as piano-locked (use class marker or backend flags)
                    document.querySelectorAll('.extension-column.piano-locked-col').forEach(col => {
                        try { this.preloadPianoLockedChord(col); } catch(_) {}
                    });
                    // Fallback: scan columns and check their chord data for pianoLockedData
                    document.querySelectorAll('.extension-column').forEach(col => {
                        try {
                            const hdr = col.querySelector('.extension-header');
                            const cd = (typeof this.getChordDataFromColumn === 'function') ? this.getChordDataFromColumn(col, hdr) : null;
                            if (cd && cd.isPianoLocked) { try { this.preloadPianoLockedChord(col); } catch(_) {} }
                        } catch(_){}
                    });
                } catch(_) {}
                // Update delta indicator
                const deltaEl = document.getElementById('transposeDelta');
                if (deltaEl) deltaEl.textContent = String(this.transposeDelta);
                // Update any locked column header tooltips
                try {
                    document.querySelectorAll('.extension-column').forEach(col=>{
                        const btn = col.querySelector('.lock-button');
                        if (btn?.classList.contains('locked')){
                            const edoNow = this.currentTuning || 12;
                            const lockedChord = this.lockedChords?.get(col);
                            if (lockedChord) {
                                const localDelta = ((+col.dataset.localTranspose || 0) % edoNow + edoNow) % edoNow;
                                const effStep = (((lockedChord.lockedRoot ?? 0) + localDelta + (this.transposeDelta || 0)) % edoNow + edoNow) % edoNow;
                                const newRoot = this.getRootNameForStep(effStep, edoNow);
                                btn.title = `Locked to ${newRoot} root with all settings`;
                            }
                        }
                    });
                } catch (_) {}
                // Refresh keyboard highlights after global transpose
                console.log('About to call highlightKeyboardForColumn with:', this.currentActiveColumnEl);
                console.log('Current this.transposeDelta before highlighting:', this.transposeDelta);
                try { if (this.currentActiveColumnEl) this.highlightKeyboardForColumn(this.currentActiveColumnEl); } catch (e) { console.log('Error highlighting:', e); }
            }

            // ================== TEXT â†’ CHORDS PARSER ==================
            initTextChordParser() {
                const openBtn = document.getElementById('openTextChordParserBtn');
                const modal = document.getElementById('textChordModal');
                const closeBtn = document.getElementById('closeTextChordModalBtn');
                const parseBtn = document.getElementById('parseTextChordsBtn');
                const textarea = document.getElementById('textChordInput');
                // Sequence preset controls
                const seqSelect = document.getElementById('seqPresetDropdown');
                const seqLoadBtn = document.getElementById('selectSeqPresetBtn');
                const seqSaveBtn = document.getElementById('addSeqPresetBtn');
                const seqDelBtn  = document.getElementById('deleteSeqPresetBtn');
                // Open the modal when SEQUENCE button is clicked
                if (openBtn && modal) {
                    openBtn.addEventListener('click', () => {
                        modal.style.display = 'block';
                        // Make draggable on first open
                        try {
                            if (!modal._draggableSet && typeof makeDraggable === 'function') { makeDraggable(modal); modal._draggableSet = true; }
                        } catch(_) {}
                        // Populate presets each open to pick up new saves/deletes
                        try { if (seqSelect) this.populateSeqPresetDropdown(seqSelect, this.getSequencePresets()); } catch(_) {}
                        // Initialize EDO field to current tuning
                        try { const ed = document.getElementById('seqEdoInput'); if (ed) ed.value = String(this.currentTuning || 24); } catch(_) {}
                        // Run an initial parse to populate palette/count
                        try { this.runTextChordParsing(); } catch(_) {}
                    });
                }
                // Update any locked column header tooltips
                if (closeBtn) closeBtn.addEventListener('click', ()=> { if(modal) modal.style.display='none'; });
                // Touch-close support (be responsive on touch screens)
                if (closeBtn && !closeBtn._touchCloseWired) {
                    closeBtn._touchCloseWired = true;
                    closeBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); e.stopPropagation(); if(modal) modal.style.display='none'; }, { passive: false });
                }
                // Create Sequence now builds from textarea
                if (parseBtn) parseBtn.addEventListener('click', ()=> this.createSequenceFromTextarea());
                // Live preview of unique chords palette
                if (textarea) textarea.addEventListener('input', ()=> this.runTextChordParsing());
                // Dismiss on backdrop click
                if (modal) modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });

                // Wire sequence presets UI
                // Initial populate on load
                try { if (seqSelect) this.populateSeqPresetDropdown(seqSelect, this.getSequencePresets()); } catch(_) {}
                // Auto-load on selection change and close modal
                if (seqSelect && textarea && modal) {
                    seqSelect.addEventListener('change', () => {
                        const id = seqSelect.value || '';
                        if (!id) return;
                        const list = this.getSequencePresets();
                        const found = list.find(p=> p.id === id);
                        if (!found) return;
                        const textOnly = found.text || '';
                        const edo = Math.max(5, Math.min(53, parseInt(found.edo || this.currentTuning || 24)));
                        const seqEdo = document.getElementById('seqEdoInput');
                        if (seqEdo) seqEdo.value = String(edo);
                        // Apply EDO now so parsing reflects it
                        try { this.updateTuningSystem(edo); const qi=document.getElementById('edoQuickInput'); if(qi) qi.value=String(edo); const p=document.getElementById('edoDivisions'); if(p) p.value=String(edo);} catch {}
                        textarea.value = textOnly;
                        textarea.dispatchEvent(new Event('input'));
                        // Apply any saved FX state
                        try { if (found.fx && typeof this.applyEffectsState === 'function') this.applyEffectsState(found.fx); } catch(_) {}
                        // If it's a Roman sequence, immediately create columns
                        try {
                            const material = this.convertRomanNumeralsInline(textOnly);
                            let list = this.extractChordsFromTextPreserveOrder(material);
                            
                            // If preset has saved sequence order, use that instead
                            if (found.sequenceOrder && found.sequenceOrder.length > 0) {
                                list = found.sequenceOrder;
                            }
                            
                            if (list && list.length) {
                                this.transposeDelta = 0;
                                const deltaEl = document.getElementById('transposeDelta');
                                if (deltaEl) deltaEl.textContent = '0';
                                this.autoCreateColumnsFromText(list);
                            }
                        } catch(_) {}
                        modal.style.display = 'none';
                    });
                }
                // Make sequencer EDO field drive the global tuning as well (kept in sync with quick/panel inputs)
                try {
                    const seqEdoEl = document.getElementById('seqEdoInput');
                    if (seqEdoEl) {
                        const applySeqEdo = () => {
                            const v = Math.max(5, Math.min(53, parseInt(seqEdoEl.value || this.currentTuning || 24)));
                            seqEdoEl.value = String(v);
                            try {
                                this.updateTuningSystem(v);
                                const qi = document.getElementById('edoQuickInput');
                                if (qi) qi.value = String(v);
                                const p = document.getElementById('edoDivisions');
                                if (p) p.value = String(v);
                            } catch {}
                            // Live preview re-parse if user is drafting a sequence
                            try { if (textarea) this.runTextChordParsing(); } catch {}
                        };
                        seqEdoEl.addEventListener('change', applySeqEdo);
                        // Also react to Enter key while focused
                        seqEdoEl.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') { e.preventDefault(); applySeqEdo(); }});
                    }
                } catch (_) {}
                // Save: prompt for name and save current textarea as a new preset, then refresh dropdown
                if (seqSaveBtn) seqSaveBtn.addEventListener('click', () => {
                    if (!textarea) return;
                    const text = (textarea.value || '').trim();
                    if (!text) return;
                    const name = prompt('Preset name?', 'My Sequence');
                    if (!name) return;
                    const edoEl = document.getElementById('seqEdoInput');
                    const edo = Math.max(5, Math.min(53, parseInt(edoEl?.value || this.currentTuning || 24)));
                    const fx = (typeof this.captureEffectsState === 'function') ? this.captureEffectsState() : null;
                    this.saveSequencePreset({ text, name, edo, fx });
                    try { if (seqSelect) this.populateSeqPresetDropdown(seqSelect, this.getSequencePresets()); } catch(_) {}
                    const list = this.getSequencePresets();
                    if (seqSelect && list.length) seqSelect.value = list[0].id;
                });
                // Delete: remove selected preset
                if (seqDelBtn) seqDelBtn.addEventListener('click', () => {
                    if (!seqSelect) return;
                    const id = seqSelect.value || '';
                    if (!id) return;
                    const key = 'omni_seq_presets_v4';
                    try {
                        const list = this.getSequencePresets();
                        const next = list.filter(x => x.id !== id);
                        localStorage.setItem(key, JSON.stringify(next));
                        this.populateSeqPresetDropdown(seqSelect, next);
                    } catch(_) {}
                });
            }

            // ================== INSTRUMENT PRESETS (OSC/ADSR) ==================
            getInstrumentPresets() {
                const key = 'omni_instr_presets_v1';
                try {
                    const raw = localStorage.getItem(key);
                    const list = raw ? JSON.parse(raw) : [];
                    return Array.isArray(list) ? list : [];
                } catch (_) {
                    return [];
                }
            }
            saveInstrumentPresets(list) {
                const key = 'omni_instr_presets_v1';
                try { localStorage.setItem(key, JSON.stringify(list.slice(0, 200))); } catch (_) {}
            }
            populateInstrumentPresetDropdown(selectEl) {
                if (!selectEl) return;
                const list = this.getInstrumentPresets();
                selectEl.innerHTML = '';
                const def = document.createElement('option');
                def.value = '';
                def.textContent = 'Choose preset';
                selectEl.appendChild(def);
                list.forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p.id;
                    opt.textContent = p.name || p.id;
                    selectEl.appendChild(opt);
                });
            }
            captureInstrumentState() {
                return {
                    osc1: { ...this.oscillators.osc1 },
                    osc2: { ...this.oscillators.osc2 },
                    envelope: { ...this.envelope },
                    osc2Envelope: { ...this.osc2Envelope }
                };
            }
            applyInstrumentState(state) {
                if (!state) return;
                if (state.osc1) Object.assign(this.oscillators.osc1, state.osc1);
                if (state.osc2) Object.assign(this.oscillators.osc2, state.osc2);
                if (state.envelope) Object.assign(this.envelope, state.envelope);
                if (state.osc2Envelope) Object.assign(this.osc2Envelope, state.osc2Envelope);
                // Sync UI controls if panel is open
                const oscPanel = document.querySelector('.panel-content[data-panel="osc"]');
                if (oscPanel && window.getComputedStyle(oscPanel).display !== 'none') {
                    const syncOscUi = (num, data) => {
                        try {
                            document.querySelectorAll(`.osc-btn[data-osc="${num}"]`).forEach(b => b.classList.remove('active'));
                            const active = document.querySelector(`.osc-btn[data-osc="${num}"][data-wave="${data.type}"]`);
                            if (active) active.classList.add('active');
                            const pwContainer = document.querySelector(`.pulse-width-container[data-osc="${num}"]`);
                            if (pwContainer) pwContainer.style.display = (data.type === 'pulse') ? 'block' : 'none';
                            const pwSlider = document.getElementById(`osc${num}PulseWidth`);
                            const pwValue = document.getElementById(`osc${num}PulseWidthValue`);
                            if (pwSlider && typeof data.pulseWidth === 'number') {
                                const pct = Math.round((data.pulseWidth || 0.5) * 100);
                                pwSlider.value = String(pct);
                                if (pwValue) pwValue.textContent = `${pct}%`;
                            }
                            // Shape width
                            const swSlider = document.getElementById(`osc${num}ShapeWidth`);
                            const swValue = document.getElementById(`osc${num}ShapeWidthValue`);
                            if (swSlider && typeof data.shapeWidth === 'number') {
                                const swPct = Math.round((data.shapeWidth || 0.5) * 100);
                                swSlider.value = String(swPct);
                                if (swValue) swValue.textContent = `${swPct}%`;
                            }
                            const lvl = document.getElementById(`osc${num}Level`);
                            const lvlV = document.getElementById(`osc${num}LevelValue`);
                            if (lvl) { const slider = Math.round(((data.level || 0) / 0.125) * 10); lvl.value = String(slider); if (lvlV) lvlV.textContent = `${slider * 10}%`; }
                            const det = document.getElementById(`osc${num}Detune`);
                            const detV = document.getElementById(`osc${num}DetuneValue`);
                            if (det) { det.value = String(Math.round(data.detune || 0)); if (detV) detV.textContent = `${Math.round(data.detune || 0)}Â¢`; }
                            const oct = document.getElementById(`osc${num}Octave`);
                            const octV = document.getElementById(`osc${num}OctaveValue`);
                            if (oct) { oct.value = String(data.octave || 0); if (octV) octV.textContent = String(data.octave || 0); }
                            const crs = document.getElementById(`osc${num}Coarse`);
                            const crsV = document.getElementById(`osc${num}CoarseValue`);
                            if (crs) { crs.value = String(data.coarse || 0); if (crsV) crsV.textContent = `${data.coarse || 0} steps`; }
                        } catch(_) {}
                    };
                    // ADSR 1
                    const a = document.getElementById('attackSlider');
                    const d = document.getElementById('decaySlider');
                    const s = document.getElementById('sustainSlider');
                    const r = document.getElementById('releaseSlider');
                    const av = document.getElementById('attackValue');
                    const dv = document.getElementById('decayValue');
                    const sv = document.getElementById('sustainValue');
                    const rv = document.getElementById('releaseValue');
                    if (a) { const ms = Math.round((this.instruments.strum1.env.attack||0)*1000); a.value = String(ms); if (av) av.textContent = `${ms}ms`; }
                    if (d) { const ms = Math.round((this.instruments.strum1.env.decay||0)*1000); d.value = String(ms); if (dv) dv.textContent = `${ms}ms`; }
                    if (s) { const pct = Math.round((this.instruments.strum1.env.sustain||0)*100); s.value = String(pct); if (sv) sv.textContent = `${pct}%`; }
                    if (r) { const ms = Math.round((this.instruments.strum1.env.release||0)*1000); r.value = String(ms); if (rv) rv.textContent = `${ms}ms`; }
                    // ADSR 2
                    const a2 = document.getElementById('osc2AttackSlider');
                    const d2 = document.getElementById('osc2DecaySlider');
                    const s2 = document.getElementById('osc2SustainSlider');
                    const r2 = document.getElementById('osc2ReleaseSlider');
                    const a2v = document.getElementById('osc2AttackValue');
                    const d2v = document.getElementById('osc2DecayValue');
                    const s2v = document.getElementById('osc2SustainValue');
                    const r2v = document.getElementById('osc2ReleaseValue');
                    if (a2) { const ms = Math.round((this.instruments.strum2.env.attack||0)*1000); a2.value = String(ms); if (a2v) a2v.textContent = `${ms}ms`; }
                    if (d2) { const ms = Math.round((this.instruments.strum2.env.decay||0)*1000); d2.value = String(ms); if (d2v) d2v.textContent = `${ms}ms`; }
                    if (s2) { const pct = Math.round((this.instruments.strum2.env.sustain||0)*100); s2.value = String(pct); if (s2v) s2v.textContent = `${pct}%`; }
                    if (r2) { const ms = Math.round((this.instruments.strum2.env.release||0)*1000); r2.value = String(ms); if (r2v) r2v.textContent = `${ms}ms`; }
                    // Waves and per-osc UI
                    syncOscUi(1, this.oscillators.osc1);
                    syncOscUi(2, this.oscillators.osc2);
                }
            }
            // ================== EFFECTS PRESETS ==================
            getEffectsPresets() {
                const key = 'omni_fx_presets_v1';
                try { const raw = localStorage.getItem(key); const list = raw ? JSON.parse(raw) : []; return Array.isArray(list)? list: []; } catch(_) { return []; }
            }
            saveEffectsPresets(list) {
                const key = 'omni_fx_presets_v1';
                try { localStorage.setItem(key, JSON.stringify(list.slice(0,200))); } catch(_) {}
            }
            populateEffectsPresetDropdown(selectEl) {
                if (!selectEl) return; const list = this.getEffectsPresets(); selectEl.innerHTML='';
                const def=document.createElement('option'); def.value=''; def.textContent='Choose preset'; selectEl.appendChild(def);
                list.forEach(p=>{ const opt=document.createElement('option'); opt.value=p.id; opt.textContent=p.name||p.id; selectEl.appendChild(opt); });
            }
            captureEffectsState() {
                return {
                    drive: {
                        amount: parseFloat(document.getElementById('driveAmount')?.value || 0),
                        mix: parseFloat(document.getElementById('driveMix')?.value || 0),
                        hp: parseFloat(document.getElementById('driveHpCutoff')?.value || 0),
                        lp: parseFloat(document.getElementById('driveLpCutoff')?.value || 100)
                    },
                    delay: {
                        timeMs: parseFloat(document.getElementById('delayTime')?.value || 280),
                        feedback: parseFloat(document.getElementById('delayFeedback')?.value || 0),
                        lp: parseFloat(document.getElementById('delayLpCutoff')?.value || 73),
                        hp: parseFloat(document.getElementById('delayHpCutoff')?.value || 0),
                        mix: parseFloat(document.getElementById('delayMix')?.value || 0)
                    },
                    filters: {
                        low: parseFloat(document.getElementById('filterLow')?.value || 0),
                        high: parseFloat(document.getElementById('filterHigh')?.value || 100),
                        q: parseFloat(document.getElementById('filterRes')?.value || 1)
                    },
                    reverb: {
                        wet: parseFloat(document.getElementById('reverbWet')?.value || 1),
                        room: parseFloat(document.getElementById('reverbRoom')?.value || 5),
                        decay: parseFloat(document.getElementById('reverbDecay')?.value || 20),
                        lp: parseFloat(document.getElementById('reverbFilterCutoff')?.value || 70),
                        hp: parseFloat(document.getElementById('reverbHpCutoff')?.value || 0)
                    },
                    panning: {
                        mode: document.getElementById('panningMode')?.value || 'center',
                        width: parseFloat(document.getElementById('panningWidth')?.value || 80),
                        speedMs: parseFloat(document.getElementById('panningSpeed')?.value || 2000)
                    }
                };
            }
            applyEffectsState(state) {
                if (!state) return;
                try {
                    const setVal = (id, val, textFormatter)=>{ const el=document.getElementById(id); if(el){ el.value=String(val); const vEl=document.getElementById(id+"Value"); if(vEl){ vEl.textContent = textFormatter? textFormatter(val): String(val); } el.dispatchEvent(new Event('input')); } };
                    if (state.drive){ setVal('driveAmount', state.drive.amount, v=> `${Math.round(v)}%`); setVal('driveMix', state.drive.mix, v=> `${Math.round(v)}%`); setVal('driveHpCutoff', state.drive.hp); setVal('driveLpCutoff', state.drive.lp); }
                    if (state.delay){ setVal('delayTime', state.delay.timeMs, v=> `${Math.round(v)}ms`); setVal('delayFeedback', state.delay.feedback, v=> `${Math.round(v)}%`); setVal('delayLpCutoff', state.delay.lp); setVal('delayHpCutoff', state.delay.hp); setVal('delayMix', state.delay.mix, v=> `${Math.round(v)}%`); }
                    if (state.filters){ setVal('filterLow', state.filters.low); setVal('filterHigh', state.filters.high); setVal('filterRes', state.filters.q, v=> `Q ${Number(v).toFixed(1)}`); }
                    if (state.reverb){ setVal('reverbWet', state.reverb.wet, v=> `${Math.round(v*10)}%`); setVal('reverbRoom', state.reverb.room, v=> `${Math.round((v||0)*10)}%`); setVal('reverbDecay', state.reverb.decay, v=> `${(Number(v)/10).toFixed(1)}s`); setVal('reverbFilterCutoff', state.reverb.lp); setVal('reverbHpCutoff', state.reverb.hp); }
                    if (state.panning){ const pm=document.getElementById('panningMode'); if(pm) { pm.value = state.panning.mode||'center'; pm.dispatchEvent(new Event('change')); } setVal('panningWidth', state.panning.width, v=> `${Math.round(v)}%`); setVal('panningSpeed', state.panning.speedMs, v=> `${(Number(v)/1000).toFixed(1)}s`); }
                } catch(_) {}
            }
            wireEffectsPresetsUI() {
                const sel = document.getElementById('effectsPresetSelect');
                const btnApply = document.getElementById('effectsPresetApply');
                const btnSave = document.getElementById('effectsPresetSave');
                const btnDel  = document.getElementById('effectsPresetDelete');
                if (sel) this.populateEffectsPresetDropdown(sel);
                if (btnApply) btnApply.addEventListener('click', ()=>{ const id=sel?.value||''; if(!id) return; const list=this.getEffectsPresets(); const found=list.find(p=>p.id===id); if(found) this.applyEffectsState(found.state); });
                if (btnSave) btnSave.addEventListener('click', ()=>{ const name=prompt('Preset name?','My FX'); if(!name) return; const list=this.getEffectsPresets(); const id=`FX${Date.now()}`; list.unshift({ id, name, state: this.captureEffectsState() }); this.saveEffectsPresets(list); if (sel){ this.populateEffectsPresetDropdown(sel); sel.value=id; } });
                if (btnDel) btnDel.addEventListener('click', ()=>{ const id=sel?.value||''; if(!id) return; const list=this.getEffectsPresets(); const next=list.filter(p=>p.id!==id); this.saveEffectsPresets(next); if (sel) this.populateEffectsPresetDropdown(sel); });
            }
            wireInstrumentPresetsUI() {
                const sel = document.getElementById('instrumentPresetSelect');
                const btnApply = document.getElementById('instrumentPresetApply');
                const btnSave = document.getElementById('instrumentPresetSave');
                const btnDel = document.getElementById('instrumentPresetDelete');
                if (sel) this.populateInstrumentPresetDropdown(sel);
                if (btnApply) btnApply.addEventListener('click', () => {
                    const id = sel?.value || '';
                    if (!id) return;
                    const list = this.getInstrumentPresets();
                    const found = list.find(p => p.id === id);
                    if (found) this.applyInstrumentState(found.state);
                });
                if (btnSave) btnSave.addEventListener('click', () => {
                    const name = prompt('Preset name?','My Instrument');
                    if (!name) return;
                    const list = this.getInstrumentPresets();
                    const id = `P${Date.now()}`;
                    list.unshift({ id, name, state: this.captureInstrumentState() });
                    this.saveInstrumentPresets(list);
                    if (sel) { this.populateInstrumentPresetDropdown(sel); sel.value = id; }
                });
                if (btnDel) btnDel.addEventListener('click', () => {
                    const id = sel?.value || '';
                    if (!id) return;
                    const list = this.getInstrumentPresets();
                    const next = list.filter(p => p.id !== id);
                    this.saveInstrumentPresets(next);
                    if (sel) this.populateInstrumentPresetDropdown(sel);
                });
            }

            runTextChordParsing() {
                const input = document.getElementById('textChordInput');
                const resultsGrid = document.getElementById('textChordResults');
                const countEl = document.getElementById('textChordCount');
                if (!input || !resultsGrid || !countEl) return;
                const text = input.value || '';
                // Always convert Roman numerals inline while leaving ordinary chord tokens as-is
                const material = this.convertRomanNumeralsInline(text);
                // Build a unique chord palette (deduped, first-appearance order)
                const unique = this.extractUniqueChordsFromEntireText(material);
                // Render clickable cards that append to textarea
                resultsGrid.innerHTML = '';
                unique.forEach(ch => {
                    const card = document.createElement('div');
                    card.style.cssText = 'padding:10px; border:1px solid #2b5567; border-radius:8px; background:#102a3a; color:#e8f5ff; font-family:var(--retro-font); display:flex; align-items:center; justify-content:center; min-height:46px;';
                    card.textContent = ch;
                    card.tabIndex = 0;
                    card.style.cursor = 'pointer';
                    const append = ()=>{
                        const ta = document.getElementById('textChordInput');
                        if (!ta) return;
                        const sep = /[\s\n]$/.test(ta.value || '') || !ta.value ? '' : ' ';
                        ta.value = (ta.value || '') + sep + ch;
                        ta.focus();
                        ta.setSelectionRange(ta.value.length, ta.value.length);
                        ta.dispatchEvent(new Event('input'));
                    };
                    card.addEventListener('click', append);
                    card.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); append(); } });
                    resultsGrid.appendChild(card);
                });
                countEl.textContent = String(unique.length);
                // Keep last palette for potential future use
                this._lastParsedChordsPalette = unique;
            }

            // New: create sequence from current textarea content; honors Roman detection and Repeat Unique Sections
            createSequenceFromTextarea() {
                console.log('ðŸŽµðŸŽµðŸŽµ createSequenceFromTextarea CALLED ðŸŽµðŸŽµðŸŽµ');
                const input = document.getElementById('textChordInput');
                const modal = document.getElementById('textChordModal');
                if (!input) return;
                let text = input.value || '';
                
                // Auto-wrap sequences in brackets if not already present to ensure looping
                const trimmed = text.trim();
                if (trimmed && !trimmed.startsWith('[') && !trimmed.includes('[')) {
                    text = '[' + trimmed + ']';
                    console.log('ðŸŽµ Auto-wrapped sequence in brackets for looping:', text);
                }
                
                const material = this.convertRomanNumeralsInline(text);
                
                // ALWAYS use bracket-aware parsing for proper repeat marker support
                const list = this.extractChordsFromTextPreserveOrder(material);
                
                try { console.log('[SEQ] material =', material, '| list =', list, '| EDO =', this.currentTuning); } catch {}
                if (!list.length) return;
                // Reset global transpose and rebuild
                this.transposeDelta = 0;
                const deltaEl = document.getElementById('transposeDelta');
                if (deltaEl) deltaEl.textContent = '0';
                this.autoCreateColumnsFromText(list);
                if (modal) modal.style.display='none';
            }

            // Unique chords across the entire text in order of first appearance
            extractUniqueChordsFromEntireText(text) {
                const out = [];
                const seen = new Set();
                if (!text) return out;
                const lines = String(text).split(/\r?\n/);
                for (const line of lines) {
                    const s = line.trim();
                    if (!s) continue;
                    const matches = this.scanChordMatches(s);
                    for (const m of matches) {
                        const norm = this.normalizeChordToken(m.raw);
                        if (!norm) continue;
                        if (!seen.has(norm)) { seen.add(norm); out.push(norm); }
                    }
                }
                return out;
            }

            // Heuristic: consider this text a Roman sequence only if most tokens are Roman numerals (with optional degree accidentals and extensions)
            isRomanSequence(text) {
                if (!text) return false;
                const tokens = [];
                String(text).split(/\r?\n/).forEach(line => {
                    line.split(/[\s\|]+|[â€“â€”-]/g).map(s=>s.trim()).filter(Boolean).forEach(t=>tokens.push(t));
                });
                if (tokens.length === 0) return false;
                // Roman token: optional leading b/#, then roman (I,II,III,IV,V,VI,VII in any case), optional extension tail
                const romanRe = /^(?:b+|#+)?(?:i{1,3}|iv|v|vi{0,3}|I{1,3}|IV|V|VI{0,3})(?:maj7|M7|Î”7|m7|7|9|11|13|maj9|M9|Î”9|add(?:9|11|13)|[#b](?:5|9|11|13))?$/;
                let romanCount = 0;
                for (const tok of tokens) {
                    if (romanRe.test(tok)) romanCount++;
                }
                if (romanCount === 0) return false;
                // Require a majority to avoid mixing modes
                return romanCount / tokens.length >= 0.6;
            }

            // Detect unique repeating blocks from multi-line input; returns array of arrays (each block => list of chords).
            extractUniqueBlocks(text) {
                if (!text) return [];
                const lines = String(text).split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
                const out = [];
                const seen = new Set();
                for (const line of lines) {
                    const tokens = this.extractUniqueChordsFromText(line);
                    if (!tokens.length) continue;
                    const key = tokens.join(' ');
                    if (!seen.has(key)) { seen.add(key); out.push(tokens); }
                }
                return out;
            }

            // New: Extract chords in order (no dedupe), across lines, preserving repeats
            // Now supports bracket notation: [C F G Am x4 Am F G C x 4] x4
            extractChordsFromTextPreserveOrder(text) {
                if (!text) return [];
                
                // Parse for VISUAL DISPLAY - keep compact form with repeat markers
                const compactChords = this.parseCompactChordSequence(text);
                console.log('ðŸŽµ Compact parsing:', text, 'â†’', compactChords);
                
                // Debug log the parsed structure  
                const debugStructure = compactChords.map(item => {
                    if (item.startsWith('__REPEAT_')) return `[REPEAT:${item.replace('__REPEAT_', '').replace('__', '')}]`;
                    if (item.startsWith('__BRACKET_')) return `[BRACKET:${item.replace('__BRACKET_', '').replace('__', '')}]`;
                    if (item === '__SECTION__') return '[SECTION]';
                    return item;
                });
                console.log('ðŸŽµ Parsed structure:', debugStructure.join(' | '));
                
                return compactChords;
            }

            // Parse compact chord sequence keeping repeat markers for visual display
            parseCompactChordSequence(text) {
                if (!text || typeof text !== 'string') return [];
                
                const lines = String(text).split(/\r?\n/);
                const out = [];
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (!trimmed) continue;
                    
                    // Handle section separators
                    const s = trimmed.replace(/(^|\s)[^\s|:]+\s*:\s*/g, ' | ');
                    const sections = s.split('|');
                    
                    sections.forEach((seg, idx) => {
                        const segment = seg.trim();
                        if (!segment) return;
                        
                        // Parse bracket notation for compact display
                        const parsedSegment = this.parseSegmentWithRepeats(segment);
                        out.push(...parsedSegment);
                        
                        if (idx < sections.length - 1) out.push('__SECTION__');
                    });
                }
                
                return out;
            }

            // Expand compact sequence for playback (expands all repeats)
            expandSequenceForPlayback(compactSequence) {
                console.log('ðŸŽµ Expanding sequence for playbook:', compactSequence);
                
                // Check if loop is enabled
                const loopToggle = document.getElementById('loopToggle');
                const loopEnabled = loopToggle ? loopToggle.checked : true;
                
                const expanded = [];
                let i = 0;

                const isMarker = (t)=> typeof t === 'string' && t.startsWith('__');
                const isChord = (t)=> typeof t === 'string' && !t.startsWith('__');

                while (i < compactSequence.length) {
                    const token = compactSequence[i];

                    // Case 1: Combined bracket end+repeat e.g., __BRACKET_END_REPEAT_L1_4__
                    if (typeof token === 'string' && token.match(/^__BRACKET_END_REPEAT_L\d+_\d+__$/)) {
                        const m = token.match(/^__BRACKET_END_REPEAT_L(\d+)_(\d+)__$/);
                        const level = parseInt(m[1], 10);
                        const count = Math.max(1, parseInt(m[2], 10));
                        console.log('ðŸŽµ Bracket END-REPEAT found:', token, 'level:', level, 'count:', count);

                        // Only process repeats if loop is enabled
                        if (loopEnabled) {
                            // Collect chords since the matching BRACKET_START of the same level
                            const slice = [];
                            let j = expanded.length - 1;
                            while (j >= 0) {
                                const prev = expanded[j];
                                if (typeof prev === 'string' && prev === `__BRACKET_START_L${level}__`) {
                                    break; // reached the boundary for this level
                                }
                                if (isChord(prev)) {
                                    slice.unshift(prev);
                                }
                                // Skip markers of any kind (including inner bracket markers and repeat tokens)
                                j--;
                            }
                            console.log('ðŸŽµ Slice to repeat (level', level, '):', slice);
                            for (let rep = 1; rep < count; rep++) {
                                expanded.push(...slice);
                            }
                        }
                        // We can drop the combined marker for playback (structure only)
                        i++;
                        continue;
                    }

                    // Case 2: Inline repeat markers (old + colored): __REPEAT_4__ or __REPEAT_L1_3__
                    if (typeof token === 'string' && (token.startsWith('__REPEAT_') || token.match(/^__REPEAT_L\d+_\d+__$/))) {
                        let count;
                        if (token.match(/^__REPEAT_L\d+_(\d+)__$/)) {
                            const match = token.match(/^__REPEAT_L\d+_(\d+)__$/);
                            count = parseInt(match[1], 10);
                        } else {
                            count = parseInt(token.replace('__REPEAT_', '').replace('__', ''), 10);
                        }
                        console.log('ðŸŽµ Inline repeat marker:', token, 'count:', count);
                        // Repeat only the immediately preceding chord (ignore markers)
                        let k = expanded.length - 1; let prevChord = null;
                        while (k >= 0) {
                            if (isChord(expanded[k])) { prevChord = expanded[k]; break; }
                            k--;
                        }
                        if (prevChord) {
                            for (let rep = 1; rep < count; rep++) expanded.push(prevChord);
                        }
                        i++;
                        continue;
                    }

                    // Case 3: Structural bracket markers (kept temporarily for boundary detection)
                    if (typeof token === 'string' && token.match(/^__BRACKET_(START|END)_L\d+__$/)) {
                        expanded.push(token);
                        i++;
                        continue;
                    }

                    // Case 4: Regular chords
                    if (isChord(token)) {
                        expanded.push(token);
                        i++;
                        continue;
                    }

                    // Case 5: Other tokens like sections, drum maps, etc.
                    expanded.push(token);
                    i++;
                }

                // Remove bracket/repeat markers from final expanded sequence (keep only chords and sections)
                const finalExpanded = expanded.filter(t =>
                    typeof t === 'string' &&
                    !t.startsWith('__BRACKET_') &&
                    !t.startsWith('__REPEAT_')
                );

                console.log('ðŸŽµ Final expanded playback sequence:', finalExpanded);
                return finalExpanded;
            }

            // Parse a segment with bracket and repeat notation, keeping structure compact
            parseSegmentWithRepeats(segment) {
                // Use the new nested bracket parser
                return this.parseNestedBrackets(segment);
            }

            // Advanced bracket parser that handles nesting: [[Am F]x4 [C F G]x2]x4 Cx4
            parseNestedBrackets(text, nestLevel = 0) {
                const out = [];
                let i = 0;
                
                console.log('ðŸŽµ Parsing nested brackets:', text, 'at nest level', nestLevel);
                
                while (i < text.length) {
                    // Skip whitespace
                    while (i < text.length && /\s/.test(text[i])) i++;
                    if (i >= text.length) break;
                    
                    const char = text[i];
                    
                    if (char === '[') {
                        // Find matching closing bracket, handling nesting
                        const bracketContent = this.extractBracketContent(text, i);
                        if (bracketContent) {
                            const { content, endIndex, repeatCount } = bracketContent;
                            
                            console.log('ðŸŽµ Found bracket:', { content, repeatCount, nestLevel, fullMatch: text.slice(i, endIndex + 1) });
                            
                            // Add colored bracket start marker
                            out.push(`__BRACKET_START_L${nestLevel}__`);
                            
                            // Recursively parse bracket content (increment nest level)
                            const innerParsed = this.parseNestedBrackets(content, nestLevel + 1);
                            
                            // Add bracket content ONCE for visual display
                            out.push(...innerParsed);
                            
                            // Add combined bracket end and repeat marker
                            if (repeatCount > 1) {
                                out.push(`__BRACKET_END_REPEAT_L${nestLevel}_${repeatCount}__`);
                            } else {
                                out.push(`__BRACKET_END_L${nestLevel}__`);
                            }
                            
                            i = endIndex + 1; // Move past the entire bracket construct
                            continue;
                        } else {
                            console.warn('ðŸŽµ Malformed bracket at position', i, 'in text:', text);
                            i++; // Skip malformed bracket
                            continue;
                        }
                    }

                    // New: Curly-brace drum pattern mapping, e.g. {1x3}{2} or {1x3 2}
                    if (char === '{') {
                        const cmap = this.extractCurlyDrumMap(text, i);
                        if (cmap) {
                            const { patterns, endIndex } = cmap;
                            // Encode as a compact token for later assignment during column creation
                            const token = `__DRMAP_${patterns.join('_')}__`;
                            out.push(token);
                            i = endIndex + 1;
                            continue;
                        } else {
                            console.warn('ðŸŽµ Malformed curly directive at position', i, 'in text:', text);
                            i++;
                            continue;
                        }
                    }
                    
                    // Not a bracket - extract regular chords and inline repeats
                    const segment = this.extractNextSegment(text, i, nestLevel);
                    if (segment) {
                        const { chords, endIndex } = segment;
                        out.push(...chords);
                        i = endIndex + 1;
                    } else {
                        i++; // Skip unrecognized characters
                    }
                }
                
                console.log('ðŸŽµ Nested parsing result (compact for visual, level', nestLevel, '):', out);
                return out;
            }

            // Parse a curly-brace drum map directive starting at '{'
            extractCurlyDrumMap(text, startIndex) {
                if (text[startIndex] !== '{') return null;
                let i = startIndex + 1;
                let content = '';
                let foundClose = false;
                while (i < text.length) {
                    const ch = text[i];
                    if (ch === '}') { foundClose = true; break; }
                    content += ch;
                    i++;
                }
                if (!foundClose) return null;
                // content may be like "1x3 2" or "1 x 3, 2" etc.
                const tokens = content.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean);
                const patterns = [];
                for (const tok of tokens) {
                    const m = tok.match(/^(\d+)(?:[xX](\d+))?$/);
                    if (!m) continue;
                    const num = parseInt(m[1], 10);
                    const rep = Math.max(1, parseInt(m[2] || '1', 10));
                    for (let r = 0; r < rep; r++) patterns.push(num);
                }
                return { patterns, endIndex: i };
            }

            // Extract bracket content with proper nesting support
            extractBracketContent(text, startIndex) {
                if (text[startIndex] !== '[') return null;
                
                let depth = 0;
                let i = startIndex;
                
                // Find matching closing bracket
                while (i < text.length) {
                    if (text[i] === '[') depth++;
                    else if (text[i] === ']') depth--;
                    
                    if (depth === 0) break;
                    i++;
                }
                
                if (depth !== 0) return null; // Unmatched bracket
                
                const content = text.slice(startIndex + 1, i).trim();
                let endIndex = i;
                
                // Check for repeat notation after closing bracket: ]x4 or ] x4
                let j = i + 1;
                
                // Skip whitespace after closing bracket
                while (j < text.length && /\s/.test(text[j])) j++;
                
                // Look for 'x' or 'X' followed by digits
                let repeatCount = 1;
                if (j < text.length && /[xX]/.test(text[j])) {
                    j++; // Skip 'x'
                    
                    // Skip whitespace after 'x'
                    while (j < text.length && /\s/.test(text[j])) j++;
                    
                    // Extract number
                    let numStr = '';
                    while (j < text.length && /\d/.test(text[j])) {
                        numStr += text[j];
                        j++;
                    }
                    
                    if (numStr) {
                        repeatCount = parseInt(numStr, 10);
                        endIndex = j - 1; // Point to last digit
                    }
                }
                
                console.log('ðŸŽµ Extracted bracket:', { content, repeatCount, originalText: text.slice(startIndex, endIndex + 1) });
                return { content, endIndex, repeatCount };
            }

            // Extract next chord segment (handles inline repeats like Cx4, and standalone brackets)
            extractNextSegment(text, startIndex, nestLevel = 0) {
                // Skip whitespace
                while (startIndex < text.length && /\s/.test(text[startIndex])) {
                    startIndex++;
                }
                
                if (startIndex >= text.length) return null;
                
                // Check for standalone bracket symbols: [ or ]
                if (text[startIndex] === '[' && (startIndex === 0 || /\s/.test(text[startIndex - 1]))) {
                    // Check if this is a standalone [ (not part of bracket notation)
                    const nextChar = startIndex + 1 < text.length ? text[startIndex + 1] : '';
                    if (!nextChar || /\s/.test(nextChar)) {
                        // Standalone left bracket - create repeat marker
                        return { 
                            chords: ['__LEFT_BRACKET__'], 
                            endIndex: startIndex 
                        };
                    }
                }
                
                if (text[startIndex] === ']' && (startIndex === 0 || /\s/.test(text[startIndex - 1]))) {
                    // Check if this is a standalone ] (not part of bracket notation)
                    const nextChar = startIndex + 1 < text.length ? text[startIndex + 1] : '';
                    if (!nextChar || /\s/.test(nextChar)) {
                        // Standalone right bracket - create repeat marker
                        return { 
                            chords: ['__RIGHT_BRACKET__'], 
                            endIndex: startIndex 
                        };
                    }
                }
                
                // Extract token until next bracket or whitespace
                let endIndex = startIndex;
                while (endIndex < text.length &&
                       text[endIndex] !== '[' &&
                       text[endIndex] !== ']' &&
                       !/\s/.test(text[endIndex])) {
                    endIndex++;
                }

                const token = text.slice(startIndex, endIndex).trim();
                if (!token) return null;
                
                console.log('ðŸŽµ Extracting segment:', token);
                
                const chords = [];
                
                // Handle inline repeat: Cx4, Amx2, etc.
                const inlineMatch = token.match(/^(.+?)[xX](\d+)$/);
                if (inlineMatch) {
                    const chordName = inlineMatch[1];
                    const chord = this.normalizeChordToken(chordName);
                    if (chord) {
                        const count = parseInt(inlineMatch[2], 10);
                        console.log('ðŸŽµ Inline repeat found:', chordName, 'x', count);
                        
                        // For VISUAL DISPLAY: show chord ONCE followed by repeat marker
                        // This creates compact display like: C x4 (not C C C C x4)
                        chords.push(chord);
                        
                        // Add visual repeat marker with nest level color if count > 1
                        if (count > 1) {
                            chords.push(`__REPEAT_L${nestLevel}_${count}__`);
                        }
                    }
                } else {
                    // Regular chord - but make sure it's not a repeat marker like "x4"
                    if (!/^[xX]\d+$/.test(token)) {
                        const chord = this.normalizeChordToken(token);
                        if (chord) {
                            console.log('ðŸŽµ Regular chord:', chord);
                            chords.push(chord);

                            // New: spaced duration multiplier, e.g. "C x2" or "C x 2".
                            // Semantics: ONE chordbox lasting N bars (bar = 16 16ths), not repeated chords.
                            let j = endIndex;
                            while (j < text.length && /\s/.test(text[j])) j++;
                            if (j < text.length && /[xX]/.test(text[j])) {
                                let k = j + 1;
                                while (k < text.length && /\s/.test(text[k])) k++;
                                let numStr = '';
                                while (k < text.length && /\d/.test(text[k])) { numStr += text[k]; k++; }
                                if (numStr) {
                                    const bars = Math.max(1, parseInt(numStr, 10) || 1);
                                    if (bars > 1) chords.push(`__LENBARS_${bars}__`);
                                    // Consume the duration tokens so they won't be parsed as standalone "x2"
                                    endIndex = k;
                                }
                            }
                        }
                    } else {
                        console.warn('ðŸŽµ Skipping standalone repeat marker:', token);
                    }
                }

                return { chords, endIndex: endIndex - 1 };
            }

            // Parse bracket content handling inner x patterns: "C F G Am x4"
            parseInnerBracketContent(content) {
                console.log('ðŸŽµ Parsing inner bracket content:', content);
                const out = [];
                const tokens = content.split(/\s+/);
                console.log('ðŸŽµ Tokens:', tokens);
                
                for (let i = 0; i < tokens.length; i++) {
                    const token = tokens[i];
                    console.log('ðŸŽµ Processing token:', token, 'at index', i);
                    
                    // Skip empty tokens
                    if (!token.trim()) continue;
                    
                    // Check for "chord x N" pattern
                    if (i < tokens.length - 2) {
                        const nextToken = tokens[i + 1];
                        const countToken = tokens[i + 2];
                        
                        if ((nextToken === 'x' || nextToken === 'X') && /^\d+$/.test(countToken)) {
                            console.log('ðŸŽµ Found spaced repeat pattern:', token, nextToken, countToken);
                            const chord = this.normalizeChordToken(token);
                            if (chord) {
                                out.push(chord);
                                const repeatCount = parseInt(countToken, 10);
                                if (repeatCount > 1) {
                                    out.push(`__REPEAT_${repeatCount}__`);
                                    console.log('ðŸŽµ Added inner repeat marker:', `__REPEAT_${repeatCount}__`);
                                }
                            }
                            i += 2; // Skip 'x' and count
                            continue;
                        }
                    }
                    
                    // Check for inline pattern: "Amx4"
                    const inlineMatch = token.match(/^(.+?)[xX](\d+)$/);
                    if (inlineMatch) {
                        console.log('ðŸŽµ Found inline repeat pattern:', token, '->', inlineMatch[1], 'x', inlineMatch[2]);
                        const chord = this.normalizeChordToken(inlineMatch[1]);
                        if (chord) {
                            out.push(chord);
                            const count = parseInt(inlineMatch[2], 10);
                            if (count > 1) {
                                out.push(`__REPEAT_${count}__`);
                                console.log('ðŸŽµ Added inline repeat marker:', `__REPEAT_${count}__`);
                            }
                        }
                        continue;
                    }
                    
                    // Regular chord
                    const chord = this.normalizeChordToken(token);
                    if (chord) {
                        console.log('ðŸŽµ Added regular chord:', chord);
                        out.push(chord);
                    } else {
                        console.log('ðŸŽµ Token not recognized as chord:', token);
                    }
                }
                
                console.log('ðŸŽµ Inner bracket result:', out);
                return out;
            }

            // Extract chords from simple text without repeat notation
            extractChordsFromSimpleText(text) {
                const out = [];
                const matches = this.scanChordMatches(text);
                for (const m of matches) {
                    const token = m.raw.trim();
                    
                    // Skip repeat notation that might have slipped through
                    if (/^[xX]\d+$/.test(token)) {
                        console.log('ðŸŽµ Skipping repeat token in chord extraction:', token);
                        continue;
                    }
                    
                    const norm = this.normalizeChordToken(token);
                    if (norm) out.push(norm);
                }
                return out;
            }

            // Expand chord sequence for PLAYBACK only (when actually playing music)
            expandChordSequenceForPlayback(compactChords) {
                const expanded = [];
                
                for (let i = 0; i < compactChords.length; i++) {
                    const item = compactChords[i];
                    
                    if (item === '__SECTION__') {
                        expanded.push(item);
                        continue;
                    }
                    
                    if (item.startsWith('__REPEAT_')) {
                        const count = parseInt(item.replace('__REPEAT_', '').replace('__', ''), 10);
                        const prevChord = expanded[expanded.length - 1];
                        if (prevChord && !prevChord.startsWith('__')) {
                            // Repeat the previous chord (count-1) more times
                            for (let r = 1; r < count; r++) {
                                expanded.push(prevChord);
                            }
                        }
                        continue;
                    }
                    
                    if (item.startsWith('__BRACKET_')) {
                        // Skip bracket markers in playback
                        continue;
                    }
                    
                    expanded.push(item);
                }
                
                return expanded;
            }

            // Presets management in localStorage
            getSequencePresets() {
                const keyNew = 'omni_seq_presets_v4';
                const keyOld = 'omni_seq_presets_v3';
                // Load new
                let listObj = [];
                try { listObj = JSON.parse(localStorage.getItem(keyNew)) || []; } catch(_) { listObj = []; }
                if (!Array.isArray(listObj) || !listObj.length) {
                    // Try migrate from v3 strings
                    let old = [];
                    try { old = JSON.parse(localStorage.getItem(keyOld)) || []; } catch(_) { old = []; }
                    if (Array.isArray(old) && old.length) {
                        const migrated = old.map(s => {
                            const nameMatch = String(s).match(/\(([^)]+)\)\s*$/);
                            const name = nameMatch ? nameMatch[1] : 'Preset';
                            const text = String(s).replace(/\s*\([^)]*\)\s*$/, '');
                            return { id: `S${Date.now()}_${Math.random().toString(36).slice(2,8)}`, name, text, edo: this.currentTuning || 24 };
                        });
                        listObj = migrated;
                        try { localStorage.setItem(keyNew, JSON.stringify(listObj)); } catch(_) {}
                    } else {
                        // Seed with defaults
            const defs = this.getDefaultSequencePresets();
            listObj = defs.map(s=>{ const nameMatch = String(s).match(/\(([^)]+)\)\s*$/); const name = nameMatch ? nameMatch[1] : 'Preset'; const text = String(s).replace(/\s*\([^)]*\)\s*$/, ''); return { id:`S${Date.now()}_${Math.random().toString(36).slice(2,8)}`, name, text, edo: this.currentTuning || 24, fx: null }; });
                        try { localStorage.setItem(keyNew, JSON.stringify(listObj)); } catch(_) {}
                    }
                }
                // Always merge in any new defaults added by the app author without removing user presets
                try {
                    const existing = Array.isArray(listObj) ? listObj.slice() : [];
                    const defs = this.getDefaultSequencePresets();
                    const toEntry = (s)=>{
                        const nm = String(s || '');
                        const nameMatch = nm.match(/\(([^)]+)\)\s*$/);
                        const name = nameMatch ? nameMatch[1] : 'Preset';
                        const text = nm.replace(/\s*\([^)]*\)\s*$/, '');
                        return { id: `DEF_${name.toLowerCase().replace(/[^a-z0-9]+/g,'-')}_${text.toLowerCase().replace(/[^a-z0-9]+/g,'-').slice(0,20)}`, name, text, edo: this.currentTuning || 24, fx: null, _isDefault: true };
                    };
                    const defaults = defs.map(toEntry);
                    const norm = (s)=> String(s || '').trim().toLowerCase().replace(/\s+/g,' ');
                    const haveName = new Set(existing.map(p=> norm(p.name)));
                    const haveText = new Set(existing.map(p=> norm(p.text)));
                    const merged = existing.slice();
                    for (const d of defaults){
                        const nameKey = norm(d.name);
                        const textKey = norm(d.text);
                        if (!haveName.has(nameKey) && !haveText.has(textKey)){
                            merged.push({ id: d.id, name: d.name, text: d.text, edo: d.edo, fx: d.fx || null });
                            haveName.add(nameKey); haveText.add(textKey);
                        }
                    }
                    // Persist back so future loads don't lose merged defaults
                    try { localStorage.setItem(keyNew, JSON.stringify(merged.slice(0, 200))); } catch(_) {}
                    return merged;
                } catch(_) {
                    return listObj;
                }
            }
            saveSequencePreset(preset) {
                const key = 'omni_seq_presets_v4';
                const list = this.getSequencePresets();
        const item = typeof preset === 'string' ? { text: preset.replace(/\s*\([^)]*\)\s*$/, ''), name: 'Saved', edo: this.currentTuning || 24 } : preset;
                if (!item || !item.text) return;
                const id = `S${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
        const entry = { 
            id, 
            name: item.name || 'Saved', 
            text: item.text, 
            edo: Math.max(5, Math.min(53, parseInt(item.edo||this.currentTuning||24))), 
            fx: item.fx || null,
            // Prefer explicit sequenceOrder; accept chordNames for backward compatibility
            sequenceOrder: (item.sequenceOrder && Array.isArray(item.sequenceOrder) && item.sequenceOrder.length)
                ? item.sequenceOrder
                : (Array.isArray(item.chordNames) && item.chordNames.length ? item.chordNames : null)
        };
                list.unshift(entry);
                try { localStorage.setItem(key, JSON.stringify(list.slice(0,100))); } catch(_) {}
            }
            populateSeqPresetDropdown(selectEl, list) {
                if (!selectEl) return;
                selectEl.innerHTML = '';
                // Default chooser option
                const def = document.createElement('option');
                def.value = '';
                def.textContent = 'Choose Preset';
                def.selected = true;
                def.disabled = false; // allow re-selecting empty to clear
                selectEl.appendChild(def);
                // Add presets with label = preset name
                list.forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p.id;
                    opt.textContent = (p.name || 'Preset').slice(0,80);
                    selectEl.appendChild(opt);
                });
            }
            getDefaultSequencePresets() {
                // A compact but comprehensive starter set
                return [
                    'C A^m E^m Ddim7 A^m Ebm  Bbm B^ E^m Abm6 Ebm Fsus4 F (Sunshine)',
                    'A^m D G^m E Am E G#vm D#v Fm C#vm Evm Bv (Headcase)',
                    'Iâ€“viâ€“IVâ€“V (50s progression)',
                    'IVâ€“Vâ€“Iâ€“vi (Doo-wop variant)',
                    'Iâ€“Vâ€“viâ€“IV (Pop progression)',
                    'Iâ€“IVâ€“â™­VIIâ€“IV (Mixolydian rock riff)',

                    'iiâ€“Vâ€“I (251 cadence)',
                    'iiâ€“â™­II7â€“I (Tritone substitution cadence)',
                    'iiâ€“â™­III+â€“I (Augmented dominant substitute)',

                    'ivâ€“IIIâ€“â™­IIâ€“I (Andalusian cadence)',
                    'iiâ€“â™­VII7â€“I (Backdoor progression)',

                    'Iâ€“viiÃ¸â€“III7â€“viâ€“II7â€“vâ€“I7â€“IV7â€“ivâ€“â™­VII7â€“iiiâ€“VI7â€“â™­iiiâ€“â™­VI7â€“iiâ€“V7â€“Iâ€“VI7â€“iiâ€“V (Bird changes)',

                    'Iâ€“Vâ€“â™­VIIâ€“IV (Chromatic 5â€“6 sequence)',
                    'viâ€“iiâ€“Vâ€“I (Circle progression)',

                    'Iâ€“Vâ€“â™­VIâ€“Vâ€“IIIâ€“Vâ€“I (Coltrane changes)',
                    'Bmaj7 D7 Gmaj7 Bb7 Ebmaj7 Am7 D7 Gmaj7 Bb7 Ebmaj7 F#7 Bmaj7 Fm7 Bb7 Ebmaj7 Am7 D7 Gmaj7 C#m7 F#7 Bmaj7 Fm7 Bb7 Ebmaj7 C#m7 F#7 (Giant Steps)',

                    'Iâ€“Vâ€“IVâ€“IVâ€“Iâ€“Vâ€“Iâ€“V (Eight-bar blues)',
                    'iâ€“Vâ€“iâ€“â™­VIIâ€“â™­IIIâ€“â™­VIIâ€“iâ€“Vâ€“iâ€“Vâ€“iâ€“â™­VIIâ€“â™­IIIâ€“â™­VIIâ€“iâ€“Vâ€“i (Folia)',
                    'V7â€“III7 (Irregular resolution)',
                    'Iâ€“IVâ€“iiâ€“V (Montgomeryâ€“Ward bridge)',
                    'Iâ€“Vâ€“viâ€“iiiâ€“IVâ€“Iâ€“IVâ€“V (Pachelbelâ€™s Canon)',
                    'iâ€“VIIâ€“iâ€“Vâ€“IIIâ€“VIIâ€“iâ€“Vâ€“i (Passamezzo antico)',
                    'Iâ€“IVâ€“Iâ€“Vâ€“Iâ€“IVâ€“Iâ€“Vâ€“I (Passamezzo moderno)',
                    'III7â€“VI7â€“II7â€“V7 (Ragtime progression)',
                    'Iâ€“ivâ€“iiâ€“V | Iâ€“I7â€“ivâ€“Iâ€“Vâ€“I | III7â€“VI7â€“II7â€“V7 (Rhythm changes)',

                    'Iâ€“IVâ€“Iâ€“Vâ€“IVâ€“Iâ€“V (Twelve-bar blues)',
                    'Iâ€“viâ€“iiâ€“V (Iâ€“viâ€“iiâ€“V progression)',
                    'â™­VIIâ€“V7â€“I (â™­VII cadence)',
                    'Vâ€“IVâ€“I (Vâ€“IVâ€“I turnaround)',
                    'Iâ€“â™­VIIâ€“â™­VIâ€“â™­VII (Aeolian rock cadence)',
                    'IVâ–³7â€“V7â€“iii7â€“vi (IVâ€“Vâ€“iiiâ€“vi progression)',
                    'â™­VIâ€“â™­VIIâ€“I (Modal cadence)'
                ];
            }

            // Convert Roman numeral sequence to concrete chord names in current key
            convertRomanNumeralSequenceToChords(text) {
                const edo = this.currentTuning || 12;
                const keyStep = this.currentRoot || 0; // tonic
                const tokens = [];
                const lines = String(text).split(/\r?\n/);
                const pushLine = (s)=>{
                    // Turn any SectionLabel: into a separator. We accept letters/numbers/_ before colon
                    const normalized = s.replace(/(^|\s)[^\s|:]+\s*:\s*/g, ' | ');
                    // Preserve '|' as its own token; split other separators
                    const withPipes = normalized.replace(/\|/g, ' | ');
                    const parts = withPipes.split(/[\s]+|[â€“â€”-]/g).map(x=>x.trim()).filter(Boolean);
                    for (const p of parts) tokens.push(p);
                };
                lines.forEach(pushLine);
                const mapped = tokens.map(tok=> this.mapRomanTokenToChord(tok, keyStep, edo)).filter(t=>t!=null);
                return mapped.join(' ');
            }

            // Convert any Roman numerals inline while preserving other chord tokens and '|' separators
            convertRomanNumeralsInline(text){
                if (!text) return '';
                const edo = this.currentTuning || 12;
                const keyStep = this.currentRoot || 0;
                const outLines = [];
                const lines = String(text).split(/\r?\n/);
                for (const rawLine of lines){
                    // Normalize section headers to pipes and keep them as standalone tokens
                    let s = String(rawLine || '').replace(/(^|\s)[^\s|:]+\s*:\s*/g, ' | ');
                    s = s.replace(/\|/g, ' | ');
                    const parts = s.split(/[\s]+|[â€“â€”-]/g).map(x=>x.trim()).filter(Boolean);
                    const mapped = parts.map(p=>{
                        const m = this.mapRomanTokenToChord(p, keyStep, edo);
                        return m != null ? m : p;
                    });
                    outLines.push(mapped.join(' '));
                }
                return outLines.join('\n');
            }

            // Map one roman token (like bVII, ii, Vmaj7, iii7, bVI#11) to a chord name in current key
            mapRomanTokenToChord(tok, keyStep, edo) {
                // Normalize unicode flats/sharps
                if (tok === '|') return '|';
                let t = String(tok).replace(/â™­/g,'b').replace(/â™¯/g,'#');
                // Extract accidental prefix for degree (b/# before the roman)
                const accMatch = t.match(/^(b+|#+)?/);
                const acc = (accMatch && accMatch[0]) || '';
                let rest = t.slice(acc.length);
                // Choose the longest matching roman token first to avoid splitting 'iv' into 'i'+'v'
                const romans = ['vii','vi','iv','iii','ii','v','i','VII','VI','IV','III','II','V','I'];
                let roman = null;
                for (const cand of romans) {
                    if (rest.startsWith(cand)) { roman = cand; break; }
                }
                if (!roman) return null;
                let tail = rest.slice(roman.length).trim();
                const isMinor = roman === roman.toLowerCase();
                // Map roman to diatonic degree in 12-TET steps (Ionian)
                const romanSteps = { i:0, ii:2, iii:4, iv:5, v:7, vi:9, vii:11 };
                const baseSemi = romanSteps[roman.toLowerCase()];
                if (baseSemi == null) return null;
                let semi = baseSemi;
                // Apply accidentals to degree
                for (const ch of acc) semi += (ch === 'b' ? -1 : 1);
                // Wrap
                semi = ((semi % 12) + 12) % 12;
                // Convert to EDO step offset from tonic for HEAD roman (relative to some reference key)
                const headDegreeStep = Math.round((semi * edo) / 12);
                let referenceKeyStep = keyStep; // may be replaced by target of "/"

                // Secondary functions e.g., V/ii, viiÂ°7/V, iiÃ¸7/V
                // If tail contains "/<roman>" (optionally accidental), compute target key first
                let preSlash = tail; let postTail = '';
                let slashMatch = tail.match(/^(.*?)(?:\/(b+|#+)?(i{1,3}|iv|v|vi{0,3}|I{1,3}|IV|V|VI{0,3})([\^v]*))?(.*)$/);
                if (slashMatch) {
                    preSlash = (slashMatch[1] || '').trim();
                    const targetAcc = slashMatch[2] || '';
                    const targetRoman = slashMatch[3] || '';
                    const targetMicro = slashMatch[4] || '';
                    postTail = (slashMatch[5] || '').trim();
                    if (targetRoman) {
                        let targetSemi = romanSteps[targetRoman.toLowerCase()];
                        if (targetSemi != null) {
                            // apply accidentals to target degree
                            for (const ch of targetAcc) targetSemi += (ch === 'b' ? -1 : 1);
                            targetSemi = ((targetSemi % 12) + 12) % 12;
                            const targetDegreeStep = Math.round((targetSemi * edo) / 12);
                            let targetRoot = ((keyStep + targetDegreeStep) % edo + edo) % edo;
                            // optional micro on target
                            if (targetMicro) {
                                const ups2 = (targetMicro.match(/\^/g) || []).length;
                                const downs2 = (targetMicro.match(/v/g) || []).length;
                                targetRoot = (((targetRoot + ups2 - downs2) % edo) + edo) % edo;
                            }
                            referenceKeyStep = targetRoot; // Now interpret head roman relative to target key
                        }
                    }
                    // Keep the rest of the tail (quality/extensions) around the slash parts
                    tail = (preSlash + ' ' + (postTail || '')).trim();
                }

                // Now compute chord root relative to the chosen referenceKeyStep
                let rootStep = ((referenceKeyStep + headDegreeStep) % edo + edo) % edo;
                // Optional micro-step marks right after the numeral: e.g., ii^7, bVIIvv
                const microMatch = tail.match(/^([\^v]+)/);
                if (microMatch) {
                    const ups = (microMatch[1].match(/\^/g) || []).length;
                    const downs = (microMatch[1].match(/v/g) || []).length;
                    rootStep = (((rootStep + ups - downs) % edo) + edo) % edo;
                    tail = tail.slice(microMatch[1].length).trim();
                }
                // Preserve ^/v micro-steps in 24-EDO by using getRootNameForStep instead of getMicrotonalNoteName (which emits â†‘/â†“)
                const rootName = this.getRootNameForStep(rootStep, edo);
                // Determine basic quality from case unless tail already encodes explicit quality (maj/M/m/Â°/Ã¸/+/sus)
                let canonicalTail = tail.replace(/â–³/g,'maj');
                const hasExplicitQuality = /^(?:maj|M|m|Â°|Ã¸|\+|sus)/.test(canonicalTail);
                const quality = hasExplicitQuality ? '' : (isMinor ? 'm' : '');
                // Special-case: user expectation that 'VII7' denotes fully diminished seventh
                if (!isMinor && roman.toUpperCase() === 'VII' && /(?:^|\b)7(?![0-9])/.test(canonicalTail)) {
                    canonicalTail = canonicalTail.replace(/(?:^|\b)7(?![0-9])/, 'Â°7');
                }
                const chord = `${rootName}${quality}${canonicalTail}`.trim();
                return this.normalizeChordToken(chord) || chord;
            }

            copyParsedChordsToClipboard() {
                const list = (this._lastParsedChordsList || []).join(', ');
                if (!navigator.clipboard) {
                    // Fallback
                    const ta = document.createElement('textarea');
                    ta.value = list; document.body.appendChild(ta); ta.select();
                    try { document.execCommand('copy'); } catch {}
                    ta.remove();
                    return;
                }
                navigator.clipboard.writeText(list).catch(()=>{});
            }

            // Create chord columns from a list of normalized chord strings, then lock each to its own root
            autoCreateColumnsFromText(chordList) {
                // Replace the current grid with this sequence
                this.chordExtensions = [];
                // Reset visibility and any prior locks so board truly clears
                this.hiddenColumns = [];
                this.lockedChords = new Map();
                this.pianoLockedChords = new Map();
                const beforeLen = 0;
                const created = [];
                const curEDO = this.currentTuning || 24;
                
                // Track repeat groups for visual representation
                let repeatGroupCount = 1;
                let insideBracket = false;
                
                // Buffer curly drum-map tokens encountered after a chord block (e.g., {1x3}{2})
                let drumMapBuffer = [];
                
                // Check if sequence already has loop markers
                let hasStartMarker = false;
                let hasEndMarker = false;
                for (let i = 0; i < chordList.length; i++) {
                    const item = chordList[i];
                    if (item === '__BRACKET_START__' || (typeof item === 'string' && item.trim() === '[')) {
                        hasStartMarker = true;
                    }
                    if (item === '__BRACKET_END__' || (typeof item === 'string' && item.trim().match(/^\](?:x\d+)?$/))) {
                        hasEndMarker = true;
                    }
                }
                
                // Auto-add loop markers if missing and sequence has content
                const hasActualChords = chordList.some(item => 
                    typeof item === 'string' && 
                    !item.startsWith('__') && 
                    !item.match(/^[\[\]x\d\s]*$/) &&
                    item.trim() !== ''
                );
                
                if (hasActualChords && !hasStartMarker) {
                    // Add opening bracket
                    this.chordExtensions.push({
                        name: '[',
                        isCustom: true,
                        isRepeatMarker: true,
                        nestLevel: 0,
                        id: 'auto_bracket_start_' + Date.now(),
                        position: this.chordExtensions.length
                    });
                    console.log('ðŸŽµ Auto-added opening loop marker');
                }

                for (let i = 0; i < chordList.length; i++) {
                    const chordStr = chordList[i];

                    // New: duration multiplier token emitted by parser after a chord.
                    // Example: [ 'C', '__LENBARS_2__', 'F', 'G' ] => C.len16 = 32.
                    if (typeof chordStr === 'string' && /^__LENBARS_(\d+)__$/.test(chordStr)) {
                        const m = chordStr.match(/^__LENBARS_(\d+)__$/);
                        const bars = Math.max(1, parseInt(m[1], 10) || 1);
                        const len16 = Math.max(1, Math.min(1024, (bars * 16) | 0));
                        const last = created.length ? created[created.length - 1] : null;
                        if (last && last.chord) {
                            try { last.chord.len16 = len16; } catch(_){ }
                            try {
                                const pos = last.position;
                                if (Number.isFinite(pos) && this.chordExtensions && this.chordExtensions[pos]) {
                                    this.chordExtensions[pos].len16 = len16;
                                }
                            } catch(_){ }
                            try {
                                if (this._isSequencing && this._arpTransport) this._arpTransport._seqRebuildRequested = true;
                            } catch(_){ }
                        }
                        continue;
                    }
                    
                    if (chordStr === '__SECTION__') {
                        const sep = {
                            name: '|',
                            isCustom: true,
                            isSeparator: true,
                            id: 'sep_' + (this.chordExtensions.length),
                            position: this.chordExtensions.length
                        };
                        this.chordExtensions.push(sep);
                        continue;
                    }
                    
                    if (chordStr === '__BRACKET_START__') {
                        insideBracket = true;
                        continue;
                    }
                    
                    if (chordStr === '__BRACKET_END__') {
                        insideBracket = false;
                        continue;
                    }
                    
                    // Handle colored repeat markers with nest levels
                    if (chordStr.match(/^__REPEAT_L\d+_\d+__$/)) {
                        const match = chordStr.match(/^__REPEAT_L(\d+)_(\d+)__$/);
                        const nestLevel = parseInt(match[1]);
                        const count = parseInt(match[2]);
                        
                        // Color scheme for nesting levels
                        const colors = [
                            { bg: 'linear-gradient(135deg, rgba(76,175,80,0.3) 0%, rgba(139,195,74,0.4) 100%)', border: 'rgba(76,175,80,0.8)', color: '#4CAF50' }, // Green (level 0)
                            { bg: 'linear-gradient(135deg, rgba(33,150,243,0.3) 0%, rgba(100,181,246,0.4) 100%)', border: 'rgba(33,150,243,0.8)', color: '#2196F3' }, // Blue (level 1)  
                            { bg: 'linear-gradient(135deg, rgba(244,67,54,0.3) 0%, rgba(239,154,154,0.4) 100%)', border: 'rgba(244,67,54,0.8)', color: '#F44336' }, // Red (level 2)
                            { bg: 'linear-gradient(135deg, rgba(156,39,176,0.3) 0%, rgba(186,104,200,0.4) 100%)', border: 'rgba(156,39,176,0.8)', color: '#9C27B0' }, // Purple (level 3)
                            { bg: 'linear-gradient(135deg, rgba(255,152,0,0.3) 0%, rgba(255,183,77,0.4) 100%)', border: 'rgba(255,152,0,0.8)', color: '#FF9800' } // Orange (level 4+)
                        ];
                        
                        const colorIndex = Math.min(nestLevel, colors.length - 1);
                        const colorTheme = colors[colorIndex];
                        
                        const repeatMarker = {
                            name: `x${count}`,
                            isCustom: true,
                            isRepeatMarker: true,
                            nestLevel: nestLevel,
                            id: 'repeat_L' + nestLevel + '_' + repeatGroupCount++,
                            position: this.chordExtensions.length,
                            colorTheme: colorTheme
                        };
                        this.chordExtensions.push(repeatMarker);
                        continue;
                    }
                    
                    // Handle colored bracket start markers
                    if (chordStr.match(/^__BRACKET_START_L\d+__$/)) {
                        const match = chordStr.match(/^__BRACKET_START_L(\d+)__$/);
                        const nestLevel = parseInt(match[1]);
                        
                        const colors = [
                            { bg: 'linear-gradient(135deg, rgba(76,175,80,0.2) 0%, rgba(139,195,74,0.3) 100%)', border: 'rgba(76,175,80,0.6)', color: '#4CAF50' },
                            { bg: 'linear-gradient(135deg, rgba(33,150,243,0.2) 0%, rgba(100,181,246,0.3) 100%)', border: 'rgba(33,150,243,0.6)', color: '#2196F3' },
                            { bg: 'linear-gradient(135deg, rgba(244,67,54,0.2) 0%, rgba(239,154,154,0.3) 100%)', border: 'rgba(244,67,54,0.6)', color: '#F44336' },
                            { bg: 'linear-gradient(135deg, rgba(156,39,176,0.2) 0%, rgba(186,104,200,0.3) 100%)', border: 'rgba(156,39,176,0.6)', color: '#9C27B0' },
                            { bg: 'linear-gradient(135deg, rgba(255,152,0,0.2) 0%, rgba(255,183,77,0.3) 100%)', border: 'rgba(255,152,0,0.6)', color: '#FF9800' }
                        ];
                        
                        const colorIndex = Math.min(nestLevel, colors.length - 1);
                        const colorTheme = colors[colorIndex];
                        
                        const leftBracket = {
                            name: '[',
                            isCustom: true,
                            isRepeatMarker: true,
                            nestLevel: nestLevel,
                            id: 'bracket_start_L' + nestLevel + '_' + repeatGroupCount++,
                            position: this.chordExtensions.length,
                            colorTheme: colorTheme
                        };
                        this.chordExtensions.push(leftBracket);
                        continue;
                    }
                    
                    // Handle colored bracket end markers
                    if (chordStr.match(/^__BRACKET_END_L\d+__$/)) {
                        const match = chordStr.match(/^__BRACKET_END_L(\d+)__$/);
                        const nestLevel = parseInt(match[1]);
                        
                        const colors = [
                            { bg: 'linear-gradient(135deg, rgba(76,175,80,0.2) 0%, rgba(139,195,74,0.3) 100%)', border: 'rgba(76,175,80,0.6)', color: '#4CAF50' },
                            { bg: 'linear-gradient(135deg, rgba(33,150,243,0.2) 0%, rgba(100,181,246,0.3) 100%)', border: 'rgba(33,150,243,0.6)', color: '#2196F3' },
                            { bg: 'linear-gradient(135deg, rgba(244,67,54,0.2) 0%, rgba(239,154,154,0.3) 100%)', border: 'rgba(244,67,54,0.6)', color: '#F44336' },
                            { bg: 'linear-gradient(135deg, rgba(156,39,176,0.2) 0%, rgba(186,104,200,0.3) 100%)', border: 'rgba(156,39,176,0.6)', color: '#9C27B0' },
                            { bg: 'linear-gradient(135deg, rgba(255,152,0,0.2) 0%, rgba(255,183,77,0.3) 100%)', border: 'rgba(255,152,0,0.6)', color: '#FF9800' }
                        ];
                        
                        const colorIndex = Math.min(nestLevel, colors.length - 1);
                        const colorTheme = colors[colorIndex];
                        
                        const rightBracket = {
                            name: ']',
                            isCustom: true,
                            isRepeatMarker: true,
                            nestLevel: nestLevel,
                            id: 'bracket_end_L' + nestLevel + '_' + repeatGroupCount++,
                            position: this.chordExtensions.length,
                            colorTheme: colorTheme
                        };
                        this.chordExtensions.push(rightBracket);
                        continue;
                    }
                    
                    // Handle combined bracket end + repeat markers
                    if (chordStr.match(/^__BRACKET_END_REPEAT_L\d+_\d+__$/)) {
                        const match = chordStr.match(/^__BRACKET_END_REPEAT_L(\d+)_(\d+)__$/);
                        const nestLevel = parseInt(match[1]);
                        const repeatCount = parseInt(match[2]);
                        
                        const colors = [
                            { bg: 'linear-gradient(135deg, rgba(76,175,80,0.2) 0%, rgba(139,195,74,0.3) 100%)', border: 'rgba(76,175,80,0.6)', color: '#4CAF50' },
                            { bg: 'linear-gradient(135deg, rgba(33,150,243,0.2) 0%, rgba(100,181,246,0.3) 100%)', border: 'rgba(33,150,243,0.6)', color: '#2196F3' },
                            { bg: 'linear-gradient(135deg, rgba(244,67,54,0.2) 0%, rgba(239,154,154,0.3) 100%)', border: 'rgba(244,67,54,0.6)', color: '#F44336' },
                            { bg: 'linear-gradient(135deg, rgba(156,39,176,0.2) 0%, rgba(186,104,200,0.3) 100%)', border: 'rgba(156,39,176,0.6)', color: '#9C27B0' },
                            { bg: 'linear-gradient(135deg, rgba(255,152,0,0.2) 0%, rgba(255,183,77,0.3) 100%)', border: 'rgba(255,152,0,0.6)', color: '#FF9800' }
                        ];
                        
                        const colorIndex = Math.min(nestLevel, colors.length - 1);
                        const colorTheme = colors[colorIndex];
                        
                        const combinedBracketRepeat = {
                            name: `]x${repeatCount}`,
                            isCustom: true,
                            isRepeatMarker: true,
                            nestLevel: nestLevel,
                            repeatCount: repeatCount,
                            id: 'bracket_end_repeat_L' + nestLevel + '_' + repeatGroupCount++,
                            position: this.chordExtensions.length,
                            colorTheme: colorTheme
                        };
                        this.chordExtensions.push(combinedBracketRepeat);
                        continue;
                    }
                    
                    // Handle colored repeat markers  
                    if (chordStr.match(/^__REPEAT_L\d+_\d+__$/)) {
                        const match = chordStr.match(/^__REPEAT_L(\d+)_(\d+)__$/);
                        const nestLevel = parseInt(match[1]);
                        const repeatCount = parseInt(match[2]);
                        
                        const colors = [
                            { bg: 'linear-gradient(135deg, rgba(76,175,80,0.2) 0%, rgba(139,195,74,0.3) 100%)', border: 'rgba(76,175,80,0.6)', color: '#4CAF50' },
                            { bg: 'linear-gradient(135deg, rgba(33,150,243,0.2) 0%, rgba(100,181,246,0.3) 100%)', border: 'rgba(33,150,243,0.6)', color: '#2196F3' },
                            { bg: 'linear-gradient(135deg, rgba(244,67,54,0.2) 0%, rgba(239,154,154,0.3) 100%)', border: 'rgba(244,67,54,0.6)', color: '#F44336' },
                            { bg: 'linear-gradient(135deg, rgba(156,39,176,0.2) 0%, rgba(186,104,200,0.3) 100%)', border: 'rgba(156,39,176,0.6)', color: '#9C27B0' },
                            { bg: 'linear-gradient(135deg, rgba(255,152,0,0.2) 0%, rgba(255,183,77,0.3) 100%)', border: 'rgba(255,152,0,0.6)', color: '#FF9800' }
                        ];
                        
                        const colorIndex = Math.min(nestLevel, colors.length - 1);
                        const colorTheme = colors[colorIndex];
                        
                        const coloredRepeat = {
                            name: `x${repeatCount}`,
                            isCustom: true,
                            isRepeatMarker: true,
                            nestLevel: nestLevel,
                            repeatCount: repeatCount,
                            id: 'repeat_L' + nestLevel + '_' + repeatGroupCount++,
                            position: this.chordExtensions.length,
                            colorTheme: colorTheme
                        };
                        this.chordExtensions.push(coloredRepeat);
                        continue;
                    }
                    
                    // Legacy repeat markers (keep for backward compatibility)
                    if (chordStr.startsWith('__REPEAT_')) {
                        const count = parseInt(chordStr.replace('__REPEAT_', '').replace('__', ''), 10);
                        const repeatMarker = {
                            name: `x${count}`,
                            isCustom: true,
                            isRepeatMarker: true,
                            id: 'repeat_' + repeatGroupCount++,
                            position: this.chordExtensions.length
                        };
                        this.chordExtensions.push(repeatMarker);
                        continue;
                    }
                    
                    if (chordStr === '__LEFT_BRACKET__') {
                        const leftBracket = {
                            name: '[',
                            isCustom: true,
                            isRepeatMarker: true,
                            id: 'left_bracket_' + repeatGroupCount++,
                            position: this.chordExtensions.length
                        };
                        this.chordExtensions.push(leftBracket);
                        continue;
                    }
                    
                    if (chordStr === '__RIGHT_BRACKET__') {
                        const rightBracket = {
                            name: ']',
                            isCustom: true,
                            isRepeatMarker: true,
                            id: 'right_bracket_' + repeatGroupCount++,
                            position: this.chordExtensions.length
                        };
                        this.chordExtensions.push(rightBracket);
                        continue;
                    }
                    
                    // Curly drum map token(s): accumulate, then apply to the most recent bars once the run ends
                    if (/^__DRMAP_(.+)__$/.test(chordStr)) {
                        const arr = chordStr.replace(/^__DRMAP_/, '').replace(/__$/, '').split('_').map(s=> parseInt(s,10)).filter(Number.isFinite);
                        if (arr.length) drumMapBuffer.push(...arr);
                        // If next token is also a DRMAP, keep buffering; otherwise apply now
                        const nextTok = chordList[i+1];
                        const nextIsMap = typeof nextTok === 'string' && /^__DRMAP_(.+)__$/.test(nextTok);
                        if (!nextIsMap && drumMapBuffer.length) {
                            const N = drumMapBuffer.length;
                            const slice = created.slice(-N);
                            // Apply in order: earliest of slice gets first pattern
                            for (let k = 0; k < slice.length; k++) {
                                const addedRef = slice[k];
                                const pat = drumMapBuffer[k];
                                if (addedRef && Number.isFinite(pat)) {
                                    try {
                                        const pos = addedRef.position;
                                        const model = this.chordExtensions[pos];
                                        if (model) model._drumPatternForBar = pat;
                                    } catch(_) {}
                                }
                            }
                            drumMapBuffer = [];
                        }
                        // Do not create a column for curly tokens
                        continue;
                    }

                    // Regular chord - add it normally
                    const added = this.addChordFromName(chordStr);
                    if (added) created.push(added);

                    // No-op: drum mapping is applied in-place when curly tokens are fully buffered
                }
                
                // Auto-add closing loop marker if we added an opening one
                if (hasActualChords && !hasStartMarker && !hasEndMarker) {
                    // Add closing bracket with repeat
                    this.chordExtensions.push({
                        name: ']',
                        isCustom: true,
                        isRepeatMarker: true,
                        nestLevel: 0,
                        id: 'auto_bracket_end_' + Date.now(),
                        position: this.chordExtensions.length,
                        repeatCount: 0 // Infinite loop
                    });
                    console.log('ðŸŽµ Auto-added closing loop marker');
                }
                
                // Render new chords
                this.normalizeChordPositions();
                if (typeof this.generateExactChordColumns === 'function') {
                    this.generateExactChordColumns();
                } else if (typeof this.generateExtensionColumns === 'function') {
                    this.generateExtensionColumns();
                }

                // Do NOT auto-lock new chords; keep everything editable and transposable per request
                const stepCents = Array.from({length: this.currentTuning}, (_,i)=> this.getCentValue(i, this.currentTuning));
                const container = document.getElementById('extensionColumns');
                const priorRoot = this.currentRoot;
                for (const data of created) {
                    const { chord, position, rootSemitone, rootStep } = data;
                    if (rootSemitone == null && rootStep == null) continue;
                    // Safety: if this chord's intervals look like raw 12-EDO values in a non-12 system, remap them now
                    try {
                        const model = chord;
                        if (model && model.isCustom && Array.isArray(model.intervals) && curEDO !== 12) {
                            const looks12 = model.intervals.some(iv => iv > 0 && iv <= 11);
                            const looks24 = model.intervals.some(iv => iv >= 12);
                            if (looks12 && !looks24) {
                                const remapped = model.intervals.map(semi => Math.round((semi * curEDO) / 12));
                                model.intervals = Array.from(new Set(remapped)).sort((a,b)=>a-b);
                                model.lastTuning = curEDO;
                                console.warn('[FIXUP] Remapped probable 12-EDO intervals to', curEDO, 'EDO for chord', model.name, 'â†’', model.intervals);
                            }
                        }
                    } catch {}
                    const lockedRoot = (rootStep != null) ? rootStep : this.findNearestStepForSemitone(rootSemitone, stepCents);
                    const column = container.querySelector(`.extension-column[data-original-position="${position}"]`);
                    if (!column) continue;
                    try {
                        // Temporarily switch root for this chord
                        const prevRoot = this.currentRoot;
                        this.currentRoot = lockedRoot;
                        // If this bar has a mapped drum pattern, annotate it for runtime use and tooltip
                        try {
                            const model = this.chordExtensions[position];
                            const mapped = model && model._drumPatternForBar;
                            if (Number.isFinite(mapped)) {
                                column.dataset.drumPattern = String(mapped);
                                column.title = (column.title ? column.title + ' | ' : '') + `Drums: Pattern ${mapped}`;
                            }
                        } catch(_) {}
                        // Recompute this column's string frequencies at this root using interval tags (robust against stale edoStep)
                        const strings = column.querySelectorAll('.string');
                        strings.forEach(string => {
                            const octave = parseInt(string.dataset.octave);
                            const interval = parseInt(string.dataset.interval);
                            if (isNaN(octave) || isNaN(interval)) return;
                            const tuningSize = this.currentTuning;
                            // Absolute step in current tuning = lockedRoot + interval (intervals are EDO steps for custom chords)
                            const absStep = ((lockedRoot + interval) % tuningSize + tuningSize) % tuningSize;
                            const frequency = this.getFrequency(absStep, octave, tuningSize);
                            string.dataset.frequency = frequency;
                            // Also refresh relative step to be consistent with lockedRoot
                            const relStep = ((absStep - lockedRoot) % tuningSize + tuningSize) % tuningSize;
                            string.dataset.edoStep = String(relStep);
                            // Update tooltip/name and vibration period
                            const noteName = this.getNoteNames()[absStep] || this.getIntervalNoteName(interval);
                            string.title = `${noteName} (step ${absStep}, ${frequency.toFixed(1)}Hz)`;
                            const core = string.querySelector('.string-core');
                            if (core) {
                                const period = this.computeVibrationPeriod(frequency, absStep);
                                core.style.setProperty('--vib-period', period + 'ms');
                            }
                        });
                        // Restore global root for subsequent chords
                        this.currentRoot = prevRoot;
                    } catch (_) {}
                }
                this.currentRoot = priorRoot;
                
                // Make any new bracket markers draggable
                setTimeout(() => {
                    const newMarkers = document.querySelectorAll('.repeat-marker-column:not([data-draggable-wired])');
                    newMarkers.forEach(marker => {
                        if (typeof window.makeBracketDraggable === 'function') {
                            window.makeBracketDraggable(marker);
                            marker.dataset.draggableWired = 'true';
                        }
                    });
                    
                    // Initialize chord column drop zones for new sequences
                    if (typeof window.makeChordColumnsDroppable === 'function') {
                        window.makeChordColumnsDroppable();
                    }
                    
                    // Ensure all chords remain visible
                    if (typeof ensureChordVisibility === 'function') {
                        setTimeout(ensureChordVisibility, 50);
                    }
                }, 100);
            }

            // Map chord name to a chordExtensions entry with computed intervals. Returns {chord, position, rootSemitone, rootStep}
            addChordFromName(chordName) {
                // Safety check: don't process repeat markers as chords
                if (!chordName || typeof chordName !== 'string') return null;
                if (/^[xX]\d+$/.test(chordName.trim())) {
                    console.log('ðŸŽµ Skipping repeat marker in addChordFromName:', chordName);
                    return null;
                }
                
                const norm = this.normalizeChordToken(chordName);
                if (!norm) return null;
                const normAscii = this._normalizeChordSymbolsForParse(norm);
                const rootMatch = normAscii.match(/^([A-G])([#bâ™­â™¯ð„²ð„³d]?)([\^v]*)/);
                let rootAcc = rootMatch ? (rootMatch[2] || '') : '';
                let rootMicro = rootMatch ? (rootMatch[3] || '') : '';
                // Treat half-flat (d/ð„³) as a micro down-step rather than a full flat
                if (rootAcc === 'd' || rootAcc === 'ð„³') {
                    rootAcc = '';
                    rootMicro = 'v' + rootMicro;
                }
                // Treat quarter-sharp (ð„²) as micro up-step
                if (rootAcc === 'ð„²') {
                    rootAcc = '';
                    rootMicro = '^' + rootMicro;
                }
                const rootSemitone = rootMatch ? this.rootToSemitone(rootMatch[1], rootAcc || '') : null;
                // Compute root step in current EDO including micro marks (^ up, v down). Multiple marks accumulate.
                let rootStep = null;
                if (rootSemitone != null) {
                    const baseStep = Math.round((rootSemitone * this.currentTuning) / 12);
                    const microMarks = rootMicro || '';
                    const ups = (microMarks.match(/\^/g) || []).length;
                    const downs = (microMarks.match(/v/g) || []).length;
                    rootStep = ((baseStep + ups - downs) % this.currentTuning + this.currentTuning) % this.currentTuning;
                    // Only enforce 12-TET semitone back-mapping if there are NO micro marks
                    const hasMicro = (ups + downs) !== 0;
                    if (!hasMicro) {
                        try {
                            const semiBack = Math.round((rootStep * 12) / this.currentTuning) % 12;
                            if (semiBack !== ((rootSemitone % 12)+12)%12) {
                                console.warn('[ADD] Root mismatch, adjusting step. norm=', norm, 'rootSemi=', rootSemitone, 'computedStep=', rootStep, 'semiBack=', semiBack, 'EDO=', this.currentTuning);
                                // Find nearest step for this semitone in current EDO
                                const stepCents = Array.from({length: this.currentTuning}, (_,i)=> this.getCentValue(i, this.currentTuning));
                                const centsTarget = (rootSemitone * 1200) / 12;
                                let best = 0, bestDist = Infinity;
                                stepCents.forEach((c, i)=>{ const d = Math.abs(c - centsTarget); if (d < bestDist) { bestDist = d; best = i; }});
                                rootStep = best;
                            }
                        } catch {}
                    }
                }
                const quality = normAscii.replace(/^([A-G][#bâ™­â™¯ð„²ð„³d]?[\^v]*)/, '');
                // Exclude slash bass from stacked-interval parsing; it will be added explicitly below
                const tailForIntervals = quality.replace(/\/[A-G](?:#|b)?/, '');
                let intervals = this.parseChordQualityToIntervals(tailForIntervals);
                try { console.log('[ADD] name=', norm, 'rootSemi=', rootSemitone, 'rootStep=', rootStep, 'intervals(steps)=', intervals, 'EDO=', this.currentTuning); } catch {}

                // Slash chord handling: if tail contains "/<bass>", add that bass pitch as an extra interval
                // Example: G/F -> add b7 (F relative to G)
                let preferredBassRel = null;
                const slash = quality.match(/\/([A-G](?:#|b)?)/);
                if (slash && rootSemitone != null) {
                    const bassLetter = slash[1][0];
                    const bassAcc = slash[1].length > 1 ? slash[1][1] : '';
                    const bassSemi = this.rootToSemitone(bassLetter, bassAcc);
                    // Interval difference bass relative to root in 12-TET (0..11)
                    const diffSemi = ((bassSemi - rootSemitone) % 12 + 12) % 12;
                    // Map to current EDO
                    const mapped = Math.round((diffSemi * this.currentTuning) / 12);
                    preferredBassRel = mapped;
                    if (!intervals.includes(mapped)) {
                        intervals = [...intervals, mapped].sort((a,b)=>a-b);
                    }
                }
                let preferredRootName = null;
                try {
                    const rootLabelMatch = normAscii.match(/^([A-G])([#bâ™­â™¯ð„²ð„³d]?)([\^v]*)/);
                    if (rootLabelMatch) {
                        preferredRootName = this._formatRootWithSymbols(rootLabelMatch[1], rootLabelMatch[2] || '', rootLabelMatch[3] || '');
                    }
                } catch(_){ }
                const preferredAccidental = this._getAccidentalPreference(preferredRootName);
                const newChord = {
                    name: norm,
                    intervals,
                    isCustom: true,
                    id: 'import_' + Date.now() + '_' + Math.floor(Math.random()*1e6),
                    createdAt: Date.now(),
                    position: this.chordExtensions.length,
                    // New timeline duration model (default 16 16ths)
                    len16: 16,
                    // Preserve the chord's original root step so we don't force a C root
                    originalRoot: (rootStep != null ? rootStep : this.currentRoot),
                    originalTuning: this.currentTuning,
                    originalGamelanMode: this.gamelanMode,
                    lastTuning: this.currentTuning,
                    headerColor: this.getIntervalColor(0)?.color || '#14b8a6',
                    localTranspose: 0,
                    preferredRootName: preferredRootName,
                    preferredAccidental: preferredAccidental,
                    preferredName: norm,
                    preferredBassRel: preferredBassRel,
                    // Set a fixed absolute root so keyboard edits use the correct base
                    fixedRootStepAbs: (rootStep != null ? rootStep : (this.currentRoot || 0)),
                    fixedRootTuning: this.currentTuning,
                    // Also capture a baseline of the original relative intervals for EDO remaps
                    originalIntervals: intervals.slice()
                };
                console.log('ðŸŽµ addChordFromName:', norm, '| rootStep =', rootStep, '| fixedRootStepAbs =', newChord.fixedRootStepAbs, '| intervals =', intervals);
                this.chordExtensions.push(newChord);

                // If we're currently sequencing (PLAY active), defer sequence/plan rebuild until the next cycle.
                try {
                    if (this._isSequencing && this._arpTransport) {
                        this._arpTransport._seqRebuildRequested = true;
                    }
                } catch(_) {}
                return { chord: newChord, position: newChord.position, rootSemitone, rootStep };
            }

            // Convert chord quality/extensions tail to interval steps in current EDO
            parseChordQualityToIntervals(tail) {
                // Defaults to major triad if unspecified
                const map = (semi)=> Math.round((semi * this.currentTuning) / 12);
                const add = (set, semi)=> set.add(map(semi));
                const set = new Set([0]);
                let third = 4; // major
                let fifth = 7;
                let hasThird = true;

                const t = (tail || '').trim();
                const has = (pat)=> new RegExp(pat).test(t);
                const hasJ = /J(?:2|3|4|5|6|7|9|11|13)/.test(t);
                const hasJ7 = /J7(?![0-9])/.test(t);

                // quality
                const isNeutralQuality = /^n(?![a-z])/i.test(t);
                const isMinorQuality = /^m(?!aj)/.test(t);
                if (isNeutralQuality) third = 3.5; // neutral third
                else if (isMinorQuality) third = 3; // 'm' but not 'maj'
                if (/^Â°/.test(t)) { third = 3; fifth = 6; }
                if (/^\+/.test(t)) { third = 4; fifth = 8; }
                if (/sus2/.test(t)) { hasThird = false; }
                if (/sus4/.test(t)) { hasThird = false; }

                // base triad
                if (hasThird) add(set, third);
                add(set, fifth);
                if (/sus2/.test(t)) add(set, 2);
                if (/sus4/.test(t)) add(set, 5);

                // seventh family
                const hasMaj7 = /maj7|Î”7|M7/.test(t);
                if (hasMaj7) add(set, 11);
                else if (/Ã¸7/.test(t)) { add(set, 10); add(set, 6); third = 3; }
                else if (/Â°7/.test(t) || /dim7|diminished\s*7(?:th)?|o7/.test(t)) { add(set, 9); third = 3; fifth = 6; }
                else if (/m7/.test(t)) { add(set, 10); third = 3; }
                else if (/7(?![0-9])/.test(t) && !hasJ7) { add(set, 10); }

                // 6th
                if (/(?:^|[^0-9])6(?![0-9])/.test(t)) add(set, 9);

                // Extensions with canonical stacking rules:
                // 9 implies 7; 11 implies 9+7; 13 implies 11+9+7.
                // Exception: m9 (minor ninth) skips the 7th unless explicitly present.
                // Plain '7' (dominant) only if not part of maj7/m7/Â°7/Ã¸7 tokens
                const hasAdd9    = /add9/.test(t);
                const hasAdd11   = /add11/.test(t);
                const hasAdd13   = /add13/.test(t);
                const hasJ9 = /J9(?![0-9])/.test(t);
                const hasJ11 = /J11(?![0-9])/.test(t);
                const hasJ13 = /J13(?![0-9])/.test(t);
                const hasPlain7  = /(?:^|[^0-9])7(?![0-9])/.test(t) && !/(?:maj7|M7|Î”7|m7|Â°7|Ã¸7)/.test(t) && !hasJ7;
                const hasSharp11 = /#11|â™¯11/.test(t);
                const hasSharp13 = /#13|â™¯13/.test(t);
                const isMaj9     = /maj9|M9|Î”9/.test(t);
                const isMinor9   = /^m9(?![0-9])/.test(t) || /\bm9(?![0-9])/.test(t);
                // Exclude 'add' forms with micro marks and bare micro-marked degrees from plain stacking detection
                const hasAdd9Micro  = /add[\^v]+9(?![0-9])/.test(t);
                const hasAdd11Micro = /add[\^v]+11(?![0-9])/.test(t);
                const hasAdd13Micro = /add[\^v]+13(?![0-9])/.test(t);
                const hasBareMicro9  = /(?:^|[^A-Za-z])[\^v]+9(?![0-9])/.test(t);
                const hasBareMicro11 = /(?:^|[^A-Za-z])[\^v]+11(?![0-9])/.test(t);
                const hasBareMicro13 = /(?:^|[^A-Za-z])[\^v]+13(?![0-9])/.test(t);
                const has9       = /(?:^|[^0-9])9(?![0-9])/.test(t) && !hasAdd9 && !isMaj9 && !isMinor9 && !hasAdd9Micro && !hasBareMicro9 && !hasJ9;
                // If #11 is present together with 13, we'll handle the sharped 11 inside the 13 stack below
                const has11      = /(?:^|[^0-9])11(?![0-9])/.test(t) && !hasAdd11 && !hasSharp11 && !hasAdd11Micro && !hasBareMicro11 && !hasJ11;
                const has13      = /(?:^|[^0-9])13(?![0-9])/.test(t) && !hasAdd13 && !hasSharp13 && !hasAdd13Micro && !hasBareMicro13 && !hasJ13;

                // maj9
                if (isMaj9) { add(set, 11); add(set, 14); }
                // m9 (no implied 7th)
                if (isMinor9) { add(set, 14); }
                // Plain stacked 9/11/13
                if (has9) { if (!hasMaj7) add(set, 10); add(set, 14); }
                if (has11) { if (!hasMaj7) add(set, 10); add(set, 14); add(set, 17); }
                if (hasSharp11 && !has13) { // standalone #11 (not tied to 13)
                    if (!hasMaj7) add(set, 10); add(set, 14); add(set, 18);
                }
                if (has13) {
                    // 13 implies 7+9+11; if #11 present, sharpen the 11 inside this stack
                    if (!hasMaj7) add(set, 10); // 7 (only if no maj7 present)
                    add(set, 14); // 9
                    if (hasSharp11) add(set, 18); else add(set, 17); // 11 or #11
                    add(set, 21); // 13
                }
                if (hasSharp13) { if (!hasMaj7) add(set, 10); add(set, 14); add(set, 17); add(set, 22); }
                // Explicit 7
                if (hasPlain7 && !hasJ7) { add(set, 10); }

                // add tones (plain)
                if (/add9(?![0-9])/.test(t)) add(set, 14);
                if (/add11(?![0-9])/.test(t)) add(set, 17);
                if (/add13(?![0-9])/.test(t)) add(set, 21);

                // alterations
                if (/â™­5|b5|\-5/.test(t)) { set.delete(map(7)); add(set, 6); }
                if (/â™¯5|#5/.test(t)) { set.delete(map(7)); add(set, 8); }
                // Only add altered 9 if there isn't a micro-marked add9 or bare micro 9 already handling the nuance
                const hasAnyMicro9 = /add[\^v]+9(?![0-9])/.test(t) || /(?:^|[^A-Za-z])[\^v]+9(?![0-9])/.test(t);
                if (/â™­9|b9|\-9/.test(t) && !hasAnyMicro9) add(set, 13);
                if (/â™¯9|#9/.test(t) && !hasAnyMicro9) add(set, 15);
                if (/â™¯11|#11/.test(t)) add(set, 18);

                // Microtonal '^' (raise) and 'v' (lower) modifiers on extensions
                // Helper: add a degree with optional microstep offset in current EDO
                const EDO = this.currentTuning;
                const degToSemi = {2:2,3:3,4:5,5:7,6:9,7:10,9:14,11:17,13:21};
                const addMicroDegree = (deg, microSteps=0)=>{
                    const semi = degToSemi[deg];
                    if (semi == null) return;
                    const base = map(semi);
                    let target = base + microSteps;
                    // wrap within EDO for safety
                    target = ((target % EDO) + EDO) % EDO;
                    set.add(target);
                };
                const microShiftOf = (s)=> ((s.match(/\^/g)||[]).length - (s.match(/v/g)||[]).length);

                // addv7/add^9/addv11/add^13 etc.
                const addMicroRe = /add([\^v]+)(2|3|4|5|6|7|9|11|13)/g;
                let mm;
                while ((mm = addMicroRe.exec(t)) !== null) {
                    const shift = microShiftOf(mm[1]);
                    const deg = parseInt(mm[2],10);
                    addMicroDegree(deg, shift);
                }

                // Bare micro-marked degrees like v7, ^9, v13
                const bareMicroRe = /(?:^|[^A-Za-z])([\^v]+)(2|3|4|5|6|7|9|11|13)(?![0-9])/g;
                while ((mm = bareMicroRe.exec(t)) !== null) {
                    const shift = microShiftOf(mm[1]);
                    const deg = parseInt(mm[2],10);
                    if (deg === 9) {
                        if (!hasMaj7) add(set, 10); // implied 7
                        addMicroDegree(9, shift);
                    } else if (deg === 11) {
                        if (!hasMaj7) add(set, 10);
                        add(set, 14); // implied 9
                        addMicroDegree(11, shift);
                    } else if (deg === 13) {
                        if (!hasMaj7) add(set, 10);
                        add(set, 14); // 9
                        add(set, hasSharp11 ? 18 : 17); // respect #11 if also present
                        addMicroDegree(13, shift);
                    } else {
                        addMicroDegree(deg, shift);
                    }
                }

                // Degree-suffix micro markers like 9^, 11v, 13^^
                const suffixMicroRe = /(?<![A-Za-z])\b(2|3|4|5|6|7|9|11|13)([\^v]+)\b/g;
                while ((mm = suffixMicroRe.exec(t)) !== null) {
                    const deg = parseInt(mm[1], 10);
                    const shift = microShiftOf(mm[2]);
                    if (deg === 9) {
                        if (!hasMaj7) add(set, 10);
                        addMicroDegree(9, shift);
                    } else if (deg === 11) {
                        if (!hasMaj7) add(set, 10);
                        add(set, 14);
                        addMicroDegree(11, shift);
                    } else if (deg === 13) {
                        if (!hasMaj7) add(set, 10);
                        add(set, 14);
                        add(set, hasSharp11 ? 18 : 17);
                        addMicroDegree(13, shift);
                    } else {
                        addMicroDegree(deg, shift);
                    }
                }

                // Just-intonation degrees (J7, J11, etc.) -> nearest EDO step by ratio
                const jiRatio = {
                    2: 9/8,
                    3: 5/4,
                    4: 4/3,
                    5: 3/2,
                    6: 5/3,
                    7: 7/4,
                    9: 9/8,
                    11: 11/8,
                    13: 13/8
                };
                const addJIDegree = (deg)=>{
                    const ratio = jiRatio[deg];
                    if (!ratio) return;
                    const cents = 1200 * Math.log2(ratio);
                    const step = Math.round(cents / (1200 / EDO));
                    const normStep = ((step % EDO) + EDO) % EDO;
                    set.add(normStep);
                };
                const jRe = /J(2|3|4|5|6|7|9|11|13)/g;
                let jm;
                while ((jm = jRe.exec(t)) !== null) {
                    const deg = parseInt(jm[1], 10);
                    addJIDegree(deg);
                }

                // Return sorted unique
                const result = Array.from(set).sort((a,b)=>a-b);
                return result;
            }

            rootToSemitone(letter, acc) {
                const base = {C:0,D:2,E:4,F:5,G:7,A:9,B:11}[letter] ?? 0;
                if (acc === '#' || acc === 'â™¯') return (base + 1) % 12;
                if (acc === 'b' || acc === 'â™­') return (base + 11) % 12;
                if (acc === 'd' || acc === 'ð„³') return base; // half-flat handled via micro step elsewhere
                if (acc === 'ð„²') return base; // half-sharp handled via micro step elsewhere
                return base;
            }

            _getAccidentalPreference(name) {
                const s = String(name || '');
                if (/[#â™¯]/.test(s)) return 'sharp';
                if (/[bâ™­dð„³]/.test(s)) return 'flat';
                return null;
            }

            _transposePreferredRootName(name, delta, edo) {
                if (!name || !Number.isFinite(delta) || !edo) return name || null;
                const d = ((delta % edo) + edo) % edo;
                if (d === 0) return name;
                try {
                    const norm = this._normalizeChordSymbolsForParse(name);
                    const m = norm.match(/^([A-G])([#bâ™­â™¯ð„²ð„³d]?)([\^v]*)/);
                    if (!m) return name;
                    const letter = m[1];
                    let acc = m[2] || '';
                    let micro = m[3] || '';
                    // half-flat/sharp as micro marks
                    if (acc === 'd' || acc === 'ð„³') { acc = 'd'; }
                    if (acc === 'ð„²') { acc = 'ð„²'; }
                    const semi = this.rootToSemitone(letter, (acc === 'd' || acc === 'ð„³' || acc === 'ð„²') ? '' : acc);
                    const baseStep = Math.round((semi * edo) / 12);
                    const ups = (micro.match(/\^/g) || []).length;
                    const downs = (micro.match(/v/g) || []).length;
                    const origStep = ((baseStep + ups - downs) % edo + edo) % edo;
                    const newStep = ((origStep + d) % edo + edo) % edo;

                    // Try to keep the same letter/accidental spelling for small micro shifts
                    let diff = newStep - baseStep;
                    if (diff > edo/2) diff -= edo;
                    if (diff < -edo/2) diff += edo;
                    const maxMicroSteps = Math.max(1, Math.round(edo / 24));
                    if (Math.abs(diff) <= maxMicroSteps) {
                        const microOut = diff > 0 ? '^'.repeat(diff) : (diff < 0 ? 'v'.repeat(-diff) : '');
                        return this._formatRootWithSymbols(letter, acc, microOut);
                    }

                    const pref = this._getAccidentalPreference(name);
                    return this.getRootNameForStepWithPreference(newStep, edo, pref);
                } catch (_) {
                    return name;
                }
            }

            getRootNameForStepWithPreference(step, edo = (this.currentTuning || 12), preference = null) {
                const pref = (preference === 'sharp' || preference === 'flat') ? preference : null;
                if (!pref) return this.getRootNameForStep(step, edo);
                const base = this.getRootNameForStep(step, edo);
                const m = String(base || '').match(/^([A-G])([#â™¯bâ™­]?)(.*)$/);
                if (!m) return base;
                const letter = m[1];
                const acc = m[2] || '';
                const rest = m[3] || '';
                // Only swap plain sharp/flat spellings; keep micro markers intact
                if (pref === 'sharp' && (acc === 'b' || acc === 'â™­')) {
                    const semi = this.rootToSemitone(letter, 'b');
                    const sharpNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
                    const raw = sharpNames[((semi % 12) + 12) % 12] + rest;
                    return this._convertRootNameSymbols(raw);
                }
                if (pref === 'flat' && (acc === '#' || acc === 'â™¯')) {
                    const semi = this.rootToSemitone(letter, '#');
                    const flatNames  = ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];
                    const raw = flatNames[((semi % 12) + 12) % 12] + rest;
                    return this._convertRootNameSymbols(raw);
                }
                return base;
            }

            // Normalize SMuFL/Unicode accidental symbols into ASCII for parsing logic
            _normalizeChordSymbolsForParse(text) {
                return String(text || '')
                    // keep standard â™­/â™¯ as-is for display-aware parsing
                    .replace(/ð„²/g,'ð„²') // quarter tone sharp
                    .replace(/ð„³/g,'ð„³') // quarter tone flat
                    .replace(/ð„°/g,'#^') // sharp up -> sharp + up
                    .replace(/ð„±/g,'#v') // sharp down -> sharp + down
                    .replace(/ð„¬/g,'b^') // flat up -> flat + up
                    .replace(/ð„­/g,'bv') // flat down -> flat + down
                    .replace(/ð„®/g,'^')  // natural up
                    .replace(/ð„¯/g,'v')  // natural down
                    .replace(/ð…‰/g,'^')  // up
                    .replace(/ð…/g,'v'); // down
            }

            // Format a root using SMuFL microtonal symbols (no ASCII #/b/d in output)
            _formatRootWithSymbols(letter, acc = '', micro = '') {
                const L = String(letter || '').toUpperCase();
                let a = '';
                if (acc === 'â™¯' || acc === '#') a = 'â™¯';
                else if (acc === 'â™­' || acc === 'b') a = 'â™­';
                else if (acc === 'ð„²') a = 'ð„²';
                else if (acc === 'ð„³' || acc === 'd') a = 'ð„³';
                const m = String(micro || '').replace(/\^/g,'ð…‰').replace(/v/g,'ð…');
                return L + a + m;
            }

            // Convert legacy root name tokens to SMuFL symbols (used for EDO table names)
            _convertRootNameSymbols(name) {
                if (!name) return name;
                let out = String(name);
                // Double accidentals first
                out = out.replace(/bb/g,'ð„³ð„³').replace(/##/g,'ð„²ð„²');
                out = out.replace(/X/g,'ð„²ð„²');
                // Single accidentals and micro marks
                out = out.replace(/#/g,'â™¯').replace(/b/g,'â™­').replace(/d/g,'ð„³');
                out = out.replace(/Ç‚/g,'ð„°');
                out = out.replace(/\^/g,'ð…‰').replace(/v/g,'ð…');
                // Extra natural modifiers in some tables
                out = out.replace(/\//g,'ð„®').replace(/\\/g,'ð„¯');
                return out;
            }

            // Core parser: returns normalized chord strings including root (e.g., Bb7, Caug)
            extractUniqueChordsFromText(text) {
                if (!text) return [];
                const lines = String(text).split(/\r?\n/);
                const seen = new Set();
                const out = [];

                const pushNorm = (raw)=>{
                    const norm = this.normalizeChordToken(raw);
                    if (!norm) return;
                    const key = norm.toLowerCase();
                    if (!seen.has(key)) { seen.add(key); out.push(norm); }
                };

                for (const line of lines) {
                    const s = line.trim();
                    if (!s) continue;

                    // First, grab all chord-like matches with positions
                    const matches = this.scanChordMatches(s);
                    // Accept all matches; dedupe later
                    for (const m of matches) pushNorm(m.raw);
                }

                return out;
            }

            // Return array of { raw, start, end } chord-like matches within a string
            scanChordMatches(s) {
                // Normalize and strip section headings like "A:" "B:" before tokenizing
                const text = this._normalizeChordSymbolsForParse(String(s))
                    .replace(/(^|\s)[^\s|:]+\s*:\s*/g, ' ');
                // Match a chord token up to the next whitespace or punctuation; do NOT consume spaces across tokens
                // Match compact slash chords like G/F but not spaced G / F (space breaks tokens)
                const re = /\b([A-Ga-g])(?:#|b|\-|d|â™­|â™¯|ð„²|ð„³|ð„°|ð„±|ð„¬|ð„­)?(?:[\^vð…‰ð…]+)?(?:add|maj|min|dim|aug|mM|sus|m|M|\+|Â°|Ã¸)?[A-Za-z0-9#bÃ¸Â°\+\-\^vâ™­â™¯ð„²ð„³ð„°ð„±ð„¬ð„­ð…‰ð…]*(?:\/(?:[A-Ga-g](?:#|b|d|â™­|â™¯|ð„²|ð„³|ð„°|ð„±|ð„¬|ð„­)?))?/g;
                const found = [];
                let m;
                while ((m = re.exec(text)) !== null) {
                    const raw = m[0].trim();
                    // Keep single-letter roots (e.g., G) â€” treat as valid chords
                    found.push({ raw, start: m.index, end: m.index + m[0].length });
                }
                return found;
            }

            // Tokenize candidates allowing: flats as b or '-', sharps as #, unicode â™­/â™¯, letters Aâ€“G, and common quality tails
            tokenizePossibleChords(text) {
                return this.scanChordMatches(text).map(x=>x.raw);
            }

            // Normalize one token to a canonical chord string
            normalizeChordToken(rawToken) {
                if (!rawToken) return null;
                if (rawToken === '__SECTION__' || rawToken === '|') return '__SECTION__';
                
                // SAFETY: Reject repeat notation tokens like x4, X2 etc
                if (/^[xX]\d+$/.test(rawToken.trim())) {
                    console.log('ðŸŽµ normalizeChordToken: Rejecting repeat token:', rawToken);
                    return null;
                }
                
                let t = rawToken.trim();
                // Standardize unicode and SMuFL symbols for parsing
                t = this._normalizeChordSymbolsForParse(t);
                // Important: do NOT remove all spaces blindly; we must distinguish "G / F" (two chords) from "G/F" (slash chord)
                // We'll collapse spaces except when a slash is present with spaces around it; in that case, keep spaces so scanner splits tokens
                if (/\/[A-G]/i.test(t)) {
                    // Already a compact slash chord like G/F â€“ remove other spaces
                    t = t.replace(/\s+/g,'');
                } else {
                    // Keep spaces, they help tokenization stage treat G / F as separate tokens
                    t = t.replace(/\s{2,}/g,' ').trim();
                }

                // Root parse: letter + optional accidental (#, b, -) and optional micro marks (^ up, v down)
                const mRoot = t.match(/^([A-Ga-g])([#b\-d]?)([\^v]*)(.*)$/);
                if (!mRoot) return null;
                const letter = mRoot[1].toUpperCase();
                const acc = (mRoot[2] === '-') ? 'b' : (mRoot[2] || '');
                const micro = mRoot[3] || '';
                let tail = mRoot[4] || '';
                // Normalize spacing before interpreting quality/extensions
                tail = tail.trim();
                // Normalize common spaced variants like "Maj 7", "Maj 9" â†’ "maj7", "maj9"
                tail = tail.replace(/^maj\s*(?=(?:7|9|11|13)\b)/i, 'maj');
                tail = tail.replace(/^M\s*(7|9|11|13)/, 'M$1');

                // Guard: ignore bare two-letter words that look like lyrics (e.g., "Bu", "Ea")
                // Criteria: exactly two chars, second is a lowercase vowel, and no chord markers like m, M, digits, +, Â°, Ã¸, #, b, or /
                if (!acc && !micro && /^[A-G][aeiou]$/.test(t) && !/[mM0-9+Â°Ã¸#b/]/.test(t)) {
                    return null;
                }

                // Convert common synonyms/variants in the tail
                // min/maj/neutral shorthand
                tail = tail.replace(/^min/i,'m');
                tail = tail.replace(/^maj/i,'M');
                tail = tail.replace(/^neutral/i,'n').replace(/^neu/i,'n');
                // Normalize just intonation marker to uppercase
                tail = tail.replace(/j/g, 'J');
                // diminished
                tail = tail.replace(/^dim/i,'Â°'); // use Â° as canonical dim triad
                // half-diminished
                tail = tail.replace(/^Ã¸/i,'Ã¸');
                // augmented
                if (/^aug/i.test(tail) || /^\+/i.test(tail)) {
                    tail = tail.replace(/^aug/i,'+');
                    // Ensure + remains
                    if (!/^\+/.test(tail)) tail = '+' + tail;
                }
                // handle c+ etc: if tail starts with '+', keep as augmented triad unless specific tensions follow
                // sus synonyms already OK

                // Remove any remaining internal spaces in the tail to keep tokens intact (e.g., Maj 9 â†’ M9)
                tail = tail.replace(/\s+/g, '');

                // Flats and sharps on extensions, allow b or -
                tail = tail.replace(/\-([0-9]+)/g,'b$1'); //  -7 -> b7
                tail = tail.replace(/b11/g,'â™­11').replace(/b9/g,'â™­9').replace(/b5/g,'â™­5').replace(/b13/g,'â™­13');
                tail = tail.replace(/#([0-9]+)/g,'â™¯$1');

                // Support simple slash chords bass note like /G or /Gb (compact only, no spaces)
                // Uppercase only the letter, keep accidental case
                tail = tail.replace(/\/([A-Ga-g])((?:#|b|d)?)$/g, (_, L, acc)=> '/' + this._formatRootWithSymbols(L, acc, ''));

                // Clean trailing punctuation or lyrics fragments after a closing bracket/paren or comma/semicolon
                tail = tail.replace(/[\],;:]+.*$/,'');
                // Keep valid tail characters, including Aâ€“G for slash bass notes (e.g., /G, /Bb)
                // Include Î” (major) so previously-normalized tokens like CÎ”7/CÎ”9 survive re-normalization
                tail = tail.replace(/[^A-GmMnJÂ°Ã¸Î”+suad0-9â™­â™¯/#^vbð„²ð„³ð„°ð„±ð„¬ð„­ð„®ð„¯ð…‰ð…]+.*$/,'');

                // If tail empty, it's a bare triad: major by default -> ''
                // If tail equals 'min' was converted to 'm' above.

                // Special: 'dim' used with 7 -> Â°7; 'm7b5' normalize to Ã¸7
                // m7b5 or m7-5 â†’ Ã¸7
                if (/^m7(?:â™­|b|\-)?5$/i.test(tail)) tail = 'Ã¸7';
                if (/^dim7$/i.test(tail)) tail = 'Â°7';
                if (/^dim$/i.test(tail)) tail = 'Â°';

                // Compose root + tail (allow bare single-letter chords e.g., G)
                const root = this._formatRootWithSymbols(letter, acc, micro);
                let chord = root + tail;

                // Cosmetic: convert 'Bbb' accidents or double signs not handled here; keep simple
                // Display: prefer 'maj' wording over Î” or bare 'M'
                chord = chord.replace(/Î”(7|9|11|13)/g,'maj$1').replace(/M(7|9|11|13)/g,'maj$1');

                return chord;
            }
            
            // ============= CHORD BUILDER SETUP =============
            
            showSimpleChordBuilder() {
                // Create a simple modal for custom chord building
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                `;
                
                const tuningSize = this.getTuningStepsPerOctave();
                const noteNames = this.getNoteNames();
                
                // Create note selector grid
                let notesGrid = '';
                for (let i = 0; i < tuningSize; i++) {
                    const isDiatonic = this.isDiatonicNote(i);
                    const noteClass = isDiatonic ? 'note-btn diatonic' : 'note-btn';
                    notesGrid += `
                        <button class="${noteClass}" data-note="${i}" style="
                            background: ${isDiatonic ? '#1e40af' : '#374151'};
                            color: white;
                            border: 1px solid ${isDiatonic ? '#3b82f6' : '#6b7280'};
                            padding: 8px;
                            margin: 2px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 12px;
                            min-width: 40px;
                        ">${noteNames[i] || i}</button>
                    `;
                }
                
                modal.innerHTML = `
                    <div style="
                        background: #1f2937;
                        border-radius: 12px;
                        padding: 20px;
                        max-width: 600px;
                        width: 90%;
                        max-height: 80vh;
                        overflow-y: auto;
                        color: white;
                    ">
                        <h2 style="margin: 0 0 20px 0; color: #f3f4f6;">Create Custom Chord</h2>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Chord Name:</label>
                            <input type="text" id="simpleChordName" placeholder="Enter chord name" style="
                                width: 100%;
                                padding: 8px;
                                border: 1px solid #6b7280;
                                border-radius: 4px;
                                background: #374151;
                                color: white;
                                font-size: 14px;
                            ">
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">
                                Select Notes (Blue = Diatonic):
                            </label>
                            <div style="
                                display: grid;
                                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
                                gap: 4px;
                                max-height: 200px;
                                overflow-y: auto;
                                border: 1px solid #6b7280;
                                padding: 10px;
                                border-radius: 4px;
                                background: #2d3748;
                            " id="simpleNotesGrid">
                                ${notesGrid}
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <button id="previewSimpleChord" style="
                                background: #059669;
                                color: white;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 4px;
                                cursor: pointer;
                                margin-right: 10px;
                            ">?? Preview</button>
                            <button id="clearSimpleChord" style="
                                background: #dc2626;
                                color: white;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Clear</button>
                        </div>
                        
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button id="cancelSimpleChord" style="
                                background: #6b7280;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Cancel</button>
                            <button id="saveSimpleChord" style="
                                background: #1e40af;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Save Chord</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Add event listeners
                this.setupSimpleChordBuilderEvents(modal);
            }
            
            setupSimpleChordBuilderEvents(modal) {
                // Note selection
                modal.querySelectorAll('.note-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('selected');
                        if (btn.classList.contains('selected')) {
                            btn.style.background = btn.classList.contains('diatonic') ? '#3b82f6' : '#6b7280';
                            btn.style.boxShadow = '0 0 8px rgba(59, 130, 246, 0.5)';
                        } else {
                            btn.style.background = btn.classList.contains('diatonic') ? '#1e40af' : '#374151';
                            btn.style.boxShadow = 'none';
                        }
                    });
                });
                
                // Preview chord
                modal.querySelector('#previewSimpleChord').addEventListener('click', () => {
                    const selectedNotes = this.getSelectedNotesFromModal(modal);
                    if (selectedNotes.length === 0) {
                        alert('Please select at least one note!');
                        return;
                    }
                    this.previewCustomChord(selectedNotes);
                });
                
                // Clear selection
                modal.querySelector('#clearSimpleChord').addEventListener('click', () => {
                    modal.querySelectorAll('.note-btn.selected').forEach(btn => {
                        btn.classList.remove('selected');
                        btn.style.background = btn.classList.contains('diatonic') ? '#1e40af' : '#374151';
                        btn.style.boxShadow = 'none';
                    });
                });
                
                // Save chord
                modal.querySelector('#saveSimpleChord').addEventListener('click', () => {
                    const chordName = modal.querySelector('#simpleChordName').value.trim();
                    const selectedNotes = this.getSelectedNotesFromModal(modal);
                    
                    if (!chordName) {
                        alert('Please enter a chord name!');
                        return;
                    }
                    
                    if (selectedNotes.length === 0) {
                        alert('Please select at least one note!');
                        return;
                    }
                    
                    this.saveSimpleCustomChord(chordName, selectedNotes);
                    modal.remove();
                    if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
                });
                
                // Cancel
                modal.querySelector('#cancelSimpleChord').addEventListener('click', () => {
                    modal.remove();
                });
                
                // Close on ESC
                const closeOnEsc = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', closeOnEsc);
                    }
                };
                document.addEventListener('keydown', closeOnEsc);
            }
            
            isDiatonicNote(noteIndex) {
                // Check if note is diatonic (major scale intervals in current tuning)
                const tuningSize = this.getTuningStepsPerOctave();
                const diatonicIntervals = [0, 2, 4, 5, 7, 9, 11]; // Major scale in semitones
                
                // Map to current tuning
                const diatonicSteps = diatonicIntervals.map(interval => 
                    Math.round((interval * tuningSize) / 12)
                );
                
                return diatonicSteps.includes(noteIndex);
            }
            
            getSelectedNotesFromModal(modal) {
                const selectedButtons = modal.querySelectorAll('.note-btn.selected');
                return Array.from(selectedButtons).map(btn => parseInt(btn.dataset.note));
            }
            
            previewCustomChord(selectedNotes) {
                // Play the selected notes as a chord
                const baseOctave = 4;
                selectedNotes.forEach(noteStep => {
                    const freq = this.getFrequency(noteStep, baseOctave, this.currentTuning);
                    this.playFrequency(freq, null, 'chord');
                });
                
                // Stop after 1 second
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
            }
            
            saveSimpleCustomChord(chordName, selectedNotes) {
                // Create a single chord extension that will auto-generate all 3 qualities
                const chordExtension = {
                    name: chordName,
                    intervals: selectedNotes,
                    isCustom: true,
                    id: chordName.toLowerCase().replace(/\s+/g, '_')
                };
                
                // ADD to existing chords instead of replacing them
                this.chordExtensions.push(chordExtension);
                
                // Save and regenerate
                this.saveChordConfiguration();
                this.preserveLockedChordsAndRegenerate();
                
                console.log(`Added custom chord: ${chordName} with notes:`, selectedNotes);
            }

            getTuningDisplayName() {
                if (this.gamelanMode) return 'Gamelan';
                switch(this.currentTuning) {
                    case 5: return '5-EDO';
                    case 7: return '7-EDO';
                    case 11: return 'C.Gamma';
                    case 12: return '12-TET';
                    case 15: return '15-EDO';
                    case 17: return '17-EDO';
                    case 19: return '19-TET';
                    case 22: return '22-TET';
                    case 24: return '24-TET';
                    case 31: return '31-TET';
                    case 34: return '34-TET';
                    case 53: return '53-TET';
                    default: return `${this.currentTuning}-TET`;
                }
            }
            
            updateFavoritesDisplay() {
            }
            
            populateChordBuilderNoteSelector() {
                const selector = document.getElementById('chordBuilderNoteSelector');
                selector.innerHTML = '';
                
                const edoSize = this.gamelanMode ? 7 : this.currentTuning;
                
                for (let i = 0; i < edoSize; i++) {
                    const button = document.createElement('div');
                    button.className = 'note-btn';
                    button.dataset.note = i;
                    button.textContent = this.getMicrotonalNoteName(i);
                    
                    // Color coding for diatonic highlighting
                    button.style.cssText = `
                        padding: 8px 4px;
                        background: ${this.getDiatonicNoteColor(i)};
                        border: 2px solid ${this.getDiatonicNoteBorderColor(i)};
                        color: white;
                        cursor: pointer;
                        border-radius: 6px;
                        font-size: 11px;
                        font-weight: bold;
                        text-align: center;
                        transition: all 0.2s;
                        user-select: none;
                    `;
                    
                    button.addEventListener('click', () => {
                        button.classList.toggle('selected');
                        if (button.classList.contains('selected')) {
                            button.style.borderColor = '#f39c12';
                            button.style.boxShadow = '0 0 8px rgba(243, 156, 18, 0.6)';
                        } else {
                            button.style.borderColor = this.getDiatonicNoteBorderColor(i);
                            button.style.boxShadow = 'none';
                        }
                    });
                    
                    selector.appendChild(button);
                }
            }
            
            populateChordExtensions() {
                const checkboxContainer = document.getElementById('chordExtensionsCheckboxes');
                checkboxContainer.innerHTML = '';
                
                const extensions = [
                    { name: 'Major', intervals: [0, 4, 7], base: true },
                    { name: 'Minor', intervals: [0, 3, 7], base: true },
                    { name: 'Neutral', intervals: [0, 3.5, 7], base: true },
                    { name: 'Diminished', intervals: [0, 3, 6] },
                    { name: 'Augmented', intervals: [0, 4, 8] },
                    { name: 'sus2', intervals: [0, 2, 7] },
                    { name: 'sus4', intervals: [0, 5, 7] },
                    { name: 'maj7', intervals: [11] },
                    { name: '7th', intervals: [10] },
                    { name: '6th', intervals: [9] },
                    { name: '9th', intervals: [14] },
                    { name: 'add9', intervals: [2] },
                    { name: '11th', intervals: [17] },
                    { name: '13th', intervals: [21] },
                    { name: '?9', intervals: [13] },
                    { name: '?9', intervals: [15] },
                    { name: '?11', intervals: [18] },
                    { name: '?13', intervals: [20] },
                    { name: '?13', intervals: [22] }
                ];
                
                extensions.forEach((ext, index) => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.display = 'flex';
                    checkboxDiv.style.alignItems = 'center';
                    checkboxDiv.style.gap = '6px';
                    checkboxDiv.style.padding = '4px 8px';
                    checkboxDiv.style.borderRadius = '4px';
                    checkboxDiv.style.background = ext.base ? 'rgba(74, 144, 226, 0.2)' : 'rgba(255, 255, 255, 0.1)';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `ext_${index}`;
                    checkbox.dataset.intervals = JSON.stringify(ext.intervals);
                    checkbox.style.cursor = 'pointer';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `ext_${index}`;
                    label.textContent = ext.name;
                    label.style.fontSize = '12px';
                    label.style.cursor = 'pointer';
                    label.style.color = ext.base ? '#4a90e2' : '#8fb3d3';
                    label.style.fontWeight = ext.base ? 'bold' : 'normal';
                    
                    checkbox.addEventListener('change', () => {
                        this.updateChordPreview();
                    });
                    
                    // Add hover preview for extensions
                    checkboxDiv.addEventListener('mouseenter', () => {
                        this.previewIntervals(ext.intervals);
                    });
                    
                    checkboxDiv.addEventListener('mouseleave', () => {
                        this.stopPreview();
                    });
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    checkboxContainer.appendChild(checkboxDiv);
                });
            }
            
            populateMicrotonalIntervals() {
                const checkboxContainer = document.getElementById('microtonalCheckboxes');
                checkboxContainer.innerHTML = '';
                
                // Generate all intervals in the current EDO
                for (let step = 1; step < this.currentTuning; step++) {
                    const semitones = (step * 12) / this.currentTuning;
                    const cents = semitones * 100;
                    
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.display = 'flex';
                    checkboxDiv.style.alignItems = 'center';
                    checkboxDiv.style.gap = '4px';
                    checkboxDiv.style.padding = '3px 6px';
                    checkboxDiv.style.borderRadius = '3px';
                    checkboxDiv.style.fontSize = '11px';
                    
                    // Color coding based on interval type
                    const color = this.getDiatonicNoteColor(step);
                    checkboxDiv.style.background = color + '20'; // Add transparency
                    checkboxDiv.style.borderLeft = `3px solid ${color}`;
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `micro_${step}`;
                    checkbox.dataset.semitones = semitones.toString();
                    checkbox.dataset.step = step.toString();
                    checkbox.style.cursor = 'pointer';
                    checkbox.style.transform = 'scale(0.8)';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `micro_${step}`;
                    label.style.fontSize = '10px';
                    label.style.cursor = 'pointer';
                    label.style.color = '#fff';
                    label.style.fontFamily = 'monospace';
                    
                    // Create descriptive label
                    const noteName = this.getMicrotonalNoteName(step);
                    const centsStr = cents >= 0 ? `+${cents.toFixed(0)} ` : `${cents.toFixed(0)} `;
                    label.textContent = `${noteName} (${centsStr})`;
                    
                    checkbox.addEventListener('change', () => {
                        this.updateChordPreview();
                    });
                    
                    // Add hover preview for microtonal intervals
                    checkboxDiv.addEventListener('mouseenter', () => {
                        this.previewIntervals([semitones]);
                    });
                    
                    checkboxDiv.addEventListener('mouseleave', () => {
                        this.stopPreview();
                    });
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    checkboxContainer.appendChild(checkboxDiv);
                }
            }
            
            updateChordPreview() {
                const previewDisplay = document.getElementById('chordPreviewDisplay');
                if (!previewDisplay) return;
                
                const selectedIntervals = this.getSelectedChordIntervals();
                
                if (selectedIntervals.length === 0) {
                    previewDisplay.textContent = 'No intervals selected';
                    previewDisplay.style.color = '#8fb3d3';
                    return;
                }
                
                // Sort intervals
                selectedIntervals.sort((a, b) => a - b);
                
                // Create preview text
                let previewText = 'Selected intervals: ';
                previewText += selectedIntervals.map(interval => {
                    if (interval === 0) return 'Root';
                    const semitones = interval;
                    const cents = Math.round(semitones * 100);
                    return `${semitones.toFixed(1)}? (${cents} )`;
                }).join(', ');
                
                previewDisplay.textContent = previewText;
                previewDisplay.style.color = '#27ae60';
            }
            
            getSelectedChordIntervals() {
                const intervals = [0]; // Always include root
                
                // Get selected diatonic extensions
                const extensionCheckboxes = document.querySelectorAll('#chordExtensionsCheckboxes input[type="checkbox"]:checked');
                extensionCheckboxes.forEach(checkbox => {
                    const extIntervals = JSON.parse(checkbox.dataset.intervals);
                    intervals.push(...extIntervals);
                });
                
                // Get selected microtonal intervals
                const microCheckboxes = document.querySelectorAll('#microtonalCheckboxes input[type="checkbox"]:checked');
                microCheckboxes.forEach(checkbox => {
                    const semitones = parseFloat(checkbox.dataset.semitones);
                    intervals.push(semitones);
                });
                
                // Remove duplicates and sort
                return [...new Set(intervals)].sort((a, b) => a - b);
            }
            
            previewIntervals(intervals) {
                // Stop any existing preview
                this.stopPreview();
                
                // Start preview timeout to avoid too many rapid previews
                this.previewTimeout = setTimeout(() => {
                    if (!intervals || intervals.length === 0) return;
                    
                    // Play the intervals as a chord
                    const baseOctave = 4;
                    intervals.forEach((interval, index) => {
                        setTimeout(() => {
                            const step = this.semitoneToEDOStep(interval);
                            const frequency = this.getFrequency(step, baseOctave, this.currentTuning);
                            const mockElement = { classList: { add: () => {}, remove: () => {} } };
                            this.playFrequency(frequency, mockElement, 'chord');
                            
                            // Store the frequency for later cleanup
                            if (!this.previewFrequencies) this.previewFrequencies = [];
                            this.previewFrequencies.push(frequency);
                        }, index * 30); // Slight arpeggiation
                    });
                    
                    // Auto-stop preview after 800ms
                    this.previewStopTimeout = setTimeout(() => {
                        this.stopPreview();
                    }, 800);
                }, 100); // 100ms delay to avoid rapid firing
            }
            
            stopPreview() {
                // Clear timeouts
                if (this.previewTimeout) {
                    clearTimeout(this.previewTimeout);
                    this.previewTimeout = null;
                }
                if (this.previewStopTimeout) {
                    clearTimeout(this.previewStopTimeout);
                    this.previewStopTimeout = null;
                }
                
                // Stop all preview frequencies
                if (this.previewFrequencies) {
                    this.previewFrequencies.forEach(frequency => {
                        const mockElement = { classList: { add: () => {}, remove: () => {} } };
                        this.stopFrequency(frequency, mockElement);
                    });
                    this.previewFrequencies = [];
                }
            }
            
            updateChordBuilderFromExtensions() {
                // Get selected extensions
                const activeExtensions = Array.from(document.querySelectorAll('#chordExtensionsGrid .osc-btn.active'))
                    .map(btn => btn.textContent);
                
                // Convert extensions to intervals
                const intervals = this.convertExtensionsToIntervals(activeExtensions);
                
                // Update note selector to reflect these intervals
                this.loadChordPatternIntoBuilder(intervals);
            }
            
            convertExtensionsToIntervals(extensions) {
                const intervals = [0]; // Always include root
                const baseTriad = this.getBaseTriadForQuality();
                intervals.push(...baseTriad.slice(1)); // Add 3rd and 5th
                
                extensions.forEach(ext => {
                    switch(ext) {
                        case '6th': intervals.push(9); break;
                        case '7th': intervals.push(10); break;
                        case 'maj7': intervals.push(11); break;
                        case '9th': intervals.push(14); break;
                        case '?9': intervals.push(13); break;
                        case '?9': intervals.push(15); break;
                        case '11th': intervals.push(17); break;
                        case '?11': intervals.push(16); break;
                        case '?11': intervals.push(18); break;
                        case '13th': intervals.push(21); break;
                        case '?13': intervals.push(20); break;
                        case '?13': intervals.push(22); break;
                        case 'sus2': 
                            intervals.splice(intervals.indexOf(baseTriad[1]), 1); // Remove 3rd
                            intervals.push(2); 
                            break;
                        case 'sus4': 
                            intervals.splice(intervals.indexOf(baseTriad[1]), 1); // Remove 3rd
                            intervals.push(5); 
                            break;
                        case 'add9': intervals.push(14); break;
                        case 'dim': 
                            intervals[intervals.indexOf(baseTriad[1])] = 3; // ?3
                            intervals[intervals.indexOf(baseTriad[2])] = 6; // ?5
                            break;
                        case 'aug': 
                            intervals[intervals.indexOf(baseTriad[2])] = 8; // ?5
                            break;
                    }
                });
                
                return [...new Set(intervals)].sort((a, b) => a - b);
            }
            
            getBaseTriadForQuality() {
                switch(this.currentQuality) {
                    case 'major': return [0, 4, 7];
                    case 'minor': return [0, 3, 7];
                    case 'neutral': return [0, 3.5, 7];
                    default: return [0, 4, 7];
                }
            }
            
            loadChordPatternIntoBuilder(intervals) {
                // Clear all selections first
                document.querySelectorAll('#chordBuilderNoteSelector .note-btn').forEach(btn => {
                    btn.classList.remove('selected');
                    btn.style.borderColor = this.getDiatonicNoteBorderColor(parseInt(btn.dataset.note));
                    btn.style.boxShadow = 'none';
                });
                
                // Convert 12-TET intervals to current EDO
                intervals.forEach(interval => {
                    const edoStep = this.semitoneToEDOStep(interval);
                    const button = document.querySelector(`#chordBuilderNoteSelector .note-btn[data-note="${edoStep}"]`);
                    if (button) {
                        button.classList.add('selected');
                        button.style.borderColor = '#f39c12';
                        button.style.boxShadow = '0 0 8px rgba(243, 156, 18, 0.6)';
                    }
                });
            }
            
            semitoneToEDOStep(semitones) {
                // Convert 12-TET semitones to current EDO step
                const exactStep = (semitones / 12) * this.currentTuning;
                return Math.round(exactStep) % this.currentTuning;
            }
            
            getMicrotonalNoteName(step, opts = {}) {
                // Use SMuFL microtonal symbols (no ASCII #/b)
                const edo = this.currentTuning || 12;
                const stepsPerSemitone = edo / 12;
                
                // Base 12-tone note names
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                
                // Calculate which semitone this step is closest to
                const semiPosition = (step * 12) / edo;
                const baseSemi = Math.round(semiPosition) % 12;
                const baseName = this._convertRootNameSymbols(noteNames[baseSemi]);
                
                // Calculate microtonal deviation
                const exactSemi = Math.round(semiPosition);
                const deviation = step - (exactSemi * edo / 12);
                
                if (Math.abs(deviation) < 0.1) {
                    // Close enough to standard semitone
                    return baseName;
                } else if (deviation > 0) {
                    // Higher than standard semitone
                    return baseName + 'ð…‰';
                } else {
                    // Lower than standard semitone  
                    return baseName + 'ð…';
                }
            }

            // Return a concise root name for a given EDO step, using preferred labels for EDOs 5â€“24.
            // For EDOs not covered, fall back to microtonal arrow notation.
            getRootNameForStep(step, edo = (this.currentTuning || 12)) {
                const norm = (n, m) => ((n % m) + m) % m;
                const s = norm(step|0, edo|0 || 12);
                const namesByEDO = {
                    5:  ['C','D^^','Fv','G^','Bbvv'],
                    6:  ['C','D','E','Gb','Ab','Bb'],
                    7:  ['C','D','E','F','G','A','B'],
                    8:  ['C','Dd','Eb','Fd','Gb','GÇ‚','A','Bd'],
                    9:  ['C','Db^','Ebv','E','F^','Gv','Ab','A^','Bv'],
                    10: ['C','Db^','D^^','Evv','Fv','Gb','G^','Ab^^','Bbvv','Bv'],
                    11: ['C','Db^','D','Eb^','E','F^','Gv','G^','Av','A^','Bv'],
                    12: ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'],
                    13: ['C','Dbb','D','Ebb','E','Fb','F#','Gb','G#','Ab','A#','Bb','B#'],
                    14: ['C','C^','D','Ev','E','E^','F','F^','G','Av','A','Bv','B','B^'],
                    15: ['C','Dbv','Dvv','D^^','Eb^','E','Fv','Gbvv','Gb^^','G^','Ab','Av','Bbvv','Bb^^','B^'],
                    16: ['C','Dbv','Dd','D^','Eb','Ev','Fd','F^','Gb','Gv','GÇ‚','Ab^','A','Bbv','Bd','B^'],
                    17: ['C','Db','Dd','D','Eb','Ed','E','F','Gb','Gd','G','Ab','Ad','A','Bb','Bd','B'],
                    18: ['C','Dbv','Db^','D','Ebv','Eb^','E','Fv','F^','Gb','Gv','G^','Ab','Av','A^','Bb','Bv','B^'],
                    19: ['C','C#','Db','D','D#','Eb','E','Fb','F','F#','Gb','G','G#','Ab','A','A#','Bb','B','Cb'],
                    20: ['C','Dbvv','Db^','Dv','D^^','Eb','Evv','E^','Fv','F^^','Gb','Gvv','G^','Abv','Ab^^','A','Bbvv','Bb^','Bv','B^^'],
                    21: ['C','C^','Dv','D','D^','Ev','E','E^','Fv','F','F^','Gv','G','G^','Av','A','A^','Bv','B','B^','Cv'],
                    22: ['C','C^','Db^','Dv','D','D^','Eb^','Ev','E','F','F^','Gb^','Gv','G','G^','Ab^','Av','A','A^','Bb^','Bv','B'],
                    23: ['C','Dbv','Db^','Dvv','D','Ebv','Eb^','Evv','E','Fv','F^','F#vv','Gb^^','Gv','G^','Ab','Ab^^','Av','A^','Bb','Bb^^','Bv','B^'],
                    24: ['C','CÇ‚','Db','Dd','D','DÇ‚','Eb','Ed','E','Fd','F','FÇ‚','Gb','Gd','G','GÇ‚','Ab','Ad','A','AÇ‚','Bb','Bd','B','Cd'],
                    25: ['C','C^','C^^','Dvv','Dv','D','Eb^','Eb^^','Evv','Ev','F','F^','F^^','Gvv','Gv','G','Ab^','Ab^^','Avv','Av','Bb','Bb^','Bb^^','Bvv','Bv'],
                    26: ['C','C#','Dbb','Db','D','D#','Ebb','Eb','E','E#','Fb','F','F#','Gbb','Gb','G','G#','Abb','Ab','A','A#','Bbb','Bb','B','B#','Cb'],
                    27: ['C','Db','Db^','Dd','Dv','D','Eb','Eb^','Ed','Ev','E','F','Gb','Gb^','Gd','Gv','G','Ab','Ab^','Ad','Av','A','Bb','Bb^','Bd','Bv','B'],
                    28: ['C','C^','C^^','Dv','D','D^','D^^','Ev','E','E^','Fvv','Fv','F','F^','F^^','Gv','G','G^','Avv','Av','A','A^','Bvv','Bv','B','B^','B^^','Cv'],
                    29: ['C','C^','Db','Db^','Dv','D','D^','Eb','Eb^','Ev','E','E^','F','F^','Gb','Gb^','Gv','G','G^','Ab','Ab^','Av','A','A^','Bb','Bb^','Bv','B','B^'],
                    30: ['C','C^^','Dbv','Db^','Dvv','D','D^^','Ebv','Eb^','Evv','E','E^^','Fv','F^','Gbvv','Gb','Gb^^','Gv','G^','Abvv','Ab','Ab^^','Av','A^','Bbvv','Bb','Bb^^','Bv','B^','Cvv'],
                    31: ['C','Dbb','Ddb','Db','Dd','D','Ebb','Edb','Eb','Ed','E','Fb','Fd','F','Gbb','Gdb','Gb','Gd','G','Abb','Adb','Ab','Ad','A','Bbb','Bdb','Bb','Bd','B','Cb','Cd'],
                    32: ['C','Db','Db^','Db^^','Dvv','Dv','D','Eb','Eb^','Eb^^','Evv','Ev','E','F','Gb','Gb^','Gb^^','Gvv','Gv','G','Ab','Ab^','Ab^^','Avv','Av','A','Bb','Bb^','Bb^^','Bvv','Bv','B'],
                    33: ['C','C#','CX','Dbb','Db','D','D#','DX','Ebb','Eb','E','E#','Fbb','Fb','F','F#','FX','Gbb','Gb','G','G#','GX','Abb','Ab','A','A#','AX','Bbb','Bb','B','B#','Cbb','Cb'],
                    34: ['C','C^','Db','Db^','Dd','Dv','D','D^','Eb','Eb^','Ed','Ev','E','Fv','F','F^','Gb','Gb^','Gd','Gv','G','G^','Ab','Ab^','Ad','Av','A','Bbv','Bb','Bb^','Bd','Bv','B','Cv'],
                    35: ['C','C^','C^^','Dvv','Dv','D','D^','D^^','Evv','Ev','E','E^','E^^','Fvv','Fv','F','F^','F^^','Gvv','Gv','G','G^','G^^','Avv','Av','A','A^','A^^','Bvv','Bvv','B','B^','B^^','Cvv','Cv'],
                    36: ['C','C^','Dbv','Db','Db^','Dv','D','D^','Ebv','Eb','Eb^','Ev','E','E^','Fv','F','F^','Gbv','Gb','Gb^','Gv','G','G^','Abv','Ab','Ab^','Av','A','A^','Bbv','Bb','Bb^','Bv','B','B^','Cv'],
                    37: ['C','Db','Db^','Db^^','Dd','Dvv','Dv','D','Eb','Eb^','Eb^^','Ed','Evv','Ev','E','F','Gb','Gb^','Gb^^','Gd','Gvv','Gv','G','Ab','Ab^','Ab^^','Ad','Avv','Av','A','Bb','Bb^','Bb^^','Bd','Bvv','Bv','B'],
                    38: ['C','CÇ‚','C#','Ddb','Db','Dd','D','DÇ‚','D#','Edb','Eb','Ed','E','EÇ‚','Fb','Fd','F','FÇ‚','F#','Gdb','Gb','Gd','G','GÇ‚','G#','Adb','Ab','Ad','A','AÇ‚','A#','Bdb','Bb','Bd','B','B ','Cb','Cd'],
                    39: ['C','C^','Db','Db^','Db^^','Dvv','Dv','D','D^','Eb','Eb^','Eb^^','Evv','Ev','E','Fv','F','F^','Gb','Gb^','Gb^^','Gvv','Gv','G','G^','Ab','Ab^','Ab^^','Avv','Av','A','A^','Bb','Bb^','Bb^^','Bvv','Bv','B','Cv'],
                    40: ['C','C#','CX','Dbbb','Dbb','Db','D','D#','DX','Ebbb','Ebb','Eb','E','E#','EX','Fbb','Fb','F','F#','FX','Gbbb','Gbb','Gb','G','G#','GX','Abbb','Abb','Ab','A','A#','AX','Bbbb','Bbb','Bb','B','B#','BX','Cbb','Cb'],
                    41: ['C','C^','Dbv','Db','Db^','Dd','Dv','D','D^','Ebv','Eb','Eb^','Ed','Ev','E','E^','Fv','F','F^','Gbv','Gb','Gb^','Gd','Gv','G','G^','Abv','Ab','Ab^','Ad','Av','A','A^','Bbv','Bb','Bb^','Bd','Bv','B','B^','Cv'],
                    42: ['C','Db','Db^','Db^^','Db^^^','Dvvv','Dvv','Dv','D','Eb','Eb^','Eb^^','Eb^^^','Evvv','Evv','Ev','E','F','Gb','Gb^','Gb^^','Gb^^^','Gvvv','Gvv','Gv','G','Ab','Ab^','Ab^^','Ab^^^','Avvv','Avv','Av','A','Bb','Bb^','Bb^^','Bb^^^','Bvvv','Bvv','Bv','B'],
                    43: ['C','C^','C#v','C#','Db','Db^','Dv','D','D^','D#v','D#','Eb','Eb^','Ev','E','E^','Fb^','Fv','F','F^','F#v','F#','Gb','Gb^','Gv','G','G^','G#v','G#','Ab','Ab^','Av','A','A^','A#v','A#','Bb','Bb^','Bv','B','B^','Cb^','Cv'],
                    44: ['C','C/','C^','C^/','Db^','Dv\\','Dv','D\\','D','D/','D^','D^/','Eb^','Ev\\','Ev','E\\','E','E/','F','F/','F^','F^/','Gb^','Gv\\','Gv','G\\','G','G/','G^','G^/','Ab^','Av\\','Av','A\\','A','A/','A^','A^/','Bb^','Bv\\','Bv','B\\','B','B/'],
                    45: ['C','CÇ‚','C#','Dbb','Ddb','Db','Dd','D','DÇ‚','D#','Ebb','Edb','Eb','Ed','E','EÇ‚','E#','Fb','Fd','F','FÇ‚','F#','Gbb','Gdb','Gb','Gd','G','GÇ‚','G#','Abb','Adb','Ab','Ad','A','AÇ‚','A#','Bbb','Bdb','Bb','Bd','B','BÇ‚','B#','Cb','Cd'],
                    46: ['C','C^','Dbv','Db','Db^','Db^^','Dvv','Dv','D','D^','Ebv','Eb','Eb^','Eb^^','Evv','Ev','E','E^','Fv','F','F^','Gbv','Gb','Gb^','Gb^^','Gvv','Gv','G','G^','Abv','Ab','Ab^','Ab^^','Avv','Av','A','A^','Bbv','Bb','Bb^','Bb^^','Bvv','Bv','B','B^','Cv'],
                    47: ['C','C#','CX','Dbbbb','Dbbb','Dbb','Db','D','D#','DX','Ebbbb','Ebbb','Ebb','Eb','E','E#','EX','Fbbb','Fbb','Fb','F','F#','FX','Gbbbb','Gbbb','Gbb','Gb','G','G#','GX','Abbbb','Abbb','Abb','Ab','A','A#','AX','Bbbbb','Bbbb','Bbb','Bb','B','B#','BX','Cbbb','Cbb','Cb'],
                    48: ['C','C^','CÇ‚','Dbv','Db','Db^','Dd','Dv','D','D^','DÇ‚','Ebv','Eb','Eb^','Ed','Ev','E','E^','Fd','Fv','F','F^','FÇ‚','Gbv','Gb','G^','Gd','Gv','G','G^','GÇ‚','Abv','Ab','Ab^','Ad','Av','A','A^','AÇ‚','Bbv','Bb','Bb^','Bd','Bv','B','B^','Cd','Cv'],
                    49: ['C','C^','Db','Db^','Db^^','Db^^^','Dvvv','Dvv','Dv','D','D^','Eb','Eb^','Eb^^','Eb^^^','Evvv','Evv','Ev','E','Fv','F','F^','Gb','Gb^','Gb^^','Gb^^^','Gvvv','Gvv','Gv','G','G^','Ab','Ab^','Ab^^','Ab^^^','Avvv','Avv','Av','A','A^','Bb','Bb^','Bb^^','Bb^^^','Bvvv','Bvv','Bv','B','Cv'],
                    50: ['C','C^','C#v','C#','Dbv','Db','Db^','Dv','D','D^','D#v','D#','Ebv','Eb','Eb^','Ev','E','E^','Fb','Fb^','Fv','F','F^','F#v','F#','Gbv','Gb','Gb^','Gv','G','G^','G#v','G#','Abv','Ab','Ab^','Av','A','A^','A#v','A#','Bbv','Bb','Bb^','Bv','B','B^','Cb','Cb^','Cv'],
                    51: ['C','C^','Dbv','Db','Db^','Ddv','Dd','Dd^','Dv','D','D^','Ebv','Eb','Eb^','Edv','Ed','Ed^','Ev','E','E^','Fv','F','F^','Gbv','Gb','Gb^','Gdv','Gd','Gd^','Gv','G','G^','Abv','Ab','Ab^','Adv','Ad','Ad^','Av','A','A^','Bbv','Bb','Bb^','Bdv','Bd','Bd^','Bv','B','B^','Cv'],
                    52: ['C','CÇ‚','C#','Ddbb','Dbb','Ddb','Db','Dd','D','DÇ‚','D#','Edbb','Ebb','Edb','Eb','Ed','E','EÇ‚','E#','Fdb','Fb','Fd','F','FÇ‚','F#','Gdbb','Gbb','Gdb','Gb','Gd','G','GÇ‚','G#','Adbb','Abb','Adb','Ab','Ad','A','AÇ‚','A#','Bdbb','Bbb','Bdb','Bb','Bd','B','BÇ‚','B#','Cdb','Cb','Cd'],
                    53: ['C','C^','C^^','Dbv','Db','Db^','Db^^','Dvv','Dv','D','D^','D^^','Ebv','Eb','Eb^','Eb^^','Evv','Ev','E','E^','E^^','Fv','F','F^','F^^','Gbv','Gb','Gb^','Gb^^','Gvv','Gv','G','G^','G^^','Abv','Ab','Ab^','Ab^^','Avv','Av','A','A^','A^^','Bbv','Bb','Bb^','Bb^^','Bvv','Bv','B','B^','B^^','Cv']
                };
                const table = namesByEDO[edo];
                if (table && table[s] != null) return this._convertRootNameSymbols(table[s]);
                // Fallback: basic 12-TET sharps for any other EDO
                const sharpNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
                if (edo === 12) return this._convertRootNameSymbols(sharpNames[s%12]);
                return this.getMicrotonalNoteName(s);
            }
            
            getDiatonicNoteColor(step) {
                // Color-code notes based on their relationship to diatonic scale
                const semitoneEquivalent = (step * 12) / this.currentTuning;
                const baseSemitone = Math.round(semitoneEquivalent) % 12;
                
                // Diatonic notes (C D E F G A B)
                if ([0, 2, 4, 5, 7, 9, 11].includes(baseSemitone)) {
                    return '#4a90e2'; // Blue for diatonic
                }
                // Neutral/microtonal
                if (Math.abs(semitoneEquivalent - Math.round(semitoneEquivalent)) > 0.3) {
                    return '#27ae60'; // Green for neutral
                }
                // Chromatic
                return '#e74c3c'; // Red for chromatic
            }
            
            getDiatonicNoteBorderColor(step) {
                const semitoneEquivalent = (step * 12) / this.currentTuning;
                const baseSemitone = Math.round(semitoneEquivalent) % 12;
                
                if ([0, 2, 4, 5, 7, 9, 11].includes(baseSemitone)) {
                    return '#6bb6ff'; // Lighter blue for diatonic
                }
                if (Math.abs(semitoneEquivalent - Math.round(semitoneEquivalent)) > 0.3) {
                    return '#2ecc71'; // Lighter green for neutral
                }
                return '#ff6b6b'; // Lighter red for chromatic
            }
            
            updateBuilderFavoritesDisplay() {
                const favoritesList = document.getElementById('chordBuilderFavoritesList');
                favoritesList.innerHTML = '';
                
                if (!this.favoriteChords || this.favoriteChords.length === 0) {
                    favoritesList.innerHTML = '<div style="color: #8fb3d3; font-style: italic; text-align: center; padding: 20px;">No favorite chords yet</div>';
                    return;
                }
                
                this.favoriteChords.forEach((chord, index) => {
                    const chordElement = document.createElement('div');
                    chordElement.className = 'favorite-chord-item';
                    chordElement.style.cssText = `
                        background: rgba(0, 30, 60, 0.6);
                        border: 1px solid #4a6870;
                        border-radius: 6px;
                        padding: 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                        text-align: center;
                    `;
                    
                    chordElement.innerHTML = `
                        <div style="font-weight: bold; color: #f39c12;">${chord.name}</div>
                        <div style="font-size: 10px; opacity: 0.8;">${chord.intervals ? chord.intervals.join(' ') : 'Custom'}</div>
                        <div style="font-size: 8px; opacity: 0.6; margin-top: 4px;">Click to load</div>
                    `;
                    
                    chordElement.addEventListener('click', () => {
                        this.loadFavoriteIntoBuilder(chord);
                    });
                    
                    chordElement.addEventListener('mouseenter', () => {
                        chordElement.style.borderColor = '#8fb3d3';
                        chordElement.style.background = 'rgba(0, 40, 80, 0.8)';
                    });
                    
                    chordElement.addEventListener('mouseleave', () => {
                        chordElement.style.borderColor = '#4a6870';
                        chordElement.style.background = 'rgba(0, 30, 60, 0.6)';
                    });
                    
                    favoritesList.appendChild(chordElement);
                });
            }
            
            loadFavoriteIntoBuilder(favoriteChord) {
                // Load name
                document.getElementById('chordBuilderName').value = favoriteChord.name;
                
                // Load pattern
                if (favoriteChord.intervals) {
                    this.loadChordPatternIntoBuilder(favoriteChord.intervals);
                }
            }
            
            saveChordFromBuilder() {
                const name = document.getElementById('chordBuilderName').value.trim();
                const selectedIntervals = this.getSelectedChordIntervals();
                
                if (!name || selectedIntervals.length <= 1) {
                    alert('Please enter a chord name and select at least one interval beyond the root.');
                    return;
                }
                
                // Use flavor-only name (no root injection)
                const newChord = {
                    name: name,
                    intervals: selectedIntervals,
                    isCustom: true,
                    id: Date.now(), // Unique ID
                    root: this.currentRoot || 0,
                    tuning: this.currentTuning || 12
                };
                
                if (this.currentEditingChord) {
                    // Update existing chord
                    this.updateExistingChord(newChord);
                } else {
                    // Use addChordColumn to automatically generate 3 chord qualities
                    this.addChordColumn(newChord);
                }
                
                // Custom chords are automatically added to extensions, no separate dropdown needed
                
                this.closeChordBuilder();
                
                console.log(`Saved custom chord: ${name} with auto-generated 3 qualities`);
            }
            
            getSelectedBuilderNotes() {
                // For backward compatibility, use the new checkbox system
                return this.getSelectedChordIntervals();
            }
            
            addBuilderChordToFavorites() {
                const name = document.getElementById('chordBuilderName').value.trim();
                const selectedNotes = this.getSelectedBuilderNotes();
                
                if (!name || selectedNotes.length === 0) {
                    alert('Please enter a chord name and select notes first.');
                    return;
                }
                
                const favoriteChord = {
                    name: name,
                    intervals: selectedNotes,
                    quality: this.currentQuality,
                    root: this.currentRoot,
                    tuning: this.currentTuning
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    JSON.stringify(fav.intervals) === JSON.stringify(favoriteChord.intervals)
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    this.updateBuilderFavoritesDisplay();
                    alert(`Added "${favoriteChord.name}" to favorites!`);
                } else {
                    alert('This chord is already in your favorites.');
                }
            }
            
            previewBuilderChord() {
                const selectedNotes = this.getSelectedBuilderNotes();
                if (selectedNotes.length === 0) {
                    alert('Please select some notes first.');
                    return;
                }
                
                // Play the chord
                selectedNotes.forEach((interval, index) => {
                    setTimeout(() => {
                        const frequency = this.getFrequency(this.semitoneToEDOStep(interval), 4);
                        const mockElement = { classList: { add: () => {}, remove: () => {} } };
                        this.playFrequency(frequency, mockElement, 'chord');
                        
                        // Stop after a short duration
                        setTimeout(() => {
                            this.stopFrequency(frequency, mockElement);
                        }, 1000);
                    }, index * 50); // Slight arpeggiation
                });
            }
            
            clearChordBuilder() {
                // Stop any active previews
                this.stopPreview();
                
                document.getElementById('chordBuilderName').value = '';
                
                // Uncheck all extension checkboxes
                document.querySelectorAll('#chordExtensionsCheckboxes input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Uncheck all microtonal checkboxes
                document.querySelectorAll('#microtonalCheckboxes input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Update preview
                this.updateChordPreview();
            }
            
            closeChordBuilder() {
                // Stop any active previews
                this.stopPreview();
                
                document.getElementById('chordBuilderModal').style.display = 'none';
                this.currentEditingChord = null;
                // Autosave on tap-out: if we were editing via selectedIntervals, commit in place
                if (this.isChordCreationMode && this.selectedIntervals && this.selectedIntervals.length > 1) {
                    const edo = this.currentTuning || 12;
                    const absSteps = this.selectedIntervals.map(iv => ((iv % edo) + edo) % edo);
                    const pendingName = this.computeFullChordNameFromAbsoluteSteps(absSteps, edo);
                    this.finalizePreviewChord(pendingName);
                }
                this.isChordCreationMode = false;
            }
            
            updateTuningSystem(divisions) {
                const previousTuning = this.currentTuning;
                this.currentTuning = divisions;
                this.gamelanMode = false;
                this.generateRootButtons();
                // Remap custom chords to nearest neighbors in new tuning
                try {
                    this.remapCustomChordsToNearestNeighbors(previousTuning, this.currentTuning);
                } catch (e) { console.warn('Remap skipped:', e); }
                // Update visible column headers to the new tuning preserving pitch/quality
                try {
                    this.relabelColumnsForNewTuning(previousTuning, this.currentTuning);
                } catch (e) { console.warn('Relabel skipped:', e); }
                this.preserveLockedChordsAndRegenerate();
                
                // Update note selector if chord builder is open
                if (document.getElementById('chordBuilderModal').style.display === 'block') {
                    this.populateChordBuilderNoteSelector();
                }
                
                // Auto-close the TUNING popup/panel after applying
                if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
                try { this._renderAllBellsBars(); } catch(_) { }
            }

            // Remap custom-chord intervals using each chord's ORIGINAL EDO baseline to nearest neighbors in the new EDO.
            remapCustomChordsToNearestNeighbors(fromEdo, toEdo) {
                if (!Array.isArray(this.chordExtensions) || !toEdo) return;
                const clampEdo = (n)=> Math.max(5, Math.min(53, parseInt(n||0))) || 12;
                const mapStepFromTo = (step, srcEdo, dstEdo) => {
                    if (!srcEdo || srcEdo === dstEdo) return ((step % dstEdo) + dstEdo) % dstEdo;
                    const cents = (step / srcEdo) * 1200;
                    const mapped = Math.round((cents / 1200) * dstEdo);
                    return ((mapped % dstEdo) + dstEdo) % dstEdo;
                };
                this.chordExtensions = this.chordExtensions.map(ch => {
                    if (!ch || !ch.isCustom) return ch;
                    // Establish original baseline: source EDO and original relative intervals
                    const srcEdo = clampEdo(ch.originalTuning || ch.fixedRootTuning || fromEdo || this.currentTuning);
                    const sourceIntervals = (Array.isArray(ch.originalIntervals) && ch.originalIntervals.length)
                        ? ch.originalIntervals.slice()
                        : (Array.isArray(ch.intervals) ? ch.intervals.slice() : [0]);
                    // Ensure we remember the baseline for future remaps
                    const ensureOriginal = (!Array.isArray(ch.originalIntervals) || ch.originalIntervals.length === 0);
                    // Map each original interval to the destination EDO
                    let mappedIntervals = sourceIntervals.map(s => mapStepFromTo(((s % srcEdo)+srcEdo)%srcEdo, srcEdo, toEdo));
                    if (!mappedIntervals.includes(0)) mappedIntervals.unshift(0);
                    const uniqueSorted = [...new Set(mappedIntervals)].sort((a,b)=>a-b);
                    // Re-anchor the fixed root to the equivalent step in the destination EDO
                    let newFixedRoot = 0;
                    let hadFixed = false;
                    if (typeof ch.fixedRootStepAbs === 'number') {
                        const srcForRoot = clampEdo(ch.fixedRootTuning || srcEdo);
                        newFixedRoot = mapStepFromTo(((ch.fixedRootStepAbs % srcForRoot)+srcForRoot)%srcForRoot, srcForRoot, toEdo);
                        hadFixed = true;
                    }
                    const next = {
                        ...ch,
                        intervals: uniqueSorted,
                        lastTuning: toEdo,
                        ...(hadFixed ? { fixedRootStepAbs: newFixedRoot, fixedRootTuning: toEdo } : {})
                    };
                    if (ensureOriginal) {
                        next.originalIntervals = sourceIntervals.slice();
                        next.originalTuning = srcEdo;
                    }
                    return next;
                });
            }

            // After changing EDO, relabel each unlocked column to keep root at 0 semantics and preserve quality
            relabelColumnsForNewTuning(fromEdo, toEdo) {
                const edo = toEdo || this.currentTuning || 12;
                document.querySelectorAll('.extension-column').forEach(col => {
                    const nameEl = col.querySelector('.extension-header .chord-name');
                    if (!nameEl) return;
                    const isLocked = nameEl.dataset.isLocked === 'true';
                    if (isLocked) return; // leave locked headers as-is; pitch is preserved by snapshot

                    // Resolve chord model
                    let model = null;
                    try {
                        const id = col.dataset.chordId;
                        let idx = -1;
                        if (id) idx = (this.chordExtensions||[]).findIndex(c=> c && (String(c.id)===String(id)));
                        if (idx < 0 && col.dataset.originalPosition != null) {
                            const op = parseInt(col.dataset.originalPosition,10);
                            if (!isNaN(op) && op >= 0) idx = op;
                        }
                        if (idx >= 0) model = (this.chordExtensions||[])[idx];
                    } catch(_) {}

                    const label = (nameEl.dataset.lockedName || nameEl.textContent || '').trim();
                    // Parse root and any ^/v local transpose decorations
                    let baseStep = 0;
                    let arrowDelta = 0;
                    const m = label.match(/^([A-G])([#b]?)([\^vâ†‘â†“]*)/);
                    if (m) {
                        const semi = this.rootToSemitone(m[1], m[2]||'');
                        baseStep = this.semitoneToStep(semi, edo);
                        const ups = (m[3].match(/[\^â†‘]/g) || []).length;
                        const downs = (m[3].match(/[vâ†“]/g) || []).length;
                        arrowDelta = ups - downs;
                    }

                    // Build degree steps in new EDO
                    let degrees = [];
                    if (model && Array.isArray(model.intervals) && model.intervals.length) {
                        if (model.isCustom) {
                            // Custom intervals are already steps and were remapped above
                            degrees = model.intervals.slice();
                        } else {
                            // Map semitone intervals to new EDO steps
                            degrees = model.intervals.map(iv => this.mapIntervalToEDO(iv, edo));
                        }
                    } else {
                        // Fallback: try to infer a simple triad (Major by default)
                        degrees = [0, this.mapIntervalToEDO(4, edo), this.mapIntervalToEDO(7, edo)];
                    }
                    // Ensure root at 0 and dedupe/sort
                    degrees = Array.from(new Set([0, ...degrees.map(x=> ((x%edo)+edo)%edo)])).sort((a,b)=>a-b);

                    // Compose absolute steps with local arrows; global transpose is added inside naming
                    const rootStep = (((baseStep + arrowDelta) % edo) + edo) % edo;
                    const abs = [rootStep, ...degrees.filter(x=>x!==0).map(iv => (rootStep + iv) % edo)];
                    const labelNew = this.computeFullChordNameFromAbsoluteSteps(
                        abs,
                        edo,
                        null,
                        (model && model.preferredRootName) ? model.preferredRootName : null,
                        (model && model.preferredBassRel != null) ? model.preferredBassRel : null
                    ) || label;

                    nameEl.textContent = labelNew;
                    nameEl.dataset.lockedName = labelNew;
                });
            }
            
            
            addChordColumn(chordData) {
                // When adding a new chord, automatically create ONE Major, ONE Minor, ONE Neutral
                if (chordData.intervals && chordData.intervals.length > 0) {
                    // Auto-generate 3 qualities for the new chord with color gradients
                    this.autoGenerateChordQualities(chordData);
                } else {
                    // For standard chord extensions without specific intervals
                    this.chordExtensions.push(chordData);
                    this.saveChordConfiguration(); // Use consistent save method
                }
                
                // Regenerate the columns to show the new chord variations
                this.preserveLockedChordsAndRegenerate();
                
                console.log(`Added chord column: ${chordData.name} with auto-generated qualities`);
            }
            
            autoGenerateChordQualities(chordData) {
                // Automatically create Major, Minor, and Neutral variants with color gradients
                const qualities = [
                    { 
                        name: 'major', 
                        suffix: 'Maj', 
                        color: { bg: '#1e40af', border: '#3b82f6' }, // Blue for Major
                        intervals: chordData.intervals 
                    },
                    { 
                        name: 'minor', 
                        suffix: 'Min', 
                        color: { bg: '#dc2626', border: '#ef4444' }, // Red for Minor
                        intervals: this.convertToMinorIntervals(chordData.intervals)
                    },
                    { 
                        name: 'neutral', 
                        suffix: 'Neu', 
                        color: { bg: '#059669', border: '#10b981' }, // Green for Neutral
                        intervals: this.convertToNeutralIntervals(chordData.intervals)
                    }
                ];
                
        qualities.forEach(quality => {
                    const qualityChord = {
            name: `${chordData.name}${quality.suffix}`,
                        originalName: chordData.name,
                        intervals: quality.intervals,
                        quality: quality.name,
                        isCustom: true,
                        color: quality.color,
            baseIntervals: chordData.intervals,
            root: chordData.root ?? this.currentRoot ?? 0,
            tuning: chordData.tuning ?? this.currentTuning ?? 12
                    };
                    
                    // Add to chord extensions for the 3-column layout
                    this.chordExtensions.push(qualityChord);
                });
                
                // Save the updated chord extensions
                this.saveChordConfiguration(); // Use consistent save method
                
                console.log(`Auto-generated 3 qualities for: ${chordData.name}`);
            }
            
            convertToMinorIntervals(intervals) {
                // Convert major intervals to minor by flattening the third
                return intervals.map(interval => {
                    if (interval === 4) return 3; // Major 3rd to minor 3rd
                    if (interval === 11) return 10; // Major 7th to minor 7th
                    return interval;
                });
            }
            
            convertToNeutralIntervals(intervals) {
                // Convert intervals to neutral by using quarter-tones
                return intervals.map(interval => {
                    if (interval === 4) return 3.5; // Major 3rd to neutral 3rd
                    if (interval === 3) return 3.5; // Minor 3rd to neutral 3rd
                    if (interval === 11) return 10.5; // Major 7th to neutral 7th
                    if (interval === 10) return 10.5; // Minor 7th to neutral 7th
                    return interval;
                });
            }
            
            updateExistingChord(newChordData) {
                if (this.currentEditingChord.isCustom) {
                    const index = this.customChords.findIndex(c => c.id === this.currentEditingChord.id);
                    if (index !== -1) {
                        const prev = this.customChords[index] || {};
                        this.customChords[index] = { ...prev, ...newChordData, id: this.currentEditingChord.id, root: prev.root ?? this.currentRoot, tuning: prev.tuning ?? this.currentTuning };
                    }
                } else {
                    const index = this.chordExtensions.findIndex(c => c.name === this.currentEditingChord.name);
                    if (index !== -1) {
                        const prev = this.chordExtensions[index] || {};
                        this.chordExtensions[index] = { ...prev, ...newChordData, root: prev.root ?? this.currentRoot, tuning: prev.tuning ?? this.currentTuning };
                        this.saveChordConfiguration(); // Use consistent save method
                    }
                }
                
                this.preserveLockedChordsAndRegenerate();
                console.log(`Updated chord: ${newChordData.name}`);
            }

        async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = this.volume * this.masterVolume; // Apply both volume and master volume at start
                    
                    // Create simple reverb
                    this.createReverb();
                    
            // Create wet gain for reverb send and a master-controlled dry output gain
        this.wetGainNode = this.audioContext.createGain();
        this.dryGainNode = this.audioContext.createGain();
        // Clamp wet to [0,1]
        const wet = Math.max(0, Math.min(1, Number.isFinite(this.reverb.wet) ? this.reverb.wet : 0.0));
        this.wetGainNode.gain.value = wet; // Amount sent into reverb
        // Dry path is governed by master volume, not (1-wet)
        this.dryGainNode.gain.value = this.masterVolume;
                    
                    // Create reverb filters: HP then LP after convolver
                    this.reverbHpNode = this.audioContext.createBiquadFilter();
                    this.reverbHpNode.type = 'highpass';
                    this.reverbHpNode.frequency.value = 20;
                    this.reverbHpNode.Q.value = 0.707;
                    this.reverbFilterNode = this.audioContext.createBiquadFilter();
                    this.reverbFilterNode.type = 'lowpass';
                    this.reverbFilterNode.frequency.value = Math.max(100, Math.min(20000, Number.isFinite(this.reverb.filterCutoff) ? this.reverb.filterCutoff : 8000));
                    this.reverbFilterNode.Q.value = 1;
                    
                    // Global Drive (first in chain after summing all notes)
                    this._drive = {
                        pre: this.audioContext.createGain(),
                        shaper: this.audioContext.createWaveShaper(),
                        // Per-effect tone for drive wet path: HP -> LP
                        hp: this.audioContext.createBiquadFilter(),
                        lp: this.audioContext.createBiquadFilter(),
                        post: this.audioContext.createGain(),
                        dry: this.audioContext.createGain(),
                        wet: this.audioContext.createGain(),
                        mix: this.audioContext.createGain()
                    };
                    this._drive.hp.type = 'highpass'; this._drive.hp.frequency.value = 20; this._drive.hp.Q.value = 0.707;
                    this._drive.lp.type = 'lowpass'; this._drive.lp.frequency.value = 20000; this._drive.lp.Q.value = 0.707;
                    // Default mix states
                    this._drive.dry.gain.value = 1;
                    this._drive.wet.gain.value = 0;
                    this._drive.mix.gain.value = 1;
                    // Build updateDrive helper for curve, mix, and output compensation
                    this.updateDrive = () => {
                        const amt = Math.max(0, Math.min(100, this.drive?.amount || 0)) / 100;
                        const mix = Math.max(0, Math.min(100, this.drive?.mix || 0)) / 100;
                        // Stronger curve range using arctangent shaper-like curve
                        const n = 2048; const curve = new Float32Array(n);
                        const k = 1 + amt * 24; // extend range
                        for (let i=0;i<n;i++){
                            const x = i/(n-1)*2-1; // -1..1
                            curve[i] = Math.tanh(k * x);
                        }
                        this._drive.shaper.curve = curve; this._drive.shaper.oversample = '4x';
                        // Perceived-loudness autogain: approximate inverse of RMS growth
                        const comp = 1 / Math.sqrt(1 + k*0.6);
                        this._drive.post.gain.value = comp;
                        // Mix
                        this._drive.dry.gain.value = 1 - mix;
                        this._drive.wet.gain.value = mix;
                    };
                    this.updateDrive();

                    // BELLS FUZZ (used when GLIDE is enabled)
                    this._bellsFuzz = {
                        input: this.audioContext.createGain(),
                        shaper: this.audioContext.createWaveShaper(),
                        hp: this.audioContext.createBiquadFilter(),
                        lp: this.audioContext.createBiquadFilter(),
                        post: this.audioContext.createGain(),
                        amount: 0
                    };
                    this._bellsFuzz.hp.type = 'highpass';
                    this._bellsFuzz.hp.frequency.value = 40;
                    this._bellsFuzz.hp.Q.value = 0.707;
                    this._bellsFuzz.lp.type = 'lowpass';
                    this._bellsFuzz.lp.frequency.value = 14000;
                    this._bellsFuzz.lp.Q.value = 0.707;
                    this._bellsFuzz.input.gain.value = 1;
                    this._bellsFuzz.post.gain.value = 1;
                    this._bellsFuzz.input.connect(this._bellsFuzz.shaper);
                    this._bellsFuzz.shaper.connect(this._bellsFuzz.hp);
                    this._bellsFuzz.hp.connect(this._bellsFuzz.lp);
                    this._bellsFuzz.lp.connect(this._bellsFuzz.post);
                    // Connect fuzz output to the main FX chain; only used when routed
                    this._bellsFuzz.post.connect(this.gainNode);
                    this.updateBellsFuzz = () => {
                        if (!this._bellsFuzz) return;
                        const amt = Math.max(0, Math.min(100, Number(this._bellsFuzz.amount) || 0)) / 100;
                        const n = 2048;
                        const curve = new Float32Array(n);
                        const k = 1 + amt * 28;
                        for (let i = 0; i < n; i++) {
                            const x = (i / (n - 1)) * 2 - 1;
                            curve[i] = Math.tanh(k * x);
                        }
                        this._bellsFuzz.shaper.curve = curve;
                        this._bellsFuzz.shaper.oversample = '4x';
                        // Auto gain compensation
                        const comp = 1 / Math.sqrt(1 + k * 0.8);
                        this._bellsFuzz.post.gain.value = comp;
                        // Pre gain to push harder as fuzz increases
                        this._bellsFuzz.input.gain.value = 1 + amt * 1.5;
                    };
                    this.updateBellsFuzz();

                    // Master routing: sum â†’ Drive (first) â†’ Delay â†’ PostDelayMix â†’ HP â†’ LP â†’ Output
                    // Reverb taps after Delay (very last stage) and goes straight to output
                    // Drive split/mix
                    this.gainNode.connect(this._drive.pre);
                    this.gainNode.connect(this._drive.dry);
                    this._drive.pre.connect(this._drive.shaper);
                    // Drive wet tone: shaper -> hp -> lp -> post -> wet
                    this._drive.shaper.connect(this._drive.hp);
                    this._drive.hp.connect(this._drive.lp);
                    this._drive.lp.connect(this._drive.post);
                    this._drive.post.connect(this._drive.wet);
                    this._drive.dry.connect(this._drive.mix);
                    this._drive.wet.connect(this._drive.mix);

                    // Global Delay with filtered feedback and wet/dry mix
                    this._delay = {
                        node: this.audioContext.createDelay(120.0),
                        feedback: this.audioContext.createGain(),
                        // Feedback loop tone (LP) and wet-path tone (HP/LP)
                        filter: this.audioContext.createBiquadFilter(),
                        wetHp: this.audioContext.createBiquadFilter(),
                        wetLp: this.audioContext.createBiquadFilter(),
                        wet: this.audioContext.createGain(),
                        dry: this.audioContext.createGain(),
                        mix: this.audioContext.createGain()
                    };
                    this._delay.node.delayTime.value = 0.28; // 280ms
                    this._delay.feedback.gain.value = 0.25;
                    this._delay.filter.type = 'lowpass';
                    this._delay.filter.frequency.value = 6000;
                    // Delay wet path tone defaults
                    this._delay.wetHp.type = 'highpass'; this._delay.wetHp.frequency.value = 20; this._delay.wetHp.Q.value = 0.707;
                    this._delay.wetLp.type = 'lowpass'; this._delay.wetLp.frequency.value = 6000; this._delay.wetLp.Q.value = 0.707;
                    this._delay.wet.gain.value = 0.0; // start bypassed
                    this._delay.dry.gain.value = 1.0;
                    this._delay.mix.gain.value = 1.0;
                    // Wire delay split
                    this._drive.mix.connect(this._delay.dry);
                    this._drive.mix.connect(this._delay.node);
                    this._delay.node.connect(this._delay.filter);
                    this._delay.filter.connect(this._delay.feedback);
                    this._delay.feedback.connect(this._delay.node);
                    // Delay wet chain: node â†’ wetHp â†’ wetLp â†’ wet
                    this._delay.node.connect(this._delay.wetHp);
                    this._delay.wetHp.connect(this._delay.wetLp);
                    this._delay.wetLp.connect(this._delay.wet);
                    // Sum delay wet/dry
                    this._postDelayMix = this.audioContext.createGain();
                    this._postDelayMix.gain.value = 1.0;
                    this._delay.dry.connect(this._postDelayMix);
                    this._delay.wet.connect(this._postDelayMix);

                    // Final filters at end of chain (HP then LP)
                    this._finalHP = this.audioContext.createBiquadFilter();
                    this._finalHP.type = 'highpass';
                    this._finalHP.frequency.value = 20;
                    this._finalLP = this.audioContext.createBiquadFilter();
                    this._finalLP.type = 'lowpass';
                    this._finalLP.frequency.value = 20000;
                    this._postDelayMix.connect(this._finalHP);
                    this._finalHP.connect(this._finalLP);
                    this._finalLP.connect(this.dryGainNode);

                    // Reverb taps after delay and is last to output
                    this._postDelayMix.connect(this.wetGainNode);
                    this.dryGainNode.connect(this.audioContext.destination);
                    this.wetGainNode.connect(this.reverbNode);
                    this.reverbNode.connect(this.reverbHpNode);
                    this.reverbHpNode.connect(this.reverbFilterNode);
                    // Add a dedicated reverb output gain so MASTER affects reverb too
                    this.reverbOutGain = this.audioContext.createGain();
                    this.reverbOutGain.gain.value = this.masterVolume;
                    this.reverbFilterNode.connect(this.reverbOutGain);
                    this.reverbOutGain.connect(this.audioContext.destination);

                    // Helper to bypass convolver when wet=0 to save CPU
                    this.updateReverbRouting = () => {
                        try {
                            const isWet = (this.reverb?.wet || 0) > 0.0001;
                            // Ensure base connections exist
                            if (!this.wetGainNode || !this.reverbNode || !this.reverbFilterNode || !this.reverbHpNode || !this.reverbOutGain) return;
                            // Disconnect all from wet chain first
                            try { this.wetGainNode.disconnect(); } catch {}
                            try { this.reverbNode.disconnect(); } catch {}
                            try { this.reverbHpNode.disconnect(); } catch {}
                            try { this.reverbFilterNode.disconnect(); } catch {}
                            if (isWet) {
                                // Enable wet path
                                this.wetGainNode.connect(this.reverbNode);
                                this.reverbNode.connect(this.reverbHpNode);
                                this.reverbHpNode.connect(this.reverbFilterNode);
                                this.reverbFilterNode.connect(this.reverbOutGain);
                            } else {
                                // Keep wetGainNode disconnected when wet=0
                                // Dry path already connected
                            }
                        } catch {}
                    };
                    // Apply initial routing state
                    this.updateReverbRouting();

                    // ---- DRUM FX BUS (dedicated; not the main instrument FX chain) ----
                    try {
                        const clamp01 = (v)=> Math.max(0, Math.min(1, Number(v) || 0));
                        const clampHz = (v, lo, hi)=> Math.max(lo, Math.min(hi, Number(v) || lo));

                        this._drumBus = this._drumBus || {};
                        this._drumBus.drySum = this.audioContext.createGain();
                        this._drumBus.sendSum = this.audioContext.createGain();
                        this._drumBus.out = this.audioContext.createGain();

                        // Saturation (fixed curve) with HP/LP tone on the wet path and a wet mix
                        this._drumBus.sat = {
                            pre: this.audioContext.createGain(),
                            shaper: this.audioContext.createWaveShaper(),
                            hp: this.audioContext.createBiquadFilter(),
                            lp: this.audioContext.createBiquadFilter(),
                            post: this.audioContext.createGain(),
                            dry: this.audioContext.createGain(),
                            wet: this.audioContext.createGain(),
                            mix: this.audioContext.createGain()
                        };
                        this._drumBus.sat.hp.type = 'highpass';
                        this._drumBus.sat.lp.type = 'lowpass';
                        // Build a moderately gentle tanh curve
                        const n = 2048;
                        const curve = new Float32Array(n);
                        const k = 3.0;
                        for (let i=0;i<n;i++){
                            const x = (i/(n-1))*2-1;
                            curve[i] = Math.tanh(k * x);
                        }
                        this._drumBus.sat.shaper.curve = curve;
                        this._drumBus.sat.shaper.oversample = '2x';

                        // Wire saturation
                        this._drumBus.sendSum.connect(this._drumBus.sat.pre);
                        this._drumBus.sendSum.connect(this._drumBus.sat.dry);
                        this._drumBus.sat.pre.connect(this._drumBus.sat.shaper);
                        this._drumBus.sat.shaper.connect(this._drumBus.sat.hp);
                        this._drumBus.sat.hp.connect(this._drumBus.sat.lp);
                        this._drumBus.sat.lp.connect(this._drumBus.sat.post);
                        this._drumBus.sat.post.connect(this._drumBus.sat.wet);
                        this._drumBus.sat.dry.connect(this._drumBus.sat.mix);
                        this._drumBus.sat.wet.connect(this._drumBus.sat.mix);

                        // Compressor
                        this._drumBus.comp = this.audioContext.createDynamicsCompressor();
                        this._drumBus.compOut = this.audioContext.createGain();
                        this._drumBus.sat.mix.connect(this._drumBus.comp);
                        this._drumBus.comp.connect(this._drumBus.compOut);

                        // Delay (wet/dry mix)
                        this._drumBus.delay = {
                            node: this.audioContext.createDelay(8.0),
                            feedback: this.audioContext.createGain(),
                            wet: this.audioContext.createGain(),
                            dry: this.audioContext.createGain(),
                            mixOut: this.audioContext.createGain()
                        };
                        this._drumBus.compOut.connect(this._drumBus.delay.dry);
                        this._drumBus.compOut.connect(this._drumBus.delay.node);
                        this._drumBus.delay.node.connect(this._drumBus.delay.feedback);
                        this._drumBus.delay.feedback.connect(this._drumBus.delay.node);
                        this._drumBus.delay.node.connect(this._drumBus.delay.wet);
                        this._drumBus.delay.dry.connect(this._drumBus.delay.mixOut);
                        this._drumBus.delay.wet.connect(this._drumBus.delay.mixOut);

                        // Reverb (wet mix; does not attenuate dry)
                        this._drumBus.reverb = {
                            in: this.audioContext.createGain(),
                            node: this.audioContext.createConvolver(),
                            hp: this.audioContext.createBiquadFilter(),
                            lp: this.audioContext.createBiquadFilter(),
                            wet: this.audioContext.createGain(),
                            dry: this.audioContext.createGain(),
                            mix: this.audioContext.createGain()
                        };
                        this._drumBus.reverb.hp.type = 'highpass';
                        this._drumBus.reverb.lp.type = 'lowpass';
                        this._drumBus.delay.mixOut.connect(this._drumBus.reverb.in);
                        this._drumBus.reverb.in.connect(this._drumBus.reverb.dry);
                        this._drumBus.reverb.in.connect(this._drumBus.reverb.node);
                        this._drumBus.reverb.node.connect(this._drumBus.reverb.hp);
                        this._drumBus.reverb.hp.connect(this._drumBus.reverb.lp);
                        this._drumBus.reverb.lp.connect(this._drumBus.reverb.wet);
                        this._drumBus.reverb.dry.connect(this._drumBus.reverb.mix);
                        this._drumBus.reverb.wet.connect(this._drumBus.reverb.mix);

                        // Final routing: dry drums + FX output â†’ drum out â†’ destination
                        this._drumBus.drySum.connect(this._drumBus.out);
                        this._drumBus.reverb.mix.connect(this._drumBus.out);
                        this._drumBus.out.connect(this.audioContext.destination);

                        // (Re)build drum reverb impulse based on drumFx state
                        this._rebuildDrumReverb = () => {
                            try {
                                if (!this.audioContext || !this._drumBus || !this._drumBus.reverb) return;
                                const rv = this.drumFx && this.drumFx.reverb ? this.drumFx.reverb : {};
                                const decaySec = Math.max(0.01, Number(rv.decay) || 0.5);
                                const roomSize = Math.max(0, Math.min(1, Number(rv.room) || 0.5));
                                const length = Math.max(1, Math.floor(this.audioContext.sampleRate * decaySec));
                                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                                for (let ch=0; ch<2; ch++){
                                    const data = impulse.getChannelData(ch);
                                    for (let i=0; i<length; i++){
                                        const n = length - i;
                                        data[i] = (Math.random() * 2 - 1) * Math.pow(n / length, roomSize);
                                    }
                                }
                                this._drumBus.reverb.node.buffer = impulse;
                            } catch(_){ }
                        };

                        this.updateDrumOutGain = () => {
                            try {
                                if (!this._drumBus || !this._drumBus.out) return;
                                const out = Math.max(0, Math.min(2, Number(this.drumFx?.out ?? 1.0) || 1.0));
                                const master = (this.masterVolume || 1);
                                this._drumBus.out.gain.value = out * master;
                            } catch(_){ }
                        };

                        this.updateDrumFx = () => {
                            try {
                                const sat = this.drumFx?.sat || {};
                                const comp = this.drumFx?.comp || {};
                                const dly = this.drumFx?.delay || {};
                                const rv = this.drumFx?.reverb || {};

                                // Saturation
                                const satMix = clamp01(sat.mix);
                                if (this._drumBus?.sat?.wet) this._drumBus.sat.wet.gain.value = satMix;
                                if (this._drumBus?.sat?.dry) this._drumBus.sat.dry.gain.value = 1;
                                if (this._drumBus?.sat?.hp) this._drumBus.sat.hp.frequency.value = clampHz(sat.hp, 20, 2000);
                                if (this._drumBus?.sat?.lp) this._drumBus.sat.lp.frequency.value = clampHz(sat.lp, 200, 20000);

                                // Compressor
                                if (this._drumBus?.comp) {
                                    this._drumBus.comp.threshold.value = Math.max(-100, Math.min(0, Number(comp.threshold) || -24));
                                    this._drumBus.comp.attack.value = Math.max(0.001, Math.min(1.0, Number(comp.attack) || 0.003));
                                    this._drumBus.comp.release.value = Math.max(0.01, Math.min(1.0, Number(comp.release) || 0.25));
                                    this._drumBus.comp.ratio.value = Math.max(1, Math.min(20, Number(comp.ratio) || 4));
                                }
                                if (this._drumBus?.compOut) {
                                    // output is in linear gain; accept dB-ish range -24..+24 mapped to gain
                                    const outDb = Math.max(-24, Math.min(24, Number(comp.output) || 0));
                                    this._drumBus.compOut.gain.value = Math.pow(10, outDb/20);
                                }

                                // Delay
                                if (this._drumBus?.delay?.node) this._drumBus.delay.node.delayTime.value = Math.max(0.01, Math.min(8.0, (Number(dly.timeMs)||180)/1000));
                                if (this._drumBus?.delay?.feedback) this._drumBus.delay.feedback.gain.value = Math.max(0, Math.min(0.95, Number(dly.feedback) || 0.25));
                                if (this._drumBus?.delay?.wet) this._drumBus.delay.wet.gain.value = clamp01(dly.mix);
                                if (this._drumBus?.delay?.dry) this._drumBus.delay.dry.gain.value = 1;

                                // Reverb tone + wet
                                if (this._drumBus?.reverb?.hp) this._drumBus.reverb.hp.frequency.value = clampHz(rv.hp, 20, 2000);
                                if (this._drumBus?.reverb?.lp) this._drumBus.reverb.lp.frequency.value = clampHz(rv.lp, 200, 20000);
                                if (this._drumBus?.reverb?.wet) this._drumBus.reverb.wet.gain.value = clamp01(rv.wet);
                                if (this._drumBus?.reverb?.dry) this._drumBus.reverb.dry.gain.value = 1;
                                this._rebuildDrumReverb && this._rebuildDrumReverb();

                                this.updateDrumOutGain && this.updateDrumOutGain();
                            } catch(_){ }
                        };
                        // Apply initial drum FX state
                        this.updateDrumFx();
                    } catch (e) {
                        console.warn('Drum FX init skipped:', e);
                    }
                    
                    // Store the initial clean state for piano lock system
                    this.storeOriginalUIState();
                    console.log('ðŸŽ¹ Stored original UI state for piano lock system');
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                }
            }

            // Ensure AudioContext exists and is running before attempting playback
        async ensureAudioContext() {
                try {
                    if (!this.audioContext) await this.initAudio();
                    if (!this.audioContext) return false;
                    if (this.audioContext.state === 'suspended') {
                        try {
                            await this.audioContext.resume();
                            console.log('AudioContext resumed');
                        } catch (e) {
                            console.warn('Failed to resume AudioContext:', e);
                            return false;
                        }
                    }
                    return this.audioContext.state === 'running';
                } catch (e) {
                    console.warn('ensureAudioContext error:', e);
                    return false;
                }
            }

            createReverb() {
                const convolver = this.audioContext.createConvolver();
                // Ensure a non-zero impulse length to avoid AudioBuffer errors when decay is 0
                const decaySec = Math.max(0.01, Number.isFinite(this.reverb.decay) ? this.reverb.decay : 0.3);
                const length = Math.max(1, Math.floor(this.audioContext.sampleRate * decaySec));
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const n = length - i;
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, this.reverb.roomSize);
                    }
                }
                
                convolver.buffer = impulse;
                this.reverbNode = convolver;
            }

            createNoiseSource() {
                // Brown (Brownian) noise: integrate white noise with slight damping; looped buffer
                const seconds = 3; // longer to minimize loop artifacts
                // Reuse a cached noise buffer to reduce per-note allocations
                if (!this._noiseBuffer || this._noiseBuffer.sampleRate !== this.audioContext.sampleRate) {
                    const bufferSize = Math.max(1, Math.floor(this.audioContext.sampleRate * seconds));
                    const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const out = noiseBuffer.getChannelData(0);
                    let last = 0;
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1; // [-1, 1]
                        // Leaky integrator to avoid DC drift; tuning keeps spectrum ~1/f^2
                        last = (last + white) * 0.995; // slight damping
                        // Scale down to safe amplitude
                        out[i] = last * 0.1;
                    }
                    this._noiseBuffer = noiseBuffer;
                }
                const brownNoise = this.audioContext.createBufferSource();
                brownNoise.buffer = this._noiseBuffer;
                brownNoise.loop = true;
                return brownNoise;
            }

            // Build or fetch a cached PeriodicWave for custom oscillator shapes.
            // type includes: 'sine','sawtooth','square','pulse','fullrect','halfrect','parabolic','stair'
            // pulseWidth: only applies to 'pulse' (0..1), default 0.5
            // width: used for sine/saw/square skewing (0..1), default 0.5
            getCustomPeriodicWave(type, pulseWidth = 0.5, width = 0.5) {
                if (!this.audioContext) return null;
                const key = `${type}:${type === 'pulse' ? Math.max(0.01, Math.min(0.99, pulseWidth || 0.5)).toFixed(3) : 'std'}:${Math.max(0.0, Math.min(1.0, width ?? 0.5)).toFixed(3)}`;
                if (this._customWaveCache.has(key)) return this._customWaveCache.get(key);

                let real = null, imag = null;
                const N = 64; // number of harmonics to include

                switch (type) {
                    case 'sine': {
                        const w = Math.max(0.0, Math.min(1.0, width ?? 0.5));
                        // Phase-skewed sine per hint
                        return this._buildSampledPeriodicWave(x => {
                            const phase = ((x / (2 * Math.PI)) % 1 + 1) % 1;
                            const skewed = (phase < w)
                                ? (phase / w) * 0.5
                                : 0.5 + ((phase - w) / (1 - w)) * 0.5;
                            return Math.sin(skewed * 2 * Math.PI);
                        }, key);
                    }
                    case 'sawtooth': {
                        const w = Math.max(0.0, Math.min(1.0, width ?? 0.5));
                        // Phase-skewed saw per hint
                        return this._buildSampledPeriodicWave(x => {
                            const phase = ((x / (2 * Math.PI)) % 1 + 1) % 1;
                            const skewed = (phase < w)
                                ? (phase / w) * 0.5
                                : 0.5 + ((phase - w) / (1 - w)) * 0.5;
                            return 2 * skewed - 1;
                        }, key);
                    }
                    case 'square': {
                        const w = Math.max(0.01, Math.min(0.99, width ?? 0.5));
                        // PWM-style duty comparator
                        return this._buildSampledPeriodicWave(x => {
                            const phase = ((x / (2 * Math.PI)) % 1 + 1) % 1;
                            return (phase < w) ? 1 : -1;
                        }, key);
                    }
                    case 'pulse': {
                        const d = Math.max(0.01, Math.min(0.99, pulseWidth));
                        real = new Float32Array(N + 1);
                        imag = new Float32Array(N + 1);
                        real[0] = 0;
                        for (let n = 1; n <= N; n++) {
                            // Duty-cycle pulse: sine-only series, scaled by sin(n*pi*d)
                            const bn = (4 / (n * Math.PI)) * Math.sin(n * Math.PI * d);
                            imag[n] = bn;
                            real[n] = 0;
                        }
                        break;
                    }
                    case 'fullrect': {
                        // |sin| -> even harmonics cosine series
                        real = new Float32Array(N + 1);
                        imag = new Float32Array(N + 1);
                        for (let k = 1; k <= N / 2; k++) {
                            const n = 2 * k;
                            const a = -4 / (Math.PI * (4 * k * k - 1));
                            real[n] = a;
                            imag[n] = 0;
                        }
                        break;
                    }
                    case 'parabolic': {
                        // Curved saw-like; cosine series decaying as 1/n^2 with alternating sign
                        real = new Float32Array(N + 1);
                        imag = new Float32Array(N + 1);
                        for (let n = 1; n <= N; n++) {
                            real[n] = (n % 2 === 0 ? 1 : -1) * (1 / (n * n));
                            imag[n] = 0;
                        }
                        break;
                    }
                    case 'halfrect': {
                        // Half-wave rectified sine: better built via sampling then DFT
                        return this._buildSampledPeriodicWave(x => Math.max(0, Math.sin(x)) * 2 - 1, key);
                    }
                    
                    case 'stair': {
                        const steps = 8;
                        return this._buildSampledPeriodicWave(x => {
                            const t = ((x / (2 * Math.PI)) % 1 + 1) % 1;
                            const s = Math.floor(t * steps) / (steps - 1);
                            return s * 2 - 1;
                        }, key);
                    }
                    default: {
                        // Fallback to a mild saw series
                        real = new Float32Array(N + 1);
                        imag = new Float32Array(N + 1);
                        real[0] = 0;
                        for (let n = 1; n <= N; n++) {
                            imag[n] = -1 / n;
                        }
                    }
                }

                let wave = null;
                if (real && imag) {
                    try {
                        wave = this.audioContext.createPeriodicWave(real, imag, { disableNormalization: false });
                    } catch(_) {
                        // Older browsers don't support the options arg
                        wave = this.audioContext.createPeriodicWave(real, imag);
                    }
                }
                if (wave) this._customWaveCache.set(key, wave);
                return wave;
            }

            // Build a PeriodicWave from a sampled function using a naive DFT for first N harmonics
            _buildSampledPeriodicWave(sampleFn, cacheKey) {
                const S = 1024; // samples per period
                const samples = new Float32Array(S);
                for (let i = 0; i < S; i++) {
                    const x = (i / S) * 2 * Math.PI;
                    samples[i] = sampleFn(x);
                }
                // Remove DC offset
                let dc = 0;
                for (let i = 0; i < S; i++) dc += samples[i];
                dc /= S;
                for (let i = 0; i < S; i++) samples[i] -= dc;

                const N = 64;
                const real = new Float32Array(N + 1);
                const imag = new Float32Array(N + 1);
                real[0] = 0; imag[0] = 0;
                for (let n = 1; n <= N; n++) {
                    let a = 0, b = 0;
                    for (let i = 0; i < S; i++) {
                        const x = (i / S) * 2 * Math.PI;
                        const y = samples[i];
                        a += y * Math.cos(n * x);
                        b += y * Math.sin(n * x);
                    }
                    a = (2 / S) * a;
                    b = (2 / S) * b;
                    real[n] = a;
                    imag[n] = b;
                }
                let wave;
                try {
                    wave = this.audioContext.createPeriodicWave(real, imag, { disableNormalization: false });
                } catch(_) {
                    wave = this.audioContext.createPeriodicWave(real, imag);
                }
                this._customWaveCache.set(cacheKey, wave);
                return wave;
            }

            initEventListeners() {
                // Tuning system selection
                document.querySelectorAll('[data-tuning]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-tuning]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        const tuningValue = btn.dataset.tuning;
                        if (tuningValue === 'gamelan') {
                            // Gamelan pelog scale (7 notes)
                            this.currentTuning = 7;
                            this.gamelanMode = true;
                        } else {
                            this.currentTuning = parseInt(tuningValue);
                            this.gamelanMode = false;
                        }
                        
                        this.generateRootButtons();
                        this.preserveLockedChordsAndRegenerate();
                        this.updateChordDisplay();
                    });
                });

                // Quality selection
                document.querySelectorAll('[data-quality]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-quality]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentQuality = btn.dataset.quality;
                        this.preserveLockedChordsAndRegenerate();
                        this.updateChordDisplay();
                    });
                });


                // ADSR controls with value displays and proper limits
                const attackSlider = document.getElementById('attackSlider');
                if (attackSlider) {
                    attackSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.instruments.strum1.env.attack = Math.max(0.003, e.target.value / 1000); // 3ms minimum
                        console.log('?? Attack changed to:', this.instruments.strum1.env.attack);
                        const attackValue = document.getElementById('attackValue');
                        if (attackValue) {
                            attackValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('attackSlider not found');
                }
                
                const decaySlider = document.getElementById('decaySlider');
                if (decaySlider) {
                    decaySlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        // 0â€“1000ms â†’ 0â€“1s
                        const ms = Math.max(0, parseInt(e.target.value, 10) || 0);
                        this.instruments.strum1.env.decay = ms / 1000;
                        const decayValue = document.getElementById('decayValue');
                        if (decayValue) decayValue.textContent = `${ms}ms`;
                    });
                } else {
                    console.error('decaySlider not found');
                }
                
                const sustainSlider = document.getElementById('sustainSlider');
                if (sustainSlider) {
                    sustainSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        // 0â€“100% â†’ 0.00â€“1.0 level
                        const pct = Math.min(100, Math.max(0, parseInt(e.target.value, 10) || 0));
                        this.instruments.strum1.env.sustain = pct / 100;
                        const sustainValue = document.getElementById('sustainValue');
                        if (sustainValue) sustainValue.textContent = `${pct}%`;
                    });
                } else {
                    console.error('sustainSlider not found');
                }
                
                const releaseSlider = document.getElementById('releaseSlider');
                if (releaseSlider) {
                    releaseSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        // Clamp to 0â€“1000ms => 0â€“1.0s
                        const ms = Math.max(0, Math.min(1000, parseInt(e.target.value, 10) || 0));
                        this.instruments.strum1.env.release = ms / 1000;
                        const releaseValue = document.getElementById('releaseValue');
                        if (releaseValue) {
                            releaseValue.textContent = `${ms}ms`;
                        }
                    });
                } else {
                    console.error('releaseSlider not found');
                }

                // Master Volume control with dB conversion
                const masterVolumeSlider = document.getElementById('masterVolume');
                if (masterVolumeSlider) {
                    masterVolumeSlider.addEventListener('input', (e) => {
                        // Convert 0-10 scale to 0dB to -3dB (linear from 0 to 0.9)
                        const sliderValue = e.target.value / 10; // 0-1
                        this.masterVolume = sliderValue * 0.9; // Max at -3dB (0.9 linear gain)
                        if (this.gainNode) {
                            this.gainNode.gain.value = this.volume * this.masterVolume;
                        }
                        // Also update dry gain node for FX-bypassed instruments
                        if (this.dryGainNode) {
                            this.dryGainNode.gain.value = this.masterVolume;
                        }
                        // Reverb output should follow master as well
                        if (this.reverbOutGain) {
                            this.reverbOutGain.gain.value = this.masterVolume;
                        }
                        // Drum bus output should follow master as well
                        try { if (typeof this.updateDrumOutGain === 'function') this.updateDrumOutGain(); } catch(_){ }
                        const masterVolumeValue = document.getElementById('masterVolumeValue');
                        if (masterVolumeValue) {
                            masterVolumeValue.textContent = `${e.target.value * 10}%`;
                        }
                        // Sync transport volume
                        const transportVol = document.getElementById('transportMasterVolume');
                        if (transportVol && transportVol.value != e.target.value) {
                            transportVol.value = e.target.value;
                        }
                    });
                } else {
                    console.error('masterVolumeSlider not found');
                }

                // Initialize Transport Controls immediately after master volume
                setTimeout(() => {
                    const playBtn = document.getElementById('playStopTransportBtn');
                    const loopToggle = document.getElementById('loopToggle');
                    const prevBtn = document.getElementById('prevChordBtn');
                    const nextBtn = document.getElementById('nextChordBtn');
                    const bpmInput = document.getElementById('transportBpm');
                    const transportVolInput = document.getElementById('transportMasterVolume');
                    const legacyPlayToggle = document.getElementById('playStopToggleBtn');

                    // Master BPM setter that works with this instance
                    const setMasterBpm = (raw) => {
                        const bpm = Math.max(20, Math.min(300, parseInt(raw,10) || 120));
                        
                        // Update all transport objects
                        if (this._arpTransport) {
                            this._arpTransport.bpm = bpm;
                            // tickMs and beatMs are computed centrally in _refreshArpTransportTiming()
                        }
                        if (this._arp) {
                            this._arp.bpm = bpm;
                        }
                        if (window._patternTransport) {
                            const pt = window._patternTransport;
                            pt.bpm = bpm;
                            try {
                                if (typeof window.refreshPatternTransportTiming === 'function') {
                                    window.refreshPatternTransportTiming();
                                } else if (pt.stepMs == null || !Number.isFinite(pt.stepMs)) {
                                    const beatMs = 60000 / bpm;
                                    pt.stepMs = beatMs * 4 / 16; // default 1/16 fallback
                                }
                                const baseStep = Math.max(1, pt.stepMs || 120);
                                const now = (performance && performance.now ? performance.now() : Date.now());
                                pt.nextAt = now + baseStep;
                                if (!pt.running && typeof pt.kick === 'function') {
                                    pt.kick();
                                }
                            } catch(_){ }
                        }
                        
                        // Update transport BPM field only
                        if (bpmInput && bpmInput.value != bpm) bpmInput.value = bpm;
                        
                        // DISABLE other BPM inputs to prevent conflicts
                        const drumBpm = document.getElementById('drumBpmMini');
                        if (drumBpm) {
                            drumBpm.disabled = true;
                            drumBpm.value = bpm;
                            drumBpm.style.opacity = '0.5';
                            drumBpm.title = 'BPM controlled by transport';
                        }
                        const patternBpm = document.getElementById('patternBpm');
                        if (patternBpm) {
                            patternBpm.disabled = true;
                            patternBpm.value = bpm;
                            patternBpm.style.opacity = '0.5';
                            patternBpm.title = 'BPM controlled by transport';
                        }
                        const universalBpm = document.getElementById('universalBpm');
                        if (universalBpm) {
                            universalBpm.disabled = true;
                            universalBpm.value = bpm;
                            universalBpm.style.opacity = '0.5';
                            universalBpm.title = 'BPM controlled by transport';
                        }
                        
                        window.__MASTER_BPM = bpm;
                        // Recompute transport timing now that BPM changed
                        try { this._refreshArpTransportTiming(); } catch(_) {}
                        console.log('ðŸŽµ Master BPM set to:', bpm, 'tickMs:', this._arpTransport?.tickMs);
                        return bpm;
                    };

                    // Initialize BPM sync
                    if (typeof window.__MASTER_BPM === 'undefined') {
                        const seed = (bpmInput && bpmInput.value) || 120;
                        setMasterBpm(seed);
                    }

                    // Wire transport play button
                    // NOTE: Multiple init blocks exist; use a single shared guard to avoid double-toggling.
                    if (playBtn && !playBtn._xenPlayWired) {
                        playBtn._xenPlayWired = true;
                        playBtn._transportWired = true;
                        playBtn.addEventListener('click', () => {
                            console.log('ðŸŽµ Transport PLAY clicked, delegating to legacy button');
                            // Always re-query: playStopToggleBtn is replaced during bracket-aware wiring.
                            const livePlayToggle = document.getElementById('playStopToggleBtn');
                            if (livePlayToggle) livePlayToggle.click();
                            setTimeout(() => { try { this._reflectPlayUI && this._reflectPlayUI(); } catch(_){ } }, 10);
                        });
                        
                        // Set up state monitoring
                        const updateTransportState = () => {
                            try { this._reflectPlayUI && this._reflectPlayUI(); } catch(_){ }
                        };
                        if (!playBtn._transportMirrorInterval) {
                            playBtn._transportMirrorInterval = setInterval(updateTransportState, 200);
                        }
                    }

                    // Wire BPM input
                    if (bpmInput && !bpmInput._transportWired) {
                        bpmInput._transportWired = true;
                        bpmInput.addEventListener('input', () => {
                            console.log('ðŸŽµ Transport BPM input changed to:', bpmInput.value);
                            setMasterBpm(bpmInput.value);
                        });
                    }

                    // Wire transport volume
                    if (transportVolInput && !transportVolInput._transportWired) {
                        transportVolInput._transportWired = true;
                        transportVolInput.addEventListener('input', (e) => {
                            const vol = parseFloat(e.target.value);
                            const sliderValue = vol / 10;
                            
                            // Only control oscillators if MIDI is not active (not muted)
                            if (this._preMidiMasterVolume === undefined) {
                                this.masterVolume = sliderValue * 0.9;
                                if (this.gainNode) this.gainNode.gain.value = this.volume * this.masterVolume;
                                if (this.dryGainNode) this.dryGainNode.gain.value = this.masterVolume;
                                if (this.reverbOutGain) this.reverbOutGain.gain.value = this.masterVolume;
                                console.log('ðŸŽµ Transport volume set oscillators to:', vol);
                            } else {
                                // MIDI is active - store new volume for when MIDI is disabled but don't apply yet
                                this._preMidiMasterVolume = sliderValue * 0.9;
                                console.log('ðŸŽµ Transport volume stored for post-MIDI:', vol);
                            }
                            
                            // Also affect MIDI output volume if enabled
                            if (window.midi && window.midi.enabled) {
                                // Apply volume scaling to MIDI velocity (stored for future note sends)
                                window.midi._masterVolumeScale = sliderValue;
                                console.log('ðŸŽµ Transport volume set MIDI scale to:', sliderValue);
                            }
                            
                            // Sync legacy volume slider
                            if (masterVolumeSlider && masterVolumeSlider.value != vol) {
                                masterVolumeSlider.value = vol;
                            }
                            const masterVolumeValue = document.getElementById('masterVolumeValue');
                            if (masterVolumeValue) {
                                masterVolumeValue.textContent = `${vol * 10}%`;
                            }
                        });
                    }

                    // Wire navigation
                    if (prevBtn && !prevBtn._transportWired) {
                        prevBtn._transportWired = true;
                        prevBtn.addEventListener('click', () => {
                            console.log('ðŸŽµ Transport PREV clicked');
                            if (typeof this.navigateChord === 'function') {
                                this.navigateChord(-1);
                            } else {
                                console.warn('navigateChord method not found');
                            }
                        });
                    }

                    if (nextBtn && !nextBtn._transportWired) {
                        nextBtn._transportWired = true;
                        nextBtn.addEventListener('click', () => {
                            console.log('ðŸŽµ Transport NEXT clicked');
                            if (typeof this.navigateChord === 'function') {
                                this.navigateChord(1);
                            } else {
                                console.warn('navigateChord method not found');
                            }
                        });
                    }

                    // Wire loop toggle
                    if (loopToggle && !loopToggle._transportWired) {
                        loopToggle._transportWired = true;
                        loopToggle.addEventListener('change', () => {
                            console.log('ðŸŽµ Transport LOOP toggled:', loopToggle.checked);
                            if (this._arpTransport) {
                                this._arpTransport.loopEnabled = loopToggle.checked;
                            }
                            // Sync with legacy loop checkbox
                            const legacyLoop = document.getElementById('playLoop');
                            if (legacyLoop && legacyLoop.checked !== loopToggle.checked) {
                                legacyLoop.checked = loopToggle.checked;
                                legacyLoop.dispatchEvent(new Event('change'));
                            }
                        });
                    }

                    console.log('ðŸŽµ Transport controls initialized and wired to omnichord instance');
                }, 100);

                // Transport Controls Integration
                this.initTransportControls = () => {
                    const playBtn = document.getElementById('playStopTransportBtn');
                    const loopToggle = document.getElementById('loopToggle');
                    const prevBtn = document.getElementById('prevChordBtn');
                    const nextBtn = document.getElementById('nextChordBtn');
                    const bpmInput = document.getElementById('transportBpm');
                    const transportVolInput = document.getElementById('transportMasterVolume');
                    const legacyPlayToggle = document.getElementById('playStopToggleBtn');

                    // Master BPM setter - single source of truth
                    const setMasterBpm = (raw) => {
                        const bpm = Math.max(20, Math.min(300, parseInt(raw,10) || 120));
                        if (this._arpTransport) this._arpTransport.bpm = bpm;
                        if (window._patternTransport) {
                            window._patternTransport.bpm = bpm;
                            // Directly recalculate stepMs for pattern transport
                            try {
                                const quantEl = document.getElementById('patternQuant') || document.getElementById('universalQuant');
                                const quant = (quantEl?.value || '1/16').trim();
                                let baseDiv = 16; let isTrip = false; let tupletRatio = 1;
                                if (/tuplet:\s*(\d+)\/(\d+)/i.test(quant)) {
                                    const m = quant.match(/tuplet:\s*(\d+)\/(\d+)/i); const n=+m[1], d=+m[2]; if(n>0&&d>0){ tupletRatio=n/d; baseDiv=4; }
                                } else if (/^1\/(\d+)(t)?$/i.test(quant)) {
                                    const m = quant.match(/^1\/(\d+)(t)?$/i); baseDiv=parseInt(m[1],10)||16; if(m[2]) isTrip=true;
                                }
                                const beatMs = 60000 / bpm;
                                let stepMs = beatMs * 4 / baseDiv;
                                if (isTrip) stepMs *= (2/3);
                                if (tupletRatio !== 1) stepMs *= (1/tupletRatio);
                                window._patternTransport.stepMs = stepMs;
                            } catch(_) {}
                        }
                        if (bpmInput && bpmInput.value != bpm) bpmInput.value = bpm;
                        const drumBpm = document.getElementById('drumBpmMini');
                        if (drumBpm && drumBpm.value != bpm) drumBpm.value = bpm;
                        const patternBpm = document.getElementById('patternBpm');
                        if (patternBpm && patternBpm.value != bpm) patternBpm.value = bpm;
                        // Also update universalBpm so pattern transport reads correct value
                        const universalBpm = document.getElementById('universalBpm');
                        if (universalBpm && universalBpm.value != bpm) universalBpm.value = bpm;
                        window.__MASTER_BPM = bpm;
                        // Refresh pattern transport timing to recalculate stepMs (backup call)
                        try { if (typeof window.refreshPatternTransportTiming === 'function') window.refreshPatternTransportTiming(); } catch(_) {}
                        return bpm;
                    };

                    // Initialize master BPM
                    if (typeof window.__MASTER_BPM === 'undefined') {
                        const seed = (bpmInput && bpmInput.value) || 120;
                        setMasterBpm(seed);
                    } else {
                        setMasterBpm(window.__MASTER_BPM);
                    }

                    // Wire transport play button
                    if (playBtn && !playBtn._xenPlayWired) {
                        playBtn._xenPlayWired = true;
                        playBtn._wired = true;
                        playBtn.addEventListener('click', () => {
                            // Always re-query: the bracket-aware wiring replaces this node.
                            const livePlayToggle = document.getElementById('playStopToggleBtn');
                            if (livePlayToggle) livePlayToggle.click();
                            setTimeout(() => { try { this._reflectPlayUI && this._reflectPlayUI(); } catch(_){ } }, 10);
                        });
                    }

                    // Mirror play state changes into the compact transport button.
                    // Do not observe legacyPlayToggle: it is replaced during bracket-aware wiring.
                    if (playBtn && !playBtn._xenMirrorSeqState) {
                        playBtn._xenMirrorSeqState = true;
                        const updateTransportBtn = () => { try { this._reflectPlayUI && this._reflectPlayUI(); } catch(_){ } };
                        playBtn._xenMirrorSeqStateInterval = setInterval(updateTransportBtn, 200);
                    }

                    // Wire transport BPM
                    if (bpmInput && !bpmInput._wired) {
                        bpmInput._wired = true;
                        bpmInput.addEventListener('input', () => { setMasterBpm(bpmInput.value); });
                    }

                    // Wire transport volume
                    if (transportVolInput && !transportVolInput._wired) {
                        transportVolInput._wired = true;
                        transportVolInput.addEventListener('input', (e) => {
                            const vol = parseFloat(e.target.value);
                            const sliderValue = vol / 10;
                            this.masterVolume = sliderValue * 0.9;
                            if (this.gainNode) this.gainNode.gain.value = this.volume * this.masterVolume;
                            if (this.dryGainNode) this.dryGainNode.gain.value = this.masterVolume;
                            if (this.reverbOutGain) this.reverbOutGain.gain.value = this.masterVolume;
                            // Sync legacy volume
                            if (masterVolumeSlider && masterVolumeSlider.value != vol) {
                                masterVolumeSlider.value = vol;
                            }
                            const masterVolumeValue = document.getElementById('masterVolumeValue');
                            if (masterVolumeValue) {
                                masterVolumeValue.textContent = `${vol * 10}%`;
                            }
                        });
                    }

                    // Wire navigation buttons
                    if (prevBtn && !prevBtn._wired) {
                        prevBtn._wired = true;
                        prevBtn.addEventListener('click', () => {
                            if (typeof this.navigateChord === 'function') {
                                this.navigateChord(-1);
                            }
                        });
                    }

                    if (nextBtn && !nextBtn._wired) {
                        nextBtn._wired = true;
                        nextBtn.addEventListener('click', () => {
                            if (typeof this.navigateChord === 'function') {
                                this.navigateChord(1);
                            }
                        });
                    }

                    // Make existing bracket markers draggable
                    const existingMarkers = document.querySelectorAll('.repeat-marker-column');
                    existingMarkers.forEach(marker => {
                        if (!marker._draggableWired && typeof makeBracketDraggable === 'function') {
                            makeBracketDraggable(marker);
                            marker._draggableWired = true;
                        }
                    });
                    
                    // Initialize chord column drop zones
                    if (typeof makeChordColumnsDroppable === 'function') {
                        makeChordColumnsDroppable();
                    }
                    
                    // Initialize chord resize functionality
                    if (typeof initChordResize === 'function') {
                        initChordResize();
                    }
                    
                // Initialize universal EDO field synchronization
                if (typeof initUniversalEDOSync === 'function') {
                    initUniversalEDOSync();
                }                    // Monitor string compression
                    if (typeof updateStringCompression === 'function') {
                        updateStringCompression();
                        // Also monitor on window resize
                        window.addEventListener('resize', updateStringCompression);
                        
                        // Add automatic monitoring for when chords are created/updated
                        const observer = new MutationObserver(() => {
                            setTimeout(() => {
                                if (typeof updateStringCompression === 'function') {
                                    updateStringCompression();
                                }
                            }, 100); // Small delay to ensure layout is complete
                        });
                        
                        // Observe changes to the extension columns container
                        const extensionColumns = document.getElementById('extensionColumns');
                        if (extensionColumns) {
                            observer.observe(extensionColumns, {
                                childList: true,
                                subtree: true,
                                attributes: false
                            });
                        }
                    }
                    
                    // Initialize keyboard modal with keys visible
                    // Make transport draggable by non-interactive background
                    try { if (typeof makeTransportDraggable === 'function') makeTransportDraggable(); } catch(_) {}
                    if (typeof bringModalToFront === 'function') {
                        bringModalToFront('keyboardModal');
                    }
                    if (typeof fixBracketMovement === 'function') {
                        // Fix bracket movement after short delay to ensure DOM is ready
                        setTimeout(fixBracketMovement, 500);
                    }
                    
                    // Fix oscillator routing - ensure oscillators work by default, MIDI only when enabled
                    const midiBtn = document.getElementById('midiBtn');
                    if (midiBtn && !midiBtn.classList.contains('active')) {
                        // MIDI is off, ensure oscillators are active
                        this.enableOscillators = true;
                        this.midiEnabled = false;
                    } else if (midiBtn && midiBtn.classList.contains('active')) {
                        // MIDI is on, prioritize MIDI
                        this.enableOscillators = false;
                        this.midiEnabled = true;
                    }
                    
                    // Ensure keyboard keys are visible by moving root grid to modal
                    setTimeout(() => {
                        const rootGrid = document.getElementById('rootGrid');
                        const modalRootGrid = document.getElementById('modalRootGrid');
                        if (rootGrid && modalRootGrid && !modalRootGrid.hasChildNodes()) {
                            // Move the root grid content into the modal
                            while (rootGrid.firstChild) {
                                modalRootGrid.appendChild(rootGrid.firstChild);
                            }
                        }
                        
                        // Ensure keyboard modal is visible and keys show
                        const keyboardModal = document.getElementById('keyboardModal');
                        if (keyboardModal && keyboardModal.style.display !== 'none') {
                            // Force regeneration of keyboard if empty
                            if (modalRootGrid && modalRootGrid.children.length === 0) {
                                // Trigger keyboard generation
                                if (typeof this.generateKeyboard === 'function') {
                                    this.generateKeyboard();
                                }
                            }
                        }
                    }, 1000);

                    // Wire loop toggle
                    if (loopToggle && !loopToggle._wired) {
                        loopToggle._wired = true;
                        loopToggle.addEventListener('change', () => {
                            if (this._arpTransport) {
                                this._arpTransport.loopEnabled = loopToggle.checked;
                            }
                            // Also sync with legacy loop checkbox
                            const legacyLoop = document.getElementById('playLoop');
                            if (legacyLoop && legacyLoop.checked !== loopToggle.checked) {
                                legacyLoop.checked = loopToggle.checked;
                            }
                        });
                    }
                };

                // Initialize transport controls
                this.initTransportControls();

                // Force compact one-octave voicing
                this.splitExtendedChordsAcrossOctaves = false;

        // Play modes via inline buttons
        this.playMode = this.playMode || 'high-low';
        // STRUM semantics (legacy): UP/DOWN describe DISPLAY orientation (high-at-top vs low-at-top).
        // ALT modes change traversal pattern but should not implicitly flip orientation.
        this.strumMode = this.strumMode || 'up'; // up | down | alt-centers | alt-ends
        this.strumOrientation = this.strumOrientation || ((this.strumMode === 'down') ? 'down' : 'up'); // up | down
    // STRUM is always enabled; CHORD vs ARP is a single exclusive toggle
    this.strumEnabled = true;
    this.chordsEnabled = true;
    this.arpEnabled = false; // default OFF (PATTERN should be off on start)
    this.bassEnabled = true;
        this.setPlayMode = (mode) => {
            const strumModes = ['high-low','low-high','alt-ends','alt-center'];
            const chordArpModes = ['chords','arp'];
            if (strumModes.includes(mode)) {
                // Update strumMode mapping only; keep playMode (arp/chords) as-is
                switch(mode){
                        case 'high-low':
                            this.strumMode = 'up';
                            this.strumOrientation = 'up';
                            break;
                        case 'low-high':
                            this.strumMode = 'down';
                            this.strumOrientation = 'down';
                            break;
                    case 'alt-center': this.strumMode = 'alt-centers'; break;
                    case 'alt-ends': default: this.strumMode = 'alt-ends'; break;
                }
                if (typeof this.applyPlayModeToAllColumns === 'function') this.applyPlayModeToAllColumns();
                this.updateModeUI?.();
                return;
            }
            if (chordArpModes.includes(mode)) {
                this.playMode = mode;
                this.chordsEnabled = (mode === 'chords');
                this.arpEnabled = (mode === 'arp');
                this.strumEnabled = true;
                this.updateModeUI?.();
                return;
            }
            // Fallback: keep current playMode, update visuals
            if (typeof this.applyPlayModeToAllColumns === 'function') this.applyPlayModeToAllColumns();
            this.updateModeUI?.();
        };
        
        // Sync playMode with CHORD/ARP selection and STRUM order
        this.syncPlayMode = () => {
            if (this.chordsEnabled && !this.arpEnabled) {
                this.playMode = 'chords';
            } else if (this.arpEnabled && !this.chordsEnabled) {
                this.playMode = 'arp';
            } else {
                // Both off: STRUM-only â€” honour full strum order set including ALT CENTRE/ENDS
                switch (this.strumMode) {
                    case 'up':
                        this.playMode = 'high-low';
                        break;
                    case 'down':
                        this.playMode = 'low-high';
                        break;
                    case 'alt-centers':
                        this.playMode = 'alt-center';
                        break;
                    case 'alt-ends':
                        this.playMode = 'alt-ends';
                        break;
                    default:
                        this.playMode = 'high-low';
                }
            }
        };
        
        // Independent mode toggles
        this.toggleStrumMode = () => {
            // STRUM always stays on, just cycle through UP, DOWN, ALT-CENTERS, ALT-ENDS
            this.strumEnabled = true;
            this.cycleStrumMode();
            if (typeof this.applyPlayModeToAllColumns === 'function') this.applyPlayModeToAllColumns();
            this.updateModeUI();
        };

        // Single button cycles: OFF â†’ CHORDS â†’ ARP â†’ ARP+CHORDS â†’ OFF
        this.toggleChordArpMode = () => {
            const a = !!this.arpEnabled, c = !!this.chordsEnabled;
            
            // Check if playback is active - if so, defer ARP change to next cycle
            const isPlaying = this._arpTransport && this._arpTransport.isRunning;
            
            if (isPlaying) {
                // Defer ARP mode change by 2 beats during playback
                if (window.scheduleDeferred && typeof window.scheduleDeferred === 'function') {
                    let nextState = 'off';
                    if (!a && !c) nextState = 'chords';
                    else if (c && !a) nextState = 'arp';
                    else if (a && !c) nextState = 'both';
                    else nextState = 'off';
                    
                    window.scheduleDeferred({ arpMode: nextState });
                    return; // Don't apply immediately
                }
            }
            
            // Apply immediately if stopped or no defer system
            let nextState = 'off';
            if (!a && !c) nextState = 'chords';
            else if (c && !a) nextState = 'arp';
            else if (a && !c) nextState = 'both';
            else nextState = 'off';

            if (nextState === 'chords') { this.chordsEnabled = true; this.arpEnabled = false; }
            else if (nextState === 'arp') { this.chordsEnabled = false; this.arpEnabled = true; }
            else if (nextState === 'both') { this.chordsEnabled = true; this.arpEnabled = true; }
            else { this.chordsEnabled = false; this.arpEnabled = false; }

            this.syncPlayMode();
            this.updateModeUI();
            // Do not auto-start transport on mode updates; only PLAY should start
            // try { if (this.chordsEnabled || this.arpEnabled) this._startArpTransport(); } catch(_) {}
        };
        
        this.toggleBassMode = () => {
            this.bassEnabled = !this.bassEnabled;
            // If turning OFF, immediately stop any active bass voices/holds
            if (!this.bassEnabled) {
                try { this.stopAllActiveNotes && this.stopAllActiveNotes('bass'); } catch(_){ }
                try {
                    if (this._heldBassVoice && typeof this._heldBassVoice.stop === 'function') {
                        this._heldBassVoice.stop();
                    }
                } catch(_){ }
                this._heldBassVoice = null;
                this._heldBassVoiceKey = null;
                this._heldBassLiveFreq = null;
            }
            // If turning off bass but no other modes active, enable strum
            if (!this.bassEnabled && !this.strumEnabled && !this.chordsEnabled && !this.arpEnabled) {
                this.strumEnabled = true;
            }
            this.syncPlayMode();
            this.updateModeUI();
        };
        
        // Universal control synchronization
        this.syncUniversalControls = () => {
            // All controls are universal now; ensure values are sane and reflect engine state.
            const universalNpc = document.getElementById('universalNpc');
            if (universalNpc) universalNpc.value = String(Math.max(1, Math.min(64, parseInt(universalNpc.value)||3)));
            const universalHold = document.getElementById('universalHold');
            const chordHold = document.getElementById('chordHold');
            if (universalHold && chordHold) universalHold.value = chordHold.value;
        };
        
        // Apply universal settings to all individual controls
        this.applyUniversalSettings = () => {
            const universalBpm = document.getElementById('universalBpm');
            const universalQuant = document.getElementById('universalQuant');
            const universalNpc = document.getElementById('universalNpc');
            const universalHold = document.getElementById('universalHold');
            const universalPattern = document.getElementById('universalPattern');
            
            // Apply to engine from universal controls
            const chordHold = document.getElementById('chordHold');
            
            if (universalBpm) { this.bpm = parseInt(universalBpm.value) || 120; }
            // quant pattern is read at use sites from universal controls
            if (universalNpc) {
                const npcValue = parseInt(universalNpc.value) || 3;
                this.arpNotesPerCycle = npcValue;
                // Also sync to other NPC-related properties
                if (this._arp) {
                    this._arp.npc = npcValue;
                    this._arp.chordsNpc = npcValue;
                }
            }
            if (universalHold) {
                if (chordHold) chordHold.value = universalHold.value;
            }
            // No per-mode pattern element to mirror
            // Handle time signature changes
            const universalTimeSignature = document.getElementById('universalTimeSignature');
            if (universalTimeSignature) {
                // Only rebuild grid immediately if transport is not running; otherwise event handler defers it
                this._ensureArpTransport();
                if (!this._arpTransport.running) {
                    try { this._updateDrumGridForTimeSignature(); } catch(_) {}
                }
            }
        };

        // Rebuild drum lanes to match current time signature (steps per bar)
        this._updateDrumGridForTimeSignature = () => {
            try {
                const grid = document.getElementById('drumGrid');
                const patternGrid = document.getElementById('patternGrid');
                if (!grid && !patternGrid) return;
                // Compute new steps per bar
                let tsNum=4, tsDen=4; try {
                    const tsRaw = String(document.getElementById('universalTimeSignature')?.value||'4/4');
                    const parts = tsRaw.split('/');
                    const a=parseInt(parts[0],10); const b=parseInt(parts[1],10);
                    if(Number.isFinite(a)&&a>0) tsNum=a; if(Number.isFinite(b)&&b>0) tsDen=b;
                } catch(_) {}
                const beatsPerBar = (tsNum*4)/tsDen;
                const stepsPerBar = Math.max(4, Math.round(beatsPerBar * 4));
                // Helper: remap a drum lane to stepsPerBar using snapshot
                const rebuildDrumLane = (lane) => {
                    const isBass = lane.closest('.drum-row')?.classList?.contains('bass-row');
                    const oldSteps = Array.from(lane.querySelectorAll('.drum-step'));
                    const snapshot = oldSteps.map(s => ({
                        active: s.classList.contains('active'),
                        npc: s.dataset.npc,
                        len: s.dataset.len,
                        tie: s.dataset.tie,
                        vel: s.dataset.vel
                    }));
                    // Clear lane except label/controls are in row, so safe to nuke steps/dividers/playhead
                    oldSteps.forEach(el=> el.remove());
                    Array.from(lane.querySelectorAll('.beat-divider')).forEach(el=> el.remove());
                    const ph = lane.querySelector('.drum-playhead'); if (ph) try { ph.remove(); } catch{}
                    // Set CSS var
                    try { lane.style.setProperty('--steps-per-bar', String(stepsPerBar)); } catch(_){ }
                    // Beat dividers
                    const fullBeats = Math.max(0, Math.floor(beatsPerBar));
                    for (let b=1; b<fullBeats; b++){
                        const div = document.createElement('div');
                        div.className = 'beat-divider';
                        div.style.left = `${(b/beatsPerBar)*100}%`;
                        lane.appendChild(div);
                    }
                    // Steps
                    for (let i=0;i<stepsPerBar;i++){
                        const s = document.createElement('div');
                        s.className = 'drum-step' + ((i%4===0)?' beat-accent':'');
                        s.dataset.step = String(i);
                        s.title = `${(isBass?'BASS':(lane._controls?.name||'DRUM'))} â€¢ Step ${i+1}`;
                        if (isBass) s.dataset.npc = '';
                        // restore state when possible
                        const prev = snapshot[i];
                        if (prev){
                            if (!isBass) { if (prev.active) s.classList.add('active'); }
                            else {
                                if (prev.npc != null && prev.npc !== undefined) { s.dataset.npc = prev.npc; if (prev.npc && prev.npc.toLowerCase() !== 'x') s.classList.add('active'); }
                                if (prev.len) s.dataset.len = prev.len; if (prev.tie) s.dataset.tie = prev.tie;
                            }
                        }
                        // Preserve per-step velocity across rebuilds
                        s.dataset.vel = (prev && prev.vel != null) ? String(prev.vel) : '100';
                        try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(s); } catch(_){ }
                        try { if (window.attachVelocityDrag) window.attachVelocityDrag(s); } catch(_){ }
                        // Reattach click/drag behavior minimal for bass; normal drums get same click toggling via event below
                        if (isBass){
                            s.addEventListener('mousedown', (e)=>{
                                if (e.button !== 0) return; e.preventDefault();
                                const startIdx = i;
                                const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                const applyLen = (toIdx)=>{
                                    const len = Math.max(1, (toIdx|0) - startIdx + 1);
                                    s.dataset.len = String(len);
                                    for (let k=0;k<steps.length;k++){
                                        if (k>startIdx && k<=startIdx+len-1) steps[k].dataset.tie='1';
                                        else if (k>startIdx) delete steps[k].dataset.tie;
                                    }
                                    try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                                };
                                const onMove = (ev)=>{
                                    const rect = lane.getBoundingClientRect();
                                    const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
                                    const idx = Math.max(0, Math.min(stepsPerBar-1, Math.floor((x / rect.width) * stepsPerBar)));
                                    applyLen(idx);
                                };
                                const onUp = ()=>{
                                    document.removeEventListener('mousemove', onMove);
                                    document.removeEventListener('mouseup', onUp);
                                };
                                document.addEventListener('mousemove', onMove);
                                document.addEventListener('mouseup', onUp);
                                // Immediate visual on initial click-drag state
                                applyLen(startIdx);
                            });
                            s.addEventListener('click', (e)=>{ e.preventDefault(); /* Delegate to existing logic by simulating? Keep simple: toggle + prompt on second click */
                                const prev = (s.dataset.npc||'');
                                if (prev === '') { s.dataset.npc='1'; s.classList.add('active'); if (!s.dataset.len) s.dataset.len='1'; }
                                else if (prev && prev.toLowerCase() !== 'x') {
                                    s.classList.add('selected');
                                    const valIn = window.prompt('Bass NPC (1â€“9) or x for rest', String(prev).toLowerCase());
                                    s.classList.remove('selected');
                                    if (valIn == null) return;
                                    const val = String(valIn).trim();
                                    if (val === '') { s.dataset.npc=''; s.classList.remove('active'); delete s.dataset.len; return; }
                                    if (/^x$/i.test(val)) { s.dataset.npc='x'; s.classList.remove('active'); delete s.dataset.len; return; }
                                    if (/^[1-9]$/.test(val)) { s.dataset.npc=val; s.classList.add('active'); if (!s.dataset.len) s.dataset.len='1'; }
                                } else { s.dataset.npc='1'; s.classList.add('active'); if (!s.dataset.len) s.dataset.len='1'; }
                            });
                        } else {
                            // Restore velocity-drag editing after rebuild (mousedown/touchstart)
                            s.addEventListener('mousedown', (e) => {
                                if (e.button !== 0) return;
                                if (s.classList.contains('disabled')) return;
                                e.preventDefault();
                                const wasActive = s.classList.contains('active');
                                const startY = e.clientY;
                                const startVel = parseInt(s.dataset.vel || '100', 10);
                                let isDragging = false;
                                let isVelMode = false;
                                const applyVel = (clientY) => {
                                    const deltaY = startY - clientY;
                                    const deltaVel = Math.round(deltaY / 1.5);
                                    const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                                    s.dataset.vel = String(newVel);
                                    try { window.updateStepVelocityClass(s); } catch(_){ }
                                };
                                const onMove = (ev) => {
                                    const dy = Math.abs(ev.clientY - startY);
                                    if (dy > 5 && !isVelMode) {
                                        isDragging = true;
                                        isVelMode = true;
                                        if (!wasActive) s.classList.add('active');
                                        s.classList.add('vel-dragging');
                                    }
                                    if (isVelMode) applyVel(ev.clientY);
                                };
                                const onUp = () => {
                                    document.removeEventListener('mousemove', onMove);
                                    document.removeEventListener('mouseup', onUp);
                                    try { s.classList.remove('vel-dragging'); } catch(_){ }
                                    if (!isDragging) {
                                        const nowActive = !wasActive;
                                        if (nowActive) s.classList.add('active'); else s.classList.remove('active');
                                        try {
                                            if (nowActive) {
                                                const row = s.closest('.drum-row');
                                                const rowIdx = parseInt(lane.dataset.row||'0',10)|0;
                                                const volEl = row ? row.querySelector('.drum-volume') : null;
                                                const sendEl = row ? row.querySelector('.drum-send') : null;
                                                const fxEl = row ? row.querySelector('.drum-fx input[type="checkbox"]') : null;
                                                const vol = volEl ? Math.max(0, Math.min(1, parseInt(volEl.value||'80',10)/100)) : 0.8;
                                                const sendPct = sendEl ? (parseInt(sendEl.value||'0',10) || 0) : (fxEl && fxEl.checked ? 100 : 0);
                                                const send = Math.max(0, Math.min(1, sendPct/100));
                                                if (this._isDrumPreviewAllowed()) this._triggerDrumSound(rowIdx, vol, send);
                                            }
                                        } catch(_){ }
                                    }
                                    try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                };
                                document.addEventListener('mousemove', onMove);
                                document.addEventListener('mouseup', onUp);
                            });

                            s.addEventListener('touchstart', (e) => {
                                if (s._touchDragActive) return;
                                if (s.classList.contains('disabled')) return;
                                s._touchDragActive = true;
                                try { e.preventDefault(); } catch(_){ }
                                const touch = e.touches && e.touches[0] ? e.touches[0] : null;
                                if (!touch) { s._touchDragActive = false; return; }
                                const activeId = touch.identifier;
                                const wasActive = s.classList.contains('active');
                                const startY = touch.clientY;
                                const startVel = parseInt(s.dataset.vel || '100', 10);
                                let isDragging = false;
                                let isVelMode = false;
                                const applyVel = (clientY) => {
                                    const deltaY = startY - clientY;
                                    const deltaVel = Math.round(deltaY / 1.5);
                                    const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                                    s.dataset.vel = String(newVel);
                                    try { window.updateStepVelocityClass(s); } catch(_){ }
                                };
                                const onMove = (ev) => {
                                    try { ev.preventDefault(); } catch(_){ }
                                    const tlist = ev.touches || [];
                                    let t = null; for (let j=0;j<tlist.length;j++){ if (tlist[j].identifier === activeId) { t = tlist[j]; break; } }
                                    if (!t) return;
                                    const dy = Math.abs(t.clientY - startY);
                                    if (!isVelMode && dy > 10) {
                                        isDragging = true;
                                        isVelMode = true;
                                        if (!wasActive) s.classList.add('active');
                                        s.classList.add('vel-dragging');
                                    }
                                    if (isVelMode) applyVel(t.clientY);
                                };
                                const onEnd = (ev) => {
                                    const changed = ev.changedTouches || [];
                                    let ended = false; for (let j=0;j<changed.length;j++){ if (changed[j].identifier === activeId) { ended = true; break; } }
                                    if (!ended) return;
                                    document.removeEventListener('touchmove', onMove, { passive: false });
                                    document.removeEventListener('touchend', onEnd);
                                    document.removeEventListener('touchcancel', onEnd);
                                    try { s.classList.remove('vel-dragging'); } catch(_){ }
                                    if (!isDragging) {
                                        const nowActive = !wasActive;
                                        if (nowActive) s.classList.add('active'); else s.classList.remove('active');
                                        try {
                                            if (nowActive) {
                                                const row = s.closest('.drum-row');
                                                const rowIdx = parseInt(lane.dataset.row||'0',10)|0;
                                                const volEl = row ? row.querySelector('.drum-volume') : null;
                                                const sendEl = row ? row.querySelector('.drum-send') : null;
                                                const fxEl = row ? row.querySelector('.drum-fx input[type="checkbox"]') : null;
                                                const vol = volEl ? Math.max(0, Math.min(1, parseInt(volEl.value||'80',10)/100)) : 0.8;
                                                const sendPct = sendEl ? (parseInt(sendEl.value||'0',10) || 0) : (fxEl && fxEl.checked ? 100 : 0);
                                                const send = Math.max(0, Math.min(1, sendPct/100));
                                                if (this._isDrumPreviewAllowed()) this._triggerDrumSound(rowIdx, vol, send);
                                            }
                                        } catch(_){ }
                                    }
                                    try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                    s._touchDragActive = false;
                                };
                                document.addEventListener('touchmove', onMove, { passive: false });
                                document.addEventListener('touchend', onEnd);
                                document.addEventListener('touchcancel', onEnd);
                            }, { passive: false });
                        }
                        lane.appendChild(s);
                    }
                    // Playhead element
                    const ph2 = document.createElement('div'); ph2.className='drum-playhead'; ph2.style.left='0%'; lane.appendChild(ph2);
                };

                // Rebuild all drum lanes if grid exists (using per-lane N/D from lane.dataset.quant)
                if (grid) {
                    const lanes = Array.from(grid.querySelectorAll('.drum-lane'));
                    lanes.forEach(lane => {
                        const isBass = lane.closest('.drum-row')?.classList?.contains('bass-row');
                        const oldSteps = Array.from(lane.querySelectorAll('.drum-step'));
                        const fromD = Math.max(1, oldSteps.length || stepsPerBar);
                        const snap = oldSteps.map((s,i)=> ({ i, active: s.classList.contains('active'), npc: s.dataset.npc, len: s.dataset.len, tie: s.dataset.tie, vel: s.dataset.vel }));
                        // Determine target N/D from quant string, default to global stepsPerBar
                        let toN = stepsPerBar, toD = stepsPerBar;
                        const qStr = lane.dataset.quant || '';
                        const m = qStr.match(/^(\d+)\/(\d+)$/);
                        if (m) { const n = parseInt(m[1],10), d = parseInt(m[2],10); if (Number.isFinite(d) && d>0) toD = d; if (Number.isFinite(n) && n>0) toN = Math.min(n, toD); }
                        else { const mn = qStr.match(/^(\d+)$/); if (mn){ const d=parseInt(mn[1],10); if (Number.isFinite(d)&&d>0) { toD=d; toN=d; } } }
                        // Clear content
                        oldSteps.forEach(n=>n.remove());
                        Array.from(lane.querySelectorAll('.beat-divider,.drum-playhead')).forEach(n=>n.remove());
                        try { lane.style.setProperty('--steps-per-bar', String(toD)); } catch(_){ }
                        // Update lane quant cache
                        try { lane._quant = { N: toN, D: toD, str: (qStr||`${toN}/${toD}`) }; } catch(_){ }
                        // Beat dividers aligned to bar beats (keep bar-synced across rows)
                        const fullBeats = Math.max(0, Math.floor(beatsPerBar));
                        for (let b=1; b<fullBeats; b++) {
                            const div = document.createElement('div');
                            div.className = 'beat-divider';
                            div.style.left = `${(b/beatsPerBar)*100}%`;
                            lane.appendChild(div);
                        }
                        // Remap
                        const dest = new Array(toD).fill(null).map(()=>({}));
                        if (!isBass) {
                            snap.forEach(o=>{ if (o.active){ const j = Math.max(0, Math.min(toD-1, Math.round((o.i / Math.max(1,fromD-1)) * (toD-1)))); dest[j].active=1; dest[j].vel=o.vel; } });
                        } else {
                            // Bass inside drum grid: keep npc/len/ties if present
                            // Detect heads (not tied)
                            snap.forEach((o, idx)=>{
                                const npc = (o.npc||'').toLowerCase();
                                const prev = snap[idx-1];
                                const isHead = npc && npc!=='x' && !(prev && prev.tie==='1');
                                if (isHead){
                                    const j = Math.max(0, Math.min(toD-1, Math.round((o.i / Math.max(1,fromD-1)) * (toD-1))));
                                    dest[j].npc = o.npc; dest[j].len = o.len || '1'; dest[j].head=1;
                                }
                            });
                        }
                        // Precompute allowed indices for N notes across D divisions (evenly distributed)
                        const allowed = new Set();
                        if (toN >= toD) { for (let k=0;k<toD;k++) allowed.add(k); }
                        else {
                            for (let k=0;k<toN;k++){ const idx = Math.max(0, Math.min(toD-1, Math.floor((k*toD)/toN))); allowed.add(idx); }
                        }
                        // Build
                        for (let i=0;i<toD;i++){
                            const s = document.createElement('div');
                            s.className = 'drum-step' + ((i%4===0)?' beat-accent':'');
                            s.dataset.step = String(i);
                            s.title = `${(isBass?'BASS':(lane._controls?.name||'DRUM'))} â€¢ Step ${i+1}`;
                            if (isBass) s.dataset.npc = '';
                            const prev = dest[i];
                            if (prev){
                                if (!isBass) { if (prev.active) s.classList.add('active'); }
                                else {
                                    if (prev.npc && prev.npc.toLowerCase()!=='x'){ s.dataset.npc = prev.npc; s.classList.add('active'); }
                                    if (prev.len) s.dataset.len = prev.len;
                                }
                            }
                            if (!isBass) {
                                s.dataset.vel = (prev && prev.vel != null) ? String(prev.vel) : '100';
                                try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(s); } catch(_){ }
                                try { if (window.attachVelocityDrag) window.attachVelocityDrag(s); } catch(_){ }
                            }
                            // Mark disabled if not in allowed index set (for drums/pattern semantics)
                            if (!isBass && !allowed.has(i)) s.classList.add('disabled');
                            // Reattach basic interactions for bass lane (length drag + prompt)
                            if (isBass) {
                                s.addEventListener('mousedown', (e)=>{
                                    if (e.button !== 0) return; e.preventDefault();
                                    const startIdx = i; const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                    const applyLen = (to)=>{ const len = Math.max(1, (to|0)-startIdx+1); s.dataset.len=String(len); for (let k=0;k<steps.length;k++){ if(k>startIdx && k<=startIdx+len-1) steps[k].dataset.tie='1'; else if(k>startIdx) delete steps[k].dataset.tie; } };
                                    const move=(ev)=>{ const rect=lane.getBoundingClientRect(); const x=Math.max(0,Math.min(rect.width,ev.clientX-rect.left)); const idx=Math.max(0,Math.min(toD-1,Math.floor((x/rect.width)*toD))); applyLen(idx); };
                                    const up=()=>{ document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); };
                                    document.addEventListener('mousemove',move); document.addEventListener('mouseup',up);
                                    applyLen(startIdx);
                                });
                                s.addEventListener('click',(e)=>{ e.preventDefault(); const prev=(s.dataset.npc||''); if(prev===''){ s.dataset.npc='1'; s.classList.add('active'); if(!s.dataset.len) s.dataset.len='1'; } else if(prev && prev.toLowerCase()!=='x'){ const valIn=window.prompt('Bass NPC (1â€“9) or x for rest', String(prev).toLowerCase()); if(valIn==null) return; const val=String(valIn).trim(); if(val===''){ s.dataset.npc=''; s.classList.remove('active'); delete s.dataset.len; } else if(/^x$/i.test(val)){ s.dataset.npc='x'; s.classList.remove('active'); delete s.dataset.len; } else if(/^[1-9]$/.test(val)){ s.dataset.npc=val; s.classList.add('active'); if(!s.dataset.len) s.dataset.len='1'; } } else { s.dataset.npc='1'; s.classList.add('active'); if(!s.dataset.len) s.dataset.len='1'; } });
                            } else {
                                    // Restore velocity-drag editing after quant/time rebuild
                                    s.addEventListener('mousedown', (e) => {
                                        if (e.button !== 0) return;
                                        if (s.classList.contains('disabled')) return;
                                        e.preventDefault();
                                        const wasActive = s.classList.contains('active');
                                        const startY = e.clientY;
                                        const startVel = parseInt(s.dataset.vel || '100', 10);
                                        let isDragging = false;
                                        let isVelMode = false;
                                        const applyVel = (clientY) => {
                                            const deltaY = startY - clientY;
                                            const deltaVel = Math.round(deltaY / 1.5);
                                            const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                                            s.dataset.vel = String(newVel);
                                            try { window.updateStepVelocityClass(s); } catch(_){ }
                                        };
                                        const onMove = (ev) => {
                                            const dy = Math.abs(ev.clientY - startY);
                                            if (dy > 5 && !isVelMode) {
                                                isDragging = true;
                                                isVelMode = true;
                                                if (!wasActive) s.classList.add('active');
                                                s.classList.add('vel-dragging');
                                            }
                                            if (isVelMode) applyVel(ev.clientY);
                                        };
                                        const onUp = () => {
                                            document.removeEventListener('mousemove', onMove);
                                            document.removeEventListener('mouseup', onUp);
                                            try { s.classList.remove('vel-dragging'); } catch(_){ }
                                            if (!isDragging) {
                                                const nowActive = !wasActive;
                                                if (nowActive) s.classList.add('active'); else s.classList.remove('active');
                                                try {
                                                    if (nowActive) {
                                                        const row = s.closest('.drum-row');
                                                        const rowIdx = parseInt(lane.dataset.row||'0',10)|0;
                                                        const volEl = row ? row.querySelector('.drum-volume') : null;
                                                        const sendEl = row ? row.querySelector('.drum-send') : null;
                                                        const fxEl = row ? row.querySelector('.drum-fx input[type="checkbox"]') : null;
                                                        const vol = volEl ? Math.max(0, Math.min(1, parseInt(volEl.value||'80',10)/100)) : 0.8;
                                                        const sendPct = sendEl ? (parseInt(sendEl.value||'0',10) || 0) : (fxEl && fxEl.checked ? 100 : 0);
                                                        const send = Math.max(0, Math.min(1, sendPct/100));
                                                        if (this._isDrumPreviewAllowed()) this._triggerDrumSound(rowIdx, vol, send);
                                                    }
                                                } catch(_){ }
                                            }
                                            try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                        };
                                        document.addEventListener('mousemove', onMove);
                                        document.addEventListener('mouseup', onUp);
                                    });

                                    s.addEventListener('touchstart', (e) => {
                                        if (s._touchDragActive) return;
                                        if (s.classList.contains('disabled')) return;
                                        s._touchDragActive = true;
                                        try { e.preventDefault(); } catch(_){ }
                                        const touch = e.touches && e.touches[0] ? e.touches[0] : null;
                                        if (!touch) { s._touchDragActive = false; return; }
                                        const activeId = touch.identifier;
                                        const wasActive = s.classList.contains('active');
                                        const startY = touch.clientY;
                                        const startVel = parseInt(s.dataset.vel || '100', 10);
                                        let isDragging = false;
                                        let isVelMode = false;
                                        const applyVel = (clientY) => {
                                            const deltaY = startY - clientY;
                                            const deltaVel = Math.round(deltaY / 1.5);
                                            const newVel = Math.max(0, Math.min(127, startVel + deltaVel));
                                            s.dataset.vel = String(newVel);
                                            try { window.updateStepVelocityClass(s); } catch(_){ }
                                        };
                                        const onMove = (ev) => {
                                            try { ev.preventDefault(); } catch(_){ }
                                            const tlist = ev.touches || [];
                                            let t = null; for (let j=0;j<tlist.length;j++){ if (tlist[j].identifier === activeId) { t = tlist[j]; break; } }
                                            if (!t) return;
                                            const dy = Math.abs(t.clientY - startY);
                                            if (!isVelMode && dy > 10) {
                                                isDragging = true;
                                                isVelMode = true;
                                                if (!wasActive) s.classList.add('active');
                                                s.classList.add('vel-dragging');
                                            }
                                            if (isVelMode) applyVel(t.clientY);
                                        };
                                        const onEnd = (ev) => {
                                            const changed = ev.changedTouches || [];
                                            let ended = false; for (let j=0;j<changed.length;j++){ if (changed[j].identifier === activeId) { ended = true; break; } }
                                            if (!ended) return;
                                            document.removeEventListener('touchmove', onMove, { passive: false });
                                            document.removeEventListener('touchend', onEnd);
                                            document.removeEventListener('touchcancel', onEnd);
                                            try { s.classList.remove('vel-dragging'); } catch(_){ }
                                            if (!isDragging) {
                                                const nowActive = !wasActive;
                                                if (nowActive) s.classList.add('active'); else s.classList.remove('active');
                                                try {
                                                    if (nowActive) {
                                                        const row = s.closest('.drum-row');
                                                        const rowIdx = parseInt(lane.dataset.row||'0',10)|0;
                                                        const volEl = row ? row.querySelector('.drum-volume') : null;
                                                        const sendEl = row ? row.querySelector('.drum-send') : null;
                                                        const fxEl = row ? row.querySelector('.drum-fx input[type="checkbox"]') : null;
                                                        const vol = volEl ? Math.max(0, Math.min(1, parseInt(volEl.value||'80',10)/100)) : 0.8;
                                                        const sendPct = sendEl ? (parseInt(sendEl.value||'0',10) || 0) : (fxEl && fxEl.checked ? 100 : 0);
                                                        const send = Math.max(0, Math.min(1, sendPct/100));
                                                        if (this._isDrumPreviewAllowed()) this._triggerDrumSound(rowIdx, vol, send);
                                                    }
                                                } catch(_){ }
                                            }
                                            try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                            s._touchDragActive = false;
                                        };
                                        document.addEventListener('touchmove', onMove, { passive: false });
                                        document.addEventListener('touchend', onEnd);
                                        document.addEventListener('touchcancel', onEnd);
                                    }, { passive: false });
                            }
                            lane.appendChild(s);
                        }
                        const ph2=document.createElement('div'); ph2.className='drum-playhead'; ph2.style.left='0%'; lane.appendChild(ph2);
                    });
                }

                // Rebuild PATTERN lanes honoring per-lane D if patternGrid exists
                if (patternGrid) {
                    const pLanes = Array.from(patternGrid.querySelectorAll('.pattern-lane'));
                    pLanes.forEach(pl => {
                        const isBass = pl.closest('.drum-row')?.classList?.contains('bass-row');
                        // Snapshot with indices
                        const oldSteps = Array.from(pl.querySelectorAll('.pattern-step'));
                        const fromD = oldSteps.length || Math.max(1, parseInt(patternGrid.dataset.length||'16',10)||16);
                        const snap = oldSteps.map((s, i) => ({ i, active: s.classList.contains('active'), len: s.dataset.len, tie: s.dataset.tie, npc: s.dataset.npc, vel: s.dataset.vel }));
                        // Determine target D from lane.dataset.quant or fallback to pattern len
                        let toD = Math.max(1, parseInt(patternGrid.dataset.length||'16',10)||16);
                        const qStr = pl.dataset.quant || '';
                        if (qStr){ const m=qStr.match(/^(\d+)\/(\d+)$/); if (m){ const d=parseInt(m[2],10); if (Number.isFinite(d)&&d>0) toD=d; } else { const mn=qStr.match(/^(\d+)$/); if (mn){ const d=parseInt(mn[1],10); if(Number.isFinite(d)&&d>0) toD=d; } } }
                        // Clear visuals
                        Array.from(pl.querySelectorAll('.pattern-step,.beat-divider,.drum-playhead')).forEach(n=> n.remove());
                        try { pl.style.setProperty('--steps-per-bar', String(toD)); } catch(_){ }
                        // Beat dividers baseline: quarters of toD
                        const fullBeats = Math.max(0, Math.floor(toD/4));
                        for (let b=1;b<fullBeats;b++){ const div=document.createElement('div'); div.className='beat-divider'; div.style.left=`${(b/fullBeats)*100}%`; pl.appendChild(div); }
                        // Build new steps and remap
                        const rowIdx = parseInt(pl.dataset.row||'0',10)||0;
                        // Compute N for pattern lanes from dataset.quant
                        let toN = toD; try { const qs = pl.dataset.quant||''; const mm = qs.match(/^(\d+)\/(\d+)$/); if (mm){ const n=parseInt(mm[1],10); const d=parseInt(mm[2],10); if (Number.isFinite(d)&&d>0) toD=d; if (Number.isFinite(n)&&n>0) toN=Math.min(n,toD); } } catch(_){}
                        const isBassRow = (rowIdx===9) || isBass;
                        const dest = new Array(toD).fill(null).map(()=>({}));
                        if (!isBassRow) {
                            // Map active heads proportionally
                            snap.forEach(o=>{ if (o.active){ const j = Math.max(0, Math.min(toD-1, Math.round((o.i / Math.max(1,fromD-1)) * (toD-1)))); dest[j].active=1; if (o.len) dest[j].len=o.len; dest[j].vel=o.vel; } });
                        } else {
                            // Bass: remap heads with lengths, preserve npc and ties
                            // Detect heads
                            const heads = snap.filter((o, idx)=>{
                                const npc = (o.npc||'').toLowerCase();
                                if (!npc || npc==='x') return false;
                                const prev = snap[idx-1];
                                return !(prev && prev.tie==='1');
                            });
                            heads.forEach(h=>{
                                const j = Math.max(0, Math.min(toD-1, Math.round((h.i / Math.max(1,fromD-1)) * (toD-1))));
                                const len = Math.max(1, parseInt(h.len||'1',10)||1);
                                dest[j].npc = h.npc;
                                dest[j].len = String(len);
                                dest[j].head = 1;
                            });
                        }
                        // Precompute allowed indices for N notes across D divisions (evenly distributed)
                        const allowed = new Set();
                        if (toN >= toD) { for (let k=0;k<toD;k++) allowed.add(k); }
                        else {
                            for (let k=0;k<toN;k++){ const idx = Math.max(0, Math.min(toD-1, Math.floor((k*toD)/toN))); allowed.add(idx); }
                        }
                        for (let i=0;i<toD;i++){
                            const st = document.createElement('div');
                            st.className='drum-step pattern-step'+((i%4===0)?' beat-accent':'');
                            st.dataset.step=String(i);
                            if (isBassRow) st.dataset.npc='';
                            const prev = dest[i];
                            if (prev){
                                if (!isBassRow) { if (prev.active) { st.classList.add('active'); if (prev.len) st.dataset.len = prev.len; } }
                                else {
                                    if (prev.npc && prev.npc.toLowerCase()!=='x'){ st.dataset.npc=prev.npc; st.classList.add('active'); }
                                    if (prev.len) st.dataset.len=prev.len;
                                }
                            }
                            if (!isBassRow) {
                                st.dataset.vel = (prev && prev.vel != null) ? String(prev.vel) : '100';
                                try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(st); } catch(_){ }
                                try { if (window.attachVelocityDrag) window.attachVelocityDrag(st); } catch(_){ }
                            }
                            if (!isBassRow && !allowed.has(i)) st.classList.add('disabled');
                            pl.appendChild(st);
                        }
                        // Rebuild tie overlays
                        try { if (!isBassRow) rebuildPatternTieOverlays(pl); else rebuildBassTieOverlays(pl); } catch(_){ }
                    });
                    // Ensure pattern handlers are wired after rebuild
                    try { if (typeof patternGrid._attachHandlers === 'function') patternGrid._attachHandlers(); } catch(_){ }
                }
            } catch(_){}
        };
        
        this.cycleStrumMode = () => {
            const order = ['up','down','alt-centers','alt-ends'];
            const i = order.indexOf(this.strumMode);
            this.strumMode = order[(i+1)%order.length];
            // Only UP/DOWN change the display orientation
            if (this.strumMode === 'up') this.strumOrientation = 'up';
            if (this.strumMode === 'down') this.strumOrientation = 'down';
            const lbl = document.getElementById('strumLabel');
            if (lbl) {
                // Prefer human-friendly labels
                if (this.strumMode === 'alt-centers') lbl.textContent = 'ALT CENTRE';
                else if (this.strumMode === 'alt-ends') lbl.textContent = 'ALT ENDS';
                else lbl.textContent = this.strumMode.charAt(0).toUpperCase()+this.strumMode.slice(1);
            }
        };
        this.updateModeUI = () => {
            const btnStrum = document.getElementById('modeStrum');
            const sidebarStrum = document.getElementById('strumBtn');
            const btnChordArp = document.getElementById('modeChordArp');
            const btnBass = document.getElementById('universalBass');
            
            // Update strum button text based on current strum mode
            const applyStrumLabel = (el) => {
                if (!el) return;
                el.classList.add('active'); // always ON visually
                let strumText = 'STRUM UP';
                switch (this.strumMode) {
                    case 'up': strumText = 'STRUM UP'; break;
                    case 'down': strumText = 'STRUM DOWN'; break;
                    case 'alt-centers': strumText = 'STRUM ALT CENTRE'; break;
                    case 'alt-ends': strumText = 'STRUM ALT ENDS'; break;
                    default: strumText = 'STRUM UP'; break;
                }
                el.textContent = strumText;
                // Optional: title tooltip
                el.title = 'Cycle strum order (UP/DOWN/ALT CENTRE/ALT ENDS)';
            };
            applyStrumLabel(btnStrum);
            applyStrumLabel(sidebarStrum);
            
            // CHORD/ARP 4-state toggle (OFF / CHORDS / ARP / ARP+CHORDS)
            if (btnChordArp) {
                let label = 'OFF';
                let title = 'Currently OFF; click to enable CHORDS';
                if (this.chordsEnabled && this.arpEnabled) { label = 'ARP+CHORDS'; title = 'Both ON; click for OFF'; }
                else if (this.chordsEnabled) { label = 'CHORDS'; title = 'CHORDS ON; click for ARP'; }
                else if (this.arpEnabled) { label = 'ARP'; title = 'ARP ON; click for ARP+CHORDS'; }
                btnChordArp.textContent = label;
                btnChordArp.classList.toggle('active', true); // keep styled active
                btnChordArp.title = title;
            }
            if (btnBass) btnBass.classList.toggle('active', this.bassEnabled);

            // OSC 3: reuse Release slider as Slide Time in CHORDS mode
            try { this._syncChordReleaseControlMode && this._syncChordReleaseControlMode(); } catch(_) {}
        };
        // Wire buttons when present
        setTimeout(()=>{
            const btnStrum = document.getElementById('modeStrum');
            const sidebarStrum = document.getElementById('strumBtn');
            const btnChordArp = document.getElementById('modeChordArp');
            const btnBass = document.getElementById('universalBass');
            const drumsBtn = document.getElementById('drumsBtn');
            const lbl = document.getElementById('strumLabel');
            if (lbl) {
                if (this.strumMode === 'alt-centers') lbl.textContent = 'ALT CENTRE';
                else if (this.strumMode === 'alt-ends') lbl.textContent = 'ALT ENDS';
                else lbl.textContent = this.strumMode.charAt(0).toUpperCase()+this.strumMode.slice(1);
            }
            if (btnStrum && !btnStrum._wired){ btnStrum._wired=true; btnStrum.addEventListener('click', ()=> this.toggleStrumMode()); }
            // Sidebar STRUM cycles too via sidebarBtnClick('strum'); ensure label initializes
            if (sidebarStrum && !sidebarStrum._initLabel){ sidebarStrum._initLabel=true; }
            if (btnChordArp && !btnChordArp._wired){ btnChordArp._wired=true; btnChordArp.addEventListener('click', ()=> this.toggleChordArpMode()); }
            if (btnBass && !btnBass._wired){ btnBass._wired=true; btnBass.addEventListener('click', ()=> this.toggleBassMode()); }
            if (drumsBtn) drumsBtn.classList.add('active');
            this.syncPlayMode();
            this.updateModeUI();
        }, 0);

                // Fixed strum delay (no menu)
                this.strumDelayMs = 12;

                // Chords slide state
                this._chordSlideEnabled = !!document.getElementById('chordSlide')?.checked;
                this._chordSlideActive = false;
                this._chordSlideVoices = new Map(); // Map<stringRowEl, {freq,startLog2}>
                // Choir-slide (OSC 3 / CHORDS) state: reuse Release slider as Slide Time when CHORDS is enabled
                this._chordReleaseMs = 500;
                this._chordSlideSteps16 = 4; // 4/16 bar ~= 500ms @120bpm in 4/4
                this._chordSlideGroupId = 0;
                this._chordSlideStartColumn = null;
                this._chordSlideHoverColumn = null;
                
                // Update PLAY/STOP button states based on initial SLIDE setting
                this._updatePlayStopButtonStates();
                this._chordSlideHoverSince = 0;
                this._chordSlideCommittedColumn = null;
                this._lastChordSlideTime = 0;
                this._chordSlideHoverCommitTimer = null;
                // Idle-stop for CHORD slide mode
                this._chordSlideIdleTimer = null;
                this._chordSlideIdleMs = 2000; // stop sustaining ~2s after last activity
                // Small dwell to avoid triggering intermediate boxes during fast slides (ms)
                this._chordSlideDwellMs = 50; // default 50ms, target: 40â€“60ms - improved touch responsiveness
                // Track last movement vector for direction-aware voice leading
                this._chordSlideLastDX = 0;
                this._chordSlideLastDY = 0;
                this._lastChordSlideDeltaT = 0;
                const chordSlideEl = document.getElementById('chordSlide');
                if (chordSlideEl) {
                    chordSlideEl.addEventListener('change', (e)=>{
                        this._chordSlideEnabled = !!e.target.checked;
                        if (!this._chordSlideEnabled) {
                            try { clearTimeout(this._chordSlideIdleTimer); } catch(_) {}
                            this._chordSlideIdleTimer = null;
                            this._chordSlideActive = false;
                        }
                        
                        // Update PLAY/STOP button states
                        this._updatePlayStopButtonStates();
                    });
                }

                // Helpers for OSC3 CHOIR SLIDE mode
                this._isChordChoirSlideMode = () => {
                    // Spec: when CHORDS is lit/active
                    return !!this.chordsEnabled;
                };
                this._getBarDurationSec = () => {
                    try {
                        // Prefer transport timing when available
                        const beatMs = this._arpTransport?.beatMs;
                        const beatsPerBar = this._arpTransport?.beatsPerBar;
                        if (Number.isFinite(beatMs) && Number.isFinite(beatsPerBar) && beatsPerBar > 0) {
                            return Math.max(0.05, (beatMs * beatsPerBar) / 1000);
                        }
                    } catch(_) {}
                    try {
                        const bpmEl = document.getElementById('universalBpm');
                        const bpm = bpmEl ? parseInt(bpmEl.value, 10) : 120;
                        const beatMs = 60000 / Math.max(20, (Number.isFinite(bpm) ? bpm : 120));
                        const tsEl = document.getElementById('universalTimeSignature');
                        const tsRaw = tsEl ? String(tsEl.value || '4/4') : '4/4';
                        let tsNum = 4, tsDen = 4;
                        try {
                            const [n, d] = tsRaw.split('/').map(x => parseInt(x, 10));
                            if (Number.isFinite(n) && n > 0) tsNum = n;
                            if (Number.isFinite(d) && d > 0) tsDen = d;
                        } catch(_) {}
                        const beatsPerBar = (tsNum * 4) / tsDen;
                        return Math.max(0.05, (beatMs * beatsPerBar) / 1000);
                    } catch(_) {}
                    return 2.0;
                };
                this._getChordSlideTimeSec = () => {
                    if (!this._isChordChoirSlideMode()) {
                        return Math.max(0, Number(this.instruments?.chord?.env?.release) || 0);
                    }
                    const steps = Math.max(1, Math.min(16, (this._chordSlideSteps16 | 0) || 4));
                    const barSec = this._getBarDurationSec();
                    return Math.max(0, (steps / 16) * barSec);
                };
                this._formatChordSlideLabel = (steps, sec) => {
                    const s = Math.max(1, Math.min(16, (steps | 0) || 1));
                    const ms = Math.round(Math.max(0, sec) * 1000);
                    return `${s}/16 bar (${ms}ms)`;
                };
                this._syncChordReleaseControlMode = () => {
                    const slider = document.getElementById('chordReleaseSlider');
                    const label = document.getElementById('chordReleaseLabel');
                    const valueEl = document.getElementById('chordReleaseValue');
                    if (!slider) return;

                    if (this._isChordChoirSlideMode()) {
                        // Switch to musical range 1..16 (1/16..1 bar)
                        if (slider.min !== '1' || slider.max !== '16') {
                            // On first entry, derive steps from existing release seconds if possible
                            try {
                                const barSec = this._getBarDurationSec();
                                const relSec = Math.max(0, Number(this.instruments?.chord?.env?.release) || 0);
                                const derived = Math.round((relSec / Math.max(0.001, barSec)) * 16);
                                if (!Number.isFinite(this._chordSlideSteps16) || this._chordSlideSteps16 <= 0) {
                                    this._chordSlideSteps16 = Math.max(1, Math.min(16, derived || 4));
                                }
                            } catch(_) {}

                            slider.min = '1';
                            slider.max = '16';
                            slider.step = '1';
                        }
                        slider.value = String(Math.max(1, Math.min(16, (this._chordSlideSteps16 | 0) || 4)));
                        const sec = this._getChordSlideTimeSec();
                        if (label) label.textContent = 'SLIDE TIME';
                        if (valueEl) valueEl.textContent = this._formatChordSlideLabel(this._chordSlideSteps16, sec);
                        // Keep env.release aligned so stop envelopes also use the same time
                        try { this.instruments.chord.env.release = sec; } catch(_) {}
                    } else {
                        // Normal ADSR release in ms
                        if (slider.min !== '0' || slider.max !== '1000') {
                            slider.min = '0';
                            slider.max = '1000';
                            slider.step = '1';
                        }
                        slider.value = String(Math.max(0, Math.min(1000, (this._chordReleaseMs | 0) || 500)));
                        const ms = Math.max(0, Math.min(1000, (this._chordReleaseMs | 0) || 500));
                        if (label) label.textContent = 'Release';
                        if (valueEl) valueEl.textContent = `${ms}ms`;
                        try { this.instruments.chord.env.release = ms / 1000; } catch(_) {}
                    }
                };

                // OSC 2 ADSR controls
                const osc2AttackSlider = document.getElementById('osc2AttackSlider');
                if (osc2AttackSlider) {
                    osc2AttackSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.instruments.strum2.env.attack = Math.max(0.003, e.target.value / 1000); // 3ms minimum
                        const osc2AttackValue = document.getElementById('osc2AttackValue');
                        if (osc2AttackValue) {
                            osc2AttackValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('osc2AttackSlider not found');
                }
                
                const osc2DecaySlider = document.getElementById('osc2DecaySlider');
                if (osc2DecaySlider) {
                    osc2DecaySlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        const ms = Math.max(0, parseInt(e.target.value, 10) || 0);
                        this.instruments.strum2.env.decay = ms / 1000;
                        const osc2DecayValue = document.getElementById('osc2DecayValue');
                        if (osc2DecayValue) osc2DecayValue.textContent = `${ms}ms`;
                    });
                } else {
                    console.error('osc2DecaySlider not found');
                }
                
                const osc2SustainSlider = document.getElementById('osc2SustainSlider');
                if (osc2SustainSlider) {
                    osc2SustainSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        const pct = Math.min(100, Math.max(0, parseInt(e.target.value, 10) || 0));
                        this.instruments.strum2.env.sustain = pct / 100;
                        const osc2SustainValue = document.getElementById('osc2SustainValue');
                        if (osc2SustainValue) osc2SustainValue.textContent = `${pct}%`;
                    });
                } else {
                    console.error('osc2SustainSlider not found');
                }
                
                const osc2ReleaseSlider = document.getElementById('osc2ReleaseSlider');
                if (osc2ReleaseSlider) {
                    osc2ReleaseSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        // Clamp to 0â€“1000ms => 0â€“1.0s
                        const ms = Math.max(0, Math.min(1000, parseInt(e.target.value, 10) || 0));
                        this.instruments.strum2.env.release = ms / 1000;
                        const osc2ReleaseValue = document.getElementById('osc2ReleaseValue');
                        if (osc2ReleaseValue) {
                            osc2ReleaseValue.textContent = `${ms}ms`;
                        }
                    });
                } else {
                    console.error('osc2ReleaseSlider not found');
                }

                // Tab switching for OSC modal (STRUM 1 / STRUM 2 / CHORD only)
                const tabBtns = document.querySelectorAll('.osc-tab-btn');
                const tabStrum1 = document.getElementById('tab-strum1');
                const tabStrum2 = document.getElementById('tab-strum2');
                const tabChord = document.getElementById('tab-chord');
                const showTab = (key)=>{
                    if (!tabStrum1 || !tabStrum2 || !tabChord) return;
                    tabBtns.forEach(b=> b.classList.remove('active'));
                    const btn = Array.from(tabBtns).find(b=> b.dataset.tab===key);
                    if (btn) btn.classList.add('active');
                    tabStrum1.style.display = (key==='strum1') ? 'block' : 'none';
                    tabStrum2.style.display = (key==='strum2') ? 'block' : 'none';
                    tabChord.style.display = (key==='chord') ? 'block' : 'none';
                };
                tabBtns.forEach(b=>{
                    if (!b._wired){ b._wired=true; b.addEventListener('click', ()=> showTab(b.dataset.tab)); }
                });

                // Oscillator controls
                // NOTE: pattern instances are created dynamically by cloning the Pattern modal.
                // Cloned .osc-btn elements won't have per-element listeners, so use event delegation.
                if (!window.__xen_oscWaveDelegationWired) {
                    window.__xen_oscWaveDelegationWired = true;
                    document.addEventListener('click', (e) => {
                        const btn = (e && e.target && e.target.closest) ? e.target.closest('.osc-btn[data-wave]') : null;
                        if (!btn) return;

                        const omni = window.omnichord || this;
                        if (omni && omni.isActiveChordPianoLocked && omni.isActiveChordPianoLocked()) { omni.flashPianoLockFeedback && omni.flashPianoLockFeedback(); return; }

                        const wave = btn.dataset.wave;
                        if (!wave) return;

                        // STRUM osc1/osc2 use existing buttons with data-osc
                        if (btn.dataset.osc) {
                            const osc = btn.dataset.osc;
                            document.querySelectorAll(`[data-osc="${osc}"]`).forEach(b => b.classList.remove('active'));
                            btn.classList.add('active');
                            if (omni && omni.oscillators && omni.oscillators[`osc${osc}`]) omni.oscillators[`osc${osc}`].type = wave;
                            const pwContainer = document.querySelector(`.pulse-width-container[data-osc="${osc}"]`);
                            if (pwContainer) pwContainer.style.display = (wave === 'pulse') ? 'block' : 'none';
                            // Mirror to per-instrument store
                            try {
                                if (omni && omni.instruments) {
                                    const target = (osc==='1') ? omni.instruments.strum1 : omni.instruments.strum2;
                                    if (target && target.osc) target.osc.type = wave;
                                }
                            } catch(_){ }
                            return;
                        }

                        // Per-instrument (CHORD/ARP/BASS and any arp-variants like arp2)
                        if (btn.dataset.inst) {
                            const instName = String(btn.dataset.inst || '').trim();
                            if (!instName) return;

                            // Ensure instrument exists (arp-variants inherit from arp)
                            try {
                                if (omni && omni.instruments && !omni.instruments[instName]) {
                                    const baseType = instName.startsWith('arp') ? 'arp' : instName;
                                    const base = omni.instruments[baseType];
                                    if (base) {
                                        omni.instruments[instName] = (typeof structuredClone === 'function') ? structuredClone(base) : JSON.parse(JSON.stringify(base));
                                    }
                                }
                            } catch(_){ }
                            if (!omni || !omni.instruments || !omni.instruments[instName] || !omni.instruments[instName].osc) return;

                            document.querySelectorAll(`.osc-btn[data-inst="${instName}"]`).forEach(b => b.classList.remove('active'));
                            btn.classList.add('active');
                            omni.instruments[instName].osc.type = wave;
                            const c = document.getElementById(`${instName}PulseWidthContainer`);
                            if (c) c.style.display = (wave==='pulse')?'block':'none';
                        }
                    });
                }

                // Oscillator detune and level controls
                ['1', '2'].forEach(num => {
                    // Shape width slider (DC proportion)
                    const swSlider = document.getElementById(`osc${num}ShapeWidth`);
                    if (swSlider) {
                        swSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            const pct = Math.min(100, Math.max(0, parseInt(e.target.value, 10) || 50));
                            this.oscillators[`osc${num}`].shapeWidth = pct / 100; // 0..1
                            const v = document.getElementById(`osc${num}ShapeWidthValue`);
                            if (v) v.textContent = `${pct}%`;
                            // Mirror to per-instrument
                            const target = (num==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.shapeWidth = pct/100;
                        });
                    }

                    // Pulse width slider
                    const pwSlider = document.getElementById(`osc${num}PulseWidth`);
                    if (pwSlider) {
                        pwSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            const pct = Math.min(95, Math.max(5, parseInt(e.target.value, 10) || 50));
                            this.oscillators[`osc${num}`].pulseWidth = pct / 100;
                            const v = document.getElementById(`osc${num}PulseWidthValue`);
                            if (v) v.textContent = `${pct}%`;
                            const target = (num==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.pulseWidth = pct/100;
                        });
                    }

                    const detuneSlider = document.getElementById(`osc${num}Detune`);
                    if (detuneSlider) {
                        detuneSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            this.oscillators[`osc${num}`].detune = parseInt(e.target.value);
                            const detuneValue = document.getElementById(`osc${num}DetuneValue`);
                            if (detuneValue) {
                                detuneValue.textContent = `${e.target.value}Â¢`;
                            }
                            const target = (num==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.detune = parseInt(e.target.value);
                        });
                    } else {
                        console.error(`osc${num}Detune not found`);
                    }
                    
                    const levelSlider = document.getElementById(`osc${num}Level`);
                    if (levelSlider) {
                        levelSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            // Convert 0-10 scale to -18dB to 0dB (linear from 0.125 to 1.0)
                            const sliderValue = e.target.value / 10; // 0-1
                            this.oscillators[`osc${num}`].level = sliderValue * 0.125; // Max at -18dB
                            const levelValue = document.getElementById(`osc${num}LevelValue`);
                            if (levelValue) {
                                levelValue.textContent = `${e.target.value * 10}%`;
                            }
                            const target = (num==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.level = sliderValue * 0.125;
                        });
                    } else {
                        console.error(`osc${num}Level not found`);
                    }
                });

                // Oscillator octave and coarse controls
                ['1', '2'].forEach(num => {
                    const octaveSlider = document.getElementById(`osc${num}Octave`);
                    if (octaveSlider) {
                        octaveSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            this.oscillators[`osc${num}`].octave = parseInt(e.target.value);
                            const octaveValue = document.getElementById(`osc${num}OctaveValue`);
                            if (octaveValue) {
                                octaveValue.textContent = e.target.value;
                            }
                            const target = (num==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.octave = parseInt(e.target.value);
                        });
                    } else {
                        console.error(`osc${num}Octave not found`);
                    }
                    
                    const coarseSlider = document.getElementById(`osc${num}Coarse`);
                    if (coarseSlider) {
                        coarseSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            this.oscillators[`osc${num}`].coarse = parseInt(e.target.value);
                            const coarseValue = document.getElementById(`osc${num}CoarseValue`);
                            if (coarseValue) {
                                coarseValue.textContent = `${e.target.value} steps`;
                            }
                            const target = (num==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.coarse = parseInt(e.target.value);
                        });
                    } else {
                        console.error(`osc${num}Coarse not found`);
                    }
                });

                // CHORD/BASS/ARP controls wiring (with piano lock protection)
                // Default values for all sliders (for double-tap reset)
                this.sliderDefaults = {
                    // OSC 1 (STRUM 1)
                    'osc1Level': 5, 'osc1Detune': 0, 'osc1Octave': 0, 'osc1Coarse': 0, 'osc1PulseWidth': 50, 'osc1ShapeWidth': 50,
                    'attackSlider': 0, 'decaySlider': 200, 'sustainSlider': 0, 'releaseSlider': 1000,
                    // OSC 2 (STRUM 2) 
                    'osc2Level': 5, 'osc2Detune': 0, 'osc2Octave': 0, 'osc2Coarse': 0, 'osc2PulseWidth': 50, 'osc2ShapeWidth': 50,
                    'attack2Slider': 0, 'decay2Slider': 200, 'sustain2Slider': 0, 'release2Slider': 1000,
                    // CHORD (OSC 3)
                    'chordLevel': 5, 'chordDetune': 0, 'chordOctave': 0, 'chordCoarse': 0, 'chordPulseWidth': 50, 'chordShapeWidth': 50,
                    'chordAttack': 10, 'chordDecay': 200, 'chordSustain': 90, 'chordRelease': 300,
                    // ARP (OSC 5)
                    'arpLevel': 5, 'arpDetune': 0, 'arpOctave': 0, 'arpCoarse': 0, 'arpPulseWidth': 50, 'arpShapeWidth': 50,
                    'arpAttack': 10, 'arpDecay': 200, 'arpSustain': 90, 'arpRelease': 300,
                    // BASS (OSC 4)
                    'bassLevel': 5, 'bassDetune': 0, 'bassOctave': 0, 'bassCoarse': 0, 'bassPulseWidth': 50, 'bassShapeWidth': 50,
                    'bassAttack': 5, 'bassDecay': 80, 'bassSustain': 90, 'bassRelease': 120,
                    // FX
                    'driveAmount': 0, 'driveMix': 0, 'driveHpCutoff': 0, 'driveLpCutoff': 100,
                    'delayTime': 280, 'delayFeedback': 25, 'delayLpCutoff': 73, 'delayHpCutoff': 0, 'delayMix': 0,
                    'filterLow': 0, 'filterHigh': 100, 'filterRes': 1,
                    'reverbWet': 1, 'reverbRoom': 5, 'reverbDecay': 20, 'reverbFilterCutoff': 70
                };

                const wireVal = (id, cb)=>{ 
                    const el=document.getElementById(id); 
                    if (el && !el._wired){ 
                        el._wired=true; 
                        
                        // Double-tap detection for sliders (not checkboxes)
                        if (el.type !== 'checkbox') {
                            let lastTapTime = 0;
                            const doubleTapDelay = 300; // ms
                            
                            // Double-tap handler
                            el.addEventListener('dblclick', (e) => {
                                e.preventDefault();
                                if (this.sliderDefaults.hasOwnProperty(id)) {
                                    el.value = this.sliderDefaults[id];
                                    // Trigger the change event to update the UI and internal state
                                    const changeEvent = new Event('input', { bubbles: true });
                                    el.dispatchEvent(changeEvent);
                                }
                            });
                        }
                        
                        // Use appropriate event based on element type
                        const eventType = el.type === 'checkbox' ? 'change' : 'input';
                        el.addEventListener(eventType, (e)=>{ 
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { 
                                this.flashPianoLockFeedback && this.flashPianoLockFeedback(); 
                                return; 
                            } 
                            cb(e); 
                        });
                    } 
                };
                wireVal('chordShapeWidth', (e)=>{ const pct=Math.max(0,Math.min(100,parseInt(e.target.value)||50)); this.instruments.chord.osc.shapeWidth=pct/100; const v=document.getElementById('chordShapeWidthValue'); if(v) v.textContent=`${pct}%`; });
                wireVal('chordPulseWidth', (e)=>{ const pct=Math.max(5,Math.min(95,parseInt(e.target.value)||50)); this.instruments.chord.osc.pulseWidth=pct/100; const v=document.getElementById('chordPulseWidthValue'); if(v) v.textContent=`${pct}%`; });
                wireVal('chordDetune', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.chord.osc.detune=v; const l=document.getElementById('chordDetuneValue'); if(l) l.textContent=`${v}Â¢`; });
                wireVal('chordLevel', (e)=>{
                    const v=parseInt(e.target.value)||0;
                    this.instruments.chord.osc.level=(v/10)*0.125;
                    const l=document.getElementById('chordLevelValue');
                    if(l) l.textContent=`${v*10}%`;
                    // Apply immediately to sustained/gliding chord voices.
                    try { this._applyLiveChordOutputLevel(); } catch(_){ }
                });
                wireVal('chordOctave', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.chord.osc.octave=v; const l=document.getElementById('chordOctaveValue'); if(l) l.textContent=String(v); });
                wireVal('chordCoarse', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.chord.osc.coarse=v; const l=document.getElementById('chordCoarseValue'); if(l) l.textContent=`${v} steps`; });
                wireVal('chordAttackSlider', (e)=>{ const ms=Math.max(3,parseInt(e.target.value)||10); this.instruments.chord.env.attack=ms/1000; const l=document.getElementById('chordAttackValue'); if(l) l.textContent=`${ms}ms`; });
                wireVal('chordDecaySlider', (e)=>{ const ms=Math.max(0,parseInt(e.target.value)||200); this.instruments.chord.env.decay=ms/1000; const l=document.getElementById('chordDecayValue'); if(l) l.textContent=`${ms}ms`; });
                wireVal('chordSustainSlider', (e)=>{ const pct=Math.max(0,Math.min(100,parseInt(e.target.value)||70)); this.instruments.chord.env.sustain=pct/100; const l=document.getElementById('chordSustainValue'); if(l) l.textContent=`${pct}%`; });
                wireVal('chordReleaseSlider', (e)=>{
                    const el = e.target;
                    if (this._isChordChoirSlideMode && this._isChordChoirSlideMode()) {
                        const steps = Math.max(1, Math.min(16, parseInt(el.value, 10) || 4));
                        this._chordSlideSteps16 = steps;
                        const sec = this._getChordSlideTimeSec ? this._getChordSlideTimeSec() : Math.max(0, Number(this.instruments?.chord?.env?.release) || 0);
                        this.instruments.chord.env.release = sec;
                        const l = document.getElementById('chordReleaseValue');
                        if (l) l.textContent = (this._formatChordSlideLabel ? this._formatChordSlideLabel(steps, sec) : `${steps}/16 bar`);
                    } else {
                        const ms = Math.max(0, Math.min(1000, parseInt(el.value, 10) || 500));
                        this._chordReleaseMs = ms;
                        this.instruments.chord.env.release = ms / 1000;
                        const l = document.getElementById('chordReleaseValue');
                        if (l) l.textContent = `${ms}ms`;
                    }
                });

                // ARP instrument controls (and arp-variants like arp2/arp3)
                const wireArpInstrumentControls = (instName='arp') => {
                    const key = String(instName || 'arp');
                    try {
                        if (!this.instruments[key]) {
                            const base = this.instruments.arp;
                            if (base) this.instruments[key] = (typeof structuredClone === 'function') ? structuredClone(base) : JSON.parse(JSON.stringify(base));
                        }
                    } catch(_){ }
                    const getIns = ()=>{ try { return this.instruments[key]; } catch(_){ return null; } };
                    wireVal(`${key}ShapeWidth`, (e)=>{ const pct=Math.max(0,Math.min(100,parseInt(e.target.value)||50)); const ins=getIns(); if(!ins) return; ins.osc.shapeWidth=pct/100; const v=document.getElementById(`${key}ShapeWidthValue`); if(v) v.textContent=`${pct}%`; });
                    wireVal(`${key}PulseWidth`, (e)=>{ const pct=Math.max(5,Math.min(95,parseInt(e.target.value)||50)); const ins=getIns(); if(!ins) return; ins.osc.pulseWidth=pct/100; const v=document.getElementById(`${key}PulseWidthValue`); if(v) v.textContent=`${pct}%`; });
                    wireVal(`${key}Detune`, (e)=>{ const v=parseInt(e.target.value)||0; const ins=getIns(); if(!ins) return; ins.osc.detune=v; const l=document.getElementById(`${key}DetuneValue`); if(l) l.textContent=`${v}Â¢`; });
                    wireVal(`${key}Level`, (e)=>{ const v=parseInt(e.target.value)||0; const ins=getIns(); if(!ins) return; ins.osc.level=(v/10)*0.125; const l=document.getElementById(`${key}LevelValue`); if(l) l.textContent=`${v*10}%`; });
                    wireVal(`${key}Octave`, (e)=>{ const v=parseInt(e.target.value)||0; const ins=getIns(); if(!ins) return; ins.osc.octave=v; const l=document.getElementById(`${key}OctaveValue`); if(l) l.textContent=String(v); });
                    wireVal(`${key}Coarse`, (e)=>{ const v=parseInt(e.target.value)||0; const ins=getIns(); if(!ins) return; ins.osc.coarse=v; const l=document.getElementById(`${key}CoarseValue`); if(l) l.textContent=`${v} steps`; });
                    wireVal(`${key}AttackSlider`, (e)=>{ const ms=Math.max(3,parseInt(e.target.value)||10); const ins=getIns(); if(!ins) return; ins.env.attack=ms/1000; const l=document.getElementById(`${key}AttackValue`); if(l) l.textContent=`${ms}ms`; });
                    wireVal(`${key}DecaySlider`, (e)=>{ const ms=Math.max(0,parseInt(e.target.value)||200); const ins=getIns(); if(!ins) return; ins.env.decay=ms/1000; const l=document.getElementById(`${key}DecayValue`); if(l) l.textContent=`${ms}ms`; });
                    wireVal(`${key}SustainSlider`, (e)=>{ const pct=Math.max(0,Math.min(100,parseInt(e.target.value)||70)); const ins=getIns(); if(!ins) return; ins.env.sustain=pct/100; const l=document.getElementById(`${key}SustainValue`); if(l) l.textContent=`${pct}%`; });
                    wireVal(`${key}ReleaseSlider`, (e)=>{ const ms=Math.max(0,parseInt(e.target.value)||500); const ins=getIns(); if(!ins) return; ins.env.release=ms/1000; const l=document.getElementById(`${key}ReleaseValue`); if(l) l.textContent=`${ms}ms`; });
                    wireVal(`${key}FxSend`, (e)=>{ const ins=getIns(); if(!ins) return; ins.fxSend = !!e.target.checked; });
                };
                // Expose for spawned Pattern instances
                this._wireArpInstrumentControls = wireArpInstrumentControls;
                wireArpInstrumentControls('arp');

                wireVal('bassShapeWidth', (e)=>{ const pct=Math.max(0,Math.min(100,parseInt(e.target.value)||50)); this.instruments.bass.osc.shapeWidth=pct/100; const l=document.getElementById('bassShapeWidthValue'); if(l) l.textContent=`${pct}%`; });
                wireVal('bassPulseWidth', (e)=>{ const pct=Math.max(5,Math.min(95,parseInt(e.target.value)||50)); this.instruments.bass.osc.pulseWidth=pct/100; const l=document.getElementById('bassPulseWidthValue'); if(l) l.textContent=`${pct}%`; });
                wireVal('bassDetune', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.bass.osc.detune=v; const l=document.getElementById('bassDetuneValue'); if(l) l.textContent=`${v}Â¢`; });
                wireVal('bassLevel', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.bass.osc.level=(v/10)*0.125; const l=document.getElementById('bassLevelValue'); if(l) l.textContent=`${v*10}%`; });
                wireVal('bassOctave', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.bass.osc.octave=v; const l=document.getElementById('bassOctaveValue'); if(l) l.textContent=String(v); });
                wireVal('bassCoarse', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.bass.osc.coarse=v; const l=document.getElementById('bassCoarseValue'); if(l) l.textContent=`${v} steps`; });
                wireVal('bassAttackSlider', (e)=>{ const ms=Math.max(3,parseInt(e.target.value)||5); this.instruments.bass.env.attack=ms/1000; const l=document.getElementById('bassAttackValue'); if(l) l.textContent=`${ms}ms`; });
                wireVal('bassDecaySlider', (e)=>{ const ms=Math.max(0,parseInt(e.target.value)||80); this.instruments.bass.env.decay=ms/1000; const l=document.getElementById('bassDecayValue'); if(l) l.textContent=`${ms}ms`; });
                wireVal('bassSustainSlider', (e)=>{ const pct=Math.max(0,Math.min(100,parseInt(e.target.value)||85)); this.instruments.bass.env.sustain=pct/100; const l=document.getElementById('bassSustainValue'); if(l) l.textContent=`${pct}%`; });
                wireVal('bassReleaseSlider', (e)=>{ const ms=Math.max(0,parseInt(e.target.value)||120); this.instruments.bass.env.release=ms/1000; const l=document.getElementById('bassReleaseValue'); if(l) l.textContent=`${ms}ms`; });

                // FX Send checkboxes
                wireVal('strum1FxSend', (e)=>{ this.instruments.strum1.fxSend = e.target.checked; });
                wireVal('strum2FxSend', (e)=>{ this.instruments.strum2.fxSend = e.target.checked; });
                wireVal('chordFxSend', (e)=>{ this.instruments.chord.fxSend = e.target.checked; });
                // (arp FX Send is wired via _wireArpInstrumentControls so arp2/arp3 can reuse it)
                wireVal('bassFxSend', (e)=>{ this.instruments.bass.fxSend = e.target.checked; });


                // Reverb controls
                // Drive controls
                const driveAmt = document.getElementById('driveAmount');
                if (driveAmt) {
                    driveAmt.addEventListener('input', (e)=>{
                        const v = Math.max(0, Math.min(100, parseInt(e.target.value)||0));
                        this.drive.amount = v;
                        const el = document.getElementById('driveAmountValue'); if (el) el.textContent = `${v}%`;
                        if (typeof this.updateDrive === 'function') this.updateDrive();
                    });
                }
                const driveMix = document.getElementById('driveMix');
                if (driveMix) {
                    driveMix.addEventListener('input', (e)=>{
                        const v = Math.max(0, Math.min(100, parseInt(e.target.value)||0));
                        this.drive.mix = v;
                        const el = document.getElementById('driveMixValue'); if (el) el.textContent = `${v}%`;
                        if (typeof this.updateDrive === 'function') this.updateDrive();
                    });
                }

                // Reverb controls
                // Delay controls
                const delayTime = document.getElementById('delayTime');
                if (delayTime) delayTime.addEventListener('input', (e)=>{
                    const ms = Math.max(20, Math.min(1000, parseInt(e.target.value)||280));
                    const el = document.getElementById('delayTimeValue'); if (el) el.textContent = `${ms}ms`;
                    if (this._delay && this._delay.node) this._delay.node.delayTime.value = ms/1000;
                });
                const delayFb = document.getElementById('delayFeedback');
                if (delayFb) delayFb.addEventListener('input', (e)=>{
                    const v = Math.max(0, Math.min(95, parseInt(e.target.value)||25))/100;
                    const el = document.getElementById('delayFeedbackValue'); if (el) el.textContent = `${Math.round(v*100)}%`;
                    if (this._delay && this._delay.feedback) this._delay.feedback.gain.value = v;
                });
                // Delay LP/HP per-effect tone (log scale)
                const delayLp = document.getElementById('delayLpCutoff');
                if (delayLp) delayLp.addEventListener('input', (e)=>{
                    const pct = Math.max(0, Math.min(100, parseInt(e.target.value)||73))/100;
                    const hz = Math.max(200, 200 * Math.pow(20000/200, pct));
                    const el = document.getElementById('delayLpCutoffValue'); if (el) el.textContent = `${hz>=20000? 'off' : (hz>=1000? (hz/1000).toFixed(1)+'kHz' : Math.round(hz)+'Hz')}`;
                    if (this._delay && this._delay.filter) this._delay.filter.frequency.value = hz; // feedback loop LP
                    if (this._delay && this._delay.wetLp) this._delay.wetLp.frequency.value = hz; // wet tone LP
                });
                const delayHp = document.getElementById('delayHpCutoff');
                if (delayHp) delayHp.addEventListener('input', (e)=>{
                    const pct = Math.max(0, Math.min(100, parseInt(e.target.value)||0))/100;
                    const hz = Math.max(20, 20 * Math.pow(2000/20, pct));
                    const el = document.getElementById('delayHpCutoffValue'); if (el) el.textContent = `${hz<=20? 'off' : Math.round(hz)+'Hz'}`;
                    if (this._delay && this._delay.wetHp) this._delay.wetHp.frequency.value = hz; // wet tone HP
                });
                const delayMix = document.getElementById('delayMix');
                if (delayMix) delayMix.addEventListener('input', (e)=>{
                    const v = Math.max(0, Math.min(100, parseInt(e.target.value)||0))/100;
                    const el = document.getElementById('delayMixValue'); if (el) el.textContent = `${Math.round(v*100)}%`;
                    if (this._delay && this._delay.wet && this._delay.dry) {
                        this._delay.wet.gain.value = v;
                        this._delay.dry.gain.value = 1;
                    }
                });

                // Dual-handle Filter controls (log scale)
                const low = document.getElementById('filterLow'); // 0..100 â†’ 20..maxHz (HP edge)
                const high = document.getElementById('filterHigh'); // 0..100 â†’ 20..maxHz (LP edge)
                const res = document.getElementById('filterRes');
                const lowLabel = document.getElementById('filterLowValue');
                const highLabel = document.getElementById('filterHighValue');
                const resLabel = document.getElementById('filterResValue');

                const getMaxHz = ()=>{
                    const nyq = (this.audioContext && this.audioContext.sampleRate) ? this.audioContext.sampleRate/2 : 22050;
                    return Math.min(20000, nyq);
                };
                const fromPercentLog = (p)=>{
                    // p in 0..100 â†’ 20..maxHz exponentially
                    const maxHz = getMaxHz();
                    const t = Math.max(0, Math.min(1, (parseFloat(p)||0)/100));
                    return Math.max(20, 20 * Math.pow(maxHz/20, t));
                };
                const toLabel = (hz, prefix)=>{
                    return `${prefix} ${hz>=1000? (hz/1000).toFixed(1)+'kHz' : Math.round(hz)+'Hz'}`;
                };
                const clampHandles = ()=>{
                    if (!low || !high) return;
                    // Ensure low <= high in frequency space; if cross, snap the moved one back
                    const lowHz = fromPercentLog(low.value);
                    const highHz = fromPercentLog(high.value);
                    if (lowHz > highHz) {
                        // Decide based on last changed element; default clamp high to low
                        if (document.activeElement === low) {
                            high.value = low.value;
                        } else {
                            low.value = high.value;
                        }
                    }
                };
                const updateDualFilter = ()=>{
                    if (!this._finalHP || !this._finalLP) return;
                    clampHandles();
                    const hpHz = fromPercentLog(low ? low.value : 0);
                    const lpHz = fromPercentLog(high ? high.value : 100);
                    const q = res ? Math.max(0.1, Math.min(20, parseFloat(res.value)||1)) : 1;
                    this._finalHP.frequency.value = hpHz;
                    this._finalLP.frequency.value = lpHz;
                    this._finalHP.Q.value = q;
                    this._finalLP.Q.value = q;
                    if (lowLabel) lowLabel.textContent = toLabel(hpHz, 'HP');
                    if (highLabel) highLabel.textContent = toLabel(lpHz, 'LP');
                    if (resLabel) resLabel.textContent = `Q ${q.toFixed(1)}`;
                };
                if (low) low.addEventListener('input', updateDualFilter);
                if (high) high.addEventListener('input', updateDualFilter);
                if (res) res.addEventListener('input', updateDualFilter);
                updateDualFilter();
                const reverbWetSlider = document.getElementById('reverbWet');
                if (reverbWetSlider) {
                    reverbWetSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.reverb.wet = e.target.value / 10; // 0-10 scale to 0-1
                        if (this.wetGainNode && this.dryGainNode) {
                            this.wetGainNode.gain.value = this.reverb.wet;
                            this.dryGainNode.gain.value = this.masterVolume;
                        }
                        // Bypass reverb processing when wet=0%
                        if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                        const reverbWetValue = document.getElementById('reverbWetValue');
                        if (reverbWetValue) {
                            reverbWetValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('reverbWet slider not found');
                }

                const reverbRoomSlider = document.getElementById('reverbRoom');
                if (reverbRoomSlider) {
                    reverbRoomSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.reverb.roomSize = e.target.value / 10; // 0-10 scale to 0-1
                        const reverbRoomValue = document.getElementById('reverbRoomValue');
                        if (reverbRoomValue) {
                            reverbRoomValue.textContent = `${e.target.value * 10}%`;
                        }
                        // Recreate reverb with new room size
                        if (this.audioContext) {
                            this.createReverb();
                            // Properly reconnect the reverb chain
                            try { this.wetGainNode.disconnect(); } catch {}
                            try { this.reverbHpNode.disconnect(); } catch {}
                            try { this.reverbFilterNode.disconnect(); } catch {}
                            this.wetGainNode.connect(this.reverbNode);
                            this.reverbNode.connect(this.reverbHpNode);
                            this.reverbHpNode.connect(this.reverbFilterNode);
                            if (!this.reverbOutGain) this.reverbOutGain = this.audioContext.createGain();
                            this.reverbOutGain.gain.value = this.masterVolume;
                            this.reverbFilterNode.connect(this.reverbOutGain);
                            this.reverbOutGain.connect(this.audioContext.destination);
                            if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                        }
                    });
                } else {
                    console.error('reverbRoom slider not found');
                }
                
                const reverbDecaySlider = document.getElementById('reverbDecay');
                if (reverbDecaySlider) {
                    reverbDecaySlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.reverb.decay = (e.target.value / 100) * 10; // 0-10 seconds
                        const reverbDecayValue = document.getElementById('reverbDecayValue');
                        if (reverbDecayValue) {
                            reverbDecayValue.textContent = `${(this.reverb.decay).toFixed(1)}s`;
                        }
                        // Recreate reverb with new decay time
                        if (this.audioContext) {
                            this.createReverb();
                            // Properly reconnect the reverb chain
                            try { this.wetGainNode.disconnect(); } catch {}
                            try { this.reverbHpNode.disconnect(); } catch {}
                            try { this.reverbFilterNode.disconnect(); } catch {}
                            this.wetGainNode.connect(this.reverbNode);
                            this.reverbNode.connect(this.reverbHpNode);
                            this.reverbHpNode.connect(this.reverbFilterNode);
                            if (!this.reverbOutGain) this.reverbOutGain = this.audioContext.createGain();
                            this.reverbOutGain.gain.value = this.masterVolume;
                            this.reverbFilterNode.connect(this.reverbOutGain);
                            this.reverbOutGain.connect(this.audioContext.destination);
                            if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                        }
                    });
                } else {
                    console.error('reverbDecay slider not found');
                }
                
                const reverbFilterCutoffSlider = document.getElementById('reverbFilterCutoff');
                if (reverbFilterCutoffSlider) {
                    reverbFilterCutoffSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        const pct = Math.max(0, Math.min(100, parseInt(e.target.value)||70)) / 100;
                        // Map 0..1 to 200..20000 Hz log
                        const hz = Math.max(200, 200 * Math.pow(20000/200, pct));
                        this.reverb.filterCutoff = hz;
                        if (this.reverbFilterNode) {
                            this.reverbFilterNode.frequency.value = hz;
                        }
                        const reverbFilterCutoffValue = document.getElementById('reverbFilterCutoffValue');
                        if (reverbFilterCutoffValue) {
                            reverbFilterCutoffValue.textContent = hz>=20000? 'off': `${Math.round(hz)}Hz`;
                        }
                    });
                } else {
                    console.error('reverbFilterCutoff slider not found');
                }
                const reverbHpCutoffSlider = document.getElementById('reverbHpCutoff');
                if (reverbHpCutoffSlider) {
                    reverbHpCutoffSlider.addEventListener('input', (e) => {
                        const pct = Math.max(0, Math.min(100, parseInt(e.target.value)||0)) / 100;
                        // Map 0..1 to 20..2000 Hz log
                        const hz = Math.max(20, 20 * Math.pow(2000/20, pct));
                        if (this.reverbHpNode) this.reverbHpNode.frequency.value = hz;
                        const el = document.getElementById('reverbHpCutoffValue'); if (el) el.textContent = hz<=20? 'off': `${Math.round(hz)}Hz`;
                    });
                }

                // Drive HP/LP per-effect tone (log scale)
                const driveHp = document.getElementById('driveHpCutoff');
                if (driveHp) driveHp.addEventListener('input', (e)=>{
                    const pct = Math.max(0, Math.min(100, parseInt(e.target.value)||0))/100;
                    const hz = Math.max(20, 20 * Math.pow(2000/20, pct));
                    const el = document.getElementById('driveHpCutoffValue'); if (el) el.textContent = `${hz<=20? 'off' : Math.round(hz)+'Hz'}`;
                    if (this._drive && this._drive.hp) this._drive.hp.frequency.value = hz;
                });
                const driveLp = document.getElementById('driveLpCutoff');
                if (driveLp) driveLp.addEventListener('input', (e)=>{
                    const pct = Math.max(0, Math.min(100, parseInt(e.target.value)||100))/100;
                    const hz = Math.max(200, 200 * Math.pow(20000/200, pct));
                    const el = document.getElementById('driveLpCutoffValue'); if (el) el.textContent = `${hz>=20000? 'off' : (hz>=1000? (hz/1000).toFixed(1)+'kHz' : Math.round(hz)+'Hz')}`;
                    if (this._drive && this._drive.lp) this._drive.lp.frequency.value = hz;
                });

                const reverbFilterResSlider = document.getElementById('reverbFilterRes');
                if (reverbFilterResSlider) {
                    reverbFilterResSlider.addEventListener('input', (e) => {
                        if (this.reverbFilterNode) {
                            this.reverbFilterNode.Q.value = parseFloat(e.target.value);
                        }
                        const reverbFilterResValue = document.getElementById('reverbFilterResValue');
                        if (reverbFilterResValue) {
                            reverbFilterResValue.textContent = e.target.value;
                        }
                    });
                }
                // Note: reverbFilterRes slider not present in current UI

                // Panning controls
                const panningModeSelect = document.getElementById('panningMode');
                if (panningModeSelect) {
                    panningModeSelect.addEventListener('change', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.mode = e.target.value;
                            console.log('?? Panning mode changed to:', window.omnichord.panning.mode);
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningMode select not found');
                }

                const panningWidthSlider = document.getElementById('panningWidth');
                if (panningWidthSlider) {
                    panningWidthSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.width = e.target.value / 100; // 0-100% to 0-1
                            console.log('?? Panning width changed to:', window.omnichord.panning.width);
                            const panningWidthValue = document.getElementById('panningWidthValue');
                            if (panningWidthValue) {
                                panningWidthValue.textContent = `${e.target.value}%`;
                            }
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningWidth slider not found');
                }

                const panningSpeedSlider = document.getElementById('panningSpeed');
                if (panningSpeedSlider) {
                    panningSpeedSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.speed = parseInt(e.target.value);
                            console.log('?? Panning speed changed to:', window.omnichord.panning.speed);
                            const panningSpeedValue = document.getElementById('panningSpeedValue');
                            if (panningSpeedValue) {
                                panningSpeedValue.textContent = `${(e.target.value / 1000).toFixed(1)}s`;
                            }
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningSpeed slider not found');
                }

                const panningResetBtn = document.getElementById('panningReset');
                if (panningResetBtn) {
                    panningResetBtn.addEventListener('click', () => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.rotationAngle = 0;
                            window.omnichord.panning.alternateState = false;
                            console.log('?? Panning reset');
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningReset button not found');
                }

                // Enhanced string playing with ultra responsiveness (60 FPS optimized)
                const extensionColumns = document.getElementById('extensionColumns');
                
                // Mouse events for strings with optimized performance
                extensionColumns.addEventListener('mousedown', (e) => {
                    if (this._isPointerOverModal(e)) return;
                    try { console.log('[INPUT] mousedown strings area mode=', (this.playMode||'high-low'), 'slide=', !!this._chordSlideEnabled); } catch(_){ }
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
            // ARP only triggers when PLAY is active (isSequencing)
            if (this.arpEnabled && !this.chordsEnabled && this._isSequencing) {
                        const hit = document.elementFromPoint(e.clientX, e.clientY);
                        const column = hit && hit.closest ? hit.closest('.extension-column') : null;
                        if (column) {
                            // Begin ARP gesture: enable lateral sliding while held - QUANTIZE ARP START TO BEAT
                            this._arpGestureActive = true;
                            this._arpLastColumn = column;
                            
                            // Check if we should quantize ARP start to the next beat
                            try {
                                const quantizedChange = this._shouldQuantizeChordChange();
                                if (quantizedChange.shouldQuantize) {
                                    this._scheduleQuantizedArpStart(column, e.clientY, quantizedChange.nextBeatMs);
                                } else {
                                    this._startArp(column, e.clientY);
                                }
                            } catch(_) { 
                                this._startArp(column, e.clientY); 
                            }
                        }
                    }
                    // In Chords mode, tapping the strings area should play or retune the whole chord for the tapped octave
                    // ONLY when PLAY is active (isSequencing) - otherwise just allow strumming
            if (this.chordsEnabled && this._isSequencing) {
                        e.preventDefault();
                        const hit = document.elementFromPoint(e.clientX, e.clientY);
                        const column = hit && hit.closest ? hit.closest('.extension-column') : null;
                        if (column) {
                // Seed slide velocity tracking
                this._lastChordSlideX = e.clientX;
                this._lastChordSlideY = e.clientY;
                this._lastChordSlideTime = performance.now(); this._markChordSlideActivity();
                            // If slide is enabled and we're sustaining, retune to the tapped column; otherwise start and seed voices
                            if (this._chordSlideEnabled && (this._chordsGestureActive || this._sustainActive)){
                                if (this._chordSlideVoices && this._chordSlideVoices.size){
                                this._chordSlideHoverColumn = column; this._chordSlideCommittedColumn = column; this._chordSlideHoverSince = performance.now();
                                const targets = this._computeChordSlideTargets(column);
                                this._retuneActiveChordVoicesToTargets(targets);
                                // Also update held bass to match the committed/hovered column
                                try { this._updateHeldBassForColumn(column); } catch(_){ }
                                this._markChordSlideActivity();
                                this._markChordSlideActivity();
                                } else {
                                // No active slide voices yet: quantize initial chord start
                                try {
                                    const quantizedChange = this._shouldQuantizeChordChange();
                                    if (quantizedChange.shouldQuantize) {
                                        this._scheduleQuantizedChordChange(column, e.clientY, quantizedChange.nextBeatMs);
                                    } else {
                                        this._executeChordChange(column, e.clientY);
                                    }
                                } catch(_) { this._executeChordChange(column, e.clientY); }
                                }
                            }
                            else {
                                // Slide disabled: quantize simple tap to next QUANT tick
                                try {
                                    const quantizedChange = this._shouldQuantizeChordChange();
                                    if (quantizedChange.shouldQuantize) {
                                        this._scheduleQuantizedChordChange(column, e.clientY, quantizedChange.nextBeatMs);
                                    } else {
                                        this._executeChordChange(column, e.clientY);
                                    }
                                } catch(_) { this._executeChordChange(column, e.clientY); }
                            }
                        }
                        // Do not start per-string swipe processing
                        return;
                    }
                    this.isPlayingStrings = true;
                    this.triggeredStrings.clear();
                    // Start of a new mouse gesture: clear mouse pointer last-hit tracking
                    this._pointerLastStringKey.set('mouse', null);
                    // Disarm edit during active strum
                    this.editArmed = false;
                    clearTimeout(this._editArmTimer);
                    this.handleStringTrigger(e);
                });
                
                document.addEventListener('mousemove', (e) => {
                    // ARP mode: lateral slide across columns schedules quantized chord switches
                    // Only when PLAY is active (isSequencing)
                    if ((this.playMode||'high-low') === 'arp' && this._arpGestureActive && this._isSequencing) {
                        const hit = document.elementFromPoint(e.clientX, e.clientY);
                        const column = hit && hit.closest ? hit.closest('.extension-column') : null;
                        if (column && column !== this._arpLastColumn) {
                            this._arpLastColumn = column;
                            
                            // QUANTIZE ARP CHANGES TO BEAT during sliding
                            try {
                                const quantizedChange = this._shouldQuantizeChordChange();
                                if (quantizedChange.shouldQuantize) {
                                    this._scheduleQuantizedArpStart(column, e.clientY, quantizedChange.nextBeatMs);
                                } else {
                                    this._startArp(column, e.clientY);
                                }
                            } catch(_) { 
                                this._startArp(column, e.clientY); 
                            }
                        }
                        return;
                    }
                    if (this.isPlayingStrings) {
                        this.handleStringTrigger(e);
                    } else if (this.chordsEnabled && this._sustainActive && this._isSequencing) {
                        // In CHORDS mode while sustaining: if slide is enabled, trigger chords when entering a new box (enter-box behavior)
                        // Only when PLAY is active (isSequencing)
                        if (this._chordSlideActive) {
                            const hit = document.elementFromPoint(e.clientX, e.clientY);
                            const column = hit && hit.closest ? hit.closest('.extension-column') : null;
                            const now = performance.now();
                            // Track movement vector and dt
                            const dx = (typeof this._lastChordSlideX==='number') ? (e.clientX - this._lastChordSlideX) : 0;
                            const dy = (typeof this._lastChordSlideY==='number') ? (e.clientY - this._lastChordSlideY) : 0;
                            const dt = Math.max(1, now - (this._lastChordSlideTime||now)); this._markChordSlideActivity();
                            this._chordSlideLastDX = dx; this._chordSlideLastDY = dy; this._lastChordSlideDeltaT = dt;
                            if (column){
                                // Enter-box trigger: when the pointer moves into a different column, switch chords immediately
                                const cur = this.currentActiveColumnEl || this._chordSlideCommittedColumn || this._chordSlideStartColumn || null;
                                if (cur && column !== cur && this._chordsGestureActive) {
                                    try {
                                        // Check if quantization is enabled and calculate next beat timing
                                        const quantizedChange = this._shouldQuantizeChordChange();
                                        
                                        if (quantizedChange.shouldQuantize) {
                                            // Schedule quantized chord change
                                            this._scheduleQuantizedChordChange(column, e.clientY, quantizedChange.nextBeatMs);
                                        } else {
                                            // Immediate chord change (existing behavior)
                                            this._executeChordChange(column, e.clientY);
                                        }
                                    } catch(_){}
                                } else {
                                    // Continuous bend while staying within a column (throttled): retune bass immediately
                                    this._chordSlideHoverColumn = column; /* hoverSince updated only when pointer slows */
                                    try { this._updateChordSlideContinuously(column); } catch(_) { }
                                }
                            }
                            else { this._chordSlideHoverColumn = null; }
                            this._lastChordSlideX = e.clientX; this._lastChordSlideY = e.clientY; this._lastChordSlideTime = now;
                            // Debounce + dwell: when pointer slows or stops for dwellMs, retune once to hovered column
                            clearTimeout(this._chordSlideHoverCommitTimer);
                            const dwellMs = Math.max(30, Math.min(200, this._chordSlideDwellMs||50));
                            this._chordSlideHoverCommitTimer = setTimeout(()=>{
                                try{
                                    if (this.chordsEnabled && this._chordSlideActive && this._chordsGestureActive && this._chordSlideHoverColumn){
                                        this._chordSlideCommittedColumn = this._chordSlideHoverColumn; this._chordSlideHoverSince = performance.now();
                                        const targets = this._computeChordSlideTargets(this._chordSlideHoverColumn);
                                        this._retuneActiveChordVoicesToTargets(targets);
                                        console.log('[SLIDE][DWELL] commit to column', this._chordSlideHoverColumn?.dataset?.chordId || this._chordSlideHoverColumn?.dataset?.originalPosition);
                                        // Update held bass on dwell commit as well
                                        try { this._updateHeldBassForColumn(this._chordSlideHoverColumn); } catch(_){ }
                                        this._markChordSlideActivity();
                                    }
                                }catch(_){}
                            }, dwellMs);
                        } else {
                            // Allow strumming additional strings over a sustained chord when slide is off
                            this.handleStringTrigger(e);
                        }
                    }
                });
                
                document.addEventListener('mouseup', (e) => {
                    // Don't stop ARPs when just finishing string strumming - only stop if ARP gesture was active
                    if (this.arpEnabled && this._arpGestureActive) { 
                        this._stopArp(); 
                        this._arpGestureActive = false; 
                        this._arpLastColumn = null; 
                    }
                    clearTimeout(this._chordSlideHoverCommitTimer);
                    this.isPlayingStrings = false;
                    this.triggeredStrings.clear();
                    // End of mouse gesture: clear last-hit
                    this._pointerLastStringKey.delete('mouse');
                    // If in CHORDS slide, settle to final hovered/target column and KEEP SUSTAINING (taps will retune)
                    if (this.chordsEnabled && this._chordSlideActive && this._chordsGestureActive) {
                        const hit = e ? document.elementFromPoint(e.clientX, e.clientY) : null;
                        let column = hit && hit.closest ? hit.closest('.extension-column') : null;
                        // Prefer committed column (dwelled) to skip intermediates
                        column = this._chordSlideCommittedColumn || this._chordSlideHoverColumn || column || this.currentActiveColumnEl || null;
                        if (column) {
                            const targets = this._computeChordSlideTargets(column);
                            this._retuneActiveChordVoicesToTargets(targets);
                            console.log('[SLIDE][RELEASE] settle to column', column?.dataset?.chordId || column?.dataset?.originalPosition);
                            // Update held bass to final column on release commit
                            try { this._updateHeldBassForColumn(column); } catch(_){ }
                            this._markChordSlideActivity();
                        }
                        // Do not stop or clear; keep sustaining so next tap retunes smoothly
                    } else {
                        // Non-slide CHORD mode: let HOLD timers release notes/bass; just end the gesture flags
                        if (this.chordsEnabled) {
                            this._sustainActive = false;
                            this._chordsGestureActive = false;
                            this._slideOctaveLock = null;
                        } else {
                            // In other modes, keep legacy behavior
                            this.stopAllActiveNotes();
                            try{ this._resetAllStringFrequencies(); }catch(_){ }
                            if (this._chordsGestureActive) { this._sustainActive = false; this._chordsGestureActive = false; this._slideOctaveLock = null; }
                            // Safety: clear chord bass state so it doesn't persist after gesture ends
                            try { if (this._chordBassVoice && this._lastBassFreq){ this.stopFrequency(this._lastBassFreq, null, 'bass'); } } catch(_){ }
                            this._chordBassVoice = null; this._lastBassFreq = null;
                        }
                    }
                    // Re-arm editing 500ms after strum ends
                    this._scheduleEditArm();
                });

                // Touch events for strings
                extensionColumns.addEventListener('touchstart', (e) => {
                    if (this._isPointerOverModal(e)) return;
                    e.preventDefault();
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    // Enhanced touch sensitivity: immediately mark all touch targets to prevent missed taps
                    this._enhanceTouchResponsiveness(e);
                    
                    // Strings are now purely for strumming - no ARP or CHORD triggering
                    // ARP and CHORD are triggered via dedicated footer buttons only
                    this.isPlayingStrings = true;
                    this.triggeredStrings.clear();
                    this.editArmed = false;
                    clearTimeout(this._editArmTimer);
                    
                    Array.from(e.changedTouches).forEach(touch => {
                        // Clear last-hit for this touch identifier at the beginning of a gesture
                        this._pointerLastStringKey.set(`t${touch.identifier}`, null);
                        this.activeTouches.set(touch.identifier, touch);
                        
                        // Always allow strumming in strings area - this is now purely for garnish
                        this.handleStringTrigger(touch);
                    });
                }, { passive: false });
                
                extensionColumns.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    // ARP mode: lateral slide across columns with quantized chord changes (preserves transport position)
                    // Only when PLAY is active (isSequencing)
                    if (this.arpEnabled && !this.chordsEnabled && this._arpGestureActive && this._isSequencing) {
                        const t = e.changedTouches[0] || (e.touches && e.touches[0]);
                        if (t){
                            const h = document.elementFromPoint(t.clientX, t.clientY);
                            const c = h && h.closest ? h.closest('.extension-column') : null;
                            if (c && c !== this._arpLastColumn) {
                                // Schedule quantized ARP chord change to preserve transport sync
                                this._scheduleQuantizedArpChordChange(c, t.clientY);
                                this._arpLastColumn = c;
                            }
                        }
                    }
                    if (this.isPlayingStrings || (this.chordsEnabled && this._sustainActive && this._isSequencing)) {
                        // CHORDS mode with slide enabled: trigger chords when entering a new box (enter-box behavior)
                        // Only when PLAY is active (isSequencing)
                        if (this.chordsEnabled && this._chordSlideActive && this._isSequencing) {
                            const t = e.changedTouches[0];
                            if (t){
                                const h = document.elementFromPoint(t.clientX, t.clientY);
                                const c = h && h.closest ? h.closest('.extension-column') : null;
                                const now = performance.now();
                                // Track movement vector and dt
                                const dx = (typeof this._lastChordSlideX==='number') ? (t.clientX - this._lastChordSlideX) : 0;
                                const dy = (typeof this._lastChordSlideY==='number') ? (t.clientY - this._lastChordSlideY) : 0;
                                const dt = Math.max(1, now - (this._lastChordSlideTime||now)); this._markChordSlideActivity();
                                this._chordSlideLastDX = dx; this._chordSlideLastDY = dy; this._lastChordSlideDeltaT = dt;
                                if (c){
                                    const cur = this.currentActiveColumnEl || this._chordSlideCommittedColumn || this._chordSlideStartColumn || null;
                                    if (cur && c !== cur && this._chordsGestureActive) {
                                        try {
                                            // Check if quantization is enabled and calculate next beat timing
                                            const quantizedChange = this._shouldQuantizeChordChange();
                                            
                                            if (quantizedChange.shouldQuantize) {
                                                // Schedule quantized chord change
                                                this._scheduleQuantizedChordChange(c, t.clientY, quantizedChange.nextBeatMs);
                                            } else {
                                                // Immediate chord change (existing behavior)
                                                this._executeChordChange(c, t.clientY);
                                            }
                                        } catch(_){}
                                    } else {
                                        // Continuous bend within the current column
                                        this._chordSlideHoverColumn = c; /* hoverSince updated only when finger slows */
                                        try { this._updateChordSlideContinuously(c); } catch(_) { }
                                    }
                                }
                                else { this._chordSlideHoverColumn = null; }
                                this._lastChordSlideX = t.clientX; this._lastChordSlideY = t.clientY; this._lastChordSlideTime = now;
                                // Debounce + dwell: when finger slows or stops for dwellMs, glide once to hovered column
                                clearTimeout(this._chordSlideHoverCommitTimer);
                                const dwellMs = Math.max(30, Math.min(200, this._chordSlideDwellMs||50));
                                this._chordSlideHoverCommitTimer = setTimeout(()=>{
                                    try{
                                        if (this.chordsEnabled && this._chordSlideActive && this._chordsGestureActive && this._chordSlideHoverColumn){
                                            this._chordSlideCommittedColumn = this._chordSlideHoverColumn; this._chordSlideHoverSince = performance.now();
                                            const targets = this._computeChordSlideTargets(this._chordSlideHoverColumn);
                                            this._retuneActiveChordVoicesToTargets(targets);
                                            console.log('[SLIDE][DWELL][touch] commit to column', this._chordSlideHoverColumn?.dataset?.chordId || this._chordSlideHoverColumn?.dataset?.originalPosition);
                                            try { this._updateHeldBassForColumn(this._chordSlideHoverColumn); } catch(_){ }
                                            this._markChordSlideActivity();
                                        }
                                    }catch(_){}
                                }, dwellMs);
                            }
                        } else {
                            Array.from(e.changedTouches).forEach(touch => {
                                this.activeTouches.set(touch.identifier, touch);
                                this.handleStringTrigger(touch);
                            });
                        }
                    }
                }, { passive: false });
                
    extensionColumns.addEventListener('touchend', (e) => {
                    e.preventDefault();
            // Don't stop ARPs when just finishing string strumming - only stop if ARP gesture was active
            if (this.arpEnabled && this._arpGestureActive) { 
                this._stopArp(); 
                this._arpGestureActive = false; 
                this._arpLastColumn = null; 
            }
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.delete(touch.identifier);
                        // Clear tracking for this touch pointer
                        this._pointerLastStringKey.delete(`t${touch.identifier}`);
                    });
                    
                    if (this.activeTouches.size === 0) {
                        this.isPlayingStrings = false;
                        this.triggeredStrings.clear();
            // CHORD slide settle on release: keep sustaining (do not stop/clear) so taps glide
            if (this.chordsEnabled && this._chordSlideActive && this._chordsGestureActive) {
                clearTimeout(this._chordSlideHoverCommitTimer);
                const t = e.changedTouches && e.changedTouches[0];
                const h = t ? document.elementFromPoint(t.clientX, t.clientY) : null;
                let c = h && h.closest ? h.closest('.extension-column') : null;
                // Prefer committed column (dwelled) to skip intermediates
                c = this._chordSlideCommittedColumn || this._chordSlideHoverColumn || c || this.currentActiveColumnEl || null;
                if (c){ const targets = this._computeChordSlideTargets(c); this._retuneActiveChordVoicesToTargets(targets); console.log('[SLIDE][RELEASE][touch] settle to column', c?.dataset?.chordId || c?.dataset?.originalPosition); try { this._updateHeldBassForColumn(c); } catch(_){ } this._markChordSlideActivity(); }
                // Keep sustaining; no stop/clear/reset here
            } else {
                if (this.chordsEnabled) {
                    // Let HOLD per-note/bass timers handle release; just end gesture flags
                    this._sustainActive = false;
                    this._chordsGestureActive = false;
                    this._slideOctaveLock = null;
                } else {
                    this.stopAllActiveNotes();
                    try{ this._resetAllStringFrequencies(); }catch(_){ }
                    if (this._chordsGestureActive) { this._sustainActive = false; this._chordsGestureActive = false; this._slideOctaveLock = null; }
                    // Safety: clear chord bass state after non-slide touch end
                    try { if (this._chordBassVoice && this._lastBassFreq){ this.stopFrequency(this._lastBassFreq, null, 'bass'); } } catch(_){ }
                    this._chordBassVoice = null; this._lastBassFreq = null;
                }
            }
        
            this._scheduleEditArm();
                    }
                }, { passive: false });
                
                extensionColumns.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.delete(touch.identifier);
                        this._pointerLastStringKey.delete(`t${touch.identifier}`);
                    });
                    
                    if (this.activeTouches.size === 0) {
                        this.isPlayingStrings = false;
                        this.triggeredStrings.clear();
                        this.stopAllActiveNotes();
                        // Clear ARP slide tracking
                        this._arpGestureActive = false; 
                        this._arpLastColumn = null;
                        this._scheduleEditArm();
                    }
                }, { passive: false });

                // Allow multitouch on control elements - prevent default only on strings
                document.addEventListener('touchstart', (e) => {
                    const target = e.target;
                    if (target.classList.contains('tuning-btn') || 
                        target.classList.contains('chord-btn') || 
                        target.classList.contains('quality-btn') || 
                        target.classList.contains('osc-btn')) {
                        // Don't prevent default on control buttons to allow multitouch
                        return;
                    }
                }, { passive: false });

                // Handle audio context resume on any interaction
                document.addEventListener('click', () => {
                    // Idle/HOLD transport reset: if not sequencing and idle > HOLD, reset transport so next tap starts on beat 1
                    try {
                        const now = (performance && performance.now) ? performance.now() : Date.now();
                        const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                        const hold = holdEl ? String(holdEl.value||'bar:1') : 'bar:1';
                        const [kind, valStr] = hold.split(':');
                        const n = Math.max(1, parseInt(valStr||'1',10));
                        const bpmEl = document.getElementById('universalBpm');
                        const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                        const beatMs = 60000 / Math.max(20, bpm);
                        const tsEl = document.getElementById('universalTimeSignature');
                        const tsRaw = tsEl ? String(tsEl.value||'4/4') : '4/4';
                        let tsNum=4, tsDen=4; try { const [n,d]=tsRaw.split('/').map(v=>parseInt(v,10)); if(Number.isFinite(n)&&n>0) tsNum=n; if(Number.isFinite(d)&&d>0) tsDen=d; } catch(_) {}
                        const beatsPerBar = (tsNum * 4) / tsDen;
                        const barMs = beatMs * beatsPerBar;
                        const holdMs = (kind==='beat') ? n*beatMs : n*barMs;
                        if (!this._isSequencing && now - (this._lastInteractionAt||0) > holdMs) {
                            try {
                                this._stopArpTransport();
                                this._ensureArpTransport();
                                const t = this._arpTransport; if (t) { t.tickCounter=0; t.absTickCounter=0; t.nextAt=now; t.running=false; t.inactivityStopScheduled=false; t.stopAtBarIndex=null; }
                                if (this._arp) { this._arp.pendingSwitch=null; this._arp.active=false; this._arp.seq=[]; this._arp.startTickAlign=0; this._arp.morph=null; }
                                this.stopAllActiveNotes();
                            } catch(_) {}
                        }
                        this._lastInteractionAt = now;
                        try { this._markUserActivity(); } catch(_){ }
                    } catch(_) {}
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        if (window.DEBUG_AUDIO) console.log('Attempting to resume AudioContext on click...');
                        this.audioContext.resume().then(() => {
                            if (window.DEBUG_AUDIO) console.log('AudioContext resumed successfully');
                        });
                    }
                    // Do not auto-start transport on generic clicks; only PLAY should start
                    try { if (this._isSequencing) this._startArpTransport(); } catch(_){ }
                });
                
                document.addEventListener('touchstart', () => {
                    // Idle/HOLD transport reset on touch
                    try {
                        const now = (performance && performance.now) ? performance.now() : Date.now();
                        const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                        const hold = holdEl ? String(holdEl.value||'bar:1') : 'bar:1';
                        const [kind, valStr] = hold.split(':');
                        const n = Math.max(1, parseInt(valStr||'1',10));
                        const bpmEl = document.getElementById('universalBpm');
                        const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                        const beatMs = 60000 / Math.max(20, bpm);
                        const tsEl = document.getElementById('universalTimeSignature');
                        const tsRaw = tsEl ? String(tsEl.value||'4/4') : '4/4';
                        let tsNum=4, tsDen=4; try { const [n,d]=tsRaw.split('/').map(v=>parseInt(v,10)); if(Number.isFinite(n)&&n>0) tsNum=n; if(Number.isFinite(d)&&d>0) tsDen=d; } catch(_) {}
                        const beatsPerBar = (tsNum * 4) / tsDen;
                        const barMs = beatMs * beatsPerBar;
                        const holdMs = (kind==='beat') ? n*beatMs : n*barMs;
                        if (!this._isSequencing && now - (this._lastInteractionAt||0) > holdMs) {
                            try {
                                this._stopArpTransport();
                                this._ensureArpTransport();
                                const t = this._arpTransport; if (t) { t.tickCounter=0; t.absTickCounter=0; t.nextAt=now; t.running=false; t.inactivityStopScheduled=false; t.stopAtBarIndex=null; }
                                if (this._arp) { this._arp.pendingSwitch=null; this._arp.active=false; this._arp.seq=[]; this._arp.startTickAlign=0; this._arp.morph=null; }
                                this.stopAllActiveNotes();
                            } catch(_) {}
                        }
                        this._lastInteractionAt = now;
                        try { this._markUserActivity(); } catch(_){ }
                    } catch(_) {}
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        if (window.DEBUG_AUDIO) console.log('Attempting to resume AudioContext on touch...');
                        this.audioContext.resume().then(() => {
                            if (window.DEBUG_AUDIO) console.log('AudioContext resumed successfully');
                        });
                    }
                    // Do not auto-start transport on touch; only PLAY should start
                    try { if (this._isSequencing) this._startArpTransport(); } catch(_){ }
                });
                
                document.addEventListener('mousedown', () => {
                    // Idle/HOLD transport reset on mouse down
                    try {
                        const now = (performance && performance.now) ? performance.now() : Date.now();
                        const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                        const hold = holdEl ? String(holdEl.value||'bar:1') : 'bar:1';
                        const [kind, valStr] = hold.split(':');
                        const n = Math.max(1, parseInt(valStr||'1',10));
                        const bpmEl = document.getElementById('universalBpm');
                        const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                        const beatMs = 60000 / Math.max(20, bpm);
                        const tsEl = document.getElementById('universalTimeSignature');
                        const tsRaw = tsEl ? String(tsEl.value||'4/4') : '4/4';
                        let tsNum=4, tsDen=4; try { const [n,d]=tsRaw.split('/').map(v=>parseInt(v,10)); if(Number.isFinite(n)&&n>0) tsNum=n; if(Number.isFinite(d)&&d>0) tsDen=d; } catch(_) {}
                        const beatsPerBar = (tsNum * 4) / tsDen;
                        const barMs = beatMs * beatsPerBar;
                        const holdMs = (kind==='beat') ? n*beatMs : n*barMs;
                        if (!this._isSequencing && now - (this._lastInteractionAt||0) > holdMs) {
                            try {
                                this._stopArpTransport();
                                this._ensureArpTransport();
                                const t = this._arpTransport; if (t) { t.tickCounter=0; t.absTickCounter=0; t.nextAt=now; t.running=false; t.inactivityStopScheduled=false; t.stopAtBarIndex=null; }
                                if (this._arp) { this._arp.pendingSwitch=null; this._arp.active=false; this._arp.seq=[]; this._arp.startTickAlign=0; this._arp.morph=null; }
                                this.stopAllActiveNotes();
                            } catch(_) {}
                        }
                        this._lastInteractionAt = now;
                        try { this._markUserActivity(); } catch(_){ }
                    } catch(_) {}
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        if (window.DEBUG_AUDIO) console.log('Attempting to resume AudioContext on mousedown...');
                        this.audioContext.resume().then(() => {
                            if (window.DEBUG_AUDIO) console.log('AudioContext resumed successfully');
                        });
                    }
                    // Do not auto-start transport on mousedown; only PLAY should start
                    try { if (this._isSequencing) this._startArpTransport(); } catch(_){ }
                });

                // Modal Event Listeners
                const closeColumnModalBtn = document.getElementById('closeColumnModal');
                const addCustomColumnBtn = document.getElementById('addCustomColumn');

                if (closeColumnModalBtn) {
                    closeColumnModalBtn.addEventListener('click', () => {
                        document.getElementById('columnModal').style.display = 'none';
                    });
                }

                if (addCustomColumnBtn) {
                    addCustomColumnBtn.addEventListener('click', () => {
                        document.getElementById('columnModal').style.display = 'none';
                        this.showChordBuilder();
                    });
                }

                // Add to favorites button
                const addToFavoritesBtn = document.getElementById('addToFavoritesBtn');
                if (addToFavoritesBtn) {
                    addToFavoritesBtn.addEventListener('click', () => {
                        this.addCurrentChordToFavorites();
                    });
                }

                // Initialize custom chords storage - no localStorage
                this.customChords = [];
                
                // Migrate old custom chords from 12-TET semitones to native tuning
                this.migrateCustomChords();
                
                this.hiddenColumns = [];
                this.favoriteChords = [];
                this.paletteChords = [];
                this.currentEditingColumn = null;
                
                // Set up context menu
                
                // Set up fretboard resize functionality
                this.setupFretboardResize();
                
                // Set up sonic chord functionality
                this.setupSonicChords();
                
                // Force initial generation
                console.log('Initializing omnichord with tuning:', this.currentTuning);
                setTimeout(() => {
                    this.generateRootButtons();
                    this.generateExtensionColumns();
                }, 100);
            }

            migrateCustomChords() {
                // Migrate old custom chords that used 12-TET semitones to native tuning
                let needsMigration = false;
                
                this.customChords.forEach(chord => {
                    // Check if this chord needs migration (has intervals property instead of notes)
                    if (chord.intervals && !chord.notes) {
                        // Convert from 12-TET semitones to native tuning
                        const originalTuning = this.currentTuning;
                        this.currentTuning = chord.tuning || 12;
                        
                        chord.notes = chord.intervals.map(semitone => {
                            // For chords saved in their original tuning, just use the intervals directly
                            return semitone;
                        });
                        
                        // Remove old intervals property
                        delete chord.intervals;
                        this.currentTuning = originalTuning;
                        needsMigration = true;
                        console.log(`Migrated custom chord: ${chord.name}`);
                    } else if (!chord.notes && chord.intervals) {
                        // Fallback: copy intervals to notes if notes missing
                        chord.notes = [...chord.intervals];
                        needsMigration = true;
                    }
                });
                
                if (needsMigration) {
                    console.log('Custom chords migrated to new format');
                }
            }

            setupContextMenu() {
                console.log('ðŸŽµ Context menus disabled for cleaner interface');
                
                // Setup keyboard input only
                this.setupKeyboardInput();
            }

            _getMaxCycleSteps(){
                try {
                    const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                    const hold = holdEl ? String(holdEl.value || 'bar:1') : 'bar:1';
                    const parts = hold.split(':');
                    const kind = String(parts[0] || 'bar').toLowerCase();
                    const n = Math.max(1, parseInt(parts[1] || '1', 10) || 1);
                    const bars = (kind === 'bar') ? n : 1;
                    return Math.max(1, Math.min(1024, 16 * bars));
                } catch(_){
                    return 64;
                }
            }

            _panicStopSequencer(reason){
                try { console.log('ðŸŽµ PANIC STOP', reason || ''); } catch(_){ }
                try { this.stopAllActiveNotes(); } catch(_){ }
                try { this.stopAllActiveNotes('chord'); } catch(_){ }
                try { this.stopAllActiveNotes('arp'); } catch(_){ }
                try { this.stopAllActiveNotes('bass'); } catch(_){ }
                try { this._sustainActive = false; } catch(_){ }
                try { this._chordsGestureActive = false; } catch(_){ }
                try { this._chordSlideActive = false; } catch(_){ }
                try { this._stopArp && this._stopArp(); } catch(_){ }
                try { this._stopArpTransport && this._stopArpTransport(); } catch(_){ }
                try { this.stopAllDrums && this.stopAllDrums(); } catch(_){ }
                try { this._resetDrumPlayhead && this._resetDrumPlayhead(); } catch(_){ }

                try {
                    if (this.audioContext) {
                        Object.values(this.activeNotes || {}).forEach(noteGroup => {
                            if (Array.isArray(noteGroup)) {
                                noteGroup.forEach(note => {
                                    try { if (note && note.stop) note.stop(0); } catch(_){ }
                                    try { if (note && note.disconnect) note.disconnect(); } catch(_){ }
                                });
                            }
                        });
                        this.activeNotes = {};
                    }
                } catch(_){ }

                try {
                    if (this._arp) {
                        this._arp.pendingSwitch = null;
                        this._arp.active = false;
                    }
                } catch(_){ }

                try {
                    if (this._arpTransport) {
                        this._arpTransport._seqNextSwitchAbsTick = null;
                        this._arpTransport._seqScheduleNext = null;
                        // Clear any pending start gate / count-in
                        this._arpTransport.startGateAbsTick = null;
                        this._arpTransport.countInActive = false;
                        this._arpTransport.countInStartAbsTick = null;
                        this._arpTransport.countInEndAbsTick = null;
                        this._arpTransport.countInLastBeat = 0;
                    }
                } catch(_){ }

                try {
                    if (this._seqTimer) {
                        clearTimeout(this._seqTimer);
                        this._seqTimer = null;
                    }
                } catch(_){ }

                try {
                    const stopAllPatterns = (resetPhase = true)=>{
                        try {
                            const pt0 = window._patternTransport;
                            if (pt0 && typeof pt0.stop === 'function') pt0.stop(!!resetPhase);
                            else if (pt0) { pt0.running = false; pt0.tickCounter = 0; pt0.absTickCounter = 0; pt0.stopVoices && pt0.stopVoices(); }
                        } catch(_){ }
                        try {
                            const instances = window._patternInstances || [];
                            instances.forEach(info=>{
                                const m = info && info.modal;
                                const pt = m && m._patternTransport;
                                if (!pt) return;
                                try {
                                    if (typeof pt.stop === 'function') pt.stop(!!resetPhase);
                                    else { pt.running = false; pt.tickCounter = 0; pt.absTickCounter = 0; }
                                } catch(_){ }
                                try { pt.running = false; pt.stopVoices && pt.stopVoices(); } catch(_){ }
                            });
                        } catch(_){ }
                    };
                    stopAllPatterns(true);
                } catch(_){ }

                try { this._isSequencing = false; } catch(_){ }
                try { this._stopPlayButtonFlashing && this._stopPlayButtonFlashing(); } catch(_){ }

                // MIDI panic
                try { if (window.midi && window.midi.enabled && typeof window.midi.allNotesOff === 'function') window.midi.allNotesOff(); } catch(_){ }

                // Update UI (both buttons)
                try {
                    const playStopToggle = document.getElementById('playStopToggleBtn');
                    if (playStopToggle) {
                        playStopToggle.textContent = 'PLAY';
                        playStopToggle.style.background = '#27ae60';
                        playStopToggle.style.borderColor = '#2ecc71';
                    }
                } catch(_){ }
                try {
                    const playBtn = document.getElementById('playStopTransportBtn');
                    if (playBtn) {
                        playBtn.innerHTML = 'â–¶';
                        playBtn.style.background = '#27ae60';
                        playBtn.style.borderColor = '#2ecc71';
                    }
                } catch(_){ }

                // Hide count-in display
                try {
                    const el = document.getElementById('countInDisplay');
                    if (el) el.style.display = 'none';
                } catch(_){ }

                // Ensure any other play controls stay consistent
                try { if (typeof this._reflectPlayUI === 'function') this._reflectPlayUI(); } catch(_){ }
            }

            _reflectPlayUI(){
                const isSequencing = !!this._isSequencing;
                try {
                    const playStopToggle = document.getElementById('playStopToggleBtn');
                    if (playStopToggle) {
                        playStopToggle.textContent = isSequencing ? 'STOP' : 'PLAY';
                        playStopToggle.style.background = isSequencing ? '#e74c3c' : '#27ae60';
                        playStopToggle.style.borderColor = isSequencing ? '#c0392b' : '#2ecc71';
                    }
                } catch(_){ }
                try {
                    const playBtn = document.getElementById('playStopTransportBtn');
                    if (playBtn) {
                        playBtn.innerHTML = isSequencing ? 'â¹' : 'â–¶';
                        playBtn.style.background = isSequencing ? '#e74c3c' : '#27ae60';
                        playBtn.style.borderColor = isSequencing ? '#c0392b' : '#2ecc71';
                    }
                } catch(_){ }
            }

            _panicMuteAudio(reason){
                try { console.log('ðŸŽµ PANIC MUTE', reason || ''); } catch(_){ }
                // Immediately stop all currently-sounding voices (but DO NOT stop transport / sequencing)
                try { this.stopAllActiveNotes(); } catch(_){ }
                try { this.stopAllActiveNotes('chord'); } catch(_){ }
                try { this.stopAllActiveNotes('arp'); } catch(_){ }
                try { this.stopAllActiveNotes('bass'); } catch(_){ }
                try { this.stopAllDrums && this.stopAllDrums(); } catch(_){ }
                try { this._resetDrumPlayhead && this._resetDrumPlayhead(); } catch(_){ }
                try {
                    // Silence pattern voices but keep their transports running
                    const pt0 = window._patternTransport;
                    if (pt0 && typeof pt0.stopVoices === 'function') pt0.stopVoices();
                    const instances = window._patternInstances || [];
                    instances.forEach(info=>{
                        const m = info && info.modal;
                        const pt = m && m._patternTransport;
                        if (pt && typeof pt.stopVoices === 'function') pt.stopVoices();
                    });
                } catch(_){ }

                // MIDI panic + suppress new note-ons until we unmute
                try {
                    if (window.midi) {
                        window.midi._panicMuted = true;
                        if (window.midi.enabled && typeof window.midi.allNotesOff === 'function') window.midi.allNotesOff();
                    }
                } catch(_){ }

                // Hard mute internal audio output immediately (without changing the user-facing masterVolume)
                try {
                    if (this.gainNode && this.gainNode.gain) this.gainNode.gain.value = 0;
                    if (this.dryGainNode && this.dryGainNode.gain) this.dryGainNode.gain.value = 0;
                    if (this.reverbOutGain && this.reverbOutGain.gain) this.reverbOutGain.gain.value = 0;
                    this._panicMuteActive = true;
                } catch(_){ }

                // Schedule unmute on the next bar boundary (Beat 1 is king)
                try {
                    this._ensureArpTransport && this._ensureArpTransport();
                    const t = this._arpTransport;
                    const isRunning = !!(t && (t.running || t.isRunning));
                    if (isRunning && typeof window.scheduleDeferred === 'function') {
                        window.scheduleDeferred({ panic: true });
                    } else {
                        // Not running: restore quickly so we don't get stuck muted.
                        setTimeout(()=>{ try { this._clearPanicMute && this._clearPanicMute(); } catch(_){ } }, 50);
                    }
                } catch(_){ }

                // Keep play UI reflecting the true running state
                try { if (typeof this._reflectPlayUI === 'function') this._reflectPlayUI(); } catch(_){ }
            }

            _clearPanicMute(){
                try {
                    this._panicMuteActive = false;
                    // Restore internal audio output gains from current master settings
                    // (respects MIDI mute mode because masterVolume is already reduced there)
                    const mv = (typeof this.masterVolume === 'number') ? this.masterVolume : 1;
                    const vol = (typeof this.volume === 'number') ? this.volume : 1;
                    if (this.gainNode && this.gainNode.gain) this.gainNode.gain.value = vol * mv;
                    if (this.dryGainNode && this.dryGainNode.gain) this.dryGainNode.gain.value = mv;
                    if (this.reverbOutGain && this.reverbOutGain.gain) this.reverbOutGain.gain.value = mv;
                } catch(_){ }
                try { if (window.midi) window.midi._panicMuted = false; } catch(_){ }
            }
            
            setupKeyboardInput() {
                if (this._keyboardListenerAttached) return;
                this._keyboardHandler = (e) => {
                    // Allow typing in inputs/textareas without hijacking
                    const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : '';
                    // Also allow typing in contenteditable chord name fields
                    const isEditable = (()=>{
                        try {
                            if (!e.target) return false;
                            if (e.target.isContentEditable) return true;
                            if (typeof e.target.closest === 'function') {
                                const el = e.target.closest('[contenteditable="true"]');
                                if (el) return true;
                            }
                        } catch(_) {}
                        return false;
                    })();
                    if (tag === 'INPUT' || tag === 'TEXTAREA' || isEditable || e.isComposing) return;

                    // Ctrl+1..Ctrl+0: queue drum pattern 1..10 for next bar; Ctrl+D duplicate current
                    if (e.ctrlKey && !e.shiftKey && !e.altKey && ((e.key >= '0' && e.key <= '9') || e.key.toLowerCase() === 'd')) {
                        e.preventDefault();
                        try {
                            if (e.key.toLowerCase() === 'd') {
                                // Duplicate current pattern
                                if (typeof this._duplicateCurrentDrumPattern === 'function') this._duplicateCurrentDrumPattern();
                                return;
                            }
                            // Ensure transport exists to compute bar edges
                            if (!this._arpTransport) this._ensureArpTransport();
                            // Map key to pattern number (1..10 where 0 maps to 10)
                            const targetPat = (e.key === '0') ? 10 : Math.max(1, Math.min(10, parseInt(e.key,10)));
                            this._drumPendingPattern = targetPat;
                            // Visual feedback: flash pattern input briefly
                            const patEl = document.getElementById('drumPatternNumber');
                            if (patEl) {
                                patEl.title = `Queued DRUM pattern ${targetPat} @ next bar`;
                                patEl.style.outline = '2px solid #00d1b2';
                                setTimeout(()=>{ try { patEl.style.outline = ''; } catch(_){} }, 240);
                            }
                        } catch(_) {}
                        return;
                    }

                    // In TOUCH (slide) mode, disable keyboard-triggered playback entirely
                    if (this._chordSlideEnabled) return;

                    const key = e.key;
                    let chordIndex = -1;
                    // Track held number keys to throttle OS key repeat
                    if (!this._heldNumberKeys) this._heldNumberKeys = new Set();

                    // Map number keys to chord indices (1-9, then 0 for 10th chord)
                    if (key >= '1' && key <= '9') chordIndex = parseInt(key,10) - 1;
                    else if (key === '0') chordIndex = 9;

                    if (chordIndex >= 0) {
                        // Ignore auto-repeat while key is held
                        if (this._heldNumberKeys.has(key) || e.repeat) return;
                        this._heldNumberKeys.add(key);
                        e.preventDefault();
                        this.playChordByIndex(chordIndex);
                        return;
                    }

                    // Shortcut semantics:
                    // - Ctrl +/- : global transpose
                    // - + or = alone: add chord
                    // - - alone: no-op (reserved)
                    // Do NOT trigger when ALT is held (ALT +/- is reserved for octave)
                    const isPlusKey = (key === '+' || key === '=' || e.code === 'NumpadAdd');
                    const isMinusKey = (key === '-' || key === '_' || e.code === 'NumpadSubtract');
                    if (!e.altKey && e.ctrlKey && isPlusKey) { e.preventDefault(); try { this.applyTransposeStep(1); } catch(_) {} return; }
                    if (!e.altKey && e.ctrlKey && isMinusKey) { e.preventDefault(); try { this.applyTransposeStep(-1); } catch(_) {} return; }
                    if (!e.altKey && !e.ctrlKey && isPlusKey) {
                        e.preventDefault();
                        try { document.getElementById('createNewChordBtn')?.click(); } catch(_){ }
                        return;
                    }
                    if (!e.altKey && !e.ctrlKey && isMinusKey) {
                        // no-op for now
                        return;
                    }
                    
                    // SPACE key: PLAY/STOP toggle with audio panic on stop
                    if (key === ' ' || e.code === 'Space') {
                        e.preventDefault();
                        try {
                            const playStopToggle = document.getElementById('playStopToggleBtn');
                            if (playStopToggle) {
                                if (this._isSequencing) {
                                    // Currently playing - STOP with PANIC (kill all audio)
                                    console.log('ðŸŽµ SPACE pressed: STOPPING sequence with AUDIO PANIC');
                                    this._panicStopSequencer('space');
                                } else {
                                    // Currently stopped - START playing
                                    console.log('ðŸŽµ SPACE pressed: STARTING sequence');
                                    playStopToggle.click(); // Trigger the existing play logic
                                }
                            }
                        } catch (e) {
                            console.error('Error handling SPACE key:', e);
                        }
                        return;
                    }

                    // R key: Re-randomize arpeggiator pattern at next quant edge
                    if ((key === 'r' || key === 'R')) {
                        try {
                            // Only act when PLAY is active (isSequencing)
                            if (!this._isSequencing) return;
                            // Only act when ARP is engaged or a sequence is active
                            const patEl = document.getElementById('universalPattern');
                            const pat = (patEl && patEl.value) ? patEl.value : (this._arp?.pattern||'up');
                            if (!this._arpTransport) this._ensureArpTransport();
                            if (!this._arp) this._ensureArpDefaults();
                            // If no column context, ignore
                            const col = this._arp?.column || this.currentActiveColumnEl || null;
                            if (!col) return;
                            // Build a fresh sequence using 'random' regardless of current pattern
                            const rowsAll = Array.from(col.querySelectorAll('.strings-column .string'));
                            const within = rowsAll.filter(r => {
                                const o = parseInt(r.dataset.octave||'0',10);
                                return o>=5 && o<=9;
                            });
                            const npc = Math.max(1, (this._getGlobalNpc ? this._getGlobalNpc() : (this._arp?.npc|0) || 3));
                            const seq = this._buildArpSequence(within, 'random', null).slice(0, npc);
                            // Queue for next tick to avoid phase break
                            const tpBar = this._arpTransport.ticksPerBar || 16;
                            const curTick = this._arpTransport.tickCounter|0;
                            const absTick = this._arpTransport.absTickCounter|0;
                            const targetAbsTick = absTick + 1;
                            this._arp.pendingSwitch = {
                                atAbsTick: targetAbsTick >>> 0,
                                alignPhaseToTickCounter: false,
                                seq,
                                bassFreq: this._arp.bassFreq,
                                column: col,
                                mapAsc: within.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0)-(parseFloat(b.dataset.frequency)||0)).slice(0, npc)
                            };
                            // Ensure transport (only when sequencing)
                            this._startArpTransport();
                        } catch(_) {}
                        return;
                    }
                };
                // Attach on window with capture so it fires even during bubbling-stopped handlers
                window.addEventListener('keydown', this._keyboardHandler, true);
                // Stop playback on number key release for ARP/Chords (press-to-start/release-to-stop parity with mouse/touch)
                this._keyboardKeyupHandler = (e) => {
                    // Global ESC panic (always active, cancels everything immediately)
                    if (e.key === 'Escape') {
                        try {
                            // Panic should silence immediately but NOT stop playback; unmute on next bar.
                            if (typeof this._panicMuteAudio === 'function') this._panicMuteAudio('escape');
                            else this._panicStopSequencer('escape');
                        } catch(_) {}
                        return;
                    }
                    const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : '';
                    const isEditable = (()=>{
                        try {
                            if (!e.target) return false;
                            if (e.target.isContentEditable) return true;
                            if (typeof e.target.closest === 'function') {
                                const el = e.target.closest('[contenteditable="true"]');
                                if (el) return true;
                            }
                        } catch(_) {}
                        return false;
                    })();
                    if (tag === 'INPUT' || tag === 'TEXTAREA' || isEditable || e.isComposing) return;
                    // In TOUCH (slide) mode, ignore key releases as well
                    if (this._chordSlideEnabled) return;
                    const key = e.key;
                    const isNumberKey = (key >= '1' && key <= '9') || key === '0';
                    if (!isNumberKey) return;
                    if (this._heldNumberKeys) this._heldNumberKeys.delete(key);
                    const mode = (this.playMode||'high-low');
                    if (mode === 'arp') {
                        try { this._stopArp(); } catch(_) {}
                    } else if (mode === 'chords') {
                        try { this.stopAllActiveNotes(); } catch(_) {}
                        this._sustainActive = false;
                        this._chordsGestureActive = false;
                    }
                };
                window.addEventListener('keyup', this._keyboardKeyupHandler, true);
                this._keyboardListenerAttached = true;
            }
            
            playChordByIndex(index) {
                // Prefer playing from extension grid columns; fall back to palette when needed
                const columns = document.querySelectorAll('.extension-column');
                if (index < columns.length) {
                    const column = columns[index];
                    const header = column.querySelector('.extension-header');
                    if (header) {
                        console.log(`Playing extension chord ${index + 1}:`, header.textContent);
                        // For ARP mode, start the arpeggiator from the column on key press
                        const rect = column.getBoundingClientRect();
                        const centerY = rect.top + rect.height / 2;
                        // ARP and CHORDS modes only activate when PLAY is running (isSequencing)
                        // Otherwise, always strum
                        if (this.arpEnabled && this._isSequencing) {
                            this._ensureArpDefaults();
                            // Keyboard start uses single-octave start (no span)
                            this._arp.span = { active:false, yMin:null, yMax:null, octMin:null, octMax:null };
                            
                            // Schedule quantized ARP chord change to preserve transport sync
                            this._scheduleQuantizedArpChordChange(column, centerY);
                        } else if (this.chordsEnabled && this._isSequencing) {
                            // Chords mode: if slide enabled, glide to this chord over 2 beats; else play immediately
                            if (this._chordSlideEnabled) {
                                // On first key press, if no active chord, start it immediately
                                if (!this._chordsGestureActive) {
                                    try {
                                        const quantizedChange = this._shouldQuantizeChordChange();
                                        if (quantizedChange.shouldQuantize) {
                                            this._scheduleQuantizedChordChange(column, centerY, quantizedChange.nextBeatMs);
                                        } else {
                                            this._executeChordChange(column, centerY);
                                        }
                                    } catch(_) { this._executeChordChange(column, centerY); }
                                } else {
                                    // Compute 2-beat duration from transport BPM (default 120)
                                    const bpm = (this._arp?.bpm) || 120;
                                    const beatMs = 60000 / bpm;
                                    const twoBeatsMs = 2 * beatMs;
                                    const targets = this._computeChordSlideTargets(column);
                                    // Use negative velocity hint to stretch to max
                                    this._retuneActiveChordVoicesToTargets(targets, 0);
                                    // Optionally, we could force a minimal gliss time by scheduling a follow-up exact settle after two beats
                                    setTimeout(()=>{ try{ this._retuneActiveChordVoicesToTargets(targets, 0); }catch(_){ } }, Math.max(50, twoBeatsMs));
                                }
                            } else {
                                try {
                                    const quantizedChange = this._shouldQuantizeChordChange();
                                    if (quantizedChange.shouldQuantize) {
                                        this._scheduleQuantizedChordChange(column, centerY, quantizedChange.nextBeatMs);
                                    } else {
                                        this._executeChordChange(column, centerY);
                                    }
                                } catch(_) { this._executeChordChange(column, centerY); }
                            }
                        } else {
                            // When PLAY is not active OR other modes: simulate a short swipe strum across the center (strings only)
                            this.playChordStrum(column, { name: header.textContent }, centerY - 10, centerY + 10);
                        }
                    }
                } else {
                    // Fall back to palette chords if available
                    if (this.paletteChords && index < this.paletteChords.length) {
                        const chord = this.paletteChords[index];
                        console.log(`Playing palette chord ${index + 1}:`, chord.name);
                        this.playPaletteChord(chord);
                    } else {
                        console.log(`No chord available at index ${index + 1}`);
                    }
                }
            }

            setupTouchGestures() {
                // Add touch gesture support to all chord elements
                this.addTouchGesturesToElements();
                
                // Re-apply gestures when DOM changes (for dynamically added elements)
                const observer = new MutationObserver(() => {
                    this.addTouchGesturesToElements();
                });
                
                observer.observe(document.getElementById('extensionColumns'), {
                    childList: true,
                    subtree: true
                });
            }
            
            addTouchGesturesToElements() {
                // Add gestures to chord string buttons
                document.querySelectorAll('.chord-btn').forEach(btn => {
                    this.addTouchGestureToElement(btn, 'chord');
                    this.addClickGestureToElement(btn, 'chord');
                });

                // Add gestures to extension headers (tap to play; long-press on name to edit)
                document.querySelectorAll('.extension-header').forEach(header => {
                    this.addTouchGestureToElement(header, 'chord');
                    this.addClickGestureToElement(header, 'chord');
                });

                // Add gestures to palette chords
                document.querySelectorAll('.palette-chord').forEach(chord => {
                    this.addTouchGestureToElement(chord, 'palette');
                    this.addClickGestureToElement(chord, 'palette');
                });

                // Add gestures to root chord buttons
                document.querySelectorAll('.root-btn').forEach(btn => {
                    this.addTouchGestureToElement(btn, 'root');
                    this.addClickGestureToElement(btn, 'root');
                });
            }
            
            addTouchGestureToElement(element, type) {
                // Prevent duplicate listeners
                if (element.dataset.touchGestureAdded) return;
                element.dataset.touchGestureAdded = 'true';
                
                let touchData = {
                    startTime: 0,
                    longPressTimer: null,
                    isLongPress: false
                };
                
                // Store the type for later reference
                element.dataset.touchGestureType = type;
                
                // Touch start
                element.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    touchData.startTime = Date.now();
                    touchData.isLongPress = false;
                    
                    // Add visual feedback for touch press
                    element.classList.add('touch-pressed');
                    
                    // Clear any existing timer
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                    }
                    
                    // Start long press timer - use shorter delay for chord name buttons
                    const delay = (type === 'chord' && element.classList.contains('extension-header')) ? 
                        this.touchGestures.chordNameLongPressDelay : this.touchGestures.longPressDelay;
                    
                    touchData.longPressTimer = setTimeout(() => {
                        touchData.isLongPress = true;
                        element.classList.remove('touch-pressed');
                        element.classList.add('touch-long-press');
                        this.handleLongPress(element, type, touch.clientX, touch.clientY);
                        
                        // Add haptic feedback if available
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                    }, delay);
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch move - cancel long press if moving too much
                element.addEventListener('touchmove', (e) => {
                    // Cancel long press on any significant movement
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                        element.classList.remove('touch-pressed');
                    }
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch end
                element.addEventListener('touchend', (e) => {
                    // Clear long press timer
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                    }
                    
                    // Remove all touch feedback classes
                    element.classList.remove('touch-pressed', 'touch-long-press');
                    
                    // Handle normal tap if not a long press
                    if (!touchData.isLongPress) {
                        const delay = (type === 'chord' && element.classList.contains('extension-header')) ? 
                            this.touchGestures.chordNameLongPressDelay : this.touchGestures.longPressDelay;
                        if (Date.now() - touchData.startTime < delay) {
                            this.handleNormalTap(element, type);
                        }
                    }
                    
                    touchData.isLongPress = false;
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch cancel
                element.addEventListener('touchcancel', (e) => {
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                    }
                    
                    // Remove all touch feedback classes
                    element.classList.remove('touch-pressed', 'touch-long-press');
                    
                    touchData.isLongPress = false;
                }, { passive: false });
            }
            
            addClickGestureToElement(element, type) {
                // Prevent duplicate listeners
                if (element.dataset.clickGestureAdded) return;
                element.dataset.clickGestureAdded = 'true';
                
                // Add click event listener for regular mouse clicks (using capture phase for higher priority)
                element.addEventListener('click', (e) => {
                    // Header click: select only (no strum), or load into CALC if open
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        const column = element.closest('.extension-column');
                        const calcModal = document.getElementById('keyboardModal');
                        const calcOpen = !!(calcModal && calcModal.style.display !== 'none');
                        const loopToggle = document.getElementById('loopToggle');
                        const loopEnabled = loopToggle ? !!loopToggle.checked : true;

                        if (column && calcOpen) {
                            try { this.openCalcModal({ column }); } catch(_){ }
                        } else if (column && this.editArmed && !this._isSequencing && column === this.currentActiveColumnEl) {
                            try { this.openCalcModal({ column }); } catch(_){ }
                        } else if (column && !loopEnabled) {
                            try { this.currentActiveColumnEl = column; } catch(_){ }
                            try { if (this._arp) this._arp.column = column; } catch(_){ }
                            try { this.highlightKeyboardForColumn && this.highlightKeyboardForColumn(column); } catch(_){ }
                        }

                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        return false;
                    }
                    // For chord headers or columns, short click plays; do not open context menus
                    if (type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        // For CHORDS mode, clicking the chord should play the sustained chord, not a strum
                        const column = element.classList.contains('extension-column') ? element : element.closest('.extension-column');
                        if (column && (this.playMode||'high-low') === 'chords') {
                            const rect = column.getBoundingClientRect();
                            const midY = rect.top + rect.height * 0.5;
                            try {
                                const quantizedChange = this._shouldQuantizeChordChange();
                                if (quantizedChange.shouldQuantize) {
                                    this._scheduleQuantizedChordChange(column, midY, quantizedChange.nextBeatMs);
                                } else {
                                    this._executeChordChange(column, midY);
                                }
                            } catch(_) { this._executeChordChange(column, midY); }
                        } else {
                            this.handleClick(element, type, e.clientX, e.clientY);
                        }
                        return false; // Ensure event stops here
                    } else if (type === 'palette') {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        // Play palette chord on click
                        this.handleClick(element, type, e.clientX, e.clientY);
                        return false; // Ensure event stops here
                    }
                    // For root buttons (type === 'root'), let the normal click behavior happen
                }, true); // Use capture phase
                
                // Also add a mousedown listener for long-press support
                element.addEventListener('mousedown', (e) => {
                    // Only handle left click (button 0)
                    if (e.button === 0 && type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                        // For chord name buttons (extension-header), use shorter delay and enter edit only if on the text span
                        if (element.classList.contains('extension-header')) {
                            element.dataset.mouseDownTime = Date.now();
                            element.dataset.mouseDownX = e.clientX;
                            element.dataset.mouseDownY = e.clientY;
                            
                            // Start timer for long press on header; only edit if target is .chord-name
                            element.dataset.mouseLongPressTimer = setTimeout(() => {
                                element.dataset.isMouseLongPress = 'true';
                                // If the exact text span was pressed, enter inline edit
                                const target = e.target;
                                if (target && target.classList && target.classList.contains('chord-name')) {
                                    try {
                                        target.setAttribute('contenteditable','true');
                                        target.focus();
                                        const range = document.createRange();
                                        range.selectNodeContents(target);
                                        const sel = window.getSelection();
                                        sel.removeAllRanges();
                                        sel.addRange(range);
                                    } catch(_){ }
                                } else {
                                    // Otherwise treat as long-press hold (no context menu)
                                    this.handleLongPress(element, type, e.clientX, e.clientY);
                                }
                            }, this.touchGestures.chordNameLongPressDelay);
                        } else {
                            // Regular behavior for other chord elements
                            element.dataset.showContextMenuOnMouseup = 'true';
                        }
                    }
                }, true);
                
                // Add mousemove listener to cancel long press on movement
                element.addEventListener('mousemove', (e) => {
                    if (element.dataset.mouseLongPressTimer && element.dataset.mouseDownX && element.dataset.mouseDownY) {
                        const deltaX = Math.abs(e.clientX - parseInt(element.dataset.mouseDownX));
                        const deltaY = Math.abs(e.clientY - parseInt(element.dataset.mouseDownY));
                        
                        // Cancel long press if mouse moved too much (more than 10px)
                        if (deltaX > 10 || deltaY > 10) {
                            clearTimeout(parseInt(element.dataset.mouseLongPressTimer));
                            delete element.dataset.mouseLongPressTimer;
                            delete element.dataset.mouseDownTime;
                            delete element.dataset.mouseDownX;
                            delete element.dataset.mouseDownY;
                        }
                    }
                });
                
                // Add mouseup listener to complete the action
                element.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        // Handle chord name button mouseup
                        if (element.classList.contains('extension-header') && element.dataset.mouseDownTime) {
                            const holdTime = Date.now() - parseInt(element.dataset.mouseDownTime);
                            
                            // Clear the timer
                            if (element.dataset.mouseLongPressTimer) {
                                clearTimeout(parseInt(element.dataset.mouseLongPressTimer));
                                delete element.dataset.mouseLongPressTimer;
                            }
                            
                            // If it was a long press, don't do anything else (already handled)
                            if (element.dataset.isMouseLongPress === 'true') {
                                delete element.dataset.isMouseLongPress;
                            } else if (holdTime < this.touchGestures.chordNameLongPressDelay) {
                                // Short click - treat as normal tap
                                this.handleNormalTap(element, type);
                            }
                            
                            // Clean up
                            delete element.dataset.mouseDownTime;
                            delete element.dataset.mouseDownX;
                            delete element.dataset.mouseDownY;
                        } else if (element.dataset.showContextMenuOnMouseup === 'true') {
                            // Regular behavior for other chord elements
                            delete element.dataset.showContextMenuOnMouseup;
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            this.handleClick(element, type, e.clientX, e.clientY);
                            return false;
                        }
                    }
                }, true);
            }
            
            handleClick(element, type, x, y) {
                // For chords and palette items, trigger playback (strum or sustained chord)
                // When PLAY is not active (_isSequencing false), ALWAYS strum - never play chords/arps/patterns
                    if (type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                    const column = element.classList.contains('extension-column') ? element : element.closest('.extension-column');
                    if (!column) { console.error('Could not find parent column'); return; }
                        if (column.classList.contains('calc-preview-column')) {
                            const calcChord = this._computeCalcChord();
                            this._playCalcChordPreview(calcChord);
                            return;
                        }
                    const rect = column.getBoundingClientRect();
                    // Only play sustained chords when PLAY is active (isSequencing)
                    if ((this.playMode||'high-low') === 'chords' && this._isSequencing) {
                        const midY = rect.top + rect.height * 0.5;
                            try {
                                const quantizedChange = this._shouldQuantizeChordChange();
                                if (quantizedChange.shouldQuantize) {
                                    this._scheduleQuantizedChordChange(column, midY, quantizedChange.nextBeatMs);
                                } else {
                                    this._executeChordChange(column, midY);
                                }
                            } catch(_) { this._executeChordChange(column, midY); }
                    } else {
                        // When PLAY is not active, always strum (strings only)
                        const header = column.querySelector('.extension-header');
                        const chordData = (this.getChordDataFromColumn(column, header)) || { name: header ? header.textContent : 'Chord' };
                        const startY = rect.top + Math.max(4, rect.height * 0.08);
                        const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                        this.playChordStrum(column, chordData, startY, endY);
                    }
                    return;
                }
                if (type === 'palette') {
                    const chordData = this.getPaletteChordDataFromElement(element);
                    const column = element.closest('.palette-chord') || element.closest('.extension-column') || element;
                    if (column && chordData) {
                        const rect = column.getBoundingClientRect();
                        // Only play sustained chords when PLAY is active (isSequencing)
                        if ((this.playMode || 'high-low') === 'chords' && this._isSequencing) {
                            const midY = rect.top + rect.height * 0.5;
                            try {
                                const quantizedChange = this._shouldQuantizeChordChange();
                                if (quantizedChange.shouldQuantize) {
                                    this._scheduleQuantizedChordChange(column, midY, quantizedChange.nextBeatMs);
                                } else {
                                    this._executeChordChange(column, midY);
                                }
                            } catch(_) { this._executeChordChange(column, midY); }
                        } else {
                            // When PLAY is not active, always strum (strings only)
                            const startY = rect.top + Math.max(4, rect.height * 0.08);
                            const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                            this.playChordStrum(column, chordData, startY, endY);
                        }
                    }
                    return;
                }
                // For other types (e.g., root), let normal behavior proceed
            }
            
            handleLongPress(element, type, x, y) {
                // Show appropriate context menu based on element type
                if (type === 'chord') {
                    // Check if this is an extension header (chord name button)
                    if (element.classList.contains('extension-header')) {
                        // Only enter edit mode if the long-press happened on the chord-name span
                        try {
                            const target = document.elementFromPoint(x, y);
                            const nameEl = element.querySelector('.chord-name');
                            if (target && nameEl && (target === nameEl || nameEl.contains(target))) {
                                nameEl.setAttribute('contenteditable','true');
                                nameEl.focus();
                                const range = document.createRange();
                                range.selectNodeContents(nameEl);
                                const sel = window.getSelection();
                                sel.removeAllRanges();
                                sel.addRange(range);
                            }
                        } catch(_) { /* no-op */ }
                    } else {
                        // Fallback to original logic for other chord elements
                        const columnData = this.getColumnDataFromElement(element);
                    }
                } else if (type === 'palette') {
                    const chordData = this.getPaletteChordDataFromElement(element);
                } else if (type === 'root') {
                    // Root chords could have their own context menu
                }
            }
            
            handleNormalTap(element, type) {
                // Normal tap behavior for chord headers and palette chords
                if (type === 'chord' && element.classList.contains('extension-header')) {
                    const column = element.closest('.extension-column');
                    const calcModal = document.getElementById('keyboardModal');
                    const calcOpen = !!(calcModal && calcModal.style.display !== 'none');
                    const loopToggle = document.getElementById('loopToggle');
                    const loopEnabled = loopToggle ? !!loopToggle.checked : true;

                    // CALC: tap header in EDIT mode (stopped) to open calculator
                    if (column && calcOpen) {
                        try { this.openCalcModal({ column }); } catch(_){ }
                        return;
                    }
                    try {
                        if (column && this.editArmed && !this._isSequencing && column === this.currentActiveColumnEl) {
                            this.openCalcModal({ column });
                            return;
                        }
                    } catch(_){ }

                    if (column && !loopEnabled) {
                        try { this.currentActiveColumnEl = column; } catch(_){ }
                        try { if (this._arp) this._arp.column = column; } catch(_){ }
                        try { this.highlightKeyboardForColumn && this.highlightKeyboardForColumn(column); } catch(_){ }
                    }
                    return;
                } else if (type === 'palette') {
                    const chordData = this.getPaletteChordDataFromElement(element);
                    const column = element.closest('.palette-chord') || element.closest('.extension-column') || element;
                    if (column && chordData) {
                        const rect = column.getBoundingClientRect();
                        const startY = rect.top + Math.max(4, rect.height * 0.08);
                        const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                        this.playChordStrum(column, chordData, startY, endY);
                    }
                } else if (type === 'root') {
                    // For root buttons, perform normal click behavior
                    const rootBtn = element.closest('.root-btn');
                    if (rootBtn) rootBtn.click();
                }
            }
            
            getColumnDataFromElement(element) {
                const column = element.closest('[data-chord-type]');
                if (!column) return null;
                
                return {
                    name: column.dataset.chordType,
                    extensions: column.dataset.extensions ? column.dataset.extensions.split(',') : [],
                    element: column
                };
            }
            
            getPaletteChordDataFromElement(element) {
                const chordElement = element.closest('.palette-chord');
                if (!chordElement) return null;
                
                const chordIndex = parseInt(chordElement.dataset.chordIndex);
                return this.paletteChords[chordIndex] || null;
            }
            
            showPaletteContextMenu(x, y, chordData) {
            }
            
            handlePaletteContextMenuAction(action) {
            }

            showColumnContextMenu(x, y, columnData) {
            }

            getChordDataFromColumn(column, header) {
                const chordType = column.dataset.chordType;
                let chordData = null;
                
                console.log('?? getChordDataFromColumn called with chordType:', chordType);
                
                // Check if it's a custom chord
                if (chordType && chordType.startsWith('custom_')) {
                    const customIndex = parseInt(chordType.replace('custom_', ''));
                    const customChord = this.customChords[customIndex];
                    if (customChord) {
                        chordData = {
                            name: customChord.name,
                            extensions: [],
                            quality: 'custom',
                            id: chordType,
                            isCustom: true,
                            originalName: customChord.name,
                            customIndex: customIndex,
                            intervals: customChord.notes,
                            root: this.currentRoot,
                            tuning: this.currentTuning
                        };
                    }
                } else {
                    // Regular extension chord - determine quality and extension
                    let quality = 'major'; // default
                    
                    // Try to find quality from parent quality section first
                    let qualitySection = null;
                    if (header && header.closest) {
                        qualitySection = header.closest('.quality-section');
                    }
                    
                    if (qualitySection) {
                        const allQualitySections = Array.from(document.querySelectorAll('.quality-section'));
                        const qualityIndex = allQualitySections.indexOf(qualitySection);
                        const qualities = ['major', 'neutral', 'minor'];
                        quality = qualities[qualityIndex] || 'major';
                    } else {
                        // For basic triads mode, determine quality from chord type or header text
                        const headerText = header && header.textContent ? header.textContent : '';
                        if (chordType === 'major' || headerText === 'Major') {
                            quality = 'major';
                        } else if (chordType === 'neutral' || headerText === 'Neutral') {
                            quality = 'neutral';
                        } else if (chordType === 'minor' || headerText === 'Minor') {
                            quality = 'minor';
                        }
                    }
                    
                    // Find the extension - in basic triads mode, find by name
                    let chordExt = null;
                    if (chordType === 'major' || chordType === 'neutral' || chordType === 'minor') {
                        // Basic triads mode - find by name
                        chordExt = this.chordExtensions.find(ext => 
                            ext.name.toLowerCase() === header.textContent.toLowerCase()
                        );
                    } else {
                        // Complex mode - find by index
                        const chordIndex = parseInt(chordType);
                        chordExt = this.chordExtensions[chordIndex];
                    }
                    
                    if (chordExt) {
                        chordData = {
                            name: header.textContent,
                            extensions: chordExt.extensions || [],
                            quality: quality,
                            id: chordType,
                            isCustom: false,
                            originalName: chordExt.name,
                            extensionIndex: chordExt.name, // Use name as identifier in basic mode
                            intervals: this.getBaseTriadForQuality(quality).concat(chordExt.extensions || []),
                            root: this.currentRoot,
                            tuning: this.currentTuning
                        };
                        console.log('?? Created chordData:', chordData);
                    } else {
                        console.log('?? Failed to find chordExt for chordType:', chordType);
                    }
                }
                
                return chordData;
            }

            showChordNameContextMenu(x, y, chordData) {
            }

            handleContextMenuAction(action) {
                console.log('Context menu action requested but disabled:', action);
            }
            
            // New unified methods for the refactored system
            duplicateAndEditColumn() {
                if (!this.currentEditingColumn) return;
                
                // Create a duplicate chord with new ID
                const duplicateChord = {
                    name: this.currentEditingColumn.name + ' Copy',
                    intervals: [...(this.currentEditingColumn.intervals || [])],
                    isCustom: true,
                    id: Date.now()
                };
                
                // Open chord builder with the duplicate
                this.showChordBuilder(duplicateChord);
            }
            
            editColumnInChordBuilder() {
                if (!this.currentEditingColumn) return;
                
                // Open chord builder with current column data for editing
                this.showChordBuilder(this.currentEditingColumn);
            }

            // Palette chord context menu actions
            editPaletteChordNotes(chordData) {
                // Open a modal to edit chord notes
                console.log('Editing palette chord notes:', chordData);
                // TODO: Implement chord note editor
            }
            
            copyPaletteChord(chordData) {
                // Create a copy of the chord and add it to the palette
                const copy = {
                    ...chordData,
                    name: chordData.name + ' Copy'
                };
                this.paletteChords.push(copy);
                this.savePaletteChords();
                console.log('Copied palette chord:', copy);
            }
            
            movePaletteChord(chordData, direction) {
                const currentIndex = this.paletteChords.findIndex(chord => 
                    chord.name === chordData.name && 
                    JSON.stringify(chord.notes) === JSON.stringify(chordData.notes)
                );
                
                if (currentIndex === -1) return;
                
                const newIndex = currentIndex + direction;
                if (newIndex < 0 || newIndex >= this.paletteChords.length) return;
                
                // Swap positions
                [this.paletteChords[currentIndex], this.paletteChords[newIndex]] = 
                [this.paletteChords[newIndex], this.paletteChords[currentIndex]];
                
                this.savePaletteChords();
                console.log('Moved palette chord:', direction > 0 ? 'right' : 'left');
            }
            
            removePaletteChord(chordData) {
                const index = this.paletteChords.findIndex(chord => 
                    chord.name === chordData.name && 
                    JSON.stringify(chord.notes) === JSON.stringify(chordData.notes)
                );
                
                if (index !== -1) {
                    this.paletteChords.splice(index, 1);
                    this.savePaletteChords();
                }
            }

            setupFretboardResize() {
                const resizeHandle = document.querySelector('.resize-handle');
                const extensionColumns = document.getElementById('extensionColumns');
                let isResizing = false;
                let startY = 0;
                let startHeight = 0;

                if (!resizeHandle || !extensionColumns) return;

                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startY = e.clientY;
                    startHeight = extensionColumns.offsetHeight;
                    document.body.style.cursor = 'ns-resize';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    
                    const deltaY = e.clientY - startY;
                    const newHeight = Math.max(200, Math.min(800, startHeight + deltaY));
                    
                    // Update container height
                    extensionColumns.style.height = `${newHeight}px`;
                    
                    // Update string spacing by keeping strings thin (1px) with tight margins for 8-octave support
                    const strings = document.querySelectorAll('.string');
                    const stringHeight = 1; // Always keep strings thin at 1px
                    const stringMargin = 0.2; // Consistent tight margin for 8-octave support
                    
                    strings.forEach(string => {
                        string.style.height = `${stringHeight}px`;
                        string.style.margin = `${stringMargin}px 0`;
                    });
                    
                    e.preventDefault();
                });

                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        document.body.style.cursor = '';
                    }
                });

                // Touch support for mobile
                resizeHandle.addEventListener('touchstart', (e) => {
                    isResizing = true;
                    startY = e.touches[0].clientY;
                    startHeight = extensionColumns.offsetHeight;
                    e.preventDefault();
                });

                document.addEventListener('touchmove', (e) => {
                    if (!isResizing) return;
                    
                    const deltaY = e.touches[0].clientY - startY;
                    const newHeight = Math.max(200, Math.min(800, startHeight + deltaY));
                    
                    extensionColumns.style.height = `${newHeight}px`;
                    
                    const strings = document.querySelectorAll('.string');
                    const stringHeight = 1; // Always keep strings thin at 1px
                    const stringMargin = 0.2; // Consistent tight margin for 8-octave support
                    
                    strings.forEach(string => {
                        string.style.height = `${stringHeight}px`;
                        string.style.margin = `${stringMargin}px 0`;
                    });
                    
                    e.preventDefault();
                });

                document.addEventListener('touchend', () => {
                    if (isResizing) {
                        isResizing = false;
                    }
                });
            }

            setupSonicChords() {
                // No longer rendering sonic chords - lock buttons work directly on main chord grid
                console.log('Sonic chord system disabled - using direct chord locking');
            }

            handleSonicStringTrigger(e) {
                if (!e.target.classList.contains('string')) return;
                
                const stringElement = e.target;
                const column = stringElement.closest('.sonic-column');
                if (!column) return;
                
                const index = parseInt(column.dataset.index);
                const sonicChord = this.lockedSonicChords[index];
                if (!sonicChord) return;
                
                const stringIndex = parseInt(stringElement.dataset.string);
                const stringKey = `${index}-${stringIndex}`;
                
                if (!this.sonicTriggeredStrings.has(stringKey)) {
                    this.sonicTriggeredStrings.add(stringKey);
                    
                    // Apply sonic settings temporarily and play the string
                    this.playSonicChord(sonicChord, () => {
                        this.playStringAtIndex(stringIndex);
                    });
                }
            }

            playSonicChordStrum(column, sonicChord, startY, endY) {
                // Apply sonic settings temporarily and play chord strum
                this.playSonicChord(sonicChord, () => {
                    this.playChordStrum(column, sonicChord.chordData, startY, endY);
                });
            }

            addToPalette(chordData) {
                // Always add chords to palette, even duplicates for chord progressions
                // Add a unique ID to track individual instances
                const chordWithId = {
                    ...chordData,
                    paletteId: Date.now() + Math.random() // Unique identifier for this instance
                };
                
                this.paletteChords.push(chordWithId);
                console.log(`Added "${chordData.fullName}" to palette (${this.paletteChords.length} total chords)`);
                this.renderPaletteChords();
            }

            removeFromPalette(index) {
                if (index >= 0 && index < this.paletteChords.length) {
                    const removedChord = this.paletteChords.splice(index, 1)[0];
                    this.renderPaletteChords();
                }
            }

            // =============================================================================
            // SONIC CHORD LOCKING SYSTEM - Complete snapshot of all settings
            // =============================================================================
            
            lockSonicChord(chordData, columnElement) {
                // Check if this chord is already locked
                if (!this.lockedChords) this.lockedChords = new Map();
                
                const isAlreadyLocked = this.lockedChords.has(columnElement);
                
                if (isAlreadyLocked) {
                    // UNLOCK the chord - make it editable but keep it visible
                    console.log('?? Unlocking chord but keeping it visible:', chordData.name);
                    
                    // Get the locked chord data before deleting
                    const lockedChordData = this.lockedChords.get(columnElement);
                    
                    this.lockedChords.delete(columnElement);
                    
                    // Update session data and saved locks
                    this.sessionData.lockedChords = Array.from(this.lockedChords.values());
                    this.savedLockedChords = Array.from(this.lockedChords.values());
                    
                    // Update UI - change lock button to unlocked state (buttons remain visible)
                    const lockButton = columnElement.querySelector('.lock-button');
                    if (lockButton) {
                        lockButton.innerHTML = 'ðŸ”“';
                        lockButton.classList.remove('locked');
                        lockButton.title = 'Lock chord with current root & settings';
                    }
                    
                    // Keep action buttons visible when unlocked - they should always be available
                    
                    // Reset the column header color to indicate unlocked
                    const header = columnElement.querySelector('.extension-header');
                    const chordName = header.querySelector('.chord-name');
                    if (chordName) {
                        chordName.style.color = '#fff'; // Reset to default color
                        chordName.style.fontWeight = 'normal'; // Reset font weight
                        // Restore original chord name (remove lock icon and root prefix)
                        const originalName = chordData.name || (lockedChordData ? lockedChordData.chordName : 'Chord');
                        const qualityOnlyName = originalName.replace(/^ðŸ”’\s*/, '').replace(/^[A-G][#b]?\s*/, ''); // Remove lock icon and root
                        chordName.textContent = qualityOnlyName || originalName;
                        chordName.title = 'Unlocked - will follow current root'; // Update tooltip
                    }
                    
                    // Update the chord extension data to reflect unlocked state
                    if (lockedChordData) {
                        const chordExtension = this.chordExtensions.find(ext => 
                            ext.name === lockedChordData.chordName || 
                            (ext.lockedData && ext.lockedData.lockId === lockedChordData.lockId)
                        );
                        
                        if (chordExtension) {
                            // Convert back to unlocked state but keep the chord visible
                            chordExtension.isLocked = false;
                            chordExtension.lockedData = null;
                            // Keep the intervals so the chord structure remains
                            chordExtension.intervals = lockedChordData.intervals;
                            chordExtension.isCustom = true; // Mark as custom to preserve intervals
                            
                            console.log('?? Converted locked chord to unlocked custom chord:', chordExtension.name);
                        }
                    }
                    
                    // Update the strings in this column to use current root instead of locked root
                    const strings = columnElement.querySelectorAll('.string');
                    strings.forEach(string => {
                        const interval = parseInt(string.dataset.interval);
                        if (!isNaN(interval)) {
                            // Recalculate frequency with current root
                            const absStep3 = ((this.currentRoot + interval) % this.currentTuning + this.currentTuning) % this.currentTuning;
                            const frequency = this.getFrequency(absStep3, 4, this.currentTuning);
                            string.dataset.frequency = frequency;
                            
                            // Update note name and tooltip
                            const noteName = this.getIntervalNoteName(interval);
                            string.textContent = noteName;
                            string.title = `${noteName} (${interval} steps, ${frequency.toFixed(1)}Hz)`;
                        }
                    });
                    
                    console.log('?? Chord unlocked but remains visible as editable chord:', chordData.name);
                    return;
                }
                
                // LOCK the chord
                    console.log('?? Locking chord directly in main grid with current root and settings:', chordData);
                
                // Create a unique identifier for this specific chord + root combination
                const currentRoot = this.currentRoot || 0;
                const lockId = `${chordData.name}_${chordData.quality || 'major'}_${currentRoot}`;
                
                // Capture ALL current settings directly from UI controls
                const rootName = this.getNoteNames()[currentRoot] || currentRoot;
                // Avoid duplicating root if chordData.name already starts with a root (e.g., "C", "Bb7")
                const nameHasRoot = /^[A-G][#b]?/.test(chordData.name || '');
                const fullChordName = nameHasRoot ? (chordData.name || String(rootName)) : `${rootName}${chordData.name}`; // Full display name
                
                const lockedChordData = {
                    // Chord identification
                    lockId: lockId,
                    chordName: fullChordName, // Store full name (root + quality) when locked
                    quality: chordData.quality || this.currentQuality || 'major',
                    extensions: chordData.extensions || [],
                    lockedRoot: currentRoot, // THIS is the key - lock to current root
                    
                    // Position tracking - find current position in chordExtensions array
                    originalPosition: chordData.position !== undefined ? chordData.position : this.findChordPosition(chordData),
                    
                    // Store chord intervals for exact reconstruction
                    intervals: chordData.intervals || [],
                    isCustom: chordData.isCustom || false,
                    
                    // Tuning system (locked)
                    lockedTuning: this.currentTuning || 12,
                    lockedGamelanMode: this.gamelanMode || false,
                    
                    // Audio settings (locked)
                    lockedOsc1: {
                        type: document.getElementById('osc1Type')?.value || this.oscillators.osc1.type || 'sine',
                        level: (()=>{
                            const v = parseFloat(document.getElementById('osc1Level')?.value);
                            return Number.isFinite(v) ? (v / 10) * 0.125 : (this.oscillators.osc1.level || 5 * 0.125 / 10);
                        })(),
                        octave: parseInt(document.getElementById('osc1Octave')?.value || this.oscillators.osc1.octave || 0),
                        coarse: parseInt(document.getElementById('osc1Coarse')?.value || this.oscillators.osc1.coarse || 0),
                        detune: parseFloat(document.getElementById('osc1Detune')?.value || this.oscillators.osc1.detune || 0)
                    },
                    
                    lockedOsc2: {
                        type: document.getElementById('osc2Type')?.value || this.oscillators.osc2.type || 'sine',
                        level: (()=>{
                            const v = parseFloat(document.getElementById('osc2Level')?.value);
                            return Number.isFinite(v) ? (v / 10) * 0.125 : (this.oscillators.osc2.level || 5 * 0.125 / 10);
                        })(),
                        octave: parseInt(document.getElementById('osc2Octave')?.value || this.oscillators.osc2.octave || 0),
                        coarse: parseInt(document.getElementById('osc2Coarse')?.value || this.oscillators.osc2.coarse || 0),
                        detune: parseFloat(document.getElementById('osc2Detune')?.value || this.oscillators.osc2.detune || 0)
                    },
                    
                    lockedEnvelope: {
                        attack: parseFloat(document.getElementById('envAttack')?.value || this.envelope.attack || 0.01),
                        decay: parseFloat(document.getElementById('envDecay')?.value || this.envelope.decay || 0.3),
                        sustain: parseFloat(document.getElementById('envSustain')?.value || this.envelope.sustain || 0.5),
                        release: parseFloat(document.getElementById('envRelease')?.value || this.envelope.release || 1)
                    },
                    
                    lockedOsc2Envelope: {
                        attack: parseFloat(document.getElementById('osc2EnvAttack')?.value || this.osc2Envelope.attack || 0.01),
                        decay: parseFloat(document.getElementById('osc2EnvDecay')?.value || this.osc2Envelope.decay || 0.3),
                        sustain: parseFloat(document.getElementById('osc2EnvSustain')?.value || this.osc2Envelope.sustain || 0.5),
                        release: parseFloat(document.getElementById('osc2EnvRelease')?.value || this.osc2Envelope.release || 1)
                    },
                    
                    lockedEffects: {
                        reverbWet: parseFloat(document.getElementById('reverbWet')?.value || this.reverbWet || 0),
                        reverbDecay: parseFloat(document.getElementById('reverbDecay')?.value || (this.reverb ? this.reverb.decay : 1)),
                        reverbFilterCutoff: parseFloat(document.getElementById('reverbFilterCutoff')?.value || (this.reverbFilterNode ? this.reverbFilterNode.frequency.value : 20000)),
                        panningMode: document.getElementById('panningMode')?.value || this.panning.mode || 'center',
                        panningWidth: parseFloat(document.getElementById('panningWidth')?.value || this.panning.width || 1)
                    },
                    
                    lockedVolume: {
                        master: parseFloat(document.getElementById('masterVolume')?.value || this.masterVolume || 1),
                        main: parseFloat(document.getElementById('mainVolume')?.value || this.volume || 0.5)
                    },
                    
                    // CRITICAL: Capture exact string frequencies for perfect sound preservation
                    exactFrequencies: this.captureStringFrequencies(columnElement),
                    
                    // Timestamp
                    timestamp: Date.now()
                };
                
                // Store in lockedChords map using column element as key
                if (!this.lockedChords) this.lockedChords = new Map();
                this.lockedChords.set(columnElement, lockedChordData);
                
                // Store in session data and keep saved locks in sync
                this.sessionData.lockedChords = Array.from(this.lockedChords.values());
                this.savedLockedChords = Array.from(this.lockedChords.values());

                // Mark chord model as locked so regeneration uses snapshot
                if (chordData) {
                    chordData.isLocked = true;
                    chordData.lockedData = lockedChordData;
                }
                
                // Update UI - change lock button to locked state and show locked root
                const lockButton = columnElement.querySelector('.lock-button');
                if (lockButton) {
                    lockButton.innerHTML = 'ðŸ”’';
                    lockButton.classList.add('locked');
                    lockButton.title = `Locked to ${this.getNoteNames()[currentRoot] || currentRoot} root with all settings`;
                }
                
                // Action buttons remain visible (they should always be available)
                // No edit/hide/duplicate header buttons anymore
                
                // Update the column header to show it's locked to a specific root
                const header = columnElement.querySelector('.extension-header');
                const chordName = header.querySelector('.chord-name');
                if (chordName) {
                    const rootName = this.getNoteNames()[currentRoot] || currentRoot;
                    chordName.style.color = '#4CAF50';
                    const alreadyHasRoot = /^[A-G][#b]?/.test(chordData.name || '');
                    const displayName = alreadyHasRoot ? chordData.name : `${rootName}${chordData.name}`;
                    chordName.textContent = `ðŸ”’ ${displayName}`;
                    chordName.title = `Locked to ${rootName} (oscillators & envelopes only)`;
                }
                
                console.log('?? Chord locked directly in main grid:', lockedChordData);
            }
            
            // ============= PIANO SETTINGS LOCK SYSTEM - Oscillator & Effect Settings Only =============
            
            // Store the original UI state to prevent contamination
            storeOriginalUIState() {
                if (!this.originalUIState) {
                    // Store the initial clean state when app starts
                    this.originalUIState = {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 },
                        envelope: { ...this.envelope },
                        osc2Envelope: { ...this.osc2Envelope },
                        reverb: { ...this.reverb },
                        panning: { ...this.panning },
                        volume: this.volume,
                        masterVolume: this.masterVolume
                    };
                }
                return this.originalUIState;
            }
            
            // Capture current synthesizer state for piano lock with unique preset ID
            captureCurrentSynthState() {
                // Defensive: initialize counter/map if missing
                if (typeof this.pianoLockPresetCounter !== 'number' || !isFinite(this.pianoLockPresetCounter)) {
                    this.pianoLockPresetCounter = 0;
                }
                if (!this.preloadedPresets) {
                    this.preloadedPresets = new Map();
                }
                // Generate unique preset ID
                this.pianoLockPresetCounter++;
                const presetId = `ID${String(this.pianoLockPresetCounter).padStart(3, '0')}`;
                
                const synthState = {
                    // Unique preset identifier
                    presetId: presetId,
                    
                    // Oscillator 1 settings (COMPLETE)
                    osc1: { ...this.oscillators.osc1 },
                    
                    // Oscillator 2 settings (COMPLETE)
                    osc2: { ...this.oscillators.osc2 },
                    
                    // Envelope settings (OSC 1 COMPLETE ADSR)
                    envelope: { ...this.envelope },
                    
                    // OSC 2 Envelope settings (COMPLETE ADSR)
                    osc2Envelope: { ...this.osc2Envelope },
                    
                    // Volume settings
                    volume: {
                        main: this.volume,
                        master: this.masterVolume
                    }
                };
                
                // Preload this preset for instant switching
                this.preloadedPresets.set(presetId, synthState);
                
                console.log(`ðŸŽ¹ Created new piano lock preset: ${presetId}`);
                console.log(`ðŸŽ¹ OSC1: ${synthState.osc1.type} wave, A:${Math.round(synthState.envelope.attack*1000)} D:${Math.round(synthState.envelope.decay*1000)} S:${Math.round(synthState.envelope.sustain*100)}% R:${Math.round(synthState.envelope.release*1000)}`);
                console.log(`ðŸŽ¹ OSC2: ${synthState.osc2.type} wave, A:${Math.round(synthState.osc2Envelope.attack*1000)} D:${Math.round(synthState.osc2Envelope.decay*1000)} S:${Math.round(synthState.osc2Envelope.sustain*100)}% R:${Math.round(synthState.osc2Envelope.release*1000)}`);
                
                return synthState;
            }
            
            // Migrate existing piano locks from old format (with root) to new format (without root)
            migratePianoLocksToNewFormat() {
                if (!this.pianoLockedChords || this.pianoLockedChords.size === 0) return;
                
                console.log('ðŸŽ¹ MIGRATING piano locks to new format (removing root dependency)');
                const oldEntries = Array.from(this.pianoLockedChords.entries());
                const newPianoLocks = new Map();
                const newPreloadedPresets = new Map();
                
                oldEntries.forEach(([oldKey, pianoData]) => {
                    // Check if this is an old-format key (contains root)
                    const keyParts = oldKey.split('_');
                    if (keyParts.length >= 4) {
                        // Old format: chordName_quality_root_extensions_intervals
                        const [chordName, quality, root, ...rest] = keyParts;
                        
                        // Create new key without root
                        const extensions = rest.length > 1 ? rest[0] : '';
                        const intervals = rest.length > 1 ? rest[1] : rest[0] || '';
                        const newKey = `${chordName}_${quality}_${extensions}_${intervals}`;
                        
                        console.log(`ðŸŽ¹ Migrating: ${oldKey} â†’ ${newKey}`);
                        
                        // Store with new key format
                        newPianoLocks.set(newKey, pianoData);
                        
                        // Also migrate preloaded preset
                        if (pianoData.presetId && this.preloadedPresets.has(pianoData.presetId)) {
                            newPreloadedPresets.set(pianoData.presetId, this.preloadedPresets.get(pianoData.presetId));
                        }
                    } else {
                        // Already new format, keep as-is
                        newPianoLocks.set(oldKey, pianoData);
                        if (pianoData.presetId && this.preloadedPresets.has(pianoData.presetId)) {
                            newPreloadedPresets.set(pianoData.presetId, this.preloadedPresets.get(pianoData.presetId));
                        }
                    }
                });
                
                // Replace old maps with migrated data
                this.pianoLockedChords = newPianoLocks;
                this.preloadedPresets = newPreloadedPresets;
                
                console.log('ðŸŽ¹ Migration complete. Piano locks now work across all root notes!');
            }
            
            // Generate a stable key for piano lock identification that is independent of display names/quality
            generatePianoLockKey(chordData) {
                // Prefer the chord's SHAPE (sorted intervals) so the key is stable across renames, roots, and qualities
                let iv = Array.isArray(chordData?.intervals) ? [...chordData.intervals] : [];
                if ((!iv || iv.length === 0) && typeof this.getChordIntervals === 'function') {
                    // Derive from extensions if explicit intervals were not provided
                    iv = this.getChordIntervals(chordData?.extensions || []);
                }
                if (!Array.isArray(iv)) iv = [];
                // Normalize numeric and sort
                const ivNums = iv.map(n => {
                    const v = Number(n);
                    return Number.isFinite(v) ? v : 0;
                }).sort((a,b)=> a-b);
                const intervalsSig = ivNums.join('.');

                // Include whether it's custom to reduce accidental collisions across radically different modes
                const customTag = chordData?.isCustom ? 'custom' : 'builtIn';
                const key = `shape:${intervalsSig}|${customTag}`;

                // Debug
                console.log('ðŸ”‘ generatePianoLockKey:', {intervalsSig, customTag, key, chordData});
                return key;
            }
            
            // Find piano lock data by stable key
            findPianoLockData(chordData) {
                if (!this.pianoLockedChords) return null;
                const key = this.generatePianoLockKey(chordData);
                const direct = this.pianoLockedChords.get(key);
                if (direct) return direct;

                // Fallback 1: match by intervals signature against existing entries (backward compatibility)
                let iv = Array.isArray(chordData?.intervals) ? [...chordData.intervals] : [];
                if ((!iv || iv.length === 0) && typeof this.getChordIntervals === 'function') {
                    iv = this.getChordIntervals(chordData?.extensions || []);
                }
                const sig = (Array.isArray(iv) ? iv.map(n=> Number(n)||0).sort((a,b)=>a-b).join('.') : '');
                if (sig) {
                    for (const [k, data] of this.pianoLockedChords.entries()) {
                        if (data && data.intervalsSig === sig) return data;
                        // Old-style key may end with "_intervals"; compare last token if present
                        const lastUnderscore = k.lastIndexOf('_');
                        if (lastUnderscore > -1) {
                            const tail = k.slice(lastUnderscore+1);
                            if (tail.replace(/,/g,'.') === sig.replace(/\./g,'.')) return data;
                        }
                    }
                }
                return null;
            }
            
            lockPianoSettings(chordData, columnElement) {
                console.log('ðŸŽ¹ lockPianoSettings function called with:', chordData, columnElement);
                
                // Check if this chord already has piano-locked settings using stable key
                if (!this.pianoLockedChords) this.pianoLockedChords = new Map();
                
                const lockKey = this.generatePianoLockKey(chordData);
                const isAlreadyPianoLocked = this.pianoLockedChords.has(lockKey);
                
                if (isAlreadyPianoLocked) {
                    console.log('ðŸŽ¹ Unlocking piano settings (backend) for:', chordData.name, 'key:', lockKey);
                    this.pianoLockedChords.delete(lockKey);
                    chordData.isPianoLocked = false;
                    chordData.pianoLockedData = null;
                    return;
                }
                
                // If a different column with the same shape is already locked, transfer ownership to this column
                const existingData = this.pianoLockedChords.get(lockKey);
                if (existingData) {
                    // Find currently locked column for this key
                    let currentOwnerCol = null;
                    try {
                        // Find an owner column by matching stored pianoLockKey on chord data
                        document.querySelectorAll('.extension-column').forEach(col => {
                            if (currentOwnerCol) return;
                            const headerEl = col.querySelector('.extension-header');
                            const cd = this.getChordDataFromColumn(col, headerEl);
                            if (!cd) return;
                            const k = this.generatePianoLockKey(cd);
                            if (k === lockKey && cd.isPianoLocked) {
                                currentOwnerCol = col;
                            }
                        });
                    } catch (_) {}
                    // If the same column, treat as unlock (handled above). If different, switch UI ownership.
                    if (currentOwnerCol && currentOwnerCol !== columnElement) {
                        // Unlock previous owner's UI and model flags
                        try {
                            const prevHeader = currentOwnerCol.querySelector('.extension-header');
                            const prevData = this.getChordDataFromColumn(currentOwnerCol, prevHeader);
                            if (prevData) { prevData.isPianoLocked = false; prevData.pianoLockedData = null; }
                        } catch (_) {}
                        // Transfer ownership (backend) and warm this column for instant play
                        chordData.isPianoLocked = true;
                        chordData.pianoLockedData = existingData;
                        chordData.pianoLockKey = lockKey;
                        // Warm this chord for instant play
                        try { this.preloadPianoLockedChord(columnElement); } catch (_) {}
                        console.log('ðŸŽ¹ Transferred piano-lock ownership to clicked column for key:', lockKey);
                        return;
                    }
                }

                // LOCK the piano settings (no existing owner)
                console.log('ðŸŽ¹ Locking piano settings for:', chordData.name, 'key:', lockKey);
                const currentSynthState = this.captureCurrentSynthState();
                const pianoLockedData = {
                    chordName: chordData.name,
                    lockKey: lockKey,
                    intervalsSig: (Array.isArray(chordData?.intervals) && chordData.intervals.length)
                        ? chordData.intervals.map(n=> Number(n)||0).sort((a,b)=>a-b).join('.')
                        : (typeof this.getChordIntervals === 'function' ? (this.getChordIntervals(chordData.extensions||[]).map(n=> Number(n)||0).sort((a,b)=>a-b).join('.')) : ''),
                    ...currentSynthState,
                    timestamp: Date.now()
                };
                this.pianoLockedChords.set(lockKey, pianoLockedData);
                chordData.isPianoLocked = true;
                chordData.pianoLockedData = pianoLockedData;
                chordData.pianoLockKey = lockKey;
                try { this.preloadPianoLockedChord(columnElement); } catch(_) {}
            }
            
            // Apply piano-locked settings when playing a chord (NEVER modifies base synthesizer state)
            applyPianoLockedSettings(pianoLockedData) {
                if (!pianoLockedData) return;
                
                const presetId = pianoLockedData.presetId;
                console.log(`ðŸŽ¹ Applying piano-locked preset: ${presetId} (${pianoLockedData.chordName})`);
                
                // Use preloaded preset if available for instant switching
                let settingsToApply = pianoLockedData;
                if (this.preloadedPresets.has(presetId)) {
                    settingsToApply = this.preloadedPresets.get(presetId);
                    console.log(`ðŸŽ¹ Using preloaded preset for instant switching: ${presetId}`);
                } else {
                    console.log(`ðŸŽ¹ Preset not preloaded, using stored data: ${presetId}`);
                }
                
                console.log(`ðŸŽ¹ OSC1: ${settingsToApply.osc1.type} wave, A:${Math.round(settingsToApply.envelope.attack*1000)} D:${Math.round(settingsToApply.envelope.decay*1000)} S:${Math.round(settingsToApply.envelope.sustain*100)}% R:${Math.round(settingsToApply.envelope.release*1000)}`);
                console.log(`ðŸŽ¹ OSC2: ${settingsToApply.osc2.type} wave, A:${Math.round(settingsToApply.osc2Envelope.attack*1000)} D:${Math.round(settingsToApply.osc2Envelope.decay*1000)} S:${Math.round(settingsToApply.osc2Envelope.sustain*100)}% R:${Math.round(settingsToApply.osc2Envelope.release*1000)}`);
                
                // IMPORTANT: We directly modify the synthesizer objects only temporarily
                // These will be immediately restored after playFrequency starts
                
                // Apply oscillator settings (complete objects)
                if (settingsToApply.osc1) {
                    Object.assign(this.oscillators.osc1, settingsToApply.osc1);
                }
                if (settingsToApply.osc2) {
                    Object.assign(this.oscillators.osc2, settingsToApply.osc2);
                }
                
                // Apply envelope settings (complete objects)
                if (settingsToApply.envelope) {
                    Object.assign(this.envelope, settingsToApply.envelope);
                    // Sync ADSR 1 UI
                    const a = document.getElementById('attackSlider');
                    const d = document.getElementById('decaySlider');
                    const s = document.getElementById('sustainSlider');
                    const r = document.getElementById('releaseSlider');
                    const av = document.getElementById('attackValue');
                    const dv = document.getElementById('decayValue');
                    const sv = document.getElementById('sustainValue');
                    const rv = document.getElementById('releaseValue');
                    if (a) { const ms = Math.round((this.envelope.attack||0)*1000); a.value = String(ms); if (av) av.textContent = `${ms}ms`; }
                    if (d) { const ms = Math.round((this.envelope.decay||0)*1000); d.value = String(ms); if (dv) dv.textContent = `${ms}ms`; }
                    if (s) { const pct = Math.round((this.envelope.sustain||0)*100); s.value = String(pct); if (sv) sv.textContent = `${pct}%`; }
                    if (r) { const ms = Math.round((this.envelope.release||0)*1000); r.value = String(ms); if (rv) rv.textContent = `${ms}ms`; }
                }
                if (settingsToApply.osc2Envelope) {
                    Object.assign(this.osc2Envelope, settingsToApply.osc2Envelope);
                    // Sync ADSR 2 UI
                    const a2 = document.getElementById('osc2AttackSlider');
                    const d2 = document.getElementById('osc2DecaySlider');
                    const s2 = document.getElementById('osc2SustainSlider');
                    const r2 = document.getElementById('osc2ReleaseSlider');
                    const a2v = document.getElementById('osc2AttackValue');
                    const d2v = document.getElementById('osc2DecayValue');
                    const s2v = document.getElementById('osc2SustainValue');
                    const r2v = document.getElementById('osc2ReleaseValue');
                    if (a2) { const ms = Math.round((this.osc2Envelope.attack||0)*1000); a2.value = String(ms); if (a2v) a2v.textContent = `${ms}ms`; }
                    if (d2) { const ms = Math.round((this.osc2Envelope.decay||0)*1000); d2.value = String(ms); if (d2v) d2v.textContent = `${ms}ms`; }
                    if (s2) { const pct = Math.round((this.osc2Envelope.sustain||0)*100); s2.value = String(pct); if (s2v) s2v.textContent = `${pct}%`; }
                    if (r2) { const ms = Math.round((this.osc2Envelope.release||0)*1000); r2.value = String(ms); if (r2v) r2v.textContent = `${ms}ms`; }
                }
                
                // NOTE: Do NOT apply reverb or panning from piano-lock. Those are global per-user mix choices.
                
                // Apply volume settings
                if (settingsToApply.volume) {
                    this.volume = settingsToApply.volume.main;
                    this.masterVolume = settingsToApply.volume.master;
                    if (this.gainNode) {
                        this.gainNode.gain.value = this.volume * this.masterVolume;
                    }
                }

                // If OSC panel is open, reflect the currently applied settings for clarity
                const oscPanel = document.querySelector('.panel-content[data-panel="osc"]');
                if (oscPanel && window.getComputedStyle(oscPanel).display !== 'none') {
                    const syncOscUi = (num, data) => {
                        try {
                            // Activate waveform button
                            document.querySelectorAll(`.osc-btn[data-osc="${num}"]`).forEach(b => b.classList.remove('active'));
                            const active = document.querySelector(`.osc-btn[data-osc="${num}"][data-wave="${data.type}"]`);
                            if (active) active.classList.add('active');
                            // Pulse width visibility/value
                            const pwContainer = document.querySelector(`.pulse-width-container[data-osc="${num}"]`);
                            if (pwContainer) pwContainer.style.display = (data.type === 'pulse') ? 'block' : 'none';
                            const pwSlider = document.getElementById(`osc${num}PulseWidth`);
                            const pwValue = document.getElementById(`osc${num}PulseWidthValue`);
                            if (pwSlider && typeof data.pulseWidth === 'number') {
                                const pct = Math.round((data.pulseWidth || 0.5) * 100);
                                pwSlider.value = String(pct);
                                if (pwValue) pwValue.textContent = `${pct}%`;
                            }
                            // Level
                            const lvl = document.getElementById(`osc${num}Level`);
                            const lvlV = document.getElementById(`osc${num}LevelValue`);
                            if (lvl) {
                                const slider = Math.round(((data.level || 0) / 0.125) * 10);
                                lvl.value = String(slider);
                                if (lvlV) lvlV.textContent = String(slider);
                            }
                            const det = document.getElementById(`osc${num}Detune`);
                            const detV = document.getElementById(`osc${num}DetuneValue`);
                            if (det) {
                                det.value = String(Math.round(data.detune || 0));
                                if (detV) detV.textContent = `${Math.round(data.detune || 0)}Â¢`;
                            }
                            // Octave/coarse
                            const oct = document.getElementById(`osc${num}Octave`);
                            const octV = document.getElementById(`osc${num}OctaveValue`);
                            if (oct) { oct.value = String(data.octave || 0); if (octV) octV.textContent = String(data.octave || 0); }
                            const crs = document.getElementById(`osc${num}Coarse`);
                            const crsV = document.getElementById(`osc${num}CoarseValue`);
                            if (crs) { crs.value = String(data.coarse || 0); if (crsV) crsV.textContent = `${data.coarse || 0} steps`; }
                        } catch(_) {}
                    };
                    syncOscUi(1, this.oscillators.osc1);
                    syncOscUi(2, this.oscillators.osc2);
                }
                
                console.log(`ðŸŽ¹ Applied piano-locked preset: ${presetId} for ${pianoLockedData.chordName}`);
            }
            
            // Helper to capture exact frequencies from a column's strings when locking
            captureStringFrequencies(columnElement) {
                console.log('?? Capturing exact string frequencies for locked chord');
                const stringElements = columnElement.querySelectorAll('.string');
                const frequencies = [];
                
                stringElements.forEach(stringElement => {
                    // Get exact frequency from the element dataset
                    // This will be the actual frequency value used in playback
                    const freq = parseFloat(stringElement.dataset.frequency);
                    if (!isNaN(freq)) {
                        frequencies.push(freq);
                        console.log(`?? Captured frequency: ${freq.toFixed(2)} Hz`);
                    }
                });
                
                console.log(`?? Total frequencies captured: ${frequencies.length}`);
                return frequencies.length > 0 ? frequencies : null;
            }
            
            // Create strings using exact captured frequencies - guaranteed perfect reproduction
            generateStringsWithExactFrequencies(column, lockedData) {
                console.log('?? Generating strings with EXACT frequencies for perfect reproduction');
                
                // Clear any existing strings
                const stringsContainer = document.createElement('div');
                stringsContainer.className = 'strings-column';
                // Apply subtle root tint gradient matching locked root
                try {
                    const semi = this.stepToSemitone(lockedData.lockedRoot || 0, lockedData.lockedTuning || (this.currentTuning||12));
                    const accent = this.getChromaticColorForSemitone(semi) || '#000000';
                    const tint = (hex => {
                        const m = /^#?([0-9a-f]{6})$/i.exec(hex || '');
                        if (!m) return 'rgba(0,0,0,0)';
                        const n = parseInt(m[1], 16);
                        let r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                        r = Math.max(6, Math.floor(r * 0.08));
                        g = Math.max(6, Math.floor(g * 0.08));
                        b = Math.max(6, Math.floor(b * 0.08));
                        return `linear-gradient(to bottom, rgba(${r},${g},${b},0.12), rgba(${r},${g},${b},0.08))`;
                    })(accent);
                    stringsContainer.style.setProperty('--root-tint-gradient', tint);
                    const headerEl = column.querySelector('.extension-header');
                    if (headerEl) headerEl.style.setProperty('--root-tint-gradient', tint);
                } catch (_) {}
                
                // Style the container like main columns
                // Use real header height to size strings correctly in two-row mode
                const headerEl = column.querySelector('.extension-header');
                const headerPx = Math.max(56, headerEl ? headerEl.offsetHeight : 56);
                stringsContainer.style.cssText = `
                    flex: 1;
                    overflow: hidden;
                    padding: 1px;
                    height: calc(100% - ${headerPx}px);
                    display: flex;
                    flex-direction: column;
                    justify-content: space-evenly;
                `;
                
                // Remove old strings container if exists
                const oldContainer = column.querySelector('.strings-column');
                if (oldContainer) {
                    column.removeChild(oldContainer);
                }
                
                // Create strings using exact frequencies
                lockedData.exactFrequencies.forEach((freq, index) => {
                    const stringElement = document.createElement('div');
                    stringElement.className = 'string';

                    // Store exact frequency for playback - CRITICAL
                    stringElement.dataset.frequency = freq;

                    // Estimate note and octave for display and color calculation
                    const noteInfo = this.estimateNoteFromFrequency(freq);
                    stringElement.dataset.note = noteInfo.note;
                    stringElement.dataset.octave = noteInfo.octave;
                    // Highlight mid octaves (3â€“4)
                    try {
                        const oct = parseInt(stringElement.dataset.octave, 10);
                        if (oct === 3 || oct === 4) stringElement.classList.add('mid-octave');
                    } catch(_) {}

                    // Universal pitch color by absolute step
                    const uni = this.getUniversalPitchColorForStep(noteInfo.note, lockedData.lockedTuning);
                    const baseColor = uni.color;
                    const glowColor = (baseColor && baseColor.toLowerCase() === '#000000') ? '#555555' : baseColor;
                    stringElement.dataset.glowColor = glowColor;

                    // Visible core
                    const core = document.createElement('div');
                    core.className = 'string-core';
                    core.style.background = baseColor;
                    core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;

                    // Tooltip with exact frequency
                    const noteDisplay = this.getNoteNames()[noteInfo.note] || noteInfo.note;
                    stringElement.title = `${noteDisplay}${noteInfo.octave} - LOCKED: ${freq.toFixed(2)}Hz`;

                    // Precompute vibration period
                    const period = this.computeVibrationPeriod(freq, noteInfo.note);
                    core.style.setProperty('--vib-period', period + 'ms');

                    // Click handlers for playback
                    this.addStringPlaybackHandlers(stringElement, freq);

                    // Attach
                    stringElement.appendChild(core);
                    stringsContainer.appendChild(stringElement);
                });
                
                column.appendChild(stringsContainer);
                
                // Add locked icon and visual indication this is using exact frequencies
                const header = column.querySelector('.extension-header');
                if (header) {
                    const chordName = header.querySelector('.chord-name');
                    if (chordName) {
                        chordName.style.color = '#ff9500'; // Bright orange to indicate exact frequency preservation
                        chordName.title = `LOCKED: Using exact frequencies (${lockedData.exactFrequencies.length}) for perfect reproduction`;
                    }
                }
                
                console.log(`?? Generated ${lockedData.exactFrequencies.length} strings with exact frequencies`);
            }
            
            // Helper to add click handlers to strings
            addStringPlaybackHandlers(stringElement, frequency) {
                // Add click handlers for immediate playback
                stringElement.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.playStringNote(frequency, 0); // Use exact frequency

                    // Visual feedback on core
                    const glow = stringElement.dataset.glowColor || '#FFFFFF';
                    const core = stringElement.querySelector('.string-core');
                    if (core) {
                        core.style.transform = 'scaleY(1.3)';
                        core.style.boxShadow = `0 0 6px ${glow}, 0 0 16px ${glow}B3, 0 0 24px ${glow}80`;
                        core.style.filter = 'brightness(1.15)';
                        const stepIndex = parseInt(stringElement.dataset.noteIndex||'0',10);
                        const period = this.computeVibrationPeriod(frequency, stepIndex);
                        core.style.setProperty('--vib-period', period + 'ms');
                        core.classList.add('vibrating');
                        setTimeout(() => core.classList.remove('vibrating'), 220);
                        setTimeout(() => {
                            core.style.transform = 'scaleY(1)';
                            core.style.boxShadow = `0 0 4px ${glow}, 0 0 10px ${glow}AA, 0 0 18px ${glow}66`;
                            core.style.filter = 'brightness(1)';
                        }, 200);
                    }
                });
                
                // Touch support
                stringElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.playStringNote(frequency, 0); // Use exact frequency
                });
            }
            
            // ============= PROPER CHORD NAMING SYSTEM =============
            
            // Template library for exact chord recognition, including micro (^/v) variants.
            // Each template defines a name suffix (to append after the root) and an interval list
            // expressed in 12-TET semitones with optional '^'/'v' to indicate +1/-1 EDO step.
            // Example: { name: '7^', intervals: ['0','4^','7','10'] }
            getChordTemplates() {
                // Helper to DRY strings
                const T = [];
                const add = (name, iv) => T.push({ name, intervals: iv });
                // Power/dyads/triads
                add('5', ['0','7']);
                add('b5', ['0','6']);
                add('+', ['0','4','8']);
                add('aug', ['0','4','8']);
                add('dim', ['0','3','6']);
                add('', ['0','4','7']); // major triad
                add('m', ['0','3','7']);
                add('sus2', ['0','2','7']);
                add('sus4', ['0','5','7']);
                // 6ths/7ths/maj7/etc
                add('6', ['0','4','7','9']);
                add('m6', ['0','3','7','9']);
                add('7', ['0','4','7','10']);
                add('m7', ['0','3','7','10']);
                add('maj7', ['0','4','7','11']);
                add('mMaj7', ['0','3','7','11']);
                add('dim7', ['0','3','6','9']);
                add('m7b5', ['0','3','6','10']);
                add('aug7', ['0','4','8','10']);
                // 9ths
                add('9', ['0','4','7','10','14']);
                add('m9', ['0','3','7','10','14']);
                add('maj9', ['0','4','7','11','14']);
                add('mMaj9', ['0','3','7','11','14']);
                add('6/9', ['0','4','7','9','14']);
                add('m6/9', ['0','3','7','9','14']);
                // sus with 7/9
                add('7sus4', ['0','5','7','10']);
                add('9sus4', ['0','5','7','10','14']);
                // altered dominants
                add('7b9', ['0','4','7','10','13']);
                add('7#9', ['0','4','7','10','15']);
                add('7b5', ['0','4','6','10']);
                add('7#5', ['0','4','8','10']);
                add('7alt', ['0','4','8','10','13','15']); // (#5, b9, #9)
                // 11ths / 13ths
                add('11', ['0','4','7','10','14','17']);
                add('m11', ['0','3','7','10','14','17']);
                add('maj11', ['0','4','7','11','14','17']);
                add('mMaj11', ['0','3','7','11','14','17']);
                add('11sus', ['0','5','7','10','14','17']);
                add('13', ['0','4','7','10','14','17','21']);
                add('m13', ['0','3','7','10','14','17','21']);
                add('maj13', ['0','4','7','11','14','17','21']);
                add('mMaj13', ['0','3','7','11','14','17','21']);
                // Micro-root triads (name becomes just root with micro, so empty suffix still OK)
                // We keep them implicit via root note name, no extra template needed.
                // Micro variants (caret up / v down) for common degrees
                add('7^', ['0','4^','7','10']);
                add('7v', ['0','3v','7','10']);
                add('9^', ['0','4','7','10','14^']);
                add('9v', ['0','4','7','10','14v']);
                add('maj9^', ['0','4^','7','11','14']);
                add('mMaj9v', ['0','3','7','11v','14']);
                add('6^', ['0','4^','7','9']);
                add('m6v', ['0','3','7','9v']);
                add('^sus2', ['0','2','7']); // root micro handled by root name; keep suffix distinct
                add('vsus4', ['0','5','7']);
                add('7#11^', ['0','4','7','10','18^']);
                add('7b13v', ['0','4','7','10','20v']);
                add('maj7#11^', ['0','4','7','11','18^']);
                add('m7b5v', ['0','3','6','10']); // symbol carries 'v' to indicate template request
                add('aug7^', ['0','4','8','10']);
                add('dim7v', ['0','3','6','9v']);
                // Add-chords
                add('add9', ['0','4','7','14']);
                add('madd9', ['0','3','7','14']);
                add('add4', ['0','4','7','5']);
                add('madd4', ['0','3','7','5']);
                return T;
            }

            // Convert a 12-TET semitone count (as string; may include '^'/'v') to an EDO step for matching
            _templateSemitoneToStep(semiStr, edo){
                const m = String(semiStr);
                const up = m.endsWith('^');
                const down = m.endsWith('v');
                const core = up || down ? m.slice(0, -1) : m;
                const semi = parseFloat(core) || 0;
                let step = Math.round((semi * edo) / 12);
                if (up) step += 1; else if (down) step -= 1;
                return ((step % edo) + edo) % edo;
            }

            // Attempt to recognize chord by template; returns best match with steps and type
            // { name, steps, matchType: 'exact' | 'subset' } or null
            tryMatchChordTemplate(relativeSteps, edo){
                const uniq = [...new Set(relativeSteps)].map(v=> ((v%edo)+edo)%edo).sort((a,b)=>a-b);
                const containsAll = (a,b)=> b.every(x=> a.includes(x));
                const eqSet = (a,b)=> a.length===b.length && a.every((v,i)=> v===b[i]);
                const templates = this.getChordTemplates();
                let bestSubset = null;
                for (const t of templates) {
                    const steps = t.intervals
                        .map(s=> this._templateSemitoneToStep(s, edo))
                        .map(v=> ((v%edo)+edo)%edo);
                    const uniqT = [...new Set(steps)].sort((a,b)=>a-b);
                    if (eqSet(uniq, uniqT)) return { name: t.name, steps: uniqT, matchType: 'exact' };
                    if (containsAll(uniq, uniqT)) {
                        if (!bestSubset || uniqT.length > bestSubset.steps.length) {
                            bestSubset = { name: t.name, steps: uniqT, matchType: 'subset' };
                        }
                    }
                }
                return bestSubset;
            }
            
            getProperChordSymbol(intervals) {
                if (!intervals || intervals.length === 0) return '';
                
                // Sort intervals and remove duplicates (EDO steps, relative to chosen root)
                const uniqueIntervals = [...new Set(intervals)].sort((a, b) => a - b);
                const numNotes = uniqueIntervals.length;
                const edo = this.currentTuning || 12;
                
                // Helper: map semitone target to EDO step and compute accidentals for deltas
                const stepForSemi = (semi)=> ((Math.round((semi*edo)/12))%edo+edo)%edo;
                const accidentalForDiff = (d)=> d===0?'':(d===1?'^':(d===-1?'v':(d===2?'#':(d===-2?'b':''))));
                const near = (x,y,tol=0.35)=> Math.abs(x-y) <= tol;
                const sFloat = (st)=> (st*12)/edo;
                // Allow calling hasNear(target[, tol]) by defaulting to uniqueIntervals when set not passed
                const hasNear = (maybeSet, target, tol=0.35)=> {
                    const arr = Array.isArray(maybeSet) ? maybeSet : uniqueIntervals;
                    const tgt = Array.isArray(maybeSet) ? target : maybeSet;
                    const tolVal = Array.isArray(maybeSet) ? tol : (typeof target === 'number' ? target : 0.35);
                    // If called as hasNear(target[, tol]) then tol comes in as second/third arg; normalize
                    const finalTol = Array.isArray(maybeSet)
                        ? tolVal
                        : (arguments.length >= 2 ? target : 0.35);
                    const finalTarget = Array.isArray(maybeSet) ? target : maybeSet;
                    return arr.some(i => near(sFloat(i), finalTarget, finalTol));
                };
                const removeSteps = (src,rm)=> src.filter(x=> !rm.includes(x));
                const uniqSteps = (arr)=> [...new Set(arr)].sort((a,b)=>a-b);

                // First: try template (exact or best subset)
                let baseName = '';
                let baseSteps = [];
                try {
                    const m = this.tryMatchChordTemplate(uniqueIntervals, edo);
                    if (m && m.matchType === 'exact') return m.name; // perfect match
                    if (m) { baseName = m.name; baseSteps = m.steps.slice(); }
                } catch(_) {}
                
                // Map to 12-TET pitch classes relative to the chosen root
                const pcs12 = [...new Set(uniqueIntervals.map(i => this.stepToSemitone(i, edo)))].sort((a,b)=>a-b);
                const has = (x)=> pcs12.includes(x);
                // Compare ignoring order by sorting the candidate array
                const setEq = (arr)=>{
                    const a = [...arr].sort((x,y)=> x-y);
                    return a.length===pcs12.length && a.every((v,i)=> v===pcs12[i]);
                };

                // Float semitone approximations for neutral detection
                const relSemi = uniqueIntervals.map(i => (i * 12) / edo);

                // ðŸŽµ UNISON (single note) - only root note
                if (numNotes === 1 && uniqueIntervals[0] === 0) {
                    return 'Unison';
                }
                
                // ðŸŽµ DYADS (2-note intervals) - adjusted for current tuning
                if (numNotes === 2 && uniqueIntervals[0] === 0) {
                    const interval12TET = pcs12[1] ?? 0;
                    
                    const intervalNames = {
                        1: 'Minor 2nd',
                        2: 'Major 2nd', 
                        3: 'Minor 3rd',
                        4: 'Major 3rd',
                        5: 'Perfect 4th',
                        6: 'Tritone',
                        7: 'Perfect 5th',
                        8: 'Minor 6th',
                        9: 'Major 6th',
                        10: 'Minor 7th',
                        11: 'Major 7th'
                    };
                    
                    return intervalNames[interval12TET] || `${interval12TET} semitones`;
                }
                
                // ðŸŽµ TRIADS (3-note chords) - inversion-invariant
                if (pcs12.length === 3) {
                    // Neutral triad: ~3.5 and ~7 present
                    if (hasNear(0.0) && hasNear(3.5) && hasNear(7.0)) return 'n';
                    if (setEq([0,4,7])) return '';
                    if (setEq([0,3,7])) return 'm';
                    if (setEq([0,3,6])) return 'Â°';
                    if (setEq([0,4,8])) return '+';
                    if (setEq([0,2,7])) return 'sus2';
                    if (setEq([0,5,7])) return 'sus4';
                }

                // ðŸŽµ TETRADS (4-note chords) - favor simplest (triad + one extension)
                if (pcs12.length === 4) {
                    // Neutral 7 detection (~10.5) and neutral-third + b7
                    if (hasNear(uniqueIntervals,0.0) && hasNear(uniqueIntervals,7.0)) {
                        if (hasNear(3.5) && hasNear(uniqueIntervals,10.0)) return 'n7';
                        if (hasNear(3.5) && hasNear(uniqueIntervals,10.5)) return 'n7';
                        if (hasNear(3.0) && hasNear(uniqueIntervals,10.5)) return 'm7v';
                        if (hasNear(4.0) && hasNear(uniqueIntervals,10.5)) return '7v';
                    }
                    // Neutral maj7 detection (~11.0 with neutral third)
                    if (hasNear(uniqueIntervals,0.0) && hasNear(uniqueIntervals,7.0) && hasNear(uniqueIntervals,11.0)) {
                        if (hasNear(3.5)) return 'nmaj7';
                    }
                    // Strict sets relative to chosen root (no inversion search)
                    if (setEq([0,4,7,9]))  return (hasNear(uniqueIntervals,10.0,0.5)? '7':'6');
                    if (setEq([0,3,7,9]))  return (hasNear(uniqueIntervals,10.0,0.5)? 'm7':'m6');
                    if (setEq([0,4,7,10])) return '7';
                    if (setEq([0,3,7,10])) return 'm7';
                    if (setEq([0,4,7,11])) return 'maj7';
                    if (setEq([0,3,7,11])) return 'mMaj7';
                    if (setEq([0,5,7,10])) return '7sus4';
                    if (setEq([0,3,6,10])) return 'Ã¸7';
                    if (setEq([0,3,6,9]))  return 'Â°7';
                    // Add chords (no 7 or 6)
                    if (setEq([0,2,4,7]))  return 'add9';
                    if (setEq([0,3,7,2]))  return 'madd9';
                    if (setEq([0,4,5,7]))  return 'add4';
                    if (setEq([0,3,5,7]))  return 'madd4';
                }
                
                // ðŸŽµ 5-NOTE CHORDS - keep minimal; prefer single extension naming
                if (numNotes === 5) {
                    const eq = (...arr)=> setEq(arr);
                    if (eq(0,3,7,10,2)) return 'm9';
                    if (eq(0,4,7,10,2)) return '9';
                    if (eq(0,3,7,5,2))  return 'm11';
                    if (eq(0,4,7,5,2))  return '11';
                    if (eq(0,3,7,2))    return 'madd9';
                    if (eq(0,4,7,2))    return 'add9';
                }
                
                // ðŸŽµ 6-NOTE CHORDS - cap at 11/13 families, still minimal
                if (numNotes === 6) {
                    const eq = (...a)=> setEq(a);
                    if (eq(0,3,7,10,2,5)) return 'm11';
                    if (eq(0,4,7,10,2,5)) return '11';
                    if (eq(0,3,7,10,2,9)) return 'm13';
                    if (eq(0,4,7,10,2,9)) return '13';
                }
                
                // Build a base symbol via minimal core if no template subset chosen
                if (!baseName) {
                    const core = this.findCoreChord(uniqueIntervals);
                    baseName = core.symbol;
                    baseSteps = core.intervals.map(semi=> stepForSemi(semi));
                }

                // Append add-extensions for any remaining tones not covered by base
                const extraSteps = removeSteps(uniqueIntervals, uniqSteps(baseSteps));
                if (!extraSteps.length) return baseName;

                // Context flags
                const hasMaj3 = hasNear(uniqueIntervals,4.0);
                const hasMin3 = hasNear(uniqueIntervals,3.0);
                const hasB7 = hasNear(uniqueIntervals,10.0);
                const hasMaj7 = hasNear(uniqueIntervals,11.0);

                const addParts = [];
                for (const st of extraSteps) {
                    const sf = sFloat(st);
                    // Special case: major triad plus ~3.0 -> #9
                    if (hasMaj3 && near(sf,3.0,0.5)) {
                        const base = stepForSemi(15);
                        let d = st - base; if (d>edo/2) d-=edo; if (d<-edo/2) d+=edo; d = Math.max(-2, Math.min(2, d));
                        const acc = accidentalForDiff(d);
                        addParts.push(`add${acc}#9`); // keep #9 label, include micro if any
                        continue;
                    }
                    // Map to 9 family
                    const base9 = stepForSemi(14);
                    const d9 = (()=>{ let d=st-base9; if(d>edo/2)d-=edo; if(d<-edo/2)d+=edo; return d; })();
                    if (Math.abs(d9) <= 2 && near(sf,2.0,1.0)) {
                        const acc = accidentalForDiff(Math.max(-2, Math.min(2, d9)));
                        const qual = acc==='#'?'#':(acc==='b'?'b':acc); // '^'/'v' retained
                        addParts.push(`add${acc?acc:''}9`);
                        continue;
                    }
                    // Map to 4 family (use 4 naming, not 11)
                    const base4 = stepForSemi(5);
                    const d4 = (()=>{ let d=st-base4; if(d>edo/2)d-=edo; if(d<-edo/2)d+=edo; return d; })();
                    if (Math.abs(d4) <= 2 && near(sf,5.0,1.0)) {
                        const acc = accidentalForDiff(Math.max(-2, Math.min(2, d4)));
                        addParts.push(`add${acc?acc:''}4`);
                        continue;
                    }
                    // Map to 13/6 family
                    const base13 = stepForSemi(21);
                    const d13 = (()=>{ let d=st-base13; if(d>edo/2)d-=edo; if(d<-edo/2)d+=edo; return d; })();
                    if (Math.abs(d13) <= 2 && near(sf,9.0,1.0)) {
                        const acc = accidentalForDiff(Math.max(-2, Math.min(2, d13)));
                        const deg = (hasB7||hasMaj7)? '13':'6';
                        addParts.push(`add${acc?acc:''}${deg}`);
                        continue;
                    }
                    // b9
                    if (near(sf,1.0,0.6)) { addParts.push('addb9'); continue; }
                    // #11 as fallback for tritone-ish
                    if (near(sf,6.0,0.6)) { addParts.push('add#4'); continue; }

                    // Generic fallback: produce add with degree and micro (^/v) when applicable
                    const s12 = ((Math.round((sf)) % 12) + 12) % 12; // nearest semitone
                    const baseForS = stepForSemi(s12);
                    let diff = st - baseForS; if (diff>edo/2) diff-=edo; if (diff<-edo/2) diff+=edo;
                    const micro = diff>0 ? '^' : (diff<0 ? 'v' : '');
                    // Degree label map by semitone
                    const degMap = ['1','b2','2','b3','3','4','#4','5','#5','6','b7','7'];
                    const degree = degMap[s12] || String(s12);
                    addParts.push(`add${micro}${degree}`);
                }
                return baseName + (addParts.length? addParts.join('') : '');
            }
            
            findNearestChordFit(intervals) {
                // Minimal nearest: triad + the single simplest added degree (9 or 11). Avoid piling on.
                const core = this.findCoreChord(intervals);
                const coreSet = new Set(core.intervals);
                // candidates in minimal order
        const order = [2,5,9,10,11]; // 9, 11, 13(=6/13 approx), b7, M7
                for (const iv of order) {
                    if (intervals.includes(iv) && !coreSet.has(iv)) {
            if (core.symbol === 'm' && iv === 5) return 'madd11';
            if (core.symbol === '' && iv === 5) return 'add11';
                        if (iv === 2) return (core.symbol === 'm') ? 'madd9' : 'add9';
                        if (iv === 10) return (core.symbol === 'm') ? 'm7' : '7';
                        if (iv === 11) return (core.symbol === 'm') ? 'mÎ”7' : 'Î”7';
                    }
                }
                return core.symbol;
            }
            
            findCoreChord(intervals) {
                // Find the best matching triad or tetrad
                const intervalSet = new Set(intervals);
                
                // Check tetrads first (more specific)
                const tetrads = [
                    { intervals: [0, 3, 7, 5], symbol: 'madd11' },
                    { intervals: [0, 4, 7, 5], symbol: 'add11' },
                    { intervals: [0, 3, 7, 2], symbol: 'madd9' },
                    { intervals: [0, 4, 7, 2], symbol: 'add9' },
                    { intervals: [0, 3, 7, 10], symbol: 'm7' },
                    { intervals: [0, 4, 7, 10], symbol: '7' },
                    { intervals: [0, 4, 7, 9], symbol: '6' },
                    { intervals: [0, 3, 7, 9], symbol: 'm6' },
                    { intervals: [0, 3, 6, 10], symbol: 'Ã¸7' },
                    { intervals: [0, 3, 6, 9], symbol: 'Â°7' }
                ];
                
                for (const tetrad of tetrads) {
                    if (tetrad.intervals.every(interval => intervalSet.has(interval))) {
                        return tetrad;
                    }
                }
                
                // Check triads
                const triads = [
                    { intervals: [0, 4, 7], symbol: '' }, // Major = simplest, no suffix
                    { intervals: [0, 3, 7], symbol: 'm' },
                    { intervals: [0, 3, 6], symbol: 'Â°' },
                    { intervals: [0, 4, 8], symbol: '+' },
                    { intervals: [0, 2, 7], symbol: 'sus2' },
                    { intervals: [0, 5, 7], symbol: 'sus4' }
                ];
                
                for (const triad of triads) {
                    if (triad.intervals.every(interval => intervalSet.has(interval))) {
                        return triad;
                    }
                }
                
                // Default to neutral minimal
                return { intervals: [0], symbol: '' };
            }
            
            findExtensions(intervals, coreIntervals) {
                const extensions = [];
                const coreSet = new Set(coreIntervals);
                
                for (const interval of intervals) {
                    if (!coreSet.has(interval) && interval !== 0) {
                        // Convert interval to extension name
                        const extName = this.intervalToExtensionName(interval);
                        if (extName) extensions.push(extName);
                    }
                }
                
                return extensions;
            }
            
            intervalToExtensionName(interval) {
                const extensionMap = {
                    1: 'â™­9', 2: '9', 3: 'â™¯9', 4: '3', 5: '11', 6: 'â™¯11',
                    7: '5', 8: 'â™­13', 9: '6/13', 10: 'â™­7', 11: '7'
                };
                return extensionMap[interval] || interval.toString();
            }
            
            // Estimate note and octave from frequency (for display only)
            estimateNoteFromFrequency(freq) {
                // A4 = 440 Hz is our reference
                const a4 = 440.0;
                const a4NoteNumber = 69; // MIDI note number for A4
                
                // Calculate MIDI note number from frequency
                const noteNumber = 12 * Math.log2(freq / a4) + a4NoteNumber;
                const roundedNoteNumber = Math.round(noteNumber);
                
                // Convert MIDI note number to note and octave
                const octave = Math.floor((roundedNoteNumber - 12) / 12);
                const note = roundedNoteNumber % 12;
                
                return { note, octave };
            }
            
            editLockedChord(chordData, columnElement) {
                // Get the locked chord data to extract the intervals
                const lockedChord = this.lockedChords.get(columnElement);
                if (!lockedChord) {
                    alert('This chord must be locked before it can be edited');
                    return;
                }
                
                console.log('? Editing locked chord:', chordData.name, 'with intervals:', lockedChord.intervals);
                
                // Enter chord creation mode with the locked chord's intervals
                this.enterChordCreationMode();
                
                // Set the intervals from the locked chord
                this.selectedIntervals = [...(lockedChord.intervals || [])];
                
                // Update the note selector to show these intervals
                // Refresh interval selection UI and preview column in builder
                this.updateIntervalButtons();
                this.updatePreviewChordColumn();
                
                // Show the chord name input with current name
                const modal = document.getElementById('chordBuilderModal');
                if (modal) {
                    modal.style.display = 'block';
                    const nameInput = document.getElementById('chordNameInput');
                    if (nameInput) {
                        nameInput.value = chordData.name;
                    }
                }
                
                console.log('? Chord edit mode activated with existing intervals');
            }
            
            hideLockedChord(chordData, columnElement) {
                if (!this.hiddenColumns) this.hiddenColumns = [];
                
                const chordId = chordData.id || chordData.name.toLowerCase().replace(/\s+/g, '_');
                
                if (confirm(`Hide the locked chord "${chordData.name}"? You can show it again from the settings.`)) {
                    // Add to hidden columns
                    if (!this.hiddenColumns.includes(chordId)) {
                        this.hiddenColumns.push(chordId);
                    }
                    
                    // Regenerate columns to hide this one
                    this.generateExtensionColumns();
                    
                    console.log('?? Hidden locked chord:', chordData.name);
                }
            }
            
            duplicateLockedChord(chordData, columnElement) {
                // Get the locked chord data
                const lockedChord = this.lockedChords.get(columnElement);
                if (!lockedChord) {
                    alert('This chord must be locked before it can be duplicated');
                    return;
                }
                
                console.log('? Duplicating locked chord:', chordData.name, 'with intervals:', lockedChord.intervals);
                
                // Create a new chord extension with a copy name
                const duplicateChord = {
                    name: chordData.name + ' Copy',
                    intervals: [...(lockedChord.intervals || [])],
                    extensions: [...(chordData.extensions || [])],
                    quality: chordData.quality || 'major',
                    isCustom: true,
                    id: 'duplicate_' + Date.now()
                };
                
                // Add to chord extensions
                this.chordExtensions.push(duplicateChord);
                this.saveChordConfiguration();
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log('? Duplicated chord:', duplicateChord.name);
            }
            
            // Generic functions that work for ALL chords (not just locked ones)
            editChordFromButton() { /* removed: live edit via keyboard */ }
            
            hideChordFromButton(chordData, columnElement) {
                // Repurpose as Delete Chord
                console.log('ðŸ—‘ï¸ DELETE for:', chordData?.name);
                if (!chordData || !chordData.name) {
                    alert('Error: Invalid chord data for delete');
                    return;
                }
                if (!confirm(`Delete the chord "${chordData.name}"? This cannot be undone.`)) return;
                const idx = this.getIndexFromColumn(columnElement, chordData);
                if (idx !== -1) {
                    this.chordExtensions.splice(idx, 1);
                    this.normalizeChordPositions();
                    this.generateExtensionColumns();
                    // Force rebuild to eliminate gaps
                    this._rebuildChordGridAfterDeletion();
                } else {
                    this.generateExtensionColumns();
                }
            }
            
            duplicateChordFromButton(chordData, columnElement) {
                console.log('ðŸ“‹ DUPLICATE for:', chordData?.name);
                if (!chordData || !chordData.name) {
                    alert('Error: Invalid chord data for duplication');
                    return;
                }
                // Find base chord and position
                const idx = this.getIndexFromColumn(columnElement, chordData);
                const base = (idx !== -1 && this.chordExtensions[idx]) ? this.chordExtensions[idx] : chordData;
                const intervals = (base.intervals && base.intervals.length)
                    ? [...base.intervals]
                    : (this.getBaseTriadForQuality(this.stripRootFromName(base.name).toLowerCase()) || [0,4,7]);

                const newChord = {
                    name: `${base.name} Copy`,
                    intervals: intervals,
                    extensions: Array.isArray(base.extensions) ? [...base.extensions] : [],
                    quality: base.quality || 'major',
                    isCustom: true,
                    id: `duplicate_${Date.now()}_${Math.floor(Math.random()*1e6)}`
                };
                const insertAt = (idx !== -1) ? (idx + 1) : this.chordExtensions.length;
                this.chordExtensions.splice(insertAt, 0, newChord);
                this.normalizeChordPositions?.();
                this.generateExtensionColumns();
            }

            // --- Helpers to robustly find the clicked chord in this.chordExtensions ---
            findChordIndex(chordData) {
                // Prefer exact id match
                if (chordData && chordData.id) {
                    const byId = this.chordExtensions.findIndex(ext => ext && ext.id === chordData.id);
                    if (byId !== -1) return byId;
                }
                // Fallback: name + intervals match
                const intervals = (chordData && (chordData.intervals || chordData.notes)) || [];
                const key = JSON.stringify(intervals);
                const byStruct = this.chordExtensions.findIndex(ext => {
                    if (!ext) return false;
                    if (ext.name !== chordData.name) return false;
                    const extIntervals = ext.intervals || [];
                    return JSON.stringify(extIntervals) === key;
                });
                if (byStruct !== -1) return byStruct;
                // Last resort: position if present
                if (typeof chordData.position === 'number') return chordData.position;
                return -1;
            }

            getIndexFromColumn(columnElement, chordData) {
                // First trust the dataset from the DOM column created with this chord
                const ds = columnElement && columnElement.dataset ? columnElement.dataset : {};
                if (ds && typeof ds.originalPosition !== 'undefined') {
                    const idx = parseInt(ds.originalPosition, 10);
                    if (!Number.isNaN(idx) && idx >= 0 && idx < this.chordExtensions.length) return idx;
                }
                // Then try to calculate from chordData
                const fallbackIdx = this.findChordIndex(chordData);
                if (fallbackIdx !== -1) return fallbackIdx;
                // Give up gracefully
                return -1;
            }
            
            findChordPosition(chordData) {
                // Find the position of this chord in the chordExtensions array
                for (let i = 0; i < this.chordExtensions.length; i++) {
                    const chord = this.chordExtensions[i];
                    if (chord.name === chordData.name && 
                        chord.id === chordData.id ||
                        (chord.isCustom === chordData.isCustom && chord.name === chordData.name)) {
                        return i;
                    }
                }
                return this.chordExtensions.length; // Default to end if not found
            }

            // Remove pitch-class prefix from chord names (e.g., "Csus4" -> "sus4")
            stripRootFromName(name) {
                if (!name) return '';
                return String(name).replace(/^[A-G][#b]?\s*/, '').trim();
            }
            
            applyLockedChordSettings(lockedChord) {
                console.log('?? Applying locked chord settings:', lockedChord);
                
                // Apply locked musical settings (MOST IMPORTANT - the locked root!)
                this.currentRoot = lockedChord.lockedRoot;
                this.currentQuality = lockedChord.quality;
                this.currentTuning = lockedChord.lockedTuning;
                this.gamelanMode = lockedChord.lockedGamelanMode;
                
                // Apply locked oscillator settings
                this.oscillators.osc1 = { ...lockedChord.lockedOsc1 };
                this.oscillators.osc2 = { ...lockedChord.lockedOsc2 };
                
                // Apply locked envelope settings
                this.envelope = { ...lockedChord.lockedEnvelope };
                this.osc2Envelope = { ...lockedChord.lockedOsc2Envelope };
                
                // Apply locked effects settings
                this.reverbWet = lockedChord.lockedEffects.reverbWet;
                if (this.reverb) this.reverb.decay = lockedChord.lockedEffects.reverbDecay;
                if (this.reverbFilterNode) this.reverbFilterNode.frequency.value = lockedChord.lockedEffects.reverbFilterCutoff;
                this.panning.mode = lockedChord.lockedEffects.panningMode;
                this.panning.width = lockedChord.lockedEffects.panningWidth;
                
                // Apply locked volume settings
                this.masterVolume = lockedChord.lockedVolume.master;
                this.volume = lockedChord.lockedVolume.main;
                
                console.log('?? Applied locked settings - root:', this.currentRoot, 'tuning:', this.currentTuning, 'quality:', this.currentQuality);
            }
            
            loadLockedChords() {
                // No localStorage - always return empty (start fresh each session)
                return null;
            }
            
            restoreLockedChordStates() {
                if (!this.savedLockedChords || this.savedLockedChords.length === 0) {
                    console.log('?? No saved locked chords to restore');
                    return;
                }
                
                // Ensure lockedChords Map is initialized
                if (!this.lockedChords) this.lockedChords = new Map();
                
                console.log('?? Restoring locked chord states for', this.savedLockedChords.length, 'locked chords');
                
                // After columns are generated, restore locked states using position-based matching
                this.savedLockedChords.forEach((lockedChord, index) => {
                    console.log('?? Restoring locked chord:', lockedChord.chordName, 'at position:', lockedChord.originalPosition);
                    
                    // Find the matching column element by position and chord data
                    const columns = Array.from(document.querySelectorAll('.extension-column'));
                    
                    // Method 1: Try position-based matching first (most reliable)
                    let targetColumn = null;
                    if (lockedChord.originalPosition !== undefined && columns[lockedChord.originalPosition]) {
                        targetColumn = columns[lockedChord.originalPosition];
                        console.log('?? Using position-based match at index', lockedChord.originalPosition);
                    }
                    
                    // Method 2: If position doesn't work, try finding by chord data
                    if (!targetColumn) {
                        targetColumn = columns.find(column => {
                            const chordType = column.dataset.chordType;
                            const header = column.querySelector('.extension-header');
                            const chordName = header?.querySelector('.chord-name');
                            
                            if (chordName) {
                                const currentText = chordName.textContent.trim();
                                console.log('?? Checking column with text:', currentText, 'against locked chord:', lockedChord.chordName);
                                return this.isChordMatch(currentText, lockedChord);
                            }
                            return false;
                        });
                        
                        if (targetColumn) {
                            console.log('?? Using name-based match');
                        }
                    }
                    
                    // Method 3: If still no match, try by original chord extension index
                    if (!targetColumn && lockedChord.originalPosition !== undefined) {
                        // Find chord extension that matches the locked chord
                        const matchingExtension = this.chordExtensions.find(ext => 
                            ext.name === lockedChord.chordName || 
                            (ext.isCustom && ext.id && lockedChord.lockId && lockedChord.lockId.includes(ext.id))
                        );
                        
                        if (matchingExtension) {
                            const extensionIndex = this.chordExtensions.indexOf(matchingExtension);
                            if (columns[extensionIndex]) {
                                targetColumn = columns[extensionIndex];
                                console.log('?? Using extension-based match at index', extensionIndex);
                            }
                        }
                    }
                    
                    if (targetColumn) {
                        console.log('?? Found matching column for:', lockedChord.chordName);
                        
                        // Restore the locked state
                        this.lockedChords.set(targetColumn, lockedChord);
                        
                        // No lock/duplicate/edit/hide buttons to update anymore
                        
                        // Update visual styling and show locked root in name (respect per-column local transpose)
                        const chordNameElement = targetColumn.querySelector('.chord-name');
                        if (chordNameElement) {
                            chordNameElement.style.color = '#4CAF50';
                            chordNameElement.style.fontWeight = 'bold';
                            const edo = lockedChord.lockedTuning || this.currentTuning || 12;
                            const localDelta = ((+targetColumn.dataset.localTranspose || 0) % edo + edo) % edo;
                            const effRoot = ((lockedChord.lockedRoot ?? 0) + localDelta + edo) % edo;
                            const rootName = this.getRootNameForStep(effRoot, edo);
                            
                            // ALWAYS show the locked root in the chord name
                            if (lockedChord.chordName.match(/^[A-G][#b]?/)) {
                                chordNameElement.textContent = lockedChord.chordName;
                            } else {
                                chordNameElement.textContent = `${rootName}${lockedChord.chordName}`;
                            }
                            
                            chordNameElement.title = `?? LOCKED: ${rootName} root, ${lockedChord.lockedTuning}TET, ${lockedChord.lockedOsc1.type}/${lockedChord.lockedOsc2.type} waves`;
                            
                            // Mark the effective locked label so future ops parse the correct root
                            chordNameElement.dataset.isLocked = 'true';
                            chordNameElement.dataset.lockedName = chordNameElement.textContent;
                        }
                        
                        console.log('?? Successfully restored locked chord:', lockedChord.chordName, 'at position', lockedChord.originalPosition);
                    } else {
                        console.warn('?? Could not find matching column for locked chord:', lockedChord.chordName, 'position:', lockedChord.originalPosition);
                        console.warn('?? Available columns:', columns.length, 'chord extensions:', this.chordExtensions.length);
                    }
                });
                
                console.log('?? Finished restoring locked chord states. Active locked chords:', this.lockedChords.size);
            }
            
            isChordMatch(currentText, lockedChord) {
                const chordBaseName = lockedChord.chordName;
                
                // Exact match (for custom chords like "CMaj6")
                if (currentText === chordBaseName) {
                    return true;
                }
                // Partial match (for complex chord names)
                if (currentText.includes(chordBaseName) || chordBaseName.includes(currentText)) {
                    return true;
                }
                // Quality-based match (for standard chords)
                if (lockedChord.quality && (
                    currentText.toLowerCase().includes(lockedChord.quality.toLowerCase()) ||
                    currentText.includes('Maj') && lockedChord.quality.includes('major') ||
                    currentText.includes('Min') && lockedChord.quality.includes('minor') ||
                    currentText.includes('Neu') && lockedChord.quality.includes('neutral')
                )) {
                    return true;
                }
                return false;
            }
            
            clearLockedChords() {
                if (confirm('Clear all locked chords?')) {
                    // Clear the locked chords map
                    this.lockedChords = new Map();
                    
                    // Clear localStorage
                    
                    // Reset all lock buttons to unlocked state
                    document.querySelectorAll('.lock-button').forEach(button => {
                        button.innerHTML = 'ðŸ”“';
                        button.classList.remove('locked');
                        button.title = 'Lock chord with current root & settings';
                    });
                    
                    // Reset chord header colors to indicate unlocked
                    document.querySelectorAll('.extension-header .chord-name').forEach(chordName => {
                        chordName.style.color = '#fff'; // Reset to default color
                        chordName.title = ''; // Clear locked indicator
                    });
                    
                    console.log('?? All locked chords cleared from main grid');
                }
            }

            playPaletteChord(chord) {
                // Use locked settings from when the chord was dragged
                const originalRoot = this.currentRoot;
                const originalQuality = this.currentQuality;
                const originalTuning = this.currentTuning;
                const originalGamelanMode = this.gamelanMode;
                
                // Temporarily switch to the chord's locked settings
                this.currentRoot = chord.lockedRoot || chord.root;
                this.currentQuality = chord.quality;
                if (chord.lockedTuning !== undefined) {
                    this.currentTuning = chord.lockedTuning;
                }
                if (chord.lockedGamelanMode !== undefined) {
                    this.gamelanMode = chord.lockedGamelanMode;
                }
                
                // Generate intervals for this chord using locked settings
                let intervals;
                if (chord.intervals) {
                    // Custom chord with specific intervals (already in native tuning)
                    intervals = chord.intervals.map(interval => 
                        (this.currentRoot + interval) % this.currentTuning
                    );
                } else {
                    // Standard chord with extensions
                    const chordIntervals = this.getChordIntervals(chord.extensions);
                    intervals = chordIntervals.map(interval => 
                        (this.currentRoot + interval) % this.currentTuning
                    );
                }
                
                // Play the chord for 1 second with proper ADSR routing
                const baseOctave = 4;
                intervals.forEach(step => {
                    const freq = this.getFrequency(step, baseOctave, this.currentTuning);
                    // Create a dummy element for proper ADSR handling
                    const dummyElement = { classList: { add: () => {}, remove: () => {} } };
                    this.playFrequency(freq, dummyElement, 'chord');
                });
                
                // Stop all notes after 1 second
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
                
                // Restore original settings
                this.currentRoot = originalRoot;
                this.currentQuality = originalQuality;
                this.currentTuning = originalTuning;
                this.gamelanMode = originalGamelanMode;
                
                console.log(`Played chord: ${chord.fullName} (${chord.tuningName || 'current tuning'})`);
            }

            renameColumn() {
                const newName = prompt('Enter new column name:', this.currentEditingColumn.name);
                if (newName && newName.trim()) {
                    this.currentEditingColumn.name = newName.trim();
                    this.updateColumnInStorage();
                    this.generateExtensionColumns();
                }
            }

            copyColumn() {
                // Create a copy of the current column as a new chord extension (not custom chord)
                const baseName = this.currentEditingColumn.originalName || this.currentEditingColumn.name.replace(/^(Maj|Neu|Min)/, '');
                const columnCopy = {
                    name: `${baseName} Copy`,
                    extensions: [...(this.currentEditingColumn.extensions || [])],
                    intervals: this.currentEditingColumn.intervals || null
                };
                
                // Add to chord extensions so it gets all 3 flavors
                this.chordExtensions.push(columnCopy);
                this.saveChordConfiguration();
                this.generateExtensionColumns();
                
                console.log(`Copied column: ${columnCopy.name}`);
            }

            editColumnPattern() {
                const modal = document.getElementById('editPatternModal');
                const title = document.getElementById('editPatternTitle');
                const nameInput = document.getElementById('editPatternName');
                
                title.textContent = `Edit Pattern: ${this.currentEditingColumn.name}`;
                nameInput.value = this.currentEditingColumn.name;
                
                this.setupIntervalEditor();
                modal.style.display = 'block';
            }

            setupIntervalEditor() {
                const editor = document.getElementById('intervalEditor');
                editor.innerHTML = '';
                
                // Create interval input fields for common intervals
                const intervals = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
                
                intervals.forEach(interval => {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `interval_${interval}`;
                    checkbox.value = interval;
                    
                    const label = document.createElement('label');
                    label.htmlFor = `interval_${interval}`;
                    label.textContent = interval;
                    label.style.cssText = 'display: flex; align-items: center; gap: 5px; padding: 5px; background: #16213e; border-radius: 3px; cursor: pointer;';
                    
                    label.prepend(checkbox);
                    editor.appendChild(label);
                });
            }

            setQuickPattern(intervals) {
                // Convert 12TET intervals to current tuning system
                const currentTuning = this.getTuningStepsPerOctave();
                const convertedIntervals = intervals.map(interval => {
                    // Convert from 12TET to current tuning
                    return Math.round((interval / 12) * currentTuning);
                });
                
                console.log(`?? Converting intervals from 12TET ${intervals} to ${currentTuning}EDO: ${convertedIntervals}`);
                
                // Clear all checkboxes
                document.querySelectorAll('#intervalEditor input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                
                // Check the converted intervals
                convertedIntervals.forEach(interval => {
                    const checkbox = document.getElementById(`interval_${interval}`);
                    if (checkbox) {
                        checkbox.checked = true;
                        console.log(`? Checked interval ${interval} in ${currentTuning}EDO`);
                    }
                });
                
                // Also update the chord creation mode if active
                if (this.chordCreationMode) {
                    this.selectedIntervals = [...convertedIntervals];
                    this.updateIntervalButtons();
                    this.updatePreviewChordColumn();
                }
            }

            saveEditedPattern() {
                const nameInput = document.getElementById('editPatternName');
                const selectedIntervals = Array.from(document.querySelectorAll('#intervalEditor input[type="checkbox"]:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);

                if (selectedIntervals.length === 0) {
                    alert('Please select at least one interval.');
                    return;
                }

                // Update the column
                this.currentEditingColumn.name = nameInput.value;
                this.currentEditingColumn.intervals = selectedIntervals;
                
                this.updateColumnInStorage();
                document.getElementById('editPatternModal').style.display = 'none';
                this.generateExtensionColumns();
            }

            moveColumn(direction) {
                const currentId = this.currentEditingColumn.id || this.currentEditingColumn.name.toLowerCase();
                const currentIndex = this.chordExtensions.findIndex(ext => 
                    ext.name.toLowerCase() === currentId || ext.name === this.currentEditingColumn.name
                );
                
                if (currentIndex === -1) return;
                
                const newIndex = currentIndex + direction;
                if (newIndex < 0 || newIndex >= this.chordExtensions.length) return;
                
                // Swap the chord extensions
                [this.chordExtensions[currentIndex], this.chordExtensions[newIndex]] = 
                [this.chordExtensions[newIndex], this.chordExtensions[currentIndex]];
                
                // Save configuration
                this.saveChordConfiguration();
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log(`Moved column ${this.currentEditingColumn.name} ${direction > 0 ? 'right' : 'left'}`);
            }

            loadChordConfiguration() {
                // No localStorage - always return null (start fresh each session)
                return null;
            }

            saveChordConfiguration() {
                // No localStorage - update session data instead
                if (!this.sessionData || typeof this.sessionData !== 'object') {
                    this.sessionData = {};
                }
                try {
                    this.sessionData.chordExtensions = this.chordExtensions;
                } catch (e) {
                    console.warn('saveChordConfiguration: failed to write sessionData.chordExtensions', e);
                }
                try {
                    const sections = window._sections;
                    const activeId = window._activeSectionId;
                    if (Array.isArray(sections) && activeId) {
                        const sec = sections.find(s=>s && s.id === activeId);
                        if (sec) {
                            sec.state = sec.state && typeof sec.state === 'object' ? sec.state : {};
                            sec.state.chordExtensions = cloneJson ? cloneJson(this.chordExtensions) : JSON.parse(JSON.stringify(this.chordExtensions));
                        }
                    }
                } catch(_) { }
                console.log('?? Chord configuration updated in session data');
            }
            
            // ============= OMG FILE SYSTEM =============
            
            saveSessionToFile() {
                // Legacy entry point: route to full .XEN export so EVERY parameter round-trips.
                try { return this.exportXenState(); } catch (e) { console.error('Export .XEN failed:', e); }
            }
            
            loadSessionFromFile(file) {
                // Legacy entry point used by the tiny ðŸ“‚ loader â€” delegate to the canonical importer.
                return this.importXenState(file);
            }
            
            promptSaveOnExit() {
                if (confirm('Save current session to OMG file before exiting?')) {
                    this.saveSessionToFile();
                }
            }
            
            clearUnlockedChords() {
                // Remove all unlocked chords, keeping only locked ones
                console.log('??? Clearing all unlocked chords...');
                console.log('?? Before clearing - chord extensions:', this.chordExtensions.length, 'chords:', this.chordExtensions.map(c => c.name));
                
                // Filter to keep only locked chords
                const lockedChords = this.chordExtensions.filter(chord => chord.isLocked && chord.lockedData);
                
                console.log('? Found locked chords:', lockedChords.length, 'chords:', lockedChords.map(c => c.name));
                
                // If no locked chords, start in chord creation mode
                if (lockedChords.length === 0) {
                    console.log('?? No chords available, starting in chord creation mode');
                    // Start empty - user must create chords from scratch
                    this.chordExtensions = [];
                } else {
                    console.log('?? Keeping only locked chords with preserved data');
                    // IMPORTANT: Keep the full locked chord data structure intact
                    this.chordExtensions = lockedChords.map(chord => ({
                        ...chord,
                        // Ensure intervals from locked data are preserved
                        intervals: chord.lockedData?.intervals || chord.intervals,
                        // Preserve all locked settings
                        lockedRoot: chord.lockedData?.lockedRoot,
                        lockedTuning: chord.lockedData?.lockedTuning,
                        lockedGamelanMode: chord.lockedData?.lockedGamelanMode,
                        // Keep the lock state
                        isLocked: true,
                        lockedData: chord.lockedData
                    }));
                }
                
                // Clear any old localStorage keys that might be confusing things
                
                // Save the cleaned configuration
                this.saveChordConfiguration();
                
                console.log('?? After clearing - chord extensions:', this.chordExtensions.length, 'chords:', this.chordExtensions.map(c => c.name));
                
                // Regenerate the display
                this.generateExtensionColumns();
            }

            addColumn() {
                // Show modal to select chord type
                this.showAddColumnModal();
            }

            showAddColumnModal() {
                // Create modal for adding new column
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px;">
                        <h3>Add New Chord Column</h3>
                        <div style="display: flex; gap: 20px;">
                            <div style="flex: 1;">
                                <h4>Preset Chords</h4>
                                <div class="add-column-grid">
                                    ${this.availableChordTypes.map(chord => `
                                        <button class="add-chord-btn" data-chord='${JSON.stringify(chord)}'>
                                            ${chord.name}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <h4>Create Custom Chord</h4>
                                <div style="margin-bottom: 15px;">
                                    <label>Chord Name:</label>
                                    <input type="text" id="customChordName" placeholder="My Chord" style="width: 100%; padding: 5px; margin-top: 5px;">
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <label>Select Notes (0-11 semitones):</label>
                                    <div id="noteSelector" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 10px;">
                                        ${Array.from({length: 12}, (_, i) => `
                                            <label style="display: flex; align-items: center; gap: 5px; padding: 8px; background: #333; border-radius: 4px; cursor: pointer;">
                                                <input type="checkbox" value="${i}" class="note-checkbox" style="cursor: pointer;">
                                                <span class="note-label">${this.getNoteNameFromSemitone(i)}</span>
                                                <button type="button" class="preview-btn" data-note="${i}" style="margin-left: auto; padding: 2px 6px; font-size: 10px; background: #555; border: none; color: white; border-radius: 3px; cursor: pointer;">?</button>
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <button type="button" id="previewChord" class="osc-btn" style="width: 100%;">?? Preview Full Chord</button>
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <button type="button" id="createCustomChord" class="osc-btn" style="width: 100%; background: #059669;">Create Custom Chord</button>
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                        </div>
                    </div>
                `;
                
                // Add event listeners for preset chord selection
                modal.querySelectorAll('.add-chord-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const chordData = JSON.parse(e.target.dataset.chord);
                        this.addChordColumn(chordData);
                        modal.remove();
                    });
                });
                
                // Add event listeners for custom chord creation
                const previewButtons = modal.querySelectorAll('.preview-btn');
                previewButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const note = parseInt(e.target.dataset.note);
                        this.previewNote(note);
                    });
                });
                
                const previewChordBtn = modal.querySelector('#previewChord');
                previewChordBtn.addEventListener('click', () => {
                    this.previewSelectedChord(modal);
                });
                
                const createCustomBtn = modal.querySelector('#createCustomChord');
                createCustomBtn.addEventListener('click', () => {
                    this.createCustomChordFromModal(modal);
                });
                
                document.body.appendChild(modal);
                
                // Close on ESC
                const closeOnEsc = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', closeOnEsc);
                    }
                };
                document.addEventListener('keydown', closeOnEsc);
            }

            getNoteNameFromSemitone(semitone) {
                const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                return notes[semitone];
            }

            previewNote(semitone) {
                // Calculate frequency for the note (using C4 as base)
                const baseFreq = 261.626; // C4
                const frequency = baseFreq * Math.pow(2, semitone / 12);
                
                // Play the note briefly
                this.playFrequency(frequency, 0.5, 'chord'); // 0.5 second duration
                
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 500);
            }

            previewSelectedChord(modal) {
                const selectedNotes = Array.from(modal.querySelectorAll('.note-checkbox:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);
                
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note to preview.');
                    return;
                }
                
                // Play all selected notes as a chord
                const baseFreq = 261.626; // C4
                selectedNotes.forEach(semitone => {
                    const frequency = baseFreq * Math.pow(2, semitone / 12);
                    this.playFrequency(frequency, 1.0, 'chord'); // 1 second duration
                });
                
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
            }

            createCustomChordFromModal(modal) {
                const chordName = modal.querySelector('#customChordName').value.trim();
                const selectedNotes = Array.from(modal.querySelectorAll('.note-checkbox:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);
                
                if (!chordName) {
                    alert('Please enter a chord name.');
                    return;
                }
                
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note.');
                    return;
                }
                
                // Create custom chord data
                const customChordData = {
                    name: chordName,
                    extensions: [], // Custom chords don't use extensions
                    intervals: selectedNotes,
                    isCustomPattern: true
                };
                
                this.addChordColumn(customChordData);
                modal.remove();
            }

            addChordColumn(chordData) {
                if (chordData.isCustomPattern) {
                    // Handle custom chord with specific intervals
                    if (!this.customChords) this.customChords = [];
                    
                    const customChord = {
                        name: chordData.name,
                        notes: chordData.intervals
                    };
                    
                    this.customChords.push(customChord);
                } else {
                    // Handle standard chord extension
                    this.chordExtensions.push({ ...chordData });
                    this.saveChordConfiguration();
                }
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log(`Added new chord column: ${chordData.name}`);
            }

            exportChordConfiguration() {
                const config = {
                    chordExtensions: this.chordExtensions,
                    customChords: this.customChords || [],
                    hiddenColumns: this.hiddenColumns || [],
                    exportDate: new Date().toISOString(),
                    version: '1.0'
                };
                
                const dataStr = JSON.stringify(config, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `xenon-config-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
            }
            
            /**
             * Export the COMPLETE application state as a versioned .xen file.
             * Schema (version 2.1):
             * {
             *   fileType: 'Xenmicord Session',
             *   schemaVersion: '2.1',       // explicit schema version (previous used 'version')
             *   appVersion: 'Xenmicord v2.0',
             *   savedDate: ISOString,
             *   chordExtensions: [...], customChords: [...], lockedChords: [...], paletteChords: [...],
             *   currentRoot, currentQuality, currentTuning, gamelanMode, transposeDelta,
             *   pianoLockedChords: [ [id, data], ... ], preloadedPresets: [ [id, synthState], ... ], pianoLockPresetCounter,
             *   hiddenColumns, splitExtendedChordsAcrossOctaves, playMode, strumEnabled, chordsEnabled, arpEnabled, bassEnabled,
             *   oscillators: { osc1, osc2 }, envelope, osc2Envelope,
             *   instruments: { strum1:{osc,env,fxSend}, strum2:{...}, chord:{...}, arp:{...}, bass:{...} },
             *   volume, masterVolume,
             *   bpm, quantize, timeSignature, pattern, loop, holdDuration, universalHold, npc,
             *   arpSettings: { npc, chordsNpc, chordQuant, chordsHold, pattern, gateMs, gatePct, glide, glideMs, active, seq, column },
             *   _isSequencing, _sustainActive, _chordsGestureActive,
             *   strumDelayMs, strumMode,
             *   chordSlideEnabled, _chordSlideEnabled, _chordGlideMs,
             *   heldBassEnabled, _heldBassEnabled,
             *   fx: { drive:{amount,mix,hp,lp}, delay:{timeMs,feedback,lp,hp,mix}, filters:{low,high,q}, reverb:{wet,room,decay,lp,hp}, panning:{mode,width,speedMs,alternateState,rotationAngle} },
             *   reverb, panning,
             *   textChordInput,
             *   drums: { active, patterns: { index: number[][] }, laneControls:[{vol,fx,midi,pPitch,pAtk,pDec}...], bass:[{npc,len,on}...] },
             *   midi: { outputPortMap, inputChannelMap, perSourceOctave, perSourceVelocity, defaultVelocity, octaveOffset, channelMap },
             *   sequencePresets, instrumentPresets, effectsPresets,
             *   currentActiveColumnEl: { chordName, index } | null,
             *   visualChordSequence: [ { name, intervals, position:{ index } } ],
             *   legacy: { version: '2.0' } // retained for backward compatibility
             * }
             *
             * Backward compatibility:
             *  - Older .omg or .xen with fileType 'OMG-nichord Session' or missing schemaVersion are translated.
             *  - Fields absent in legacy are defaulted.
             */
            exportXenState() {
                // Ensure the Pattern Editor state is committed into banks BEFORE we serialize.
                // Otherwise, dots edited in clone Pattern instances (arp2/arp3/...) may never be saved
                // unless the user switches pattern numbers.
                try {
                    const cloneJson = (v)=>{ try { return JSON.parse(JSON.stringify(v)); } catch(_){ return v; } };
                    const captureGridFromModal = (modal)=>{
                        try {
                            const pg = modal && modal.querySelector
                                ? (modal.querySelector('[data-role="patternGrid"]') || modal.querySelector('#patternGrid') || modal.querySelector('.pattern-grid'))
                                : null;
                            if (!pg) return [];
                            const lanes = Array.from(pg.querySelectorAll('.pattern-lane'));
                            return lanes.map(lane=>{
                                const steps = Array.from(lane.querySelectorAll('.pattern-step')).map(s=>{
                                    if (!s.classList.contains('active')) return null;
                                    const obj = { active: 1 };
                                    if (s.dataset.len) obj.len = String(s.dataset.len);
                                    if (s.dataset.tie === '1') obj.tie = 1;
                                    if (s.dataset.npc) obj.npc = String(s.dataset.npc);
                                    if (s.dataset.vel != null) obj.vel = String(s.dataset.vel);
                                    return obj;
                                });
                                return steps;
                            });
                        } catch(_){ return []; }
                    };
                    const captureSynthFromModal = (modal, instKey)=>{
                        try {
                            const key = String(instKey||'').trim();
                            if (!modal || !modal.querySelector || !key) return null;
                            const host = modal.querySelector('[data-role="tab-arp"]') || modal.querySelector('#tab-arp');
                            const activeBtn = host ? host.querySelector(`.osc-btn[data-inst="${key}"].active`) : null;
                            const wave = activeBtn ? String(activeBtn.dataset.wave||'sine') : 'sine';
                            const num = (id, fallback)=>{
                                const el = modal.querySelector(`#${id}`);
                                const v = el ? parseFloat(el.value) : NaN;
                                return Number.isFinite(v) ? v : fallback;
                            };
                            const str = (id, fallback)=>{
                                const el = modal.querySelector(`#${id}`);
                                const v = el ? String(el.value||'').trim() : '';
                                return v || fallback;
                            };
                            const chk = (id, fallback)=>{
                                const el = modal.querySelector(`#${id}`);
                                return el ? !!el.checked : !!fallback;
                            };
                            return {
                                wave,
                                [`${key}PulseWidth`]: num(`${key}PulseWidth`, 50),
                                [`${key}ShapeWidth`]: num(`${key}ShapeWidth`, 50),
                                [`${key}Level`]: num(`${key}Level`, 5),
                                [`${key}Detune`]: num(`${key}Detune`, 0),
                                [`${key}Octave`]: num(`${key}Octave`, 0),
                                [`${key}Coarse`]: num(`${key}Coarse`, 0),
                                [`${key}AttackSlider`]: num(`${key}AttackSlider`, 10),
                                [`${key}DecaySlider`]: num(`${key}DecaySlider`, 200),
                                [`${key}SustainSlider`]: num(`${key}SustainSlider`, 70),
                                [`${key}ReleaseSlider`]: num(`${key}ReleaseSlider`, 500),
                                [`${key}FxSend`]: chk(`${key}FxSend`, true),
                                midiIn: num(`midiIn-${key}`, 1),
                                midiOut: str(`midiOut-${key}`, ''),
                                midiOct: str(`midiOct-${key}`, '0'),
                                midiVel: num(`midiVel-${key}`, 100),
                            };
                        } catch(_){ return null; }
                    };

                    // Commit base Pattern Editor (arp) current slot.
                    try { this._saveArpPattern && this._saveArpPattern(); } catch(_){ }
                    try { this._saveArpPatternSynth && this._saveArpPatternSynth(); } catch(_){ }

                    // Commit clone Pattern instances (arp2/arp3/...) current slots.
                    try {
                        const arr = Array.isArray(window._patternInstances) ? window._patternInstances : [];
                        this._arpPatternsByInst = this._arpPatternsByInst || {};
                        this._arpSynthPatternsByInst = this._arpSynthPatternsByInst || {};
                        arr.forEach(info=>{
                            try {
                                const modal = info && info.modal;
                                const key = info && info.key ? String(info.key) : (modal && modal.dataset ? String(modal.dataset.patternInstanceKey||'') : '');
                                if (!modal || !key) return;
                                const patNumEl = modal.querySelector('[data-role="patternPatternNumber"]') || modal.querySelector('#patternPatternNumber');
                                const curNum = Math.max(1, parseInt(patNumEl ? patNumEl.value : '1', 10) || 1);

                                const mp = this._arpPatternsByInst[key] = this._arpPatternsByInst[key] || new Map();
                                const mpS = this._arpSynthPatternsByInst[key] = this._arpSynthPatternsByInst[key] || new Map();

                                mp.set(curNum, captureGridFromModal(modal));
                                const st = captureSynthFromModal(modal, key);
                                if (st) mpS.set(curNum, cloneJson(st));
                            } catch(_){ }
                        });
                    } catch(_){ }
                } catch(_){ }

                // Capture current chord/marker ordering from the DOM (drag-rearranged), without mutating live state.
                const cloneJson = (v)=>{ try { return JSON.parse(JSON.stringify(v)); } catch(_){ return v; } };
                const buildChordExtensionsFromDomOrder = ()=>{
                    try {
                        const container = document.getElementById('extensionColumns');
                        if (!container) return Array.isArray(this.chordExtensions) ? this.chordExtensions : [];

                        const els = Array.from(container.querySelectorAll('.repeat-marker-column, .extension-separator, .extension-column'));
                        if (!els.length) return Array.isArray(this.chordExtensions) ? this.chordExtensions : [];

                        const src = Array.isArray(this.chordExtensions) ? this.chordExtensions : [];
                        const out = [];
                        const present = new Set();

                        const findChordByEl = (el)=>{
                            try {
                                const chordId = el?.dataset?.chordId ? String(el.dataset.chordId) : null;
                                if (chordId) {
                                    const byId = src.find(c=> c && c.id != null && String(c.id) === chordId);
                                    if (byId) return byId;
                                }
                                const opRaw = el?.dataset?.originalPosition;
                                if (opRaw != null) {
                                    const op = parseInt(String(opRaw),10);
                                    if (Number.isFinite(op) && op >= 0) {
                                        if (src[op]) return src[op];
                                        const byPos = src.find(c=> c && typeof c.position === 'number' && c.position === op);
                                        if (byPos) return byPos;
                                    }
                                }
                            } catch(_){ }
                            return null;
                        };

                        els.forEach((el, idx)=>{
                            try {
                                if (!el) return;
                                // Repeat marker (brackets)
                                if (el.classList.contains('repeat-marker-column') || el.dataset.isRepeatMarker === 'true') {
                                    const name = String((el.textContent||'').trim());
                                    if (!name) return;
                                    const nestLevel = parseInt(String(el.dataset.nestLevel||'0'),10);
                                    const rcRaw = el.dataset.repeatCount;
                                    const repeatCount = (rcRaw != null && rcRaw !== '') ? parseInt(String(rcRaw),10) : undefined;
                                    const marker = {
                                        id: `repeat_${idx}`,
                                        name,
                                        type: 'bracket',
                                        isRepeatMarker: true,
                                        nestLevel: Number.isFinite(nestLevel) ? nestLevel : 0,
                                        position: out.length
                                    };
                                    if (Number.isFinite(repeatCount)) marker.repeatCount = repeatCount;
                                    if (el.dataset.autoOuter === 'true') marker.autoOuter = true;
                                    out.push(marker);
                                    present.add(String(marker.id));
                                    return;
                                }
                                // Separator
                                if (el.classList.contains('extension-separator')) {
                                    const sep = {
                                        id: `sep_${idx}`,
                                        name: '|',
                                        isSeparator: true,
                                        position: out.length
                                    };
                                    out.push(sep);
                                    present.add(String(sep.id));
                                    return;
                                }
                                // Chord column
                                if (el.classList.contains('extension-column')) {
                                    const chordExt = findChordByEl(el);
                                    const header = el.querySelector('.chord-name');
                                    const displayName = header ? String(header.textContent||'').trim() : '';
                                    const base = chordExt ? cloneJson(chordExt) : { name: displayName || 'Chord', intervals: [], extensions: [], isCustom: true };

                                    // Persist len16 from DOM (yellow-handle width) as the source of truth.
                                    try {
                                        const rawLen16 = el?.dataset?.len16;
                                        let v = parseInt(String(rawLen16 || ''), 10);
                                        if (!Number.isFinite(v) || v <= 0) v = (base && base.len16) ? parseInt(String(base.len16),10) : 16;
                                        if (!Number.isFinite(v) || v <= 0) v = 16;
                                        base.len16 = Math.max(1, Math.min(1024, v|0));
                                    } catch(_){ }

                                    // Preserve any per-column local transpose as the source of truth
                                    try {
                                        if (el.dataset.localTranspose != null) {
                                            const lt = parseInt(String(el.dataset.localTranspose||'0'),10);
                                            base.localTranspose = Number.isFinite(lt) ? lt : (base.localTranspose||0);
                                        }
                                    } catch(_){ }
                                    if (displayName) base.name = displayName;
                                    if (!base.id) {
                                        const chordId = el?.dataset?.chordId ? String(el.dataset.chordId) : '';
                                        base.id = chordId || `ch_${idx}_${Date.now()}`;
                                    }
                                    base.position = out.length;
                                    out.push(base);
                                    present.add(String(base.id));
                                }
                            } catch(_){ }
                        });

                        // Preserve any chord extensions that are not currently rendered (e.g., hidden columns)
                        const fallbackIdForSrc = (c, i)=>{
                            try {
                                if (c && c.id != null) return String(c.id);
                                const nm = c && c.name != null ? String(c.name) : 'chord';
                                return (nm + '_' + i).toLowerCase().replace(/\s+/g, '_');
                            } catch(_){ return `chord_${i}`; }
                        };
                        src.forEach((c, i)=>{
                            try {
                                if (!c || typeof c !== 'object') return;
                                if (c.isRepeatMarker || c.isSeparator || c.name === '|') return;
                                const key = fallbackIdForSrc(c, i);
                                if (present.has(key)) return;
                                const extra = cloneJson(c);
                                if (!extra.id) extra.id = key;
                                extra.position = out.length;
                                out.push(extra);
                                present.add(String(extra.id));
                            } catch(_){ }
                        });

                        return out.length ? out : (Array.isArray(this.chordExtensions) ? this.chordExtensions : []);
                    } catch(_){
                        return Array.isArray(this.chordExtensions) ? this.chordExtensions : [];
                    }
                };

                const chordExtensionsForSave = buildChordExtensionsFromDomOrder();

                // Capture base Pattern Editor bank (PATTERN 1/2/3...) so it round-trips via .xen
                const patternEditor = (()=>{
                    try {
                        const modal = document.getElementById('patternModal');
                        const pg = document.getElementById('patternGrid');
                        const patNumEl = document.getElementById('patternPatternNumber');
                        const curNum = Math.max(1, parseInt(patNumEl?.value||'1',10) || 1);

                        const captureGrid = ()=>{
                            if (!pg) return [];
                            const lanes = Array.from(pg.querySelectorAll('.pattern-lane'));
                            return lanes.map(lane=>{
                                const steps = Array.from(lane.querySelectorAll('.pattern-step')).map(s=>{
                                    if (!s.classList.contains('active')) return null;
                                    const obj = { active: 1 };
                                    if (s.dataset.len) obj.len = String(s.dataset.len);
                                    if (s.dataset.tie === '1') obj.tie = 1;
                                    if (s.dataset.npc) obj.npc = String(s.dataset.npc);
                                    if (s.dataset.vel != null) obj.vel = String(s.dataset.vel);
                                    return obj;
                                });
                                return steps;
                            });
                        };

                        const mapToObj = (mp)=>{
                            const out = {};
                            try {
                                if (!mp || typeof mp.forEach !== 'function') return out;
                                mp.forEach((v,k)=>{ out[String(k)] = cloneJson(v); });
                            } catch(_){ }
                            return out;
                        };

                        const patternsObj = mapToObj(this._arpPatterns instanceof Map ? this._arpPatterns : null);
                        const synthObj = mapToObj(this._arpSynthPatterns instanceof Map ? this._arpSynthPatterns : null);

                        // Ensure current on-screen edits are persisted even if the user never switched slots
                        patternsObj[String(curNum)] = captureGrid();
                        try {
                            if (typeof this._captureArpSynthUIState === 'function') {
                                const st = this._captureArpSynthUIState();
                                if (st) synthObj[String(curNum)] = cloneJson(st);
                            }
                        } catch(_){ }

                        const speakerBtn = document.getElementById('patternSpeakerBtn');
                        const enabled = (modal && typeof modal._patternEnabled === 'boolean')
                            ? !!modal._patternEnabled
                            : (speakerBtn ? (String(speakerBtn.textContent||'').trim() === 'ðŸ”Š') : true);
                        const arpPanel = document.getElementById('tab-arp');
                        const arpPanelOpen = arpPanel ? (arpPanel.style.display !== 'none') : false;

                        return {
                            enabled,
                            pendingEnabled: (modal && modal._patternPendingEnabled != null) ? !!modal._patternPendingEnabled : null,
                            currentPatternNumber: curNum,
                            lastArpPatternNumber: this._lastArpPatternNumber != null ? this._lastArpPatternNumber : curNum,
                            patterns: patternsObj,
                            synthPatterns: synthObj,
                            arpPanelOpen,
                            gridLength: pg ? (parseInt(pg.dataset.length||'16',10) || 16) : 16,
                            gridNpc: pg ? Array.from(pg.querySelectorAll('.pattern-lane')).length : null
                        };
                    } catch(_){ return null; }
                })();

                // Transport values (top bar) are the single source of truth at runtime.
                // Capture them explicitly so BPM/loop always round-trip even if legacy controls are disabled.
                const readInt = (id, fallback) => {
                    try {
                        const el = document.getElementById(id);
                        const v = el ? parseInt(el.value, 10) : NaN;
                        return Number.isFinite(v) ? v : fallback;
                    } catch (_) {
                        return fallback;
                    }
                };
                const masterBpmRaw = (() => {
                    try {
                        const v = (typeof window.__MASTER_BPM !== 'undefined') ? parseInt(String(window.__MASTER_BPM), 10) : NaN;
                        return Number.isFinite(v) ? v : NaN;
                    } catch (_) {
                        return NaN;
                    }
                })();
                const bpmForSave = Math.max(20, Math.min(300,
                    (Number.isFinite(masterBpmRaw) ? masterBpmRaw : NaN) ||
                    readInt('transportBpm', NaN) ||
                    readInt('universalBpm', NaN) ||
                    120
                ));
                const loopForSave = (() => {
                    try {
                        const t = document.getElementById('loopToggle');
                        if (t) return !!t.checked;
                        const legacy = document.getElementById('playLoop');
                        return !!legacy?.checked;
                    } catch (_) {
                        return false;
                    }
                })();

                const sessionData = {
                    // ==== CHORD DATA ====
                    chordExtensions: chordExtensionsForSave,
                    customChords: this.customChords || [],
                    lockedChords: this.savedLockedChords || Array.from(this.lockedChords?.values() || []),
                    paletteChords: this.paletteChords || [],
                    currentRoot: this.currentRoot,
                    currentQuality: this.currentQuality,
                    currentTuning: this.currentTuning,
                    gamelanMode: this.gamelanMode,
                    // Global transpose state
                    transposeDelta: this.transposeDelta || 0,
                    
                    // ==== PIANO LOCK DATA - COMPLETE PRESERVATION ====
                    pianoLockedChords: this.pianoLockedChords ? Array.from(this.pianoLockedChords.entries()) : [],
                    preloadedPresets: this.preloadedPresets ? Array.from(this.preloadedPresets.entries()) : [],
                    pianoLockPresetCounter: this.pianoLockPresetCounter || 0,
                    
                    // ==== UI STATE - COMPLETE ====
                    hiddenColumns: this.hiddenColumns || [],
                    splitExtendedChordsAcrossOctaves: this.splitExtendedChordsAcrossOctaves,
                    playMode: this.playMode,
                    strumEnabled: this.strumEnabled,
                    chordsEnabled: this.chordsEnabled,
                    arpEnabled: this.arpEnabled,
                    bassEnabled: this.bassEnabled,
                    
                    // ==== OSCILLATOR SETTINGS - COMPLETE ====
                    oscillators: {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 }
                    },
                    envelope: { ...this.envelope },
                    osc2Envelope: { ...this.osc2Envelope },
                    
                    // ==== PER-INSTRUMENT SETTINGS - COMPLETE ====
                    instruments: {
                        strum1: {
                            osc: { ...this.instruments.strum1.osc },
                            env: { ...this.instruments.strum1.env },
                            fxSend: this.instruments.strum1.fxSend
                        },
                        strum2: {
                            osc: { ...this.instruments.strum2.osc },
                            env: { ...this.instruments.strum2.env },
                            fxSend: this.instruments.strum2.fxSend
                        },
                        chord: {
                            osc: { ...this.instruments.chord.osc },
                            env: { ...this.instruments.chord.env },
                            fxSend: this.instruments.chord.fxSend
                        },
                        arp: {
                            osc: { ...this.instruments.arp.osc },
                            env: { ...this.instruments.arp.env },
                            fxSend: this.instruments.arp.fxSend
                        },
                        bass: {
                            osc: { ...this.instruments.bass.osc },
                            env: { ...this.instruments.bass.env },
                            fxSend: this.instruments.bass.fxSend
                        }
                    },
                    
                    // ==== AUDIO ENGINE STATE ====
                    volume: this.volume,
                    masterVolume: this.masterVolume,
                    audioContext: {
                        sampleRate: this.audioContext ? this.audioContext.sampleRate : 44100,
                        state: this.audioContext ? this.audioContext.state : 'suspended'
                    },
                    
                    // ==== TRANSPORT AND TIMING - COMPLETE ====
                    // Master tempo (transport bar) â€” this MUST restore master timing.
                    bpm: bpmForSave,
                    transportBpm: bpmForSave,
                    quantize: document.getElementById('universalQuant')?.value || 'beat:1',
                    timeSignature: document.getElementById('universalTimeSignature')?.value || '4/4',
                    pattern: document.getElementById('universalPattern')?.value || 'up',
                    // Persist custom typed pattern (if any) from companion text field
                    patternText: document.getElementById('universalPatternText')?.value || '',
                    loop: loopForSave,
                    transportLoop: loopForSave,
                    holdDuration: document.getElementById('chordHold')?.value || 'bar:1',
                    universalHold: document.getElementById('universalHold')?.value || 'bar:1',
                    npc: parseInt(document.getElementById('universalNpc')?.value) || 3,
                    
                    // ==== ARP/SEQUENCER STATE - COMPLETE ====
                    arpSettings: {
                        npc: this._arp?.npc || 3,
                        chordsNpc: this._arp?.chordsNpc || 3,
                        chordQuant: this._arp?.chordQuant || '1/4',
                        chordsHold: this._arp?.chordsHold || 'bar:1',
                        pattern: this._arp?.pattern || 'up',
                        gateMs: this._arp?.gateMs || 50,
                        gatePct: this._arp?.gatePct || 50,
                        glide: this._arp?.glide || false,
                        glideMs: this._arp?.glideMs || 0,
                        active: this._arp?.active || false,
                        seq: this._arp?.seq || [],
                        column: this._arp?.column || null
                    },
                    _isSequencing: this._isSequencing,
                    _sustainActive: this._sustainActive,
                    _chordsGestureActive: this._chordsGestureActive,
                    
                    // ==== STRUM SETTINGS ====
                    strumDelayMs: this.strumDelayMs,
                    strumMode: this.strumMode || 'up',
                    
                    // ==== SLIDE SETTINGS ====
                    chordSlideEnabled: !!document.getElementById('chordSlide')?.checked,
                    _chordSlideEnabled: this._chordSlideEnabled,
                    _chordGlideMs: this._chordGlideMs,
                    
                    // ==== BASS SETTINGS ====
                    heldBassEnabled: this._heldBassEnabled,
                    _heldBassEnabled: this._heldBassEnabled,
                    
                    // ==== EFFECTS SETTINGS - COMPLETE ====
                    fx: {
                        drive: {
                            amount: parseFloat(document.getElementById('driveAmount')?.value || 0),
                            mix: parseFloat(document.getElementById('driveMix')?.value || 0),
                            hp: parseFloat(document.getElementById('driveHpCutoff')?.value || 0),
                            lp: parseFloat(document.getElementById('driveLpCutoff')?.value || 100)
                        },
                        delay: {
                            timeMs: parseFloat(document.getElementById('delayTime')?.value || 280),
                            feedback: parseFloat(document.getElementById('delayFeedback')?.value || 0),
                            lp: parseFloat(document.getElementById('delayLpCutoff')?.value || 73),
                            hp: parseFloat(document.getElementById('delayHpCutoff')?.value || 0),
                            mix: parseFloat(document.getElementById('delayMix')?.value || 0)
                        },
                        filters: {
                            low: parseFloat(document.getElementById('filterLow')?.value || 0),
                            high: parseFloat(document.getElementById('filterHigh')?.value || 100),
                            q: parseFloat(document.getElementById('filterRes')?.value || 1)
                        },
                        reverb: {
                            wet: parseFloat(document.getElementById('reverbWet')?.value || 1),
                            room: parseFloat(document.getElementById('reverbRoom')?.value || 5),
                            decay: parseFloat(document.getElementById('reverbDecay')?.value || 20),
                            lp: parseFloat(document.getElementById('reverbFilterCutoff')?.value || 70),
                            hp: parseFloat(document.getElementById('reverbHpCutoff')?.value || 0)
                        },
                        panning: {
                            mode: document.getElementById('panningMode')?.value || 'center',
                            width: parseFloat(document.getElementById('panningWidth')?.value || 80),
                            speedMs: parseFloat(document.getElementById('panningSpeed')?.value || 2000),
                            alternateState: this.panning?.alternateState || false,
                            rotationAngle: this.panning?.rotationAngle || 0
                        }
                    },

                    // ==== DRUM FX (GLOBAL BUS) ====
                    drumFx: cloneJson(this.drumFx || null),
                    
                    // ==== REVERB OBJECT STATE ====
                    reverb: this.reverb ? { ...this.reverb } : {},
                    panning: this.panning ? { ...this.panning } : {},
                    
                    // ==== TEXT INPUT STATE ====
                    textChordInput: document.getElementById('textChordInput')?.value || '',

                    // ==== DRUMS: PATTERNS + LANE CONTROLS ====
                    drums: (()=>{
                        try {
                            const active = Math.max(1, parseInt(document.getElementById('drumPatternNumber')?.value||'1',10));
                            // Serialize pattern bank map<number, number[][]>
                            let patterns = {};
                            try {
                                const mp = this._drumPatterns instanceof Map ? this._drumPatterns : null;
                                if (mp) {
                                    for (const [k,v] of mp.entries()) { patterns[String(k)] = Array.isArray(v) ? JSON.parse(JSON.stringify(v)) : v; }
                                } else {
                                    // Fallback: capture current grid into pattern 1
                                    const lanes = Array.from(document.querySelectorAll('.drum-row:not(.bass-row) .drum-lane'));
                                    patterns['1'] = lanes.map(lane=> Array.from(lane.querySelectorAll('.drum-step')).map(s=> s.classList.contains('active') ? 1 : 0));
                                }
                            } catch(_){ }
                            // Per-lane controls (non-bass rows only)
                            const lanes = Array.from(document.querySelectorAll('.drum-row:not(.bass-row)'));
                            const laneControls = lanes.map(row=>{
                                try {
                                    const vol = row.querySelector('.drum-volume');
                                    const sendEl = row.querySelector('.drum-send');
                                    const fx  = row.querySelector('.drum-fx input[type="checkbox"]');
                                    const midi= row.querySelector('.drum-midi input[type="text"]');
                                    const pPitch = row.querySelector('.drum-params input[title$=" Pitch"]');
                                    const pAtk   = row.querySelector('.drum-params input[title$=" Attack"]');
                                    const pDec   = row.querySelector('.drum-params input[title$=" Decay"]');
                                    const sendPct = sendEl ? (parseInt(sendEl.value||'0',10) || 0) : (!!(fx&&fx.checked) ? 100 : 0);
                                    return {
                                        vol: vol? vol.value: '80',
                                        send: String(Math.max(0, Math.min(100, sendPct))),
                                        fx: !!(fx&&fx.checked),
                                        midi: midi? midi.value: '',
                                        pPitch: pPitch? pPitch.value : '0',
                                        pAtk: pAtk? pAtk.value : '2',
                                        pDec: pDec? pDec.value : '180'
                                    };
                                } catch(_){ return {vol:'80',fx:false,midi:'',pPitch:'0',pAtk:'2',pDec:'180'}; }
                            });
                            // Bass NPC/ties row
                            let bass = [];
                            try {
                                const bassLane = document.querySelector('.drum-row.bass-row .drum-lane');
                                if (bassLane) {
                                    const steps = Array.from(bassLane.querySelectorAll('.drum-step'));
                                    bass = steps.map(s=>{
                                        const npc=(s.dataset.npc||''); const len=(s.dataset.len||'');
                                        const on = s.classList.contains('active');
                                        return { npc, len, on };
                                    });
                                }
                            } catch(_){}
                            return { active, patterns, laneControls, bass };
                        } catch(_) { return { active:1, patterns:{}, laneControls:[], bass:[] }; }
                    })(),

                    // ==== WEB MIDI STATE (OUTPUT ROUTING + PER-SECTION) ====
                    midi: (()=>{
                        try {
                            const m = (window && window.midi) ? window.midi : null;
                            if (!m) return {};
                            return {
                                outputPortMap: { ...(m.outputPortMap||{}) },
                                inputChannelMap: { ...(m.inputChannelMap||{}) },
                                perSourceOctave: { ...(m.perSourceOctave||{}) },
                                perSourceVelocity: { ...(m.perSourceVelocity||{}) },
                                defaultVelocity: m.defaultVelocity||100,
                                octaveOffset: m.octaveOffset||0,
                                channelMap: { ...(m.channelMap||{}) }
                            };
                        } catch(_) { return {}; }
                    })(),
                    
                    // ==== PRESET DATA ====
                    sequencePresets: this.getSequencePresets ? this.getSequencePresets() : [],
                    instrumentPresets: this.getInstrumentPresets ? this.getInstrumentPresets() : [],
                    effectsPresets: this.getEffectsPresets ? this.getEffectsPresets() : [],

                    // ==== INSTANCE STATE (MULTI-INSTANCE DRUM/PATTERN) ====
                    drumInstances: (()=>{
                        try {
                            const arr = Array.isArray(window._drumInstances) ? window._drumInstances : [];
                            return arr.map(inst=>{
                                if (!inst || typeof inst !== 'object') return null;
                                return {
                                    id: inst.id,
                                    name: inst.name,
                                    enabled: !!inst.enabled,
                                    pendingEnabled: (inst.pendingEnabled != null) ? !!inst.pendingEnabled : null,
                                    len: inst.len,
                                    pendingLen: inst.pendingLen != null ? inst.pendingLen : null,
                                    state: inst.state ? JSON.parse(JSON.stringify(inst.state)) : null,
                                    startAtBarIndex: inst.startAtBarIndex != null ? inst.startAtBarIndex : null,
                                    cycleStartGlobalStep: inst.cycleStartGlobalStep != null ? inst.cycleStartGlobalStep : null,
                                    _lastStep: inst._lastStep != null ? inst._lastStep : null
                                };
                            }).filter(Boolean);
                        } catch(_){ return []; }
                    })(),
                    activeDrumInstanceId: (()=>{ try { return window._activeDrumInstanceId || null; } catch(_){ return null; } })(),
                    patternInstances: (()=>{
                        try {
                            const cloneJson = (v)=>{ try { return JSON.parse(JSON.stringify(v)); } catch(_){ return v; } };
                            const mapToObj = (mp)=>{
                                const out = {};
                                try {
                                    if (!mp || typeof mp.forEach !== 'function') return out;
                                    mp.forEach((v,k)=>{ out[String(k)] = cloneJson(v); });
                                } catch(_){ }
                                return out;
                            };
                            const arr = Array.isArray(window._patternInstances) ? window._patternInstances : [];
                            return arr.map(info=>{
                                const key = info && info.key ? String(info.key) : '';
                                const modal = info && info.modal ? info.modal : null;
                                if (!key || !modal) return null;
                                const patNumEl = modal.querySelector('[data-role="patternPatternNumber"]') || modal.querySelector('#patternPatternNumber');
                                const curNum = patNumEl ? (parseInt(patNumEl.value,10) || 1) : 1;
                                const arpPanel = modal.querySelector('[data-role="tab-arp"]') || modal.querySelector('#tab-arp');
                                const arpPanelOpen = arpPanel ? (arpPanel.style.display !== 'none') : true;
                                const patterns = this._arpPatternsByInst && this._arpPatternsByInst[key] ? this._arpPatternsByInst[key] : null;
                                const synthPatterns = this._arpSynthPatternsByInst && this._arpSynthPatternsByInst[key] ? this._arpSynthPatternsByInst[key] : null;
                                return {
                                    key,
                                    displayName: (modal._patternDisplayName != null) ? String(modal._patternDisplayName) : '',
                                    enabled: !!modal._patternEnabled,
                                    pendingEnabled: (modal._patternPendingEnabled != null) ? !!modal._patternPendingEnabled : null,
                                    currentPatternNumber: curNum,
                                    lastArpPatternNumber: modal._lastArpPatternNumber != null ? modal._lastArpPatternNumber : null,
                                    defaultSynthState: modal._defaultSynthState ? cloneJson(modal._defaultSynthState) : null,
                                    patterns: mapToObj(patterns),
                                    synthPatterns: mapToObj(synthPatterns),
                                    modalStyleText: modal.getAttribute('style') || '',
                                    className: modal.className || '',
                                    arpPanelOpen,
                                    zIndex: modal.style.zIndex || ''
                                };
                            }).filter(Boolean);
                        } catch(_){ return []; }
                    })(),

                    // ==== BASE PATTERN EDITOR BANK (PATTERN 1/2/3...) ====
                    patternEditor,
                    uiSnapshot: (()=>{
                        try {
                            const modals = Array.from(document.querySelectorAll('.floating-modal'))
                                .map(el=>{
                                    try {
                                        if (!el || !el.id) return null;
                                        const cs = (window.getComputedStyle && el) ? window.getComputedStyle(el) : null;
                                        const computed = cs ? {
                                            display: cs.display || '',
                                            left: cs.left || '',
                                            top: cs.top || '',
                                            width: cs.width || '',
                                            height: cs.height || '',
                                            zIndex: cs.zIndex || '',
                                            opacity: cs.opacity || ''
                                        } : null;
                                        return {
                                            id: el.id,
                                            className: el.className || '',
                                            styleText: el.getAttribute('style') || '',
                                            computed,
                                            scrollTop: (typeof el.scrollTop === 'number') ? el.scrollTop : 0,
                                            scrollLeft: (typeof el.scrollLeft === 'number') ? el.scrollLeft : 0
                                        };
                                    } catch(_){ return null; }
                                })
                                .filter(Boolean);

                            const controls = {};
                            try {
                                const els = Array.from(document.querySelectorAll('input[id], select[id], textarea[id]'));
                                els.forEach(el=>{
                                    try {
                                        const id = String(el.id||'');
                                        if (!id) return;
                                        const tag = String(el.tagName||'').toLowerCase();
                                        const type = tag === 'input' ? String(el.type||'') : '';
                                        if (type === 'file') return;
                                        const rec = { tag, type };
                                        if (tag === 'input' && (type === 'checkbox' || type === 'radio')) {
                                            rec.checked = !!el.checked;
                                        } else {
                                            rec.value = (el.value != null) ? String(el.value) : '';
                                        }
                                        controls[id] = rec;
                                    } catch(_){ }
                                });
                            } catch(_){ }

                            return {
                                modals,
                                controls,
                                contentEditables,
                                elementStateById,
                                scroll,
                                activeElementId,
                                bodyClassName: document.body ? (document.body.className || '') : '',
                                htmlClassName: document.documentElement ? (document.documentElement.className || '') : ''
                            };
                        } catch(_){ return { modals: [], controls: {} }; }
                    })(),
                    
                    // ==== VISUAL STATE ====
                    currentActiveColumnEl: this.currentActiveColumnEl ? {
                        chordName: this.currentActiveColumnEl.querySelector('.chord-name')?.textContent,
                        index: Array.from(document.querySelectorAll('.extension-column')).indexOf(this.currentActiveColumnEl)
                    } : null,
                    
                    // ==== CANVAS/VISUAL CHORD SEQUENCE ====
                    visualChordSequence: (() => {
                        try {
                            const columns = Array.from(document.querySelectorAll('#extensionColumns .extension-column'));
                            return columns.map(col => {
                                const header = col.querySelector('.extension-column-header .chord-name');
                                const chordName = header ? header.textContent.trim() : '';
                                if (!chordName) return null;
                                
                                try {
                                    const relSteps = this.getChordStepsForColumn ? this.getChordStepsForColumn(col) : [];
                                    return {
                                        name: chordName,
                                        intervals: relSteps,
                                        position: {
                                            rect: col.getBoundingClientRect(),
                                            index: Array.from(columns).indexOf(col)
                                        }
                                    };
                                } catch(e) {
                                    return { name: chordName, intervals: [], position: { index: Array.from(columns).indexOf(col) } };
                                }
                            }).filter(Boolean);
                        } catch(e) {
                            console.error('Error capturing visual chord sequence:', e);
                            return [];
                        }
                    })(),
                    
                    // ==== SESSION METADATA ====
                    savedDate: new Date().toISOString(),
                    fileType: 'Xenmicord Session',
                    appVersion: 'Xenmicord v2.0',
                    schemaVersion: '2.4',
                    legacy: { version: '2.0' }
                };
                
                const dataStr = JSON.stringify(sessionData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `Xenmicord-session-${new Date().toISOString().split('T')[0]}.xen`;
                link.click();
                
                URL.revokeObjectURL(url);
                
                console.log('ðŸŽµ Complete session saved as .XEN file');
            }
            // Legacy alias (kept for any external references still calling old method name)
            saveSessionAsOMG() { return this.exportXenState(); }
            
            importXenState(event) {
                return new Promise((resolve, reject) => {
                const file = event?.target?.files ? event.target.files[0] : event;
                if (!file) { resolve(null); return; }
                const fileName = (file.name||'').toLowerCase();
                if (!fileName.endsWith('.xen') && !fileName.endsWith('.omg')) {
                    alert('Please select a .XEN session file (or .OMG for legacy support)');
                    reject(new Error('Invalid file extension'));
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const sessionData = JSON.parse(e.target.result);
                        const isNewFormat = sessionData.fileType === 'Xenmicord Session';
                        const isLegacyFormat = sessionData.fileType === 'OMG-nichord Session';
                        if (!isNewFormat && !isLegacyFormat) {
                            alert('Invalid session file format');
                            reject(new Error('Invalid session file format'));
                            return;
                        }
                        console.log('ðŸŽµ Loading session file:', sessionData);
                        // Stop transport/playback if active (safety)
                        try { if (this.stop) this.stop(); } catch(_) {}
                        // COMPLETE RESTORATION - EVERY VARIABLE
                        
                        // ==== CHORD DATA ====
                        if (sessionData.chordExtensions) this.chordExtensions = sessionData.chordExtensions;
                        if (sessionData.customChords) this.customChords = sessionData.customChords;
                        if (sessionData.paletteChords) this.paletteChords = sessionData.paletteChords;
                        if (sessionData.currentRoot !== undefined) this.currentRoot = sessionData.currentRoot;
                        if (sessionData.currentQuality !== undefined) this.currentQuality = sessionData.currentQuality;
                        if (sessionData.currentTuning !== undefined) this.currentTuning = sessionData.currentTuning;
                        if (sessionData.gamelanMode !== undefined) this.gamelanMode = sessionData.gamelanMode;
                        if (sessionData.transposeDelta !== undefined) this.transposeDelta = sessionData.transposeDelta;

                        // Keep position fields consistent (important for exact restore after drag reorder)
                        try { if (typeof this.normalizeChordPositions === 'function') this.normalizeChordPositions(); } catch(_){ }
                        
                        // ==== LOCKED CHORDS RESTORATION ====
                        if (sessionData.lockedChords && sessionData.lockedChords.length > 0) {
                            console.log('ðŸŽµ Restoring locked chords:', sessionData.lockedChords.length, 'chords');
                            this.lockedChords = new Map();
                            this.savedLockedChords = sessionData.lockedChords;
                            
                            // Convert locked chords to chord extensions that will appear as locked
                            this.chordExtensions = [...(this.chordExtensions || []), ...sessionData.lockedChords.map(locked => ({
                                name: locked.chordName,
                                intervals: locked.intervals,
                                extensions: locked.extensions || [],
                                quality: locked.quality || 'custom',
                                isCustom: true,
                                isLocked: true,
                                lockedData: locked,
                                position: locked.originalPosition || 0
                            }))];
                        }
                        
                        // ==== PIANO LOCK DATA RESTORATION ====
                        if (sessionData.pianoLockedChords) {
                            this.pianoLockedChords = new Map(sessionData.pianoLockedChords);
                        }
                        if (sessionData.preloadedPresets) {
                            this.preloadedPresets = new Map(sessionData.preloadedPresets);
                        }
                        if (sessionData.pianoLockPresetCounter !== undefined) {
                            this.pianoLockPresetCounter = sessionData.pianoLockPresetCounter;
                        }
                        
                        // ==== UI STATE RESTORATION ====
                        if (sessionData.hiddenColumns) this.hiddenColumns = sessionData.hiddenColumns;
                        if (sessionData.splitExtendedChordsAcrossOctaves !== undefined) {
                            this.splitExtendedChordsAcrossOctaves = sessionData.splitExtendedChordsAcrossOctaves;
                        }
                        if (sessionData.playMode !== undefined) this.playMode = sessionData.playMode;
                        if (sessionData.strumEnabled !== undefined) this.strumEnabled = sessionData.strumEnabled;
                        if (sessionData.chordsEnabled !== undefined) this.chordsEnabled = sessionData.chordsEnabled;
                        if (sessionData.arpEnabled !== undefined) this.arpEnabled = sessionData.arpEnabled;
                        if (sessionData.bassEnabled !== undefined) this.bassEnabled = sessionData.bassEnabled;
                        
                        // ==== OSCILLATOR SETTINGS RESTORATION ====
                        if (sessionData.oscillators) {
                            if (sessionData.oscillators.osc1) Object.assign(this.oscillators.osc1, sessionData.oscillators.osc1);
                            if (sessionData.oscillators.osc2) Object.assign(this.oscillators.osc2, sessionData.oscillators.osc2);
                        }
                        if (sessionData.envelope) Object.assign(this.envelope, sessionData.envelope);
                        if (sessionData.osc2Envelope) Object.assign(this.osc2Envelope, sessionData.osc2Envelope);
                        
                        // ==== PER-INSTRUMENT SETTINGS RESTORATION ====
                        if (sessionData.instruments) {
                            if (sessionData.instruments.strum1) {
                                if (sessionData.instruments.strum1.osc) Object.assign(this.instruments.strum1.osc, sessionData.instruments.strum1.osc);
                                if (sessionData.instruments.strum1.env) Object.assign(this.instruments.strum1.env, sessionData.instruments.strum1.env);
                                if (sessionData.instruments.strum1.fxSend !== undefined) this.instruments.strum1.fxSend = sessionData.instruments.strum1.fxSend;
                            }
                            if (sessionData.instruments.strum2) {
                                if (sessionData.instruments.strum2.osc) Object.assign(this.instruments.strum2.osc, sessionData.instruments.strum2.osc);
                                if (sessionData.instruments.strum2.env) Object.assign(this.instruments.strum2.env, sessionData.instruments.strum2.env);
                                if (sessionData.instruments.strum2.fxSend !== undefined) this.instruments.strum2.fxSend = sessionData.instruments.strum2.fxSend;
                            }
                            if (sessionData.instruments.chord) {
                                if (sessionData.instruments.chord.osc) Object.assign(this.instruments.chord.osc, sessionData.instruments.chord.osc);
                                if (sessionData.instruments.chord.env) Object.assign(this.instruments.chord.env, sessionData.instruments.chord.env);
                                if (sessionData.instruments.chord.fxSend !== undefined) this.instruments.chord.fxSend = sessionData.instruments.chord.fxSend;
                            }
                            if (sessionData.instruments.arp) {
                                if (sessionData.instruments.arp.osc) Object.assign(this.instruments.arp.osc, sessionData.instruments.arp.osc);
                                if (sessionData.instruments.arp.env) Object.assign(this.instruments.arp.env, sessionData.instruments.arp.env);
                                if (sessionData.instruments.arp.fxSend !== undefined) this.instruments.arp.fxSend = sessionData.instruments.arp.fxSend;
                            }
                            if (sessionData.instruments.bass) {
                                if (sessionData.instruments.bass.osc) Object.assign(this.instruments.bass.osc, sessionData.instruments.bass.osc);
                                if (sessionData.instruments.bass.env) Object.assign(this.instruments.bass.env, sessionData.instruments.bass.env);
                                if (sessionData.instruments.bass.fxSend !== undefined) this.instruments.bass.fxSend = sessionData.instruments.bass.fxSend;
                            }
                        }
                        
                        // ==== AUDIO ENGINE STATE ====
                        if (sessionData.volume !== undefined) this.volume = sessionData.volume;
                        if (sessionData.masterVolume !== undefined) this.masterVolume = sessionData.masterVolume;
                        
                        // ==== ARP/SEQUENCER STATE RESTORATION ====
                        if (sessionData.arpSettings) {
                            if (!this._arp) this._arp = {};
                            Object.assign(this._arp, sessionData.arpSettings);
                        }
                        if (sessionData._isSequencing !== undefined) this._isSequencing = sessionData._isSequencing;
                        if (sessionData._sustainActive !== undefined) this._sustainActive = sessionData._sustainActive;
                        if (sessionData._chordsGestureActive !== undefined) this._chordsGestureActive = sessionData._chordsGestureActive;
                        
                        // ==== STRUM SETTINGS ====
                        if (sessionData.strumDelayMs !== undefined) this.strumDelayMs = sessionData.strumDelayMs;
                        if (sessionData.strumMode !== undefined) this.strumMode = sessionData.strumMode;
                        
                        // ==== SLIDE SETTINGS ====
                        if (sessionData._chordSlideEnabled !== undefined) this._chordSlideEnabled = sessionData._chordSlideEnabled;
                        if (sessionData._chordGlideMs !== undefined) this._chordGlideMs = sessionData._chordGlideMs;
                        
                        // ==== BASS SETTINGS ====
                        if (sessionData._heldBassEnabled !== undefined) this._heldBassEnabled = sessionData._heldBassEnabled;
                        
                        // ==== REVERB/PANNING OBJECT STATE ====
                        if (sessionData.reverb) Object.assign(this.reverb || {}, sessionData.reverb);
                        if (sessionData.panning) Object.assign(this.panning || {}, sessionData.panning);
                        
                        // ==== UI SYNCHRONIZATION ====
                        // Transport and timing settings
                        const setVal = (id, val, formatter) => {
                            const el = document.getElementById(id);
                            if (el) {
                                el.value = String(val);
                                const vEl = document.getElementById(id + "Value");
                                if (vEl && formatter) vEl.textContent = formatter(val);
                                el.dispatchEvent(new Event('input'));
                            }
                        };

                        // Apply BPM to the actual master transport (single source of truth).
                        const applyMasterBpmAfterLoad = (raw) => {
                            const bpm = Math.max(20, Math.min(300, parseInt(String(raw ?? ''), 10) || 120));
                            try { window.__MASTER_BPM = bpm; } catch (_) {}
                            // Update transport BPM first (it drives the rest via existing listeners)
                            try {
                                const tb = document.getElementById('transportBpm');
                                if (tb) {
                                    tb.value = String(bpm);
                                    tb.dispatchEvent(new Event('input'));
                                    tb.dispatchEvent(new Event('change'));
                                }
                            } catch (_) {}
                            // Also reflect into legacy/universal BPM fields (if present)
                            try {
                                const ub = document.getElementById('universalBpm');
                                if (ub) {
                                    ub.value = String(bpm);
                                    ub.dispatchEvent(new Event('input'));
                                    ub.dispatchEvent(new Event('change'));
                                }
                            } catch (_) {}
                            // Ensure internal timing refresh
                            try { this._refreshArpTransportTiming && this._refreshArpTransportTiming(); } catch (_) {}
                            return bpm;
                        };
                        
                        if (sessionData.bpm !== undefined || sessionData.transportBpm !== undefined) {
                            const bpmRaw = (sessionData.bpm !== undefined) ? sessionData.bpm : sessionData.transportBpm;
                            applyMasterBpmAfterLoad(bpmRaw);
                        }
                        if (sessionData.quantize !== undefined) {
                            const el = document.getElementById('universalQuant');
                            if (el) { el.value = sessionData.quantize; el.dispatchEvent(new Event('change')); }
                        }
                        if (sessionData.timeSignature !== undefined) {
                            const el = document.getElementById('universalTimeSignature');
                            if (el) { el.value = sessionData.timeSignature; el.dispatchEvent(new Event('change')); }
                        }
                        if (sessionData.pattern !== undefined) {
                            const el = document.getElementById('universalPattern');
                            if (el) { el.value = sessionData.pattern; el.dispatchEvent(new Event('change')); }
                        }
                        // Restore custom pattern text BEFORE NPC/other dependent recalcs, then trigger handler
                        if (sessionData.patternText !== undefined) {
                            const txt = document.getElementById('universalPatternText');
                            if (txt) { txt.value = sessionData.patternText; txt.dispatchEvent(new Event('change')); }
                        }
                        if (sessionData.loop !== undefined || sessionData.transportLoop !== undefined) {
                            const loopVal = (sessionData.loop !== undefined) ? !!sessionData.loop : !!sessionData.transportLoop;
                            const el = document.getElementById('playLoop');
                            if (el) { el.checked = loopVal; el.dispatchEvent(new Event('change')); }
                            // Also sync the transport loop toggle (top bar)
                            const t = document.getElementById('loopToggle');
                            if (t) { t.checked = loopVal; t.dispatchEvent(new Event('change')); }
                        }
                        if (sessionData.holdDuration !== undefined) {
                            const el = document.getElementById('chordHold');
                            if (el) { el.value = sessionData.holdDuration; el.dispatchEvent(new Event('change')); }
                        }
                        if (sessionData.universalHold !== undefined) {
                            const el = document.getElementById('universalHold');
                            if (el) { el.value = sessionData.universalHold; el.dispatchEvent(new Event('change')); }
                        }
                        if (sessionData.npc !== undefined) setVal('universalNpc', sessionData.npc);
                        
                        // Effects restoration
                        if (sessionData.fx) {
                            const fx = sessionData.fx;
                            if (fx.drive) {
                                setVal('driveAmount', fx.drive.amount, v => `${Math.round(v)}%`);
                                setVal('driveMix', fx.drive.mix, v => `${Math.round(v)}%`);
                                setVal('driveHpCutoff', fx.drive.hp);
                                setVal('driveLpCutoff', fx.drive.lp);
                            }
                            if (fx.delay) {
                                setVal('delayTime', fx.delay.timeMs, v => `${Math.round(v)}ms`);
                                setVal('delayFeedback', fx.delay.feedback, v => `${Math.round(v)}%`);
                                setVal('delayLpCutoff', fx.delay.lp);
                                setVal('delayHpCutoff', fx.delay.hp);
                                setVal('delayMix', fx.delay.mix, v => `${Math.round(v)}%`);
                            }
                            if (fx.filters) {
                                setVal('filterLow', fx.filters.low);
                                setVal('filterHigh', fx.filters.high);
                                setVal('filterRes', fx.filters.q, v => `Q ${Number(v).toFixed(1)}`);
                            }
                            if (fx.reverb) {
                                setVal('reverbWet', fx.reverb.wet, v => `${Math.round(v*10)}%`);
                                setVal('reverbRoom', fx.reverb.room, v => `${Math.round((v||0)*10)}%`);
                                setVal('reverbDecay', fx.reverb.decay, v => `${(Number(v)/10).toFixed(1)}s`);
                                setVal('reverbFilterCutoff', fx.reverb.lp);
                                setVal('reverbHpCutoff', fx.reverb.hp);
                            }
                            if (fx.panning) {
                                const pm = document.getElementById('panningMode');
                                if (pm) {
                                    pm.value = fx.panning.mode || 'center';
                                    pm.dispatchEvent(new Event('change'));
                                }
                                setVal('panningWidth', fx.panning.width, v => `${Math.round(v)}%`);
                                setVal('panningSpeed', fx.panning.speedMs, v => `${(Number(v)/1000).toFixed(1)}s`);
                            }
                        }

                        // Drum FX restoration (global drum bus)
                        try {
                            if (sessionData.drumFx && typeof sessionData.drumFx === 'object') {
                                const def = this.drumFx && typeof this.drumFx === 'object' ? this.drumFx : {};
                                const incoming = sessionData.drumFx;
                                const merged = {
                                    sat: { ...(def.sat||{}), ...(incoming.sat||{}) },
                                    comp: { ...(def.comp||{}), ...(incoming.comp||{}) },
                                    delay: { ...(def.delay||{}), ...(incoming.delay||{}) },
                                    reverb: { ...(def.reverb||{}), ...(incoming.reverb||{}) },
                                    out: (incoming.out != null ? incoming.out : def.out)
                                };
                                this.drumFx = merged;
                                try { this.updateDrumFx && this.updateDrumFx(); } catch(_){ }
                                try { this._wireDrumFxPanel && this._wireDrumFxPanel(); } catch(_){ }
                                try { this._applyDrumFxPanel && this._applyDrumFxPanel(); } catch(_){ }
                            }
                        } catch(_){ }
                        
                        // Update transpose UI label if present
                        try {
                            const deltaEl = document.getElementById('transposeDelta');
                            if (deltaEl && typeof this.transposeDelta === 'number') {
                                deltaEl.textContent = String(this.transposeDelta);
                            }
                        } catch(_) {}

                        // Checkboxes
                        if (sessionData.chordSlideEnabled !== undefined) {
                            const el = document.getElementById('chordSlide');
                            if (el) el.checked = sessionData.chordSlideEnabled;
                        }
                        
                        // FX Send checkboxes
                        if (sessionData.instruments) {
                            const checkboxes = [
                                ['strum1FxSend', sessionData.instruments.strum1?.fxSend],
                                ['strum2FxSend', sessionData.instruments.strum2?.fxSend],
                                ['chordFxSend', sessionData.instruments.chord?.fxSend],
                                ['arpFxSend', sessionData.instruments.arp?.fxSend],
                                ['bassFxSend', sessionData.instruments.bass?.fxSend]
                            ];
                            checkboxes.forEach(([id, value]) => {
                                if (value !== undefined) {
                                    const el = document.getElementById(id);
                                    if (el) el.checked = value;
                                }
                            });
                        }
                        
                        // Text input restoration
                        if (sessionData.textChordInput !== undefined) {
                            const el = document.getElementById('textChordInput');
                            if (el) el.value = sessionData.textChordInput;
                        }

                        // ==== DRUMS: RESTORE PATTERNS, ACTIVE SLOT, LANE CONTROLS, BASS ====
                        try {
                            const d = sessionData.drums || {};
                            // Restore pattern map then apply active pattern grid
                            if (d.patterns && typeof d.patterns === 'object') {
                                this._drumPatterns = new Map();
                                for (const k of Object.keys(d.patterns)) {
                                    const num = parseInt(k,10); if (!Number.isFinite(num) || num<1) continue;
                                    this._drumPatterns.set(num, d.patterns[k]);
                                }
                            }
                            const patEl = document.getElementById('drumPatternNumber');
                            if (patEl) {
                                const act = Math.max(1, parseInt((d.active!=null? d.active: patEl.value)||'1',10));
                                patEl.value = String(act);
                                // Apply grid for this pattern
                                const patt = this._drumPatterns ? this._drumPatterns.get(act) : null;
                                if (patt && Array.isArray(patt)) {
                                    const lanes = Array.from(document.querySelectorAll('.drum-row:not(.bass-row) .drum-lane'));
                                    lanes.forEach((lane, i)=>{
                                        const row = patt[i] || [];
                                        const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                        steps.forEach((s, j)=>{ if (row[j]) s.classList.add('active'); else s.classList.remove('active'); });
                                    });
                                    this._lastDrumPatternNumber = act;
                                }
                            }
                            // Per-lane controls
                            if (Array.isArray(d.laneControls)) {
                                const rows = Array.from(document.querySelectorAll('.drum-row:not(.bass-row)'));
                                d.laneControls.forEach((cfg, idx)=>{
                                    const row = rows[idx]; if (!row || !cfg) return;
                                    try {
                                        const vol = row.querySelector('.drum-volume'); if (vol && cfg.vol!=null) vol.value = String(cfg.vol);
                                        const sendEl = row.querySelector('.drum-send');
                                        const fx  = row.querySelector('.drum-fx input[type="checkbox"]');
                                        if (sendEl && cfg.send!=null) sendEl.value = String(cfg.send);
                                        else if (fx && typeof cfg.fx==='boolean') fx.checked = cfg.fx;
                                        const midi= row.querySelector('.drum-midi input[type="text"]'); if (midi && cfg.midi!=null) midi.value = String(cfg.midi);
                                        const pPitch = row.querySelector('.drum-params input[title$=" Pitch"]'); if (pPitch && cfg.pPitch!=null) pPitch.value = String(cfg.pPitch);
                                        const pAtk   = row.querySelector('.drum-params input[title$=" Attack"]'); if (pAtk && cfg.pAtk!=null) pAtk.value = String(cfg.pAtk);
                                        const pDec   = row.querySelector('.drum-params input[title$=" Decay"]'); if (pDec && cfg.pDec!=null) pDec.value = String(cfg.pDec);
                                    } catch(_){}
                                });
                            }
                            // Bass NPC/ties
                            if (Array.isArray(d.bass)) {
                                const bassLane = document.querySelector('.drum-row.bass-row .drum-lane');
                                if (bassLane) {
                                    const steps = Array.from(bassLane.querySelectorAll('.drum-step'));
                                    steps.forEach((s, i)=>{
                                        const cfg = d.bass[i]; if (!cfg) { s.classList.remove('active'); s.dataset.npc=''; delete s.dataset.len; return; }
                                        s.dataset.npc = cfg.npc || '';
                                        if (cfg.len!=null && cfg.len!=='') s.dataset.len = String(cfg.len); else delete s.dataset.len;
                                        if (cfg.on || (cfg.npc && cfg.npc.toLowerCase()!=='x')) s.classList.add('active'); else s.classList.remove('active');
                                    });
                                    try { this.rebuildBassTieOverlays(bassLane); } catch(_){ }
                                }
                            }
                        } catch(_){ }

                        // ==== MIDI ROUTING RESTORATION (per-section OUT selections etc.) ====
                        try {
                            const m = sessionData.midi || {};
                            if (m && window.midi) {
                                if (m.outputPortMap) window.midi.outputPortMap = { ...(window.midi.outputPortMap||{}), ...m.outputPortMap };
                                if (m.inputChannelMap) window.midi.inputChannelMap = { ...(window.midi.inputChannelMap||{}), ...m.inputChannelMap };
                                if (m.perSourceOctave) window.midi.perSourceOctave = { ...(window.midi.perSourceOctave||{}), ...m.perSourceOctave };
                                if (m.perSourceVelocity) window.midi.perSourceVelocity = { ...(window.midi.perSourceVelocity||{}), ...m.perSourceVelocity };
                                if (Number.isFinite(m.defaultVelocity)) window.midi.defaultVelocity = m.defaultVelocity|0;
                                if (Number.isFinite(m.octaveOffset)) window.midi.octaveOffset = m.octaveOffset|0;
                                if (m.channelMap) window.midi.channelMap = { ...(window.midi.channelMap||{}), ...m.channelMap };
                                // Try to reflect OUT selects in UI immediately
                                try {
                                    ['strum1','strum2','chord','arp','bass','bells','drum'].forEach(sec=>{
                                        const el = document.getElementById(`midiOut-${sec}`);
                                        if (el && el.tagName==='SELECT') {
                                            const id = window.midi.outputPortMap?.[sec] || '';
                                            el.value = id || '';
                                        }
                                    });
                                } catch(_){}
                            }
                        } catch(_){ }
                        
                        // ==== REGENERATE UI ====
                        this.regenerateChordGrid();
                        this.syncOscillatorUI();

                        // ==== RESTORE MULTI-INSTANCE STATE (PATTERN / DRUM) + MODAL GEOMETRY ====
                        try {
                            const applyPatternGrid = (modal, gridArr)=>{
                                try {
                                    if (!modal || !Array.isArray(gridArr)) return;
                                    const pg = (modal.querySelector('[data-role="patternGrid"]') || modal.querySelector('#patternGrid') || modal.querySelector('.pattern-grid'));
                                    if (!pg) return;
                                    const lanes = Array.from(pg.querySelectorAll('.pattern-lane'));
                                    lanes.forEach((lane, i)=>{
                                        const row = gridArr[i] || [];
                                        const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                                        steps.forEach((s, j)=>{
                                            const data = row[j];
                                            if (data && data.active) {
                                                s.classList.add('active');
                                                if (data.len) s.dataset.len = String(data.len); else delete s.dataset.len;
                                                if (data.tie) s.dataset.tie = '1'; else delete s.dataset.tie;
                                                if (data.npc) s.dataset.npc = String(data.npc); else delete s.dataset.npc;
                                                if (data.vel != null) s.dataset.vel = String(data.vel);
                                            } else {
                                                s.classList.remove('active');
                                                delete s.dataset.len;
                                                delete s.dataset.tie;
                                                delete s.dataset.npc;
                                            }
                                            try { if (window.updateStepVelocityClass) window.updateStepVelocityClass(s); } catch(_){ }
                                        });
                                        try { window.rebuildPatternTieOverlays && window.rebuildPatternTieOverlays(lane); } catch(_){ }
                                    });
                                } catch(_){ }
                            };

                            const applySynthState = (modal, instKey, state)=>{
                                try {
                                    if (!modal || !instKey || !state || typeof state !== 'object') return;
                                    const host = modal.querySelector('[data-role="tab-arp"]') || modal.querySelector('#tab-arp');
                                    if (host && state.wave) {
                                        const btn = host.querySelector(`.osc-btn[data-inst="${instKey}"][data-wave="${String(state.wave)}"]`);
                                        if (btn && typeof btn.click === 'function') btn.click();
                                    }
                                    const setInput = (id, val, evtName='input')=>{
                                        const el = modal.querySelector(`#${id}`);
                                        if (!el) return;
                                        el.value = String(val);
                                        try { el.dispatchEvent(new Event(evtName, { bubbles:true })); } catch(_){ }
                                    };
                                    const setCheck = (id, val)=>{
                                        const el = modal.querySelector(`#${id}`);
                                        if (!el) return;
                                        el.checked = !!val;
                                        try { el.dispatchEvent(new Event('change', { bubbles:true })); } catch(_){ }
                                    };
                                    const maybe = (key, fn)=>{ if (key in state) fn(state[key]); };

                                    maybe(`${instKey}PulseWidth`, (v)=>setInput(`${instKey}PulseWidth`, v));
                                    maybe(`${instKey}ShapeWidth`, (v)=>setInput(`${instKey}ShapeWidth`, v));
                                    maybe(`${instKey}Level`, (v)=>setInput(`${instKey}Level`, v));
                                    maybe(`${instKey}Detune`, (v)=>setInput(`${instKey}Detune`, v));
                                    maybe(`${instKey}Octave`, (v)=>setInput(`${instKey}Octave`, v));
                                    maybe(`${instKey}Coarse`, (v)=>setInput(`${instKey}Coarse`, v));
                                    maybe(`${instKey}AttackSlider`, (v)=>setInput(`${instKey}AttackSlider`, v));
                                    maybe(`${instKey}DecaySlider`, (v)=>setInput(`${instKey}DecaySlider`, v));
                                    maybe(`${instKey}SustainSlider`, (v)=>setInput(`${instKey}SustainSlider`, v));
                                    maybe(`${instKey}ReleaseSlider`, (v)=>setInput(`${instKey}ReleaseSlider`, v));
                                    maybe(`${instKey}FxSend`, (v)=>setCheck(`${instKey}FxSend`, v));

                                    if ('midiIn' in state) setInput(`midiIn-${instKey}`, state.midiIn, 'change');
                                    if ('midiOut' in state) setInput(`midiOut-${instKey}`, state.midiOut, 'change');
                                    if ('midiOct' in state) setInput(`midiOct-${instKey}`, state.midiOct, 'change');
                                    if ('midiVel' in state) setInput(`midiVel-${instKey}`, state.midiVel, 'change');
                                } catch(_){ }
                            };

                            const objToMap = (obj)=>{
                                const mp = new Map();
                                try {
                                    if (!obj || typeof obj !== 'object') return mp;
                                    for (const k of Object.keys(obj)) {
                                        const n = parseInt(k,10);
                                        if (!Number.isFinite(n) || n < 1) continue;
                                        mp.set(n, obj[k]);
                                    }
                                } catch(_){ }
                                return mp;
                            };

                            // Restore BASE pattern editor bank (PATTERN 1/2/3...) BEFORE instance spawns
                            try {
                                const pe = sessionData.patternEditor;
                                if (pe && typeof pe === 'object') {
                                    // Banks
                                    this._arpPatterns = objToMap(pe.patterns || {});
                                    this._arpSynthPatterns = objToMap(pe.synthPatterns || {});
                                    if (pe.lastArpPatternNumber != null) this._lastArpPatternNumber = pe.lastArpPatternNumber;

                                    // Modal enable state + ARP drawer
                                    const baseModal = document.getElementById('patternModal');
                                    if (baseModal) {
                                        if (pe.enabled != null) baseModal._patternEnabled = !!pe.enabled;
                                        baseModal._patternPendingEnabled = (pe.pendingEnabled != null) ? !!pe.pendingEnabled : null;
                                        try {
                                            const speakerBtn = document.getElementById('patternSpeakerBtn');
                                            if (speakerBtn) speakerBtn.textContent = baseModal._patternEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
                                        } catch(_){ }
                                        try {
                                            if (pe.arpPanelOpen != null) {
                                                const panel = document.getElementById('tab-arp');
                                                if (panel) panel.style.display = pe.arpPanelOpen ? 'block' : 'none';
                                            }
                                        } catch(_){ }
                                    }

                                    // Apply current slot + grid + synth state
                                    const patNumEl = document.getElementById('patternPatternNumber');
                                    const curNum = Math.max(1, parseInt((pe.currentPatternNumber != null ? pe.currentPatternNumber : (patNumEl ? patNumEl.value : 1)),10) || 1);
                                    if (patNumEl) patNumEl.value = String(curNum);
                                    try {
                                        const grid = (this._arpPatterns && typeof this._arpPatterns.get === 'function') ? this._arpPatterns.get(curNum) : null;
                                        if (grid) applyPatternGrid(document.getElementById('patternModal'), grid);
                                    } catch(_){ }
                                    try {
                                        const st = (this._arpSynthPatterns && typeof this._arpSynthPatterns.get === 'function') ? this._arpSynthPatterns.get(curNum) : null;
                                        if (st && typeof this._applyArpSynthUIState === 'function') this._applyArpSynthUIState(st);
                                    } catch(_){ }
                                }
                            } catch(_){ }

                            // Restore Pattern instances
                            if (Array.isArray(sessionData.patternInstances)) {
                                try {
                                    (window._patternInstances || []).forEach(info=>{
                                        try { if (info && info.modal) window.destroyPatternInstance && window.destroyPatternInstance(info.modal); } catch(_){ }
                                    });
                                } catch(_){ }
                                try { window._patternInstances = []; } catch(_){ }
                                try { window._patternInstanceCounter = 0; } catch(_){ }

                                sessionData.patternInstances.forEach(saved=>{
                                    try {
                                        const modal = window.spawnPatternInstance && window.spawnPatternInstance();
                                        if (!modal) return;
                                        const key = String(modal.dataset.patternInstanceKey || saved.key || '');
                                        if (!key) return;

                                        if (saved.displayName != null) modal._patternDisplayName = String(saved.displayName);
                                        if (saved.enabled != null) modal._patternEnabled = !!saved.enabled;
                                        modal._patternPendingEnabled = (saved.pendingEnabled != null) ? !!saved.pendingEnabled : null;
                                        if (saved.defaultSynthState) modal._defaultSynthState = saved.defaultSynthState;
                                        if (saved.lastArpPatternNumber != null) modal._lastArpPatternNumber = saved.lastArpPatternNumber;

                                        // Restore modal appearance/geometry
                                        try {
                                            if (saved.className) modal.className = String(saved.className);
                                            if (saved.modalStyleText != null) modal.setAttribute('style', String(saved.modalStyleText));
                                            if (saved.zIndex != null) modal.style.zIndex = String(saved.zIndex);
                                        } catch(_){ }

                                        // Restore arp drawer visibility
                                        try {
                                            if (saved.arpPanelOpen != null) {
                                                const panel = modal.querySelector('[data-role="tab-arp"]') || modal.querySelector('#tab-arp');
                                                if (panel) panel.style.display = saved.arpPanelOpen ? 'block' : 'none';
                                            }
                                        } catch(_){ }

                                        // Restore banks into omnichord
                                        try {
                                            this._arpPatternsByInst = this._arpPatternsByInst || {};
                                            this._arpSynthPatternsByInst = this._arpSynthPatternsByInst || {};
                                            this._arpPatternsByInst[key] = objToMap(saved.patterns || {});
                                            this._arpSynthPatternsByInst[key] = objToMap(saved.synthPatterns || {});
                                        } catch(_){ }

                                        // Apply current pattern selection + grid + synth
                                        const patNumEl = modal.querySelector('[data-role="patternPatternNumber"]') || modal.querySelector('#patternPatternNumber');
                                        const curNum = Math.max(1, parseInt((saved.currentPatternNumber != null ? saved.currentPatternNumber : (patNumEl ? patNumEl.value : 1)), 10) || 1);
                                        if (patNumEl) patNumEl.value = String(curNum);
                                        try {
                                            const mp = this._arpPatternsByInst && this._arpPatternsByInst[key];
                                            const grid = mp && typeof mp.get === 'function' ? mp.get(curNum) : null;
                                            if (grid) applyPatternGrid(modal, grid);
                                        } catch(_){ }
                                        try {
                                            const mpS = this._arpSynthPatternsByInst && this._arpSynthPatternsByInst[key];
                                            const st = mpS && typeof mpS.get === 'function' ? mpS.get(curNum) : null;
                                            if (st) applySynthState(modal, key, st);
                                        } catch(_){ }

                                        // Update strip button text and traffic state
                                        try {
                                            if (modal._stripBtn) {
                                                const label = modal._patternDisplayName ? String(modal._patternDisplayName) : modal._stripBtn.textContent;
                                                modal._stripBtn.textContent = label;
                                            }
                                        } catch(_){ }
                                        try { window._updatePatternInstanceButtonVisual && window._updatePatternInstanceButtonVisual(modal); } catch(_){ }
                                    } catch(_){ }
                                });
                            }

                            // Restore Drum instances
                            if (Array.isArray(sessionData.drumInstances)) {
                                try {
                                    window._suppressInstanceAutoOpen = true;
                                    // Remove existing instance buttons
                                    try {
                                        (window._drumInstances || []).forEach(inst=>{ try { inst && inst._stripBtn && inst._stripBtn.remove && inst._stripBtn.remove(); } catch(_){ } });
                                    } catch(_){ }
                                    window._drumInstances = [];
                                    window._drumInstanceCounter = 0;

                                    sessionData.drumInstances.forEach(saved=>{
                                        try {
                                            const inst = window.spawnDrumInstance && window.spawnDrumInstance();
                                            if (!inst || !saved) return;
                                            // Keep the existing button reference; overwrite serializable state
                                            const btn = inst._stripBtn;
                                            Object.assign(inst, saved);
                                            inst._stripBtn = btn;
                                            try { if (inst._stripBtn) inst._stripBtn.textContent = String(inst.name || inst._stripBtn.textContent); } catch(_){ }
                                            try { window._updateDrumInstanceButtonVisual && window._updateDrumInstanceButtonVisual(inst); } catch(_){ }
                                        } catch(_){ }
                                    });

                                    if (sessionData.activeDrumInstanceId != null) window._activeDrumInstanceId = sessionData.activeDrumInstanceId;
                                } catch(_){ }
                                try { window._suppressInstanceAutoOpen = false; } catch(_){ }
                            }

                            // Restore modal geometry/visibility snapshot (including base modals)
                            try {
                                const snap = sessionData.uiSnapshot || {};
                                const mods = Array.isArray(snap.modals) ? snap.modals : [];
                                const hasInlineProp = (styleText, prop)=>{
                                    try {
                                        if (!styleText) return false;
                                        const safe = String(prop || '').replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
                                        const re = new RegExp('(?:^|;\\s*)' + safe + '\\s*:', 'i');
                                        return re.test(String(styleText));
                                    } catch(_){ return false; }
                                };
                                mods.forEach(m=>{
                                    try {
                                        if (!m || !m.id) return;
                                        const el = document.getElementById(String(m.id));
                                        if (!el) return;
                                        if (m.className != null) el.className = String(m.className);
                                        if (m.styleText != null) el.setAttribute('style', String(m.styleText));

                                        // If geometry/visibility wasn't inline, apply computed snapshot as a fallback
                                        try {
                                            const styleText = (m.styleText != null) ? String(m.styleText) : (el.getAttribute('style') || '');
                                            const c = m.computed || null;
                                            if (c) {
                                                if (c.display && !hasInlineProp(styleText, 'display')) el.style.display = String(c.display);
                                                if (c.left && !hasInlineProp(styleText, 'left')) el.style.left = String(c.left);
                                                if (c.top && !hasInlineProp(styleText, 'top')) el.style.top = String(c.top);
                                                if (c.width && !hasInlineProp(styleText, 'width')) el.style.width = String(c.width);
                                                if (c.height && !hasInlineProp(styleText, 'height')) el.style.height = String(c.height);
                                                if (c.zIndex && !hasInlineProp(styleText, 'z-index')) el.style.zIndex = String(c.zIndex);
                                                if (c.opacity && !hasInlineProp(styleText, 'opacity')) el.style.opacity = String(c.opacity);
                                            }
                                        } catch(_){ }

                                        // Restore modal scroll positions after layout settles
                                        try {
                                            const st = (m.scrollTop != null) ? Number(m.scrollTop) : null;
                                            const sl = (m.scrollLeft != null) ? Number(m.scrollLeft) : null;
                                            if ((st != null && !isNaN(st)) || (sl != null && !isNaN(sl))) {
                                                setTimeout(()=>{
                                                    try {
                                                        if (st != null && !isNaN(st)) el.scrollTop = st;
                                                        if (sl != null && !isNaN(sl)) el.scrollLeft = sl;
                                                    } catch(_){ }
                                                }, 0);
                                            }
                                        } catch(_){ }
                                    } catch(_){ }
                                });
                            } catch(_){ }

                            // Restore generic control values (sliders, selects, checkboxes...) by id
                            try {
                                const snap = sessionData.uiSnapshot || {};
                                if (snap.htmlClassName != null && document.documentElement) document.documentElement.className = String(snap.htmlClassName);
                                if (snap.bodyClassName != null && document.body) document.body.className = String(snap.bodyClassName);

                                const controls = snap.controls || {};
                                Object.keys(controls).forEach(id=>{
                                    try {
                                        const rec = controls[id];
                                        const el = document.getElementById(id);
                                        if (!el || !rec) return;
                                        const tag = String(rec.tag||'');
                                        const type = String(rec.type||'');
                                        if (tag === 'input' && (type === 'checkbox' || type === 'radio')) {
                                            if ('checked' in rec) el.checked = !!rec.checked;
                                            try { el.dispatchEvent(new Event('change', { bubbles:true })); } catch(_){ }
                                        } else {
                                            if ('value' in rec) el.value = String(rec.value);
                                            try { el.dispatchEvent(new Event('input', { bubbles:true })); } catch(_){ }
                                            try { el.dispatchEvent(new Event('change', { bubbles:true })); } catch(_){ }
                                        }
                                    } catch(_){ }
                                });

                                // Restore contenteditable values (e.g., slider value labels)
                                try {
                                    const ce = snap.contentEditables || {};
                                    Object.keys(ce).forEach(id=>{
                                        try {
                                            const rec = ce[id];
                                            const el = document.getElementById(id);
                                            if (!el || !rec) return;
                                            if (el.getAttribute && el.getAttribute('contenteditable') !== 'true') return;
                                            if ('text' in rec) el.textContent = String(rec.text);
                                            try { el.dispatchEvent(new Event('input', { bubbles:true })); } catch(_){ }
                                            try { el.dispatchEvent(new Event('change', { bubbles:true })); } catch(_){ }
                                        } catch(_){ }
                                    });
                                } catch(_){ }

                                // Restore basic state for other id elements (toggles, etc.)
                                try {
                                    const es = snap.elementStateById || {};
                                    Object.keys(es).forEach(id=>{
                                        try {
                                            const rec = es[id];
                                            const el = document.getElementById(id);
                                            if (!el || !rec) return;
                                            if (el.classList && el.classList.contains('floating-modal')) return;
                                            if (rec.className != null) el.className = String(rec.className);
                                            if (rec.styleText != null && String(rec.styleText)) el.setAttribute('style', String(rec.styleText));
                                            if (rec.ariaPressed != null) el.setAttribute('aria-pressed', String(rec.ariaPressed));
                                            if (rec.ariaExpanded != null) el.setAttribute('aria-expanded', String(rec.ariaExpanded));
                                        } catch(_){ }
                                    });
                                } catch(_){ }

                                // Restore window scroll and active focus last
                                try {
                                    const sc = snap.scroll || null;
                                    if (sc && (sc.x != null || sc.y != null) && window.scrollTo) {
                                        const x = (sc.x != null) ? Number(sc.x) : 0;
                                        const y = (sc.y != null) ? Number(sc.y) : 0;
                                        window.scrollTo(isNaN(x)?0:x, isNaN(y)?0:y);
                                    }
                                } catch(_){ }
                                try {
                                    const aeId = snap.activeElementId ? String(snap.activeElementId) : '';
                                    if (aeId) {
                                        const el = document.getElementById(aeId);
                                        if (el && typeof el.focus === 'function') el.focus();
                                    }
                                } catch(_){ }

                                // IMPORTANT: UI snapshot restoration can fire input/change handlers (e.g., NPC/LEN)
                                // that rebuild the Pattern grid and wipe dots. Re-apply base Pattern bank last.
                                try {
                                    const pe = sessionData.patternEditor;
                                    if (pe && typeof pe === 'object' && this._arpPatterns && typeof this._arpPatterns.get === 'function') {
                                        const reapplyBasePattern = ()=>{
                                            try {
                                                const patNumEl = document.getElementById('patternPatternNumber');
                                                const curNum = Math.max(1, parseInt((pe.currentPatternNumber != null ? pe.currentPatternNumber : (patNumEl ? patNumEl.value : 1)), 10) || 1);
                                                if (patNumEl) patNumEl.value = String(curNum);
                                                const grid = this._arpPatterns.get(curNum);
                                                if (grid) applyPatternGrid(document.getElementById('patternModal'), grid);
                                                const st = (this._arpSynthPatterns && typeof this._arpSynthPatterns.get === 'function') ? this._arpSynthPatterns.get(curNum) : null;
                                                if (st && typeof this._applyArpSynthUIState === 'function') this._applyArpSynthUIState(st);
                                                try {
                                                    const pg = document.getElementById('patternGrid');
                                                    if (pg && typeof pg._recomputePatternText === 'function') pg._recomputePatternText();
                                                } catch(_){ }
                                            } catch(_){ }
                                        };
                                        setTimeout(reapplyBasePattern, 0);
                                        setTimeout(reapplyBasePattern, 80);
                                    }
                                } catch(_){ }

                                // Also re-apply Pattern INSTANCE dots after UI snapshot restore, because restoring
                                // inputs can trigger rebuilds that wipe instance grids too.
                                try {
                                    const savedInst = Array.isArray(sessionData.patternInstances) ? sessionData.patternInstances : [];
                                    if (savedInst.length) {
                                        const reapplyInstances = ()=>{
                                            try {
                                                savedInst.forEach(saved=>{
                                                    try {
                                                        const key = saved && saved.key ? String(saved.key) : '';
                                                        if (!key) return;
                                                        const modal = document.getElementById(`patternModal_${key}`) || document.querySelector(`.floating-modal[data-pattern-instance-key="${key}"]`);
                                                        if (!modal) return;
                                                        const patNumEl = modal.querySelector('[data-role="patternPatternNumber"]') || modal.querySelector('#patternPatternNumber');
                                                        const curNum = Math.max(1, parseInt((saved.currentPatternNumber != null ? saved.currentPatternNumber : (patNumEl ? patNumEl.value : 1)), 10) || 1);
                                                        if (patNumEl) patNumEl.value = String(curNum);
                                                        const mp = this._arpPatternsByInst && this._arpPatternsByInst[key];
                                                        const grid = mp && typeof mp.get === 'function' ? mp.get(curNum) : null;
                                                        if (grid) applyPatternGrid(modal, grid);
                                                        const mpS = this._arpSynthPatternsByInst && this._arpSynthPatternsByInst[key];
                                                        const st = mpS && typeof mpS.get === 'function' ? mpS.get(curNum) : null;
                                                        if (st) applySynthState(modal, key, st);
                                                    } catch(_){ }
                                                });
                                            } catch(_){ }
                                        };
                                        setTimeout(reapplyInstances, 0);
                                        setTimeout(reapplyInstances, 120);
                                    }
                                } catch(_){ }
                            } catch(_){ }
                        } catch(_){ }

                        // ---- SILENCE AFTER LOAD (prevent auto drum/arp start) ----
                        try {
                            // Stop any lingering voices
                            this.stopAll && this.stopAll();
                        } catch(_) {}
                        try { this.stopAllDrums && this.stopAllDrums(); } catch(_) {}
                        try { this._stopArpTransport && this._stopArpTransport(); } catch(_) {}
                        try { this._isSequencing = false; } catch(_) {}
                        try { this.isPlaying = false; } catch(_) {}
                        try { this.playMode = this.playMode; } catch(_) {}
                        // Clear any queued next chord / bass state
                        try { this._pendingArpChord = null; } catch(_){ }
                        try { this._heldBassVoice = null; } catch(_){ }
                        // Reflect play button UI if present
                        try {
                            const playBtn = document.getElementById('playButton');
                            if (playBtn) {
                                playBtn.classList.remove('active');
                                playBtn.textContent = 'PLAY';
                            }
                        } catch(_) {}
                        // Ensure drum transport indicator off
                        try {
                            const drumPlay = document.getElementById('drumPlayButton');
                            if (drumPlay) {
                                drumPlay.classList.remove('active');
                                drumPlay.textContent = 'DRUMS';
                            }
                        } catch(_) {}
                        // ---- END SILENCE AFTER LOAD ----

                        // ==== VISUAL CHORD SEQUENCE RESTORATION (if available) ====
                        if (sessionData.visualChordSequence && sessionData.visualChordSequence.length > 0) {
                            console.log('ðŸŽµ Restoring visual chord sequence:', sessionData.visualChordSequence.length, 'chords');
                            // The regenerateChordGrid() above should handle this through the restored chordExtensions
                        }
                        
                        console.log('âœ… Session restoration completed (silent)');
                        // Optionally restart playback in a safe state (left stopped for user to decide)
                        resolve(sessionData);
                        
                    } catch (error) {
                        console.error('Error loading session file:', error);
                        alert('Error loading session: ' + error.message);
                        reject(error);
                    }
                };
                
                reader.onerror = (err) => { reject(err); };
                reader.readAsText(file);
                });
            }
            // Legacy alias
            loadSessionFromOMG(event){ return this.importXenState(event); }
            
            syncOscillatorUI() {
                // Sync all oscillator and envelope UI elements with current state
                const syncOscUi = (num, data) => {
                    if (!data) return;
                    try {
                        // Wave type buttons
                        const waveButtons = document.querySelectorAll(`[data-osc="${num}"]`);
                        waveButtons.forEach(btn => btn.classList.remove('active'));
                        const activeWaveBtn = document.querySelector(`[data-osc="${num}"][data-wave="${data.type}"]`);
                        if (activeWaveBtn) activeWaveBtn.classList.add('active');
                        
                        // Level, Detune, Octave, Coarse sliders
                        const setSliderAndLabel = (sliderId, labelId, value, formatter) => {
                            const slider = document.getElementById(sliderId);
                            const label = document.getElementById(labelId);
                            if (slider) slider.value = String(value);
                            if (label && formatter) label.textContent = formatter(value);
                        };
                        
                        setSliderAndLabel(`osc${num}Level`, `osc${num}LevelValue`, Math.round(data.level * 10), v => `${v}`);
                        setSliderAndLabel(`osc${num}Detune`, `osc${num}DetuneValue`, data.detune, v => `${v}Â¢`);
                        setSliderAndLabel(`osc${num}Octave`, `osc${num}OctaveValue`, data.octave, v => `${v >= 0 ? '+' : ''}${v}`);
                        setSliderAndLabel(`osc${num}Coarse`, `osc${num}CoarseValue`, data.coarse, v => `${v >= 0 ? '+' : ''}${v}`);
                        setSliderAndLabel(`osc${num}PulseWidth`, `osc${num}PulseWidthValue`, Math.round(data.pulseWidth * 100), v => `${v}%`);
                        setSliderAndLabel(`osc${num}ShapeWidth`, `osc${num}ShapeWidthValue`, Math.round(data.shapeWidth * 100), v => `${v}%`);
                        
                        // Show/hide pulse width controls
                        const pulseWidthContainer = document.querySelector(`.pulse-width-container[data-osc="${num}"]`);
                        if (pulseWidthContainer) {
                            pulseWidthContainer.style.display = (data.type === 'pulse') ? 'block' : 'none';
                        }
                    } catch(e) {
                        console.error(`Error syncing osc${num} UI:`, e);
                    }
                };
                
                // Sync ADSR displays
                const syncADSR = (attackId, decayId, sustainId, releaseId, attackValId, decayValId, sustainValId, releaseValId, envData) => {
                    if (!envData) return;
                    try {
                        const setADSR = (id, valId, value, formatter) => {
                            const el = document.getElementById(id);
                            const valEl = document.getElementById(valId);
                            if (el) el.value = String(formatter ? formatter(value) : value);
                            if (valEl) valEl.textContent = formatter ? formatter(value) : String(value);
                        };
                        
                        setADSR(attackId, attackValId, envData.attack, v => Math.round(v * 1000));
                        setADSR(decayId, decayValId, envData.decay, v => Math.round(v * 1000));
                        setADSR(sustainId, sustainValId, envData.sustain, v => Math.round(v * 100));
                        setADSR(releaseId, releaseValId, envData.release, v => Math.round(v * 1000));
                    } catch(e) {
                        console.error('Error syncing ADSR UI:', e);
                    }
                };
                
                // Sync oscillators
                syncOscUi(1, this.oscillators.osc1);
                syncOscUi(2, this.oscillators.osc2);
                
                // Sync ADSR envelopes
                syncADSR('attackSlider', 'decaySlider', 'sustainSlider', 'releaseSlider',
                        'attackValue', 'decayValue', 'sustainValue', 'releaseValue', 
                        this.instruments.strum1.env);
                        
                syncADSR('osc2AttackSlider', 'osc2DecaySlider', 'osc2SustainSlider', 'osc2ReleaseSlider',
                        'osc2AttackValue', 'osc2DecayValue', 'osc2SustainValue', 'osc2ReleaseValue', 
                        this.instruments.strum2.env);
                        
                // Sync per-instrument ADSR
                if (this.instruments.chord) {
                    syncADSR('chordAttackSlider', 'chordDecaySlider', 'chordSustainSlider', 'chordReleaseSlider',
                            'chordAttackValue', 'chordDecayValue', 'chordSustainValue', 'chordReleaseValue', 
                            this.instruments.chord.env);
                }
                if (this.instruments.arp) {
                    syncADSR('arpAttackSlider', 'arpDecaySlider', 'arpSustainSlider', 'arpReleaseSlider',
                            'arpAttackValue', 'arpDecayValue', 'arpSustainValue', 'arpReleaseValue', 
                            this.instruments.arp.env);
                }
                if (this.instruments.bass) {
                    syncADSR('bassAttackSlider', 'bassDecaySlider', 'bassSustainSlider', 'bassReleaseSlider',
                            'bassAttackValue', 'bassDecayValue', 'bassSustainValue', 'bassReleaseValue', 
                            this.instruments.bass.env);
                }
                
                console.log('ðŸŽµ Oscillator and envelope UI synchronized');
            }

            importChordConfiguration(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);
                        
                        if (config.chordExtensions) {
                            this.chordExtensions = config.chordExtensions;
                        }
                        if (config.customChords) {
                            this.customChords = config.customChords;
                        }
                        if (config.hiddenColumns) {
                            this.hiddenColumns = config.hiddenColumns;
                        }
                        
                        this.saveChordConfiguration();
                        this.generateExtensionColumns();
                        
                        alert('Configuration imported successfully!');
                    } catch (error) {
                        alert('Error importing configuration: Invalid file format');
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = '';
            }

            resetToDefaults() {
                if (confirm('Reset completely? This will remove ALL chords and start fresh.')) {
                    // Clear all storage
                    
                    // Reset to completely empty state
                    this.chordExtensions = [];
                    this.customChords = [];
                    this.hiddenColumns = [];
                    this.lockedChords = new Map();
                    this.savedLockedChords = [];
                    this.currentEditingColumn = null;
                    
                    // Start in chord creation mode since no chords exist
                    this.enterChordCreationMode();
                    
                    alert('Reset complete - you can now create chords from scratch');
                }
            }

            hideColumn() {
                if (!this.hiddenColumns) this.hiddenColumns = [];
                const columnId = this.currentEditingColumn.id || this.currentEditingColumn.name.toLowerCase();
                
                if (!this.hiddenColumns.includes(columnId)) {
                    this.hiddenColumns.push(columnId);
                    this.generateExtensionColumns();
                }
            }

            addToFavorites() {
                if (!this.favoriteChords) this.favoriteChords = [];
                
                const favoriteChord = {
                    name: this.currentEditingColumn.name,
                    originalName: this.currentEditingColumn.originalName || this.currentEditingColumn.name,
                    extensions: this.currentEditingColumn.extensions || [],
                    quality: this.currentEditingColumn.quality,
                    intervals: this.currentEditingColumn.intervals,
                    root: this.currentRoot, // Store current root note
                    isCustom: this.currentEditingColumn.isCustom || false,
                    addedAt: Date.now()
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    fav.quality === favoriteChord.quality &&
                    fav.root === favoriteChord.root
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    this.generateExtensionColumns();
                    console.log(`Added "${favoriteChord.name}" to favorites with root ${this.getNoteNames()[favoriteChord.root]}`);
                } else {
                    alert('This chord with this root is already in favorites!');
                }
            }

            addCurrentChordToFavorites() {
                const chordName = document.getElementById('customChordName').value.trim();
                if (!chordName) {
                    alert('Please enter a chord name first!');
                    return;
                }
                
                const selectedNotes = this.getSelectedNotes();
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note!');
                    return;
                }
                
                if (!this.favoriteChords) this.favoriteChords = [];
                
                const favoriteChord = {
                    name: chordName,
                    originalName: chordName,
                    extensions: [],
                    quality: this.currentQuality,
                    intervals: selectedNotes,
                    notes: selectedNotes,
                    root: this.currentRoot,
                    isCustom: true,
                    addedAt: Date.now(),
                    tuning: this.currentTuning
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    fav.quality === favoriteChord.quality &&
                    fav.root === favoriteChord.root
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    this.updateFavoritesDisplay();
                    console.log(`Added "${favoriteChord.name}" to favorites`);
                    alert(`Added "${favoriteChord.name}" to favorites!`);
                } else {
                    alert('This chord is already in favorites!');
                }
            }
            
            updateFavoritesDisplay() {
                const favoritesList = document.getElementById('favoriteChordsList');
                if (!favoritesList) return;
                
                favoritesList.innerHTML = '';
                
                if (!this.favoriteChords || this.favoriteChords.length === 0) {
                    favoritesList.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #8fb3d3; font-style: italic; padding: 20px;">No favorite chords yet</div>';
                    return;
                }
                
                this.favoriteChords.forEach((chord, index) => {
                    const chordElement = document.createElement('div');
                    chordElement.style.cssText = `
                        background: linear-gradient(135deg, #f39c12, #e67e22);
                        border: 1px solid #d68910;
                        border-radius: 6px;
                        padding: 8px;
                        text-align: center;
                        cursor: pointer;
                        font-size: 12px;
                        color: #fff;
                        position: relative;
                        transition: all 0.2s ease;
                        user-select: none;
                    `;
                    
                    chordElement.innerHTML = `
                        <div style="font-weight: bold;">${chord.name}</div>
                        <div style="font-size: 10px; opacity: 0.8;">${this.getNoteNames()[chord.root] || 'C'} ${chord.quality}</div>
                        <div style="position: absolute; top: 2px; right: 2px; background: rgba(0,0,0,0.3); border-radius: 50%; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; font-size: 10px; cursor: pointer;" class="remove-favorite" data-index="${index}"> </div>
                    `;
                    
                    // Play chord on click
                    chordElement.addEventListener('click', (e) => {
                        if (e.target.classList.contains('remove-favorite')) return;
                        this.playChord(chord.intervals || chord.notes, chord.root);
                    });
                    
                    // Hover effects
                    chordElement.addEventListener('mouseenter', () => {
                        chordElement.style.transform = 'scale(1.05)';
                        chordElement.style.boxShadow = '0 4px 12px rgba(243, 156, 18, 0.4)';
                    });
                    
                    chordElement.addEventListener('mouseleave', () => {
                        chordElement.style.transform = 'scale(1)';
                        chordElement.style.boxShadow = 'none';
                    });
                    
                    favoritesList.appendChild(chordElement);
                });
                
                // Add remove functionality
                favoritesList.addEventListener('click', (e) => {
                    if (e.target.classList.contains('remove-favorite')) {
                        const index = parseInt(e.target.dataset.index);
                        this.removeFavoriteChord(index);
                    }
                });
            }
            
            removeFavoriteChord(index) {
                if (confirm('Remove this chord from favorites?')) {
                    this.favoriteChords.splice(index, 1);
                    this.updateFavoritesDisplay();
                }
            }
            
            getSelectedNotes() {
                const selector = document.getElementById('edoNoteSelector');
                if (!selector) return [];
                
                const selectedButtons = selector.querySelectorAll('.note-btn.selected');
                return Array.from(selectedButtons).map(btn => parseInt(btn.dataset.note));
            }

            removeFromFavorites() {
                if (this.currentEditingColumn.favoriteIndex !== undefined) {
                    const favoriteName = this.favoriteChords[this.currentEditingColumn.favoriteIndex].name;
                    this.favoriteChords.splice(this.currentEditingColumn.favoriteIndex, 1);
                    this.generateExtensionColumns();
                }
            }

            addToPalette() {
                if (!this.paletteChords) this.paletteChords = [];
                
                const noteNames = this.getNoteNames();
                const rootName = noteNames[this.currentRoot] || this.currentRoot;
                
                // Generate the actual chord intervals for this column
                let chordIntervals = [];
                if (this.currentEditingColumn.intervals && this.currentEditingColumn.intervals.length > 0) {
                    // Use stored intervals (for custom chords)
                    chordIntervals = this.currentEditingColumn.intervals;
                } else {
                    // Generate intervals from extensions and quality (for standard chords)
                    const originalQuality = this.currentQuality;
                    this.currentQuality = this.currentEditingColumn.quality || 'major';
                    chordIntervals = this.getChordIntervals(this.currentEditingColumn.extensions || []);
                    // Convert EDO steps back to semitones for storage
                    chordIntervals = chordIntervals.map(step => (step * 12) / this.currentTuning);
                    this.currentQuality = originalQuality;
                }
                
                const paletteChord = {
                    name: this.currentEditingColumn.name,
                    fullName: `${rootName}${this.currentEditingColumn.name}`,
                    extensions: this.currentEditingColumn.extensions || [],
                    quality: this.currentEditingColumn.quality || 'major',
                    rootNote: this.currentRoot,
                    originalName: this.currentEditingColumn.originalName || this.currentEditingColumn.name,
                    isCustom: this.currentEditingColumn.isCustom || false,
                    intervals: chordIntervals,
                    root: this.currentRoot,
                    lockedTuning: this.currentTuning,
                    lockedGamelanMode: this.gamelanMode
                };
                
                // Always allow adding chords to create sequences
                this.paletteChords.push(paletteChord);
                this.renderPaletteChords();
                console.log(`Added "${paletteChord.fullName}" to palette with intervals:`, chordIntervals);
            }

            deleteColumn() {
                console.log('?? deleteColumn called, currentEditingColumn:', this.currentEditingColumn);
                
                if (!this.currentEditingColumn) {
                    console.error('?? No currentEditingColumn set for deleteColumn');
                    alert('Error: No column selected for deletion');
                    return;
                }
                
                if (this.currentEditingColumn.isCustom) {
                    console.log('?? Deleting custom chord:', this.currentEditingColumn.name);
                    if (confirm(`Delete custom column "${this.currentEditingColumn.name}"?`)) {
                        const index = this.customChords.findIndex(chord => chord.name === this.currentEditingColumn.name);
                        console.log('?? Found custom chord at index:', index);
                        if (index !== -1) {
                            this.customChords.splice(index, 1);
                            console.log('?? Custom chord deleted, regenerating columns');
                            this.generateExtensionColumns();
                            // Custom chords automatically appear in extensions
                        } else {
                            console.error('?? Custom chord not found for deletion');
                            alert('Error: Custom chord not found for deletion');
                        }
                    }
                } else {
                    console.log('?? Deleting standard chord:', this.currentEditingColumn.originalName || this.currentEditingColumn.name);
                    // Allow deleting standard chord columns too
                    if (confirm(`Delete column "${this.currentEditingColumn.originalName || this.currentEditingColumn.name}"? This will remove all 3 flavors (Maj/Neu/Min) permanently.`)) {
                        // Use extension index if available, otherwise find by name
                        let index = -1;
                        if (this.currentEditingColumn.extensionIndex !== undefined) {
                            index = this.currentEditingColumn.extensionIndex;
                            console.log('?? Using extensionIndex:', index);
                        } else {
                            const searchName = this.currentEditingColumn.originalName || this.currentEditingColumn.name;
                            index = this.chordExtensions.findIndex(ext => 
                                ext.name === searchName || ext.name.toLowerCase() === searchName.toLowerCase()
                            );
                            console.log('?? Found extension by name at index:', index);
                        }
                        
                        if (index !== -1 && index < this.chordExtensions.length) {
                            console.log('?? Deleting chord extension at index:', index);
                            this.chordExtensions.splice(index, 1);
                            this.saveChordConfiguration();
                            this.generateExtensionColumns();
                            // Force rebuild of chord grid to eliminate gaps
                            this._rebuildChordGridAfterDeletion();
                            console.log(`?? Deleted chord extension at index ${index}`);
                        } else {
                            console.error('?? Could not find chord extension to delete:', this.currentEditingColumn);
                            alert('Error: Could not find chord extension to delete');
                        }
                    }
                }
            }

            // Enhanced method to rebuild chord grid and eliminate gaps after deletion
            _rebuildChordGridAfterDeletion() {
                try {
                    const container = document.getElementById('extensionColumns');
                    if (!container) return;
                    
                    console.log('ðŸŽµ Rebuilding chord grid after deletion');
                    
                    // Remove any empty columns or placeholders
                    const allElements = Array.from(container.children);
                    allElements.forEach(element => {
                        // Remove empty extension columns
                        if (element.classList.contains('extension-column')) {
                            const header = element.querySelector('.extension-header');
                            const strings = element.querySelector('.strings-column');
                            if (!header || !strings || !header.textContent.trim()) {
                                console.log('ðŸŽµ Removing empty chord column');
                                element.remove();
                            }
                        }
                    });
                    
                    // Regenerate the layout to ensure proper spacing and bracket positioning
                    setTimeout(() => {
                        this.generateExtensionColumns();
                        // Re-enable chord column drop zones
                        if (typeof makeChordColumnsDroppable === 'function') {
                            makeChordColumnsDroppable();
                        }
                        // Ensure chord visibility after rebuild
                        if (typeof ensureChordVisibility === 'function') {
                            ensureChordVisibility();
                        }
                    }, 50);
                } catch (e) {
                    console.error('Error rebuilding chord grid:', e);
                }
            }
            
            // Update bracket positions in data model after drag and drop
            _updateBracketPositions() {
                try {
                    const container = document.getElementById('extensionColumns');
                    if (!container) return;
                    
                    // Get current order of all elements
                    const elements = Array.from(container.children);
                    const newExtensions = [];
                    
                    elements.forEach((element, index) => {
                        if (element.classList.contains('extension-column')) {
                            // Find corresponding chord in data model
                            const chordId = element.dataset && element.dataset.chordId ? String(element.dataset.chordId) : null;
                            let existingChord = null;
                            if (chordId) {
                                existingChord = (this.chordExtensions || []).find(ext => String(ext.id) === chordId);
                            }
                            // Fallback strictly by originalPosition index when id missing
                            if (!existingChord && element.dataset && element.dataset.originalPosition != null) {
                                const op = parseInt(element.dataset.originalPosition, 10);
                                if (!isNaN(op) && op >= 0 && op < (this.chordExtensions?.length || 0)) {
                                    existingChord = this.chordExtensions[op];
                                }
                            }
                            // As a last resort, match by name but only among non-repeat entries
                            if (!existingChord) {
                                const nameEl = element.querySelector('.extension-header .chord-name');
                                const chordName = (nameEl ? nameEl.textContent : '').trim();
                                existingChord = (this.chordExtensions || []).find(ext => !ext.isRepeatMarker && String(ext.name).trim() === chordName);
                            }
                            if (existingChord) {
                                // Preserve the exact object with updated position to keep references and IDs stable
                                existingChord.position = newExtensions.length;
                                newExtensions.push(existingChord);
                            }
                        } else if (element.classList.contains('repeat-marker-column')) {
                            // Add bracket marker to data model
                            const markerText = element.textContent.trim();
                            const nestLevel = parseInt(element.dataset.nestLevel || '0');
                            const repeatCount = parseInt(element.dataset.repeatCount || '0');
                            
                            newExtensions.push({
                                name: markerText,
                                isCustom: true,
                                isRepeatMarker: true,
                                nestLevel: nestLevel,
                                repeatCount: repeatCount,
                                position: newExtensions.length
                            });
                        }
                    });
                    
                    // Update the data model
                    this.chordExtensions = newExtensions;
                    this.saveChordConfiguration();
                    
                    console.log('ðŸŽµ Updated bracket positions in data model');
                } catch (e) {
                    console.error('Error updating bracket positions:', e);
                }
            }

            // Bracket-aware navigation functionality for transport controls
            navigateChord(direction) {
                try {
                    const container = document.getElementById('extensionColumns');
                    if (!container) return;
                    
                    // Get all columns including bracket markers
                    const allElements = Array.from(container.querySelectorAll('.extension-column, .repeat-marker-column'));
                    const chordColumns = allElements.filter(el => el.classList.contains('extension-column'));
                    if (chordColumns.length === 0) return;
                    
                    // Find bracket sections - sections start after '[' markers
                    const bracketSections = [];
                    let currentSection = [];
                    
                    for (let i = 0; i < allElements.length; i++) {
                        const element = allElements[i];
                        
                        if (element.classList.contains('repeat-marker-column')) {
                            const text = element.textContent?.trim();
                            if (text === '[') {
                                // Start new section
                                if (currentSection.length > 0) {
                                    bracketSections.push(currentSection);
                                }
                                currentSection = [];
                            } else if (text === ']' || /^\]x\d+$/.test(text)) {
                                // End current section
                                if (currentSection.length > 0) {
                                    bracketSections.push(currentSection);
                                    currentSection = [];
                                }
                            }
                        } else if (element.classList.contains('extension-column')) {
                            // Add chord to current section
                            currentSection.push(element);
                        }
                    }
                    
                    // Add any remaining chords as final section
                    if (currentSection.length > 0) {
                        bracketSections.push(currentSection);
                    }
                    
                    // If no bracket sections found, fall back to all chords as one section
                    if (bracketSections.length === 0) {
                        bracketSections.push(chordColumns);
                    }
                    
                    // Find current section
                    let currentSectionIndex = -1;
                    const activeColumn = chordColumns.find(col => 
                        col.classList.contains('active') || col.classList.contains('playing')
                    );
                    
                    if (activeColumn) {
                        for (let i = 0; i < bracketSections.length; i++) {
                            if (bracketSections[i].includes(activeColumn)) {
                                currentSectionIndex = i;
                                break;
                            }
                        }
                    }
                    
                    // Calculate target section
                    let targetSectionIndex = currentSectionIndex + direction;
                    
                    // Handle looping
                    const loopEnabled = document.getElementById('playLoop')?.checked ?? true;
                    if (loopEnabled) {
                        if (targetSectionIndex >= bracketSections.length) {
                            targetSectionIndex = 0;
                        } else if (targetSectionIndex < 0) {
                            targetSectionIndex = bracketSections.length - 1;
                        }
                    } else {
                        if (targetSectionIndex >= bracketSections.length || targetSectionIndex < 0) {
                            return;
                        }
                    }
                    
                    // Clear previous active state
                    chordColumns.forEach(col => {
                        col.classList.remove('active', 'playing');
                    });
                    
                    // Activate first chord of target section
                    const targetSection = bracketSections[targetSectionIndex];
                    if (targetSection && targetSection.length > 0) {
                        const firstChord = targetSection[0];
                        firstChord.classList.add('active', 'playing');
                        
                        // Trigger chord sound if playing
                        if (this._arpTransport?.isRunning) {
                            firstChord.click();
                        }
                        
                        // Update visual feedback
                        firstChord.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'nearest',
                            inline: 'center'
                        });
                    }
                } catch (e) {
                    console.error('Error navigating chords:', e);
                }
            }

            // Override loop behavior to respect the loop toggle
            _checkLoopBehavior() {
                const loopToggle = document.getElementById('loopToggle');
                if (loopToggle && this._arpTransport) {
                    this._arpTransport.loopEnabled = loopToggle.checked;
                }
            }

            updateColumnInStorage() {
                if (this.currentEditingColumn.isCustom) {
                    const index = this.customChords.findIndex(chord => chord.name === this.currentEditingColumn.originalName || this.currentEditingColumn.name);
                    if (index !== -1) {
                        this.customChords[index].name = this.currentEditingColumn.name;
                        if (this.currentEditingColumn.intervals) {
                            this.customChords[index].notes = this.currentEditingColumn.intervals;
                        }
                    }
                }
            }

            // Chord Name Context Menu Methods
            hideChord() {
                this.pushState();
                console.log('?? hideChord called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for hideChord');
                    alert('Error: No chord selected for hiding');
                    return;
                }
                
                const chordId = this.currentEditingChord.id;
                if (!this.hiddenColumns.includes(chordId)) {
                    this.hiddenColumns.push(chordId);
                    this.generateExtensionColumns();
                    console.log(`?? Hidden chord: ${this.currentEditingChord.name}`);
                }
            }

            duplicateChord() {
                this.pushState();
                console.log('?? duplicateChord called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for duplicateChord');
                    alert('Error: No chord selected for duplication');
                    return;
                }
                
                // Create a duplicate chord
                const duplicateChord = {
                    name: this.currentEditingChord.name + ' Copy',
                    intervals: [...(this.currentEditingChord.intervals || [])],
                    isCustom: true,
                    id: 'custom_' + Date.now()
                };
                
                // Open chord builder with the duplicate
                this.showChordBuilder(duplicateChord);
            }

            editChord() {
                console.log('?? editChord called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for editChord');
                    alert('Error: No chord selected for editing');
                    return;
                }
                
                // Open chord builder with the current chord
                this.showChordBuilder(this.currentEditingChord);
            }

            copyToCustomChords() {
                console.log('?? copyToCustomChords called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for copyToCustomChords');
                    alert('Error: No chord selected for copying');
                    return;
                }
                
                // Get safe root note name
                const noteNames = this.getNoteNames();
                const rootIndex = this.currentEditingChord.root || this.currentRoot || 0;
                const rootName = noteNames[rootIndex] || `Note${rootIndex}`;
                
                console.log('?? Root details - index:', rootIndex, 'name:', rootName, 'noteNames:', noteNames);
                
                // Create a custom chord copy with root and tuning system
                const customChord = {
                    name: this.currentEditingChord.name + ` (${rootName})`,
                    notes: [...(this.currentEditingChord.intervals || [])],
                    id: Date.now()
                };
                
                console.log('?? Created customChord:', customChord);
                
                // Add to custom chords storage
                if (!this.customChords) this.customChords = [];
                this.customChords.push(customChord);
                
                // Add to palette for immediate use
                const paletteChord = {
                    name: customChord.name,
                    fullName: customChord.name,
                    extensions: [],
                    quality: 'custom',
                    id: 'custom_' + customChord.id,
                    isCustom: true,
                    originalName: customChord.name,
                    intervals: customChord.notes,
                    root: this.currentEditingChord.root || this.currentRoot || 0,
                    lockedTuning: this.currentEditingChord.tuning || this.currentTuning,
                    lockedGamelanMode: this.gamelanMode
                };
                
                console.log('?? Created paletteChord:', paletteChord);
                
                if (!this.paletteChords) this.paletteChords = [];
                this.paletteChords.push(paletteChord);
                
                // Regenerate everything
                this.generateExtensionColumns();
                this.renderPaletteChords();
                
                // Show success message
                alert(`Successfully copied "${customChord.name}" to custom palette!`);
                
                console.log(`?? Copied chord "${customChord.name}" to custom chords and palette`);
            }

            getNotesFromExtensions(extensions) {
                // Convert chord extensions to note intervals
                const intervals = this.getChordIntervals(extensions);
                return intervals;
            }

            // =============================================================================
            // =============================================================================
            
            // OLD: showColumnModal(), showCustomChordModal(), saveCustomChord()
            // NEW: All functionality moved to unified ChordBuilder module above
            
            toggleColumnVisibility(columnId, visible) {
                if (visible) {
                    this.hiddenColumns = this.hiddenColumns.filter(id => id !== columnId);
                } else {
                    if (!this.hiddenColumns.includes(columnId)) {
                        this.hiddenColumns.push(columnId);
                    }
                }
                this.generateExtensionColumns();
            }

            deleteCustomChord(index) {
                if (confirm('Delete this custom chord?')) {
                    this.customChords.splice(index, 1);
                    this.generateExtensionColumns();
                }
            }

            updateChordDisplay() {
                try {
                    const columns = Array.from(document.querySelectorAll('.extension-column'));
                    if (!columns.length) return;
                    const chords = Array.isArray(this.chordExtensions) ? this.chordExtensions : [];

                    const isGreyish = (hex)=>{
                        try {
                            const m = String(hex||'').trim().match(/^#?([0-9a-f]{6})$/i);
                            if (!m) return false;
                            const n = parseInt(m[1], 16);
                            const r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                            return (Math.max(r,g,b) - Math.min(r,g,b)) < 12;
                        } catch(_) { return false; }
                    };
                    const safeColor = (c)=>{
                        if (!c || typeof c !== 'string') return null;
                        const v = c.trim();
                        if (!v) return null;
                        if (v.toLowerCase() === '#000000') return null;
                        if (isGreyish(v)) return null;
                        return v;
                    };

                    columns.forEach(column => {
                        if (column.dataset.isRepeatMarker === 'true') return;
                        const header = column.querySelector('.extension-header');
                        if (!header) return;
                        const chordName = header.querySelector('.chord-name');

                        let chordExt = null;
                        const colId = column.dataset.chordId || column.dataset.chordType;
                        if (colId) {
                            chordExt = chords.find(c => c && (c.id === colId || String(c.name || '').toLowerCase().replace(/\s+/g, '_') === colId));
                        }
                        if (!chordExt && column.dataset.originalPosition != null) {
                            const idx = parseInt(column.dataset.originalPosition, 10);
                            if (Number.isFinite(idx) && idx >= 0 && idx < chords.length) chordExt = chords[idx];
                        }

                        // Blank custom chord: keep header neutral/black until user defines it
                        try {
                            const isBlank = !!(chordExt && chordExt.isCustom && (!Array.isArray(chordExt.intervals) || chordExt.intervals.length === 0));
                            if (isBlank) {
                                header.style.background = '#000000';
                                header.style.borderBottom = '1px solid #222222';
                                header.style.boxShadow = 'none';
                                header.style.color = '#9db6c8';
                                header.style.border = '1px solid #222222';
                                return;
                            }
                        } catch(_) {}

                        let accent = null;
                        const isLocked = !!(chordExt && chordExt.isLocked && chordExt.lockedData);
                        const hasFixed = !!(chordExt && typeof chordExt.fixedRootStepAbs === 'number' && chordExt.fixedRootTuning);
                        let edoForRoot = this.currentTuning || 12;
                        let rootStep;
                        if (isLocked) {
                            edoForRoot = chordExt.lockedData.lockedTuning || edoForRoot;
                            const localDelta = ((+column.dataset.localTranspose || 0) % edoForRoot + edoForRoot) % edoForRoot;
                            rootStep = ((chordExt.lockedData.lockedRoot ?? 0) + localDelta + edoForRoot) % edoForRoot;
                        } else if (hasFixed) {
                            edoForRoot = chordExt.fixedRootTuning || edoForRoot;
                            const localDelta = ((+column.dataset.localTranspose || 0) % edoForRoot + edoForRoot) % edoForRoot;
                            rootStep = ((chordExt.fixedRootStepAbs ?? 0) + localDelta + edoForRoot) % edoForRoot;
                        } else {
                            const label = (chordName?.dataset?.lockedName || chordName?.textContent || '').trim();
                            const normLabel = this._normalizeChordSymbolsForParse ? this._normalizeChordSymbolsForParse(label) : label;
                            const m = normLabel.match(/^([A-Ga-g])([#b\-d]?)([\^v]*)/);
                            if (m) {
                                const semi = this.rootToSemitone(m[1].toUpperCase(), m[2] || '');
                                let step = Math.round((semi * edoForRoot) / 12);
                                const ups = (m[3].match(/\^/g) || []).length;
                                const downs = (m[3].match(/v/g) || []).length;
                                rootStep = ((step + ups - downs) % edoForRoot + edoForRoot) % edoForRoot;
                            } else if (chordExt && typeof chordExt.originalRoot === 'number') {
                                rootStep = ((chordExt.originalRoot % edoForRoot) + edoForRoot) % edoForRoot;
                            } else {
                                rootStep = this.currentRoot ?? 0;
                            }
                        }
                        const semi = this.stepToSemitone(rootStep, edoForRoot);
                        accent = safeColor(this.getChromaticColorForSemitone(semi)) || '#ff0000';

                        const text = this.pickTextColor(accent);
                        header.style.background = accent;
                        header.style.borderBottom = `2px solid ${accent}`;
                        header.style.boxShadow = `0 0 10px ${accent}55`;
                        header.style.color = text;
                        header.style.border = `1px solid ${accent}`;
                    });
                } catch (_) { /* noop */ }
            }

            translateSemitoneToTuning(semitone) {
                // Translate 12-TET semitone to nearest step in current tuning
                // This ensures custom chords sound close in different tunings
                const exactStep = (semitone / 12) * this.currentTuning;
                return Math.round(exactStep) % this.currentTuning;
            }

            generateRootButtons() {
                const rootGrid = document.getElementById('rootGrid');
                if (!rootGrid) return;
                // Create or reuse a keyboard row containing left transpose controls + keyboard
                let row = rootGrid.querySelector('.keyboard-row');
                if (!row) {
                    row = document.createElement('div');
                    row.className = 'keyboard-row';
                    rootGrid.appendChild(row);
                }
                
                // Reuse existing keyboard element to avoid layout shift flicker
                let keyboard = row.querySelector('.piano-keyboard');
                if (!keyboard) {
                    // First-time creation
                    keyboard = document.createElement('div');
                    keyboard.className = 'piano-keyboard';
                    // Drag hint
                    const hint = document.createElement('div');
                    hint.className = 'drag-hint';
                    hint.textContent = 'drag â† â†’';
                    keyboard.appendChild(hint);
                    row.appendChild(keyboard);
                } else {
                    // Clear dynamic children (keys + dots) only
                    keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn, .edo-dot').forEach(el=> el.remove());
                    if (!keyboard.querySelector('.drag-hint')) {
                        const hint = document.createElement('div');
                        hint.className = 'drag-hint';
                        hint.textContent = 'drag â† â†’';
                        keyboard.appendChild(hint);
                    }
                }

                // Attach drag-to-rotate across all EDOs (cyclic modulo currentTuning)
                if (!keyboard.dataset.rotateBound) {
                    keyboard.dataset.rotateBound = '1';
                    let dragging = false; let startX = 0; let startRot = 0;
                    const applyDrag = (dx)=>{
                        const stepPx = Math.max(12, (keyboard.clientWidth || 600) / 12);
                        // Keep discrete steps but compute continuously, then round once
                        const delta = -Math.round(dx / stepPx);
                        const edo = this.currentTuning || 12;
                        let next = ((startRot + delta) % edo + edo) % edo;
                        if (next !== this.keyboardRotation) {
                            this.keyboardRotation = next;
                            this.generateRootButtons();
                            if (this.chordCreationMode) { this.setupIntervalSelection(); this.updatePreviewChordColumn(); }
                            if (this.currentActiveColumnEl) this.highlightKeyboardForColumn(this.currentActiveColumnEl);
                        }
                    };
                    keyboard.addEventListener('mousedown', (e)=>{
                        if (e.target && e.target.closest && e.target.closest('[data-step]')) return;
                        dragging=true; keyboard.classList.add('is-dragging'); startX=e.clientX; startRot=this.keyboardRotation|0;
                    });
                    window.addEventListener('mousemove', (e)=>{ if(!dragging) return; applyDrag(e.clientX - startX); });
                    window.addEventListener('mouseup', ()=>{ dragging=false; keyboard.classList.remove('is-dragging'); });
                    keyboard.addEventListener('touchstart', (e)=>{
                        const target = e.target && e.target.closest ? e.target.closest('[data-step]') : null;
                        if (target) return;
                        dragging=true; keyboard.classList.add('is-dragging'); startX=e.touches[0].clientX; startRot=this.keyboardRotation|0;
                    }, {passive:false});
                    window.addEventListener('touchmove', (e)=>{ if(!dragging) return; applyDrag(e.touches[0].clientX - startX); }, {passive:false});
                    window.addEventListener('touchend', ()=>{ dragging=false; keyboard.classList.remove('is-dragging'); }, {passive:false});
                }

                // Root-note drag (drop into chord area to create the first chord)
                if (!keyboard.dataset.rootDragBound) {
                    keyboard.dataset.rootDragBound = '1';
                    const dragState = { active:false, moved:false, startX:0, startY:0, step:null, tuning:null };

                    const onPointerDown = (e)=>{
                        const target = e.target && e.target.closest ? e.target.closest('[data-step]') : null;
                        if (!target) return;
                        if (e.button != null && e.button !== 0) return;
                        dragState.active = true;
                        dragState.moved = false;
                        dragState.startX = e.clientX;
                        dragState.startY = e.clientY;
                        dragState.step = parseInt(target.dataset.step || 'NaN', 10);
                        dragState.tuning = this.currentTuning || 12;
                        try { target.setPointerCapture && target.setPointerCapture(e.pointerId); } catch(_){ }
                        try { e.stopPropagation(); } catch(_){ }
                    };

                    const onPointerMove = (e)=>{
                        if (!dragState.active) return;
                        const dx = e.clientX - dragState.startX;
                        const dy = e.clientY - dragState.startY;
                        if (!dragState.moved && Math.hypot(dx, dy) > 6) dragState.moved = true;
                    };

                    const onPointerUp = (e)=>{
                        if (!dragState.active) return;
                        const moved = dragState.moved;
                        const step = dragState.step;
                        const tuning = dragState.tuning;
                        dragState.active = false;
                        dragState.moved = false;
                        dragState.step = null;
                        dragState.tuning = null;
                        if (!moved) return;
                        try { this._handleRootKeyDrop(e, step, tuning); } catch(_){ }
                    };

                    keyboard.addEventListener('pointerdown', onPointerDown, { passive: true });
                    window.addEventListener('pointermove', onPointerMove, { passive: true });
                    window.addEventListener('pointerup', onPointerUp, { passive: true });
                    window.addEventListener('pointercancel', onPointerUp, { passive: true });
                }

                if (this.gamelanMode) {
                    const noteNames = this.getNoteNames();
                    for (let i = 0; i < this.currentTuning; i++) {
                        const b = document.createElement('div');
                        b.className = 'root-btn';
                        b.textContent = noteNames[i] || i;
                        b.addEventListener('click', async ()=>{
                            const ok = await this.ensureAudioContext();
                            if (ok) {
                                const f = this.getFrequency(i % this.currentTuning, 4, this.currentTuning);
                                
                                // Route to MIDI or oscillators based on midiEnabled flag
                                if (this.midiEnabled && this.midi) {
                                    // Send to MIDI output
                                    const midiNote = Math.round(12 * Math.log2(f / 440) + 69); // A4=440Hz=MIDI 69
                                    this.midi.sendNoteOn(midiNote, 100, 1); // velocity 100, channel 1
                                    console.log('MIDI routing: sent note', midiNote, 'for frequency', f, 'Hz');
                                } else {
                                    // Send to oscillators (default behavior)
                                    this.playFrequency(f, null, 'chord');
                                    console.log('Oscillator routing: playing frequency', f, 'Hz');
                                }
                            }
                            const activeCol = this.getActiveColumnElement?.();
                            if (activeCol && this.editArmed) {
                                // Use the effective step for chord editing
                                this.toggleNoteInActiveChord(i % this.currentTuning);
                                this._scheduleEditSave(activeCol);
                            }
                            this._scheduleEditArm();
                        });
                        rootGrid.appendChild(b);
                    }
                    return;
                }

                // Piano layout definitions
                const whiteOrder = [0,2,4,5,7,9,11]; // semitone numbers for C D E F G A B
                const whiteLabels = ['C','D','E','F','G','A','B'];
                const blackMap = { 1:'C#',3:'D#',6:'F#',8:'G#',10:'A#' };
                const blackPositionsRelativeToWhite = {1:0,3:1,6:3,8:4,10:5}; // index of white to left

                // Precompute cent positions of all current tuning steps (0..currentTuning-1)
                const stepCents = Array.from({length:this.currentTuning},(_,i)=> this.getCentValue(i));

                // Map each tuning step to nearest 12TET semitone (0..11)
                const semitoneCenters = Array.from({length:12},(_,i)=> i*100);
                const stepToSemitone = stepCents.map(c=>{
                    let best=0; let mind=Infinity;
                    for (let s=0;s<12;s++){const d=Math.abs(c-semitoneCenters[s]); if(d<mind){mind=d;best=s;}}
                    return {cent:c, step: c/ (1200/ this.currentTuning), idx:best, dist:mind};
                });

                // For deciding which standard keys (white/black) are represented by an EDO step
                const threshold = 35; // cents tolerance to claim a semitone
                const semitoneHasStep = new Array(12).fill(false);
                stepToSemitone.forEach(o=>{ if(o.dist<=threshold) semitoneHasStep[o.idx]=true; });

                // keyboard already prepared above
                // Dynamic width scaling for higher EDO counts
                this.adjustKeyboardWidth(keyboard);


                // Pick representative step for each claimed semitone (closest)
                const semitoneToStep = new Array(12).fill(null);
                for (let s=0;s<12;s++){
                    let best=null; let mind=Infinity;
                    stepToSemitone.forEach(o=>{ if(o.idx===s && o.dist < mind){ mind=o.dist; best=o; }});
                    semitoneToStep[s]=best; // may be null
                }

                // Horizontal positions for 7 white circles equally spaced across width
                const whiteCenters = whiteOrder.map((_,i)=> ( (i+0.5)/7 )*100 );
                let centersUsed = whiteCenters.slice();

                // Uniform-slot keyboard for all EDOs: 12 visual slots that rotate, keys map to nearest EDO steps
                const edo = this.currentTuning || 12;
                const rotBase = (this.keyboardRotation||0) % 12; // visual rotation in 12 slots
                
                // Calculate positions with proper spacing (MORE gaps between all keys)
                // At 53 EDO we want keys to fill viewport width with gaps
                // Key size is 35px, so calculate spacing dynamically
                const keySize = 35;
                const viewportWidth = window.innerWidth;
                const numKeys = 12; // Always 12 visual slots
                
                // Calculate gap size: at 53 EDO, want to use full viewport width
                // For other EDOs, scale proportionally with LARGER minimum gaps
                const maxEDO = 53;
                const scaleFactor = edo / maxEDO;
                const availableWidth = viewportWidth * scaleFactor;
                const totalKeyWidth = numKeys * keySize;
                const totalGapSpace = availableWidth - totalKeyWidth;
                // Increase minimum gap to 1.5x key width for more spacing
                const gapSize = Math.max(keySize * 1.5, totalGapSpace / (numKeys + 1));
                
                // Calculate keyboard actual width needed
                const keyboardWidthNeeded = (numKeys * keySize) + ((numKeys + 1) * gapSize);
                
                // Calculate positions as percentages
                const slotCenters = Array.from({length:12},(_,i)=> {
                    const leftEdgeGap = gapSize;
                    const centerPx = leftEdgeGap + (i * (keySize + gapSize)) + (keySize / 2);
                    return (centerPx / keyboardWidthNeeded) * 100;
                });
                
                centersUsed = slotCenters.slice();
                // Track which EFFECTIVE steps are already used to avoid duplicates across keys/dots
                const usedEffSteps = new Set();
                for (let i = 0; i < 12; i++) {
                    const semi = (rotBase + i) % 12; // visual semitone
                    // find nearest step for this semitone in current EDO
                    let stepIndex;
                    if (edo === 12) stepIndex = semi;
                    else stepIndex = this.findNearestStepForSemitone(semi, stepCents);
                    const isWhite = whiteOrder.includes(semi);
                    const el = document.createElement('div');
                    el.className = (isWhite? 'white-key' : 'black-key') + ' root-btn';
            // Store the EFFECTIVE step (what you hear) so selection and glow match labels
                    el.dataset.semitone = semi;
                    // no persistent 'active' highlight for root; only chord-tone glow handled elsewhere
                    el.style.left = slotCenters[i] + '%';
                    // Label reflects global transpose so keys show what you hear
                    const effStep = ((stepIndex + (this.transposeDelta||0)) % edo + edo) % edo;
                    // Record the key's effective step to prevent duplicate dots, but never alter the key mapping
                    usedEffSteps.add(effStep);
        el.dataset.step = effStep;
        el.dataset.originalStep = stepIndex; // Store original step for chord editing
            // Use EDO naming tables so keyboard labels match chord enharmonics
            el.textContent = this.getRootNameForStep(effStep, edo);
                    // Prevent multiple event listeners
                    if (!el.dataset.clickHandlerAttached) {
                        el.dataset.clickHandlerAttached = 'true';
                    el.addEventListener('click', async (ev)=>{
                        console.log('KEYBOARD CLICK HANDLER: Using effective step for chord editing');
                        console.log('CLICK DEBUG: el.dataset.step =', el.dataset.step, 'el.dataset.originalStep =', el.dataset.originalStep);
                        console.log('CLICK DEBUG: this.transposeDelta =', this.transposeDelta);
                        try { ev.stopPropagation(); ev.stopImmediatePropagation && ev.stopImmediatePropagation(); } catch(_){ }
                        // mark interaction and ensure audio; keep editArmed state
                        this.userInteracted = true;
                        // Clear preview highlight if any immediately
                        this.previewInterval = null;
                        try { document.querySelectorAll('#rootGrid [data-step].preview').forEach(x=> x.classList.remove('preview')); } catch {}
                        try { this.updateIntervalButtons(); } catch {}
                        let activeCol = this.getActiveColumnElement?.();
                        if (!activeCol) { activeCol = document.querySelector('.extension-column'); if (activeCol) this.currentActiveColumnEl = activeCol; }
                        const ok = await this.ensureAudioContext();
                        if (ok) {
                const eff = parseInt(el.dataset.step,10);
                const f = this.getFrequency(eff, 4, edo);
                            
                            // Route to MIDI or oscillators based on midiEnabled flag
                            if (this.midiEnabled && this.midi) {
                                // Send to MIDI output
                                const midiNote = Math.round(12 * Math.log2(f / 440) + 69); // A4=440Hz=MIDI 69
                                this.midi.sendNoteOn(midiNote, 100, 1); // velocity 100, channel 1
                                console.log('Piano MIDI routing: sent note', midiNote, 'for frequency', f, 'Hz');
                            } else {
                                // Send to oscillators (default behavior)
                                this.playFrequency(f, null, 'chord');
                                console.log('Piano oscillator routing: playing frequency', f, 'Hz');
                            }
                        }
                        // Use effective step so clicks match what you hear (accounts for transpose)
                        const effectiveStep = parseInt(el.dataset.step,10);
                        console.log('CHORD EDIT: effectiveStep =', effectiveStep);
                        if (activeCol) {
                            this.toggleNoteInActiveChord(effectiveStep);
                            this._scheduleEditSave(activeCol);
                        } else {
                            // No active column, just arm editing for soon
                            this._scheduleEditArm();
                        }
                    });
                    }
                    keyboard.appendChild(el);
                }

                // For non-12 EDO, place micro dots between the current rotated semitone slots
                if (this.currentTuning !== 12) {
                    // Build a mapping from semitone -> slot center based on current rotation
                    const centersBySemitone = {};
                    for (let i = 0; i < 12; i++) {
                        const semi = (rotBase + i) % 12;
                        centersBySemitone[semi] = slotCenters[i];
                    }

            // Helper to add a micro dot at a fractional position between two adjacent slots
            // stepIndex is the exact EDO step we want this dot to represent (no nearest rounding)
        const addMicroDot = (s, frac01, color, stepIndex) => {
                        // j is the slot index for semitone s in the rotated view
                        const j = ((s - rotBase) % 12 + 12) % 12;
                        const jNext = (j + 1) % 12;
                        let leftPct = slotCenters[j];
                        let rightPct = slotCenters[jNext];
                        // Handle wrap-around across 100% -> 0%
                        if (rightPct < leftPct) rightPct += 100;
            let pct = leftPct + (rightPct - leftPct) * frac01;
                        if (pct >= 100) pct -= 100;

                        // Create the dot element and map it to the nearest EDO step inside this gap
                        const d = document.createElement('div');
            d.className = `edo-dot ${color}`; // inline style will set vertical position precisely
                        d.style.left = pct + '%';
            
            // Determine if we're going from WHITE to BLACK or BLACK to WHITE
            const whiteSemis = new Set([0,2,4,5,7,9,11]); // C D E F G A B
            const blackSemis = new Set([1,3,6,8,10]); // C# D# F# G# A#
            const startIsWhite = whiteSemis.has(s);
            const endIsBlack = blackSemis.has((s + 1) % 12);
            const whiteToBlack = startIsWhite && endIsBlack;
            
            // Vertically position dot based on cents offset with proper spacing
            // WHITE to BLACK: microkeys go UP (diagonal upward line from C to Db)
            // BLACK to WHITE: microkeys go DOWN (diagonal downward line from Db to D)
            const topBound = 30;   // percent from top of keyboard (for dots near black keys)
            const bottomBound = 70; // percent from top (for dots near white keys)
            
            // If WHITE to BLACK, INVERT the fraction so dots go UP as we move right
            const verticalFrac = whiteToBlack ? (1 - frac01) : frac01;
            const topPct = topBound + (bottomBound - topBound) * Math.min(Math.max(verticalFrac, 0), 1);
            d.style.top = topPct + '%';
        let effStep = ((stepIndex + (this.transposeDelta||0)) % this.currentTuning + this.currentTuning)%this.currentTuning;
        // Skip creating a dot if its effective step is already represented (avoid duplicates like E^ and Ev coupling)
        if (usedEffSteps.has(effStep)) return;
        usedEffSteps.add(effStep);
            // Store effective step so click and highlight align with label
            d.dataset.step = effStep;
            d.dataset.originalStep = stepIndex; // Store original step for chord editing
            // Use EDO naming tables for micro-step dots as well
            d.textContent = this.getRootNameForStep(effStep, edo);
                        d.title = `${d.textContent}`;
                        // Prevent multiple event listeners
                        if (!d.dataset.clickHandlerAttached) {
                            d.dataset.clickHandlerAttached = 'true';
                        d.addEventListener('click', async (ev)=>{
                            try { ev.stopPropagation(); ev.stopImmediatePropagation && ev.stopImmediatePropagation(); } catch(_){ }
                            let activeCol = this.getActiveColumnElement?.();
                            if (!activeCol) { activeCol = document.querySelector('.extension-column'); if (activeCol) this.currentActiveColumnEl = activeCol; }
                            // Clear preview highlight if any immediately
                            this.previewInterval = null;
                            try { document.querySelectorAll('#rootGrid [data-step].preview').forEach(x=> x.classList.remove('preview')); } catch {}
                            try { this.updateIntervalButtons(); } catch {}
                            const ok = await this.ensureAudioContext();
                            if (ok) {
                const eff = parseInt(d.dataset.step,10);
                const f = this.getFrequency(eff, 4, this.currentTuning);
                                this.playFrequency(f, null, 'chord');
                            }
                            // Use effective step so clicks match what you hear (accounts for transpose)
                            const effectiveStep = parseInt(d.dataset.step,10);
                            console.log('MICRO DOT EDIT: effectiveStep =', effectiveStep);
                            if (activeCol) {
                                this.toggleNoteInActiveChord(effectiveStep);
                                this._scheduleEditSave(activeCol);
                            } else {
                                this._scheduleEditArm();
                            }
                        });
                        }
                        keyboard.appendChild(d);
                    };

                    // Determine which EDO steps already claimed a main 12-slot key
                    const claimedSteps = new Set();
                    semitoneToStep.forEach(rep=>{ if(rep) claimedSteps.add(Math.round(rep.step)); });

                    // Iterate each 12-TET gap in cents space and drop dots between its rotated slots
                    const whiteSemis = new Set([0,2,4,5,7,9,11]);
                    const blackSemis = new Set([1,3,6,8,10]);
                    for (let s = 0; s < 12; s++) {
                        const nextSemi = (s + 1) % 12;
                        const gapStartCent = s * 100;
                        const gapEndCent = ((s + 1) % 12) * 100;
                        // Collect EDO steps whose cents fall strictly inside this 12-TET gap
                        const candidates = [];
                        stepCents.forEach((c,i)=>{
                            const cent = c % 1200;
                            // Handle wrap for 11->0 gap by treating end at 1200
                            if (s === 11) {
                                if (cent > 1100 && cent < 1200 && !claimedSteps.has(i)) {
                                    candidates.push({cent, offset: cent - 1100, step: i});
                                }
                            } else {
                                if (cent > gapStartCent && cent < gapEndCent && !claimedSteps.has(i)) {
                                    candidates.push({cent, offset: cent - gapStartCent, step: i});
                                }
                            }
                        });
                        if (!candidates.length) continue;
                        candidates.sort((a,b)=> a.offset - b.offset);

                        // Map each candidate to a fraction within the 0-100c gap
                        const fracs = candidates.map(c => ({...c, frac: c.offset/100}));
                        // Find the one nearest 50c (0.5) to be the neutral green
                        let greenIdx = 0; let minDist = Infinity;
                        fracs.forEach((c,idx)=>{ const d = Math.abs(c.frac - 0.5); if (d < minDist){ minDist = d; greenIdx = idx; } });
                        // Add the green neutral dot first, centered vertically (handled in addMicroDot)
                        const g = fracs[greenIdx];
                        if (g) addMicroDot(s, Math.min(Math.max(g.frac, 0.02), 0.98), 'green', g.step);
                        // Dots below 50c are blue, above are red
                        fracs.forEach((c,idx)=>{
                            if (idx === greenIdx) return;
                            const color = (c.frac < 0.5) ? 'blue' : 'red';
                            addMicroDot(s, Math.min(Math.max(c.frac, 0.02), 0.98), color, c.step);
                        });
                    }
                }
                // After constructing all keys, resize to fit; skip dot overlap fixes in 12EDO
                this.resizeKeyboardKeys(keyboard, centersUsed);
                if (this.currentTuning !== 12) {
                    this.adjustForDotOverlap(keyboard);
                    this.resizeDotsToKeySize(keyboard);
                }
                // Edge fade and dot/link exclusions
                this.applyDotEdgeFadeAndExclusions(keyboard);
                // Reapply highlight if a chord is currently active
                try {
                    const activeCol = this.getActiveColumnElement?.();
                    if (activeCol) this.highlightKeyboardForColumn(activeCol);
                } catch(_){}

                // If in creation mode, re-bind interval selection to include new UI and reflect state
                if (this.chordCreationMode) {
                    this.setupIntervalSelection();
                    this.updatePreviewChordColumn();
                }
            }

            getNoteNames() {
                if (this.gamelanMode) {
                    // Gamelan pelog note names
                    return ['Bem', 'Gulu', 'Dada', 'Pelog', 'Lima', 'Nem', 'Barang'];
                }
                
                // Use EDO-specific naming tables for 5â€“24; fallback to arrow notation otherwise
                const names = [];
                for (let i = 0; i < this.currentTuning; i++) {
                    names.push(this.getRootNameForStep(i, this.currentTuning));
                }
                return names;
            }

            getCentValue(step, tuning = null) {
                const currentTuning = tuning || this.currentTuning;
                console.log('getCentValue called with step:', step, 'tuning:', tuning, 'gamelanMode:', this.gamelanMode, 'currentTuning:', currentTuning);
                
                if (this.gamelanMode) {
                    // Gamelan pelog scale approximation in cents from root
                    const gamelanCents = [0, 136, 348, 560, 704, 840, 1056]; // 7-note pelog scale
                    const result = gamelanCents[step % 7] + (Math.floor(step / 7) * 1200);
                    console.log('gamelan cents result:', result);
                    return result;
                }
                const result = (step * 1200) / currentTuning;
                console.log('equal temperament cents result:', result);
                return result;
            }

            // Find nearest EDO step (index) whose cent value is closest to a given 12-TET semitone center
            findNearestStepForSemitone(semitone, stepCents){
                const targetCent = semitone * 100;
                let bestIdx = 0; let bestDist = Infinity;
                stepCents.forEach((c,i)=>{
                    const dist = Math.abs((c%1200) - targetCent);
                    if(dist < bestDist){ bestDist = dist; bestIdx = i; }
                });
                return bestIdx;
            }

            // Dynamically resize circular keys to avoid overflow and keep everything after first C
            resizeKeyboardKeys(keyboard, whiteCenters){
                if(!keyboard || !whiteCenters || whiteCenters.length < 2) return;
                const kbWidth = (keyboard.clientWidth || 1000);
                const edo = this.currentTuning || 12;
                
                // Always use 35px keys
                const diameter = 35;
                this.currentKeyDiameter = diameter;
                
                // Apply fixed size to all keys
                keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn').forEach(el=>{
                    el.style.width = diameter + 'px';
                    el.style.height = diameter + 'px';
                });
                
                // Dots are smaller
                keyboard.querySelectorAll('.edo-dot').forEach(el=>{
                    const dotD = 22;
                    el.style.width = dotD + 'px';
                    el.style.height = dotD + 'px';
                });
            }

            // Widen keyboard proportionally with EDO so higher divisions have more horizontal space
            adjustKeyboardWidth(keyboard){
                if(!keyboard) return;
            }

            // Detect dot/key overlaps; shrink keys globally until all dots clear or min size reached
            adjustForDotOverlap(keyboard){
                if(!keyboard) return;
                const kbWidth = keyboard.clientWidth || 1000;
                const percentPerPx = 100 / kbWidth;
                const padPx = 2;
                const dotRadiusPx = 10; // 20px diameter per CSS
                let diameter = this.currentKeyDiameter || 70;
                const minDiameter = 34;
                const dots = Array.from(keyboard.querySelectorAll('.edo-dot'));
                if(!dots.length) return;
                const getOverlapExists = ()=>{
                    const keyCenters = [];
                    keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn').forEach(k=>{
                        const leftPct = parseFloat(k.style.left);
                        keyCenters.push(leftPct);
                    });
                    const keyRadiusPct = (diameter/2) * percentPerPx;
                    const dotRadiusPct = dotRadiusPx * percentPerPx;
                    const padPct = padPx * percentPerPx;
                    for(const d of dots){
                        const dPct = parseFloat(d.style.left);
                        for(const kc of keyCenters){
                            if (Math.abs(dPct - kc) < (keyRadiusPct + dotRadiusPct + padPct)){
                                return true;
                            }
                        }
                    }
                    return false;
                };
                let guard=0;
                while(getOverlapExists() && diameter>minDiameter && guard<20){
                    guard++;
                    diameter -= 3; // shrink step
                    this.currentKeyDiameter = diameter;
                    // Use the same scale logic as in resizeKeyboardKeys
                    const renderD = diameter;
                    keyboard.querySelectorAll('.white-key.root-btn').forEach(el=>{
                        el.style.width = renderD + 'px';
                        el.style.height = renderD + 'px';
                    });
                    keyboard.querySelectorAll('.black-key.root-btn').forEach(el=>{
                        el.style.width = renderD + 'px';
                        el.style.height = renderD + 'px';
                    });
                }
             }

            // No longer fades - keep all elements fully visible
            applyDotEdgeFadeAndExclusions(keyboard) {
                if (!keyboard) return;
                const dots = Array.from(keyboard.querySelectorAll('.edo-dot'));
                const keys = Array.from(keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn'));
                
                // Keep all elements fully opaque
                [...dots, ...keys].forEach(el => {
                    el.style.opacity = '1';
                });
            }

            // Reposition all key & dot centers to be perfectly equidistant while preserving ordering
            enforceEquidistantCenters(keyboard){
                if(!keyboard) return;
                const all = Array.from(keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn, .edo-dot'));
                if(all.length < 2) return;
                // Sort by current left
                all.sort((a,b)=> parseFloat(a.style.left) - parseFloat(b.style.left));
                // Determine first C (white key with label starting C) to lock at current position
                const firstCEl = all.find(el=> el.classList.contains('white-key') && /C/.test(el.textContent));
                const firstLeft = firstCEl ? parseFloat(firstCEl.style.left) : parseFloat(all[0].style.left);
                const lastEl = all[all.length-1];
                const lastLeft = parseFloat(lastEl.style.left);
                if (lastLeft <= firstLeft) return;
                // If any element already exceeds 100%, abort normalization (shouldn't happen after earlier clamps)
                if (all.some(el=> parseFloat(el.style.left) > 100)) return;
                const span = lastLeft - firstLeft;
                const uniformGap = span / (all.length - 1);
                all.forEach((el,idx)=>{
                    if (el===firstCEl || el===lastEl) return; // lock ends
                    const newLeft = firstLeft + idx*uniformGap;
                    // Safety clamp
                    el.style.left = Math.min(99.5, Math.max(firstLeft, newLeft)) + '%';
                });
            }

            // Make colored micro dots same diameter as (reduced) black/white keys for easier tapping
            resizeDotsToKeySize(keyboard){
                if(!keyboard) return;
                const diameter = (this.currentKeyDiameter || 70) * 0.97; // match black key size
                keyboard.querySelectorAll('.edo-dot').forEach(dot=>{
                    dot.style.width = diameter + 'px';
                    dot.style.height = diameter + 'px';
                    dot.style.lineHeight = diameter + 'px';
                    // Adjust font size relative to diameter
                    const fs = Math.max(10, Math.min(14, diameter * 0.22));
                    dot.style.fontSize = fs + 'px';
                });
            }

            getFrequency(step, octave = 4, tuning = null) {
                
                const cents = this.getCentValue(step, tuning);
                console.log('cents calculated:', cents);
                
                // Use C4 as base frequency (261.626 Hz) since step 0 = C
                const baseFreq = 261.626 * Math.pow(2, (octave - 4)); // C4 = 261.626Hz
                console.log('baseFreq calculated:', baseFreq);
                
                const finalFreq = baseFreq * Math.pow(2, cents / 1200);
                console.log('finalFreq calculated:', finalFreq);
                
                if (isNaN(finalFreq)) {
                    console.error('NaN frequency detected! step:', step, 'octave:', octave, 'cents:', cents, 'baseFreq:', baseFreq);
                }
                
                return finalFreq;
            }

            generateChordPattern(extensions) {
                // Generate a pattern of chord intervals
                const intervals = this.getChordIntervals(extensions);
                return intervals;
            }

            getTuningDivisions() {
                return this.currentTuning;
            }

            getNoteName(noteIndex) {
                if (noteIndex === undefined || noteIndex === null) {
                    return 'C'; // Default to C if undefined
                }
                const noteNames = this.getNoteNames();
                return noteNames[noteIndex] || noteIndex.toString();
            }

            getChordIntervals(extensions = []) {
                let intervals = [0]; // Root
                
                // Base triad
                switch (this.currentQuality) {
                    case 'major':
                        intervals.push(Math.round(4 * this.currentTuning / 12)); // Major third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                    case 'minor':
                        intervals.push(Math.round(3 * this.currentTuning / 12)); // Minor third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                    case 'neutral':
                        intervals.push(Math.round(3.5 * this.currentTuning / 12)); // Neutral third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                }
                
                // Apply extensions
                extensions.forEach(ext => {
                    switch (ext) {
                        case '6':
                            intervals.push(Math.round(9 * this.currentTuning / 12));
                            break;
                        case '7':
                            intervals.push(Math.round(10 * this.currentTuning / 12));
                            break;
                        case 'maj7':
                            intervals.push(Math.round(11 * this.currentTuning / 12));
                            break;
                        case '9':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // Add 7th first
                            intervals.push(Math.round(14 * this.currentTuning / 12)); // Then 9th
                            break;
                        case 'sus2':
                            intervals = intervals.filter(i => i !== Math.round(4 * this.currentTuning / 12) && i !== Math.round(3 * this.currentTuning / 12) && i !== Math.round(3.5 * this.currentTuning / 12));
                            intervals.push(Math.round(2 * this.currentTuning / 12));
                            break;
                        case 'sus4':
                            intervals = intervals.filter(i => i !== Math.round(4 * this.currentTuning / 12) && i !== Math.round(3 * this.currentTuning / 12) && i !== Math.round(3.5 * this.currentTuning / 12));
                            intervals.push(Math.round(5 * this.currentTuning / 12));
                            break;
                        case 'add9':
                            intervals.push(Math.round(14 * this.currentTuning / 12));
                            break;
                        case '13':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // Add 7th
                            intervals.push(Math.round(21 * this.currentTuning / 12)); // Add 13th
                            break;
                        case '#11':
                            intervals.push(Math.round(18 * this.currentTuning / 12)); // #11
                            break;
                        case '7#9':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // 7th
                            intervals.push(Math.round(15 * this.currentTuning / 12)); // #9 (raised 9th)
                            break;
                        case '#9':
                            intervals.push(Math.round(15 * this.currentTuning / 12)); // #9 (raised 9th)
                            break;
                        case 'n7':
                            intervals.push(Math.round(10.5 * this.currentTuning / 12)); // neutral 7th
                            break;
                        case 'n11':
                            intervals.push(Math.round(16.5 * this.currentTuning / 12)); // neutral 11th
                            break;
                    }
                });
                
                return [...new Set(intervals)].sort((a, b) => a - b);
            }

            // Build the visible sequence string from current columns, preserving sections "|"
            buildCurrentSequenceString(includeSections = true) {
                const cols = Array.from(document.querySelectorAll('#extensionColumns .extension-column'));
                const parts = [];
                cols.forEach(col => {
                    const nameEl = col.querySelector('.extension-header .chord-name');
                    if (!nameEl) return;
                    const t = (nameEl.dataset.lockedName || nameEl.textContent || '').trim();
                    if (!t) return;
                    if (t === '|' || col.dataset.chordId === '__SECTION__') {
                        if (includeSections) parts.push('|');
                    } else {
                        parts.push(t);
                    }
                });
                return parts.join(' ');
            }
            
            regenerateAllColumnsPreservingLocks() {
                console.log('?? Regenerating all columns while preserving locked chord settings');
                
                // Get all current columns
                const container = document.getElementById('extensionColumns');
                const allColumns = Array.from(container.querySelectorAll('.extension-column'));
                
                // For each column, regenerate its strings using appropriate settings
                allColumns.forEach(column => {
                    const isLocked = this.lockedChords && this.lockedChords.has(column);
                    
                    if (isLocked) {
                        // This column is locked - regenerate using its locked settings
                        const lockedChord = this.lockedChords.get(column);
                        console.log('?? Regenerating locked column:', lockedChord.chordName, 'with locked root:', lockedChord.lockedRoot);
                        
                        // Resolve the backing chord model by stable id/position if possible
                        let chordExt = null;
                        try {
                            if (column.dataset.chordId) {
                                chordExt = (this.chordExtensions || []).find(c => String(c.id) === String(column.dataset.chordId));
                            }
                            if (!chordExt && column.dataset.originalPosition != null) {
                                const op = parseInt(column.dataset.originalPosition, 10);
                                if (!isNaN(op) && op >= 0 && this.chordExtensions && this.chordExtensions[op]) {
                                    chordExt = this.chordExtensions[op];
                                }
                            }
                        } catch(_) {}
                        // Fallback to name match only if id/position not found
                        if (!chordExt) {
                            chordExt = this.chordExtensions.find(ext => 
                                ext.name === lockedChord.chordName || 
                                ext.name === lockedChord.originalChordName ||
                                (ext.symbol && lockedChord.chordName && lockedChord.chordName.includes(ext.symbol))
                            );
                        }
                        
                        if (chordExt) {
                            // Clear existing strings and regenerate with locked settings
                            const stringsContainer = column.querySelector('.strings-column');
                            if (stringsContainer) {
                                stringsContainer.remove();
                            }
                            
                            // Generate strings using locked settings
                            this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals, lockedChord);
                        }
                    } else {
                        // This column is unlocked - regenerate using current global settings
                        // Resolve the backing chord model by stable id/position; do not depend on header text
                        let chordExt = null;
                        try {
                            if (column.dataset.chordId) {
                                chordExt = (this.chordExtensions || []).find(c => String(c.id) === String(column.dataset.chordId));
                            }
                            if (!chordExt && column.dataset.originalPosition != null) {
                                const op = parseInt(column.dataset.originalPosition, 10);
                                if (!isNaN(op) && op >= 0 && this.chordExtensions && this.chordExtensions[op]) {
                                    chordExt = this.chordExtensions[op];
                                }
                            }
                        } catch(_) {}
                        console.log('?? Regenerating unlocked column using model:', chordExt?.name, 'with current root:', this.currentRoot, 'transposeDelta:', this.transposeDelta);
                        
                        if (chordExt) {
                            // Clear existing strings and regenerate with current settings
                            const stringsContainer = column.querySelector('.strings-column');
                            if (stringsContainer) {
                                stringsContainer.remove();
                            }
                            
                            // Generate strings using current global settings
                            this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom);
                        }
                    }
                });
                
                console.log('?? Completed regeneration preserving', this.lockedChords ? this.lockedChords.size : 0, 'locked chords');
            }

            regenerateUnlockedChordsOnly() {
                console.log('?? Regenerating only unlocked chords, preserving locked ones exactly as they are');
                
                if (!this.lockedChords || this.lockedChords.size === 0) {
                    // No locked chords, just regenerate everything normally
                    console.log('?? No locked chords found, regenerating all chords normally');
                    this.preserveLockedChordsAndRegenerate();
                    return;
                }
                
                // Get all columns currently in the DOM
                const container = document.getElementById('extensionColumns');
                const existingColumns = Array.from(container.querySelectorAll('.extension-column'));
                
                console.log('?? Found', existingColumns.length, 'existing columns,', this.lockedChords.size, 'are locked');
                
                // Separate locked and unlocked columns
                const lockedColumns = [];
                const unlockedColumns = [];
                
                existingColumns.forEach(column => {
                    if (this.lockedChords.has(column)) {
                        lockedColumns.push(column);
                        console.log('?? Preserving locked column:', column.querySelector('.chord-name')?.textContent);
                    } else {
                        unlockedColumns.push(column);
                        console.log('?? Will regenerate unlocked column:', column.querySelector('.chord-name')?.textContent);
                    }
                });
                
                // Remove only the unlocked columns from DOM (keep locked ones in place)
                unlockedColumns.forEach(column => {
                    column.remove();
                });
                
                // Update chord names in locked columns to ensure they display correctly
                // but preserve their locked root information
                lockedColumns.forEach(column => {
                    const lockedChord = this.lockedChords.get(column);
                    if (lockedChord) {
                        const chordNameElement = column.querySelector('.chord-name');
                        if (chordNameElement) {
                            // Keep the locked chord name exactly as it was locked
                            // This prevents it from being rewritten with the new root
                            const lockedName = lockedChord.chordName;
                            chordNameElement.textContent = `ðŸ”’ ${lockedName}`;
                            chordNameElement.style.color = '#4CAF50';
                            chordNameElement.style.fontWeight = 'bold';
                            
                            const rootName = this.getNoteNames()[lockedChord.lockedRoot] || lockedChord.lockedRoot;
                            chordNameElement.title = `LOCKED: ${rootName} root, ${lockedChord.lockedTuning}TET, ${lockedChord.lockedOsc1.type}/${lockedChord.lockedOsc2.type} waves`;
                            
                            console.log('?? Preserved locked chord display:', lockedName, 'locked to root:', lockedChord.lockedRoot);
                        }
                    }
                });
                
                // Now regenerate only the chord extensions that correspond to unlocked columns
                // Find which chord extensions were unlocked
                const unlockedExtensions = this.chordExtensions.filter(ext => {
                    // Check if this extension had a locked column
                    const wasLocked = lockedColumns.some(column => {
                        const lockedChord = this.lockedChords.get(column);
                        return lockedChord && (
                            ext.name === lockedChord.chordName ||
                            (ext.isCustom && lockedChord.lockId && lockedChord.lockId.includes(ext.id || ext.name))
                        );
                    });
                    return !wasLocked;
                });
                
                // unlocked extensions to regenerate: count logged disabled
                
                // Generate new columns for unlocked extensions with the new root
                unlockedExtensions.forEach(ext => {
                    // regenerating column for unlocked extension
                    this.generateSingleChordColumn(ext, container);
                });
                
                // regeneration complete; logs suppressed
            }
            
            generateSingleChordColumn(chordExt, container) {
                // This function generates a single chord column for the given chord extension
                // This is extracted from the main generateExtensionColumns function
                const noteNames = this.getNoteNames();
                
                const column = document.createElement('div');
                column.className = 'extension-column';
                // Provide stable identifiers so delete/reorder logic can map back to data
                try {
                    const absoluteIndex = (typeof chordExt.position === 'number')
                        ? chordExt.position
                        : (this.findChordIndex ? this.findChordIndex(chordExt) : (this.chordExtensions ? this.chordExtensions.indexOf(chordExt) : -1));
                    if (absoluteIndex !== -1) column.dataset.originalPosition = String(absoluteIndex);
                    const slug = (chordExt.id || (chordExt.name || '').toLowerCase().replace(/\s+/g, '_'));
                    column.dataset.chordId = slug;
                    column.dataset.chordType = slug;
                } catch (_) { /* non-fatal */ }
                column.style.flex = '1';
                column.style.height = '100%';
                column.style.border = 'none';
                column.style.borderRadius = '0';
                column.style.margin = '0';
                column.style.padding = '0';
                
                // Create header with chord name and action buttons
                const header = document.createElement('div');
                header.className = 'extension-header';
                
                // Create chord name span
                const chordName = document.createElement('span');
                chordName.className = 'chord-name';
                chordName.textContent = chordExt.name;
                
                // Create buttons container
                const buttonsContainer = document.createElement('div');
                buttonsContainer.className = 'header-buttons';
                
                
                // (buttonsContainer kept for other action buttons)
                // Per-column transpose controls (single-column path)
                const downBtn = document.createElement('button');
                downBtn.className = 'chord-action-button transpose-down';
                downBtn.title = 'Transpose this chord down one step';
                downBtn.textContent = 'â–¼';
                const upBtn = document.createElement('button');
                upBtn.className = 'chord-action-button transpose-up';
                upBtn.title = 'Transpose this chord up one step';
                upBtn.textContent = 'â–²';
                let _pressGuard = false;
                const norm = (v, m)=> ((v % m) + m) % m;
                const applyLocalTranspose = (delta)=>{
                    if (_pressGuard) return;
                    _pressGuard = true;
                    const edoNow = chordExt.fixedRootTuning || this.currentTuning || 24;
                    const prevLocal = parseInt(column.dataset.localTranspose || '0', 10) || 0;
                    const nextLocal = norm(prevLocal + delta, edoNow);
                    column.dataset.localTranspose = String(nextLocal);
                    chordExt.localTranspose = nextLocal; // persist
                    // Relabel: for custom (â€œ+â€) chords, recompute from absolute steps (matches SEQ semantics);
                    // for others, keep the lightweight root-respell.
                    try {
                        const baseRoot = typeof chordExt.fixedRootStepAbs === 'number' ? chordExt.fixedRootStepAbs : 0;
                        const effRoot = norm((baseRoot % edoNow) + nextLocal, edoNow);
                        if (chordExt.isCustom && Array.isArray(chordExt.intervals) && chordExt.intervals.length > 0) {
                            // Build absolute steps: transposed root + each interval from the transposed root
                            const absNow = [effRoot, ...chordExt.intervals.map(iv => norm(effRoot + iv, edoNow))];
                            const prefName = (chordExt && chordExt.preferredRootName)
                                ? this._transposePreferredRootName(chordExt.preferredRootName, nextLocal, edoNow)
                                : null;
                            const recomputed = this.computeFullChordNameFromAbsoluteSteps(
                                absNow,
                                edoNow,
                                null,
                                prefName,
                                (chordExt && chordExt.preferredBassRel != null) ? chordExt.preferredBassRel : null
                            ) || chordExt.name;
                            chordName.textContent = recomputed;
                            chordName.dataset.lockedName = recomputed;
                            chordExt.name = recomputed;
                        } else {
                            const mRoot = (chordExt.name || '').match(/^([A-G])([#b]?)([\^vâ†‘â†“]*)(.*)$/);
                            const tail = mRoot ? (mRoot[4] || '') : '';
                            const pref = chordExt.preferredAccidental || this._getAccidentalPreference(chordExt.preferredRootName || chordExt.name);
                            const newRootName = this.getRootNameForStepWithPreference(effRoot, edoNow, pref) || String(effRoot);
                            const newName = `${newRootName}${tail}`.trim();
                            chordName.textContent = newName;
                            chordName.dataset.lockedName = newName;
                            chordExt.name = newName;
                        }
                    } catch(_) {}
                    // Re-render strings with offset applied at playback time
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                        // IMPORTANT: For custom (â€œ+â€) chords, always use the stored custom intervals
                        // to avoid wiping strings due to empty extension-derived intervals
                        console.log('ðŸ”§ DEBUG: About to call generateStringsForColumn with intervals:', chordExt.intervals, 'isCustom:', chordExt.isCustom);
                        this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom || false);
                    Promise.resolve().then(()=>{ _pressGuard = false; });
                };
                const onPointer = (delta)=> (e)=>{ e.preventDefault(); e.stopPropagation(); applyLocalTranspose(delta); };
                upBtn.addEventListener('pointerdown', onPointer(+1));
                downBtn.addEventListener('pointerdown', onPointer(-1));
                buttonsContainer.appendChild(downBtn);
                buttonsContainer.appendChild(upBtn);

                header.appendChild(chordName);
                header.appendChild(buttonsContainer);
                
                // Root-based header color (no greys)
                try {
                    const isGreyish = (hex)=>{
                        try {
                            const m = String(hex||'').trim().match(/^#?([0-9a-f]{6})$/i);
                            if (!m) return false;
                            const n = parseInt(m[1], 16);
                            const r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                            return (Math.max(r,g,b) - Math.min(r,g,b)) < 12;
                        } catch(_) { return false; }
                    };
                    const safeColor = (c)=>{
                        if (!c || typeof c !== 'string') return null;
                        const v = c.trim();
                        if (!v) return null;
                        if (v.toLowerCase() === '#000000') return null;
                        if (isGreyish(v)) return null;
                        return v;
                    };
                    const isLocked = !!(chordExt && chordExt.isLocked && chordExt.lockedData);
                    const hasFixed = !!(chordExt && typeof chordExt.fixedRootStepAbs === 'number' && chordExt.fixedRootTuning);
                    let edoForRoot = this.currentTuning || 12;
                    let rootStep;
                    if (isLocked) {
                        edoForRoot = chordExt.lockedData.lockedTuning || edoForRoot;
                        const localDelta = ((+column.dataset.localTranspose || 0) % edoForRoot + edoForRoot) % edoForRoot;
                        rootStep = ((chordExt.lockedData.lockedRoot ?? 0) + localDelta + edoForRoot) % edoForRoot;
                    } else if (hasFixed) {
                        edoForRoot = chordExt.fixedRootTuning || edoForRoot;
                        const localDelta = ((+column.dataset.localTranspose || 0) % edoForRoot + edoForRoot) % edoForRoot;
                        rootStep = ((chordExt.fixedRootStepAbs ?? 0) + localDelta + edoForRoot) % edoForRoot;
                    } else {
                        const label = (chordName?.dataset?.lockedName || chordName?.textContent || '').trim();
                        const normLabel = this._normalizeChordSymbolsForParse ? this._normalizeChordSymbolsForParse(label) : label;
                        const m = normLabel.match(/^([A-Ga-g])([#b\-d]?)([\^v]*)/);
                        if (m) {
                            const semi = this.rootToSemitone(m[1].toUpperCase(), m[2] || '');
                            let step = Math.round((semi * edoForRoot) / 12);
                            const ups = (m[3].match(/\^/g) || []).length;
                            const downs = (m[3].match(/v/g) || []).length;
                            rootStep = ((step + ups - downs) % edoForRoot + edoForRoot) % edoForRoot;
                        } else if (chordExt && typeof chordExt.originalRoot === 'number') {
                            rootStep = ((chordExt.originalRoot % edoForRoot) + edoForRoot) % edoForRoot;
                        } else {
                            rootStep = this.currentRoot ?? 0;
                        }
                    }
                    const semi = this.stepToSemitone(rootStep, edoForRoot);
                    const accent = safeColor(this.getChromaticColorForSemitone(semi)) || '#ff0000';
                    const text = this.pickTextColor(accent);
                    header.style.background = accent;
                    header.style.backgroundImage = 'none';
                    header.style.borderBottom = `2px solid ${accent}`;
                    header.style.boxShadow = `0 0 10px ${accent}55`;
                    header.style.color = text;
                    header.style.border = `1px solid ${accent}`;
                } catch(_) {}
                
                // Short click on header handled by generic gesture routing elsewhere
                
                column.appendChild(header);
                
                // Generate strings for this chord using the shared renderer
                const intervals = this.getChordIntervals(chordExt.extensions || []);
                this.generateStringsForColumn(column, intervals, chordExt.isCustom || false);
                // Initialize per-column local transpose from model, defaulting to 0
                if (!column.dataset.localTranspose) column.dataset.localTranspose = String(chordExt.localTranspose || 0);
                
                // Add to container
                container.appendChild(column);
                
                // Ensure new single-generated columns are draggable like others
                if (this.attachColumnDragHandlers) {
                    this.attachColumnDragHandlers(column);
                }
                
                return column;
            }
            
            preserveLockedChordsAndRegenerate() {
                
                // Store current locked chords before regeneration
                if (this.lockedChords && this.lockedChords.size > 0) {
                    this.savedLockedChords = Array.from(this.lockedChords.values());
                    
                    // Store the original root before any changes occur
                    const originalRoot = this.currentRoot;
                    
                    // CRITICAL: Preserve the chord extensions that are locked
                    // Don't let them get overwritten during regeneration
                    this.savedLockedChords.forEach(lockedChord => {
                        // preserve locked chord extension
                        
                        // Find the corresponding chord extension and mark it as locked
                        const chordExtension = this.chordExtensions.find(ext => {
                            // Try exact match first
                            if (ext.name === lockedChord.chordName) return true;
                            
                            const nameWithoutRoot = lockedChord.chordName.replace(/^[A-G][#b]?/, '');
                            if (ext.name === nameWithoutRoot) return true;
                            
                            // Try custom chord match
                            if (ext.isCustom && lockedChord.lockId && lockedChord.lockId.includes(ext.id || ext.name)) return true;
                            
                            return false;
                        });
                        
                        if (chordExtension) {
                            // Mark this extension as locked so it won't be modified
                            chordExtension.isLocked = true;
                            chordExtension.lockedData = lockedChord;
                            // marked as locked
                        } else {
                            // could not find chord extension for locked chord
                        }
                    });
                }
                
                // Store current piano locked chords before regeneration
                if (this.pianoLockedChords && this.pianoLockedChords.size > 0) {
                    this.savedPianoLockedChords = Array.from(this.pianoLockedChords.values());
                    
                    // Mark chord extensions as piano locked
                    this.savedPianoLockedChords.forEach(pianoLockedData => {
                        const chordExtension = this.chordExtensions.find(ext => ext.name === pianoLockedData.chordName);
                        if (chordExtension) {
                            chordExtension.isPianoLocked = true;
                            chordExtension.pianoLockedData = pianoLockedData;
                        }
                    });
                }
                
                // Clear the Maps since DOM elements will be destroyed
                this.lockedChords = new Map();
                this.pianoLockedChords = new Map();
                
                // Check if we have custom chords - if so, use exact regeneration
                const hasCustomChords = this.chordExtensions.some(chord => chord.isCustom);
                
                if (hasCustomChords) {
                    console.log('?? Has custom chords - using exact regeneration');
                    this.generateExactChordColumns();
                } else {
                    console.log('?? No custom chords - using standard regeneration');
                    this.generateExtensionColumns();
                }
            }

            generateExtensionColumns(opts = null) {
                // Generating extension columns for current tuning
                // During PLAY, defer heavy DOM rebuilds to a bar boundary for audio stability
                try {
                    const force = !!(opts && opts.force);
                    const t = this._arpTransport;
                    const playing = !!(t && (t.running || t.isRunning));
                    if (!force && playing) {
                        const scheduleDeferred = window.scheduleDeferred;
                        if (typeof scheduleDeferred === 'function') {
                            scheduleDeferred({ chordGrid: 'standard' });
                            return;
                        }
                    }
                } catch(_){ }
                const container = document.getElementById('extensionColumns');
                
                // Clear container completely to remove any leftover columns
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.gap = '0px';
                container.style.width = '100%';
                container.style.height = '100%';
                // Always reset to one-row layout by default; we may switch to two rows below
                container.style.flexDirection = 'row';
                
                const noteNames = this.getNoteNames();
                
                // Initialize hiddenColumns if not exists
                if (!this.hiddenColumns) {
                    this.hiddenColumns = [];
                }
                
                // Map chord extensions to identifiers for hiding (per-instance)
                const chordIds = this.chordExtensions.map((chord, index) => {
                    const id = (chord.id || (chord.name + '_' + index)).toLowerCase().replace(/\s+/g, '_');
                    return id;
                });
                
                // Filter visible chord extensions
                const visibleExtensions = this.chordExtensions.filter((chordExt, index) => {
                    const chordId = chordIds[index];
                    const isVisible = !this.hiddenColumns.includes(chordId);
                    return isVisible;
                });
                
                // console debug removed
                
                // If no visible extensions, show empty interface (only locked chords should be loaded)
                if (visibleExtensions.length === 0) {
                    // No visible extensions - showing empty interface
                    // Show message for empty state
                    container.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; color: #8fb3d3; font-size: 16px; text-align: center; flex-direction: column;">
                            <div id="emptyChordSplash" class="empty-chord-splash">Welcome to XENON. Drag notes here to create chords</div>
                        </div>
                    `;
                    
                    // Still restore locked chord states if they exist
                    this.restoreLockedChordStates();
                    return;
                }
                
                // Layout: split into two rows if many columns
                const useTwoRows = visibleExtensions.length > 16;
                let rowTop, rowBottom;
                if (useTwoRows) {
                    container.style.flexDirection = 'column';
                    rowTop = document.createElement('div');
                    rowBottom = document.createElement('div');
                    // Use flex growth instead of fixed 50% height, and allow shrinking (minHeight:0) to avoid clipping
                    Object.assign(rowTop.style, { display:'flex', gap:'0px', width:'100%', flex:'1 1 0', minHeight:'0' });
                    Object.assign(rowBottom.style, { display:'flex', gap:'0px', width:'100%', flex:'1 1 0', minHeight:'0' });
                    container.appendChild(rowTop);
                    container.appendChild(rowBottom);
                }

                // Always use simple layout - one column per chord type (no more variants)
                // Creating modern chord layout - each chord gets its own column
                visibleExtensions.forEach((chordExt, extensionIndex) => {
                    // Render repeat marker as a special thin column
                    if (chordExt.isRepeatMarker) {
                        const repeatCol = document.createElement('div');
                        repeatCol.className = 'repeat-marker-column';
                        repeatCol.style.width = '50px';
                        repeatCol.style.minWidth = '50px';
                        repeatCol.style.maxWidth = '50px';
                        repeatCol.style.height = '100%';
                        repeatCol.style.flex = '0 0 50px';
                        repeatCol.style.background = 'linear-gradient(135deg, rgba(255,215,0,0.3) 0%, rgba(255,140,0,0.4) 100%)';
                        repeatCol.style.border = '2px solid rgba(255,215,0,0.6)';
                        repeatCol.style.borderRadius = '8px';
                        repeatCol.style.display = 'flex';
                        repeatCol.style.alignItems = 'center';
                        repeatCol.style.justifyContent = 'center';
                        repeatCol.style.fontSize = '16px';
                        repeatCol.style.fontWeight = 'bold';
                        repeatCol.style.color = '#FFD700';
                        repeatCol.style.textShadow = '0 0 6px rgba(0,0,0,0.8)';
                        repeatCol.style.cursor = 'default';
                        repeatCol.textContent = chordExt.name; // e.g., "x4"
                        repeatCol.title = `Repeat marker: ${chordExt.name} - NO chord strings, just visual indicator`;
                        
                        // Mark as repeat marker so it gets filtered out during playback
                        repeatCol.dataset.isRepeatMarker = 'true';
                        
                        if (useTwoRows) {
                            const half = Math.ceil(visibleExtensions.length / 2);
                            const targetRow = extensionIndex < half ? rowTop : rowBottom;
                            targetRow.appendChild(repeatCol);
                        } else {
                            container.appendChild(repeatCol);
                        }
                        return; // IMPORTANT: Return early - no chord processing!
                    }
                    
                    // Render section separator as a thin dummy column
                    if (chordExt.isSeparator || chordExt.name === '|') {
                        const sepCol = document.createElement('div');
                        sepCol.className = 'extension-separator';
                        sepCol.style.width = '30px';
                        sepCol.style.minWidth = '30px';
                        sepCol.style.maxWidth = '30px';
                        sepCol.style.height = '100%';
                        sepCol.style.flex = '0 0 30px';
                        sepCol.style.background = 'transparent';
                        sepCol.style.borderLeft = '2px solid rgba(255,255,255,0.15)';
                        sepCol.style.boxShadow = 'inset 0 0 12px rgba(255,255,255,0.08)';
                        if (useTwoRows) {
                            const half = Math.ceil(visibleExtensions.length / 2);
                            const targetRow = extensionIndex < half ? rowTop : rowBottom;
                            targetRow.appendChild(sepCol);
                        } else {
                            container.appendChild(sepCol);
                        }
                        return; // go to next item
                    }
                    const column = document.createElement('div');
                    column.className = 'extension-column';
                    column.dataset.chordType = chordIds[this.chordExtensions.indexOf(chordExt)];
                    // Persist absolute index to support precise mapping for delete/reorder without DOM recreation
                    try {
                        const absoluteIndex = (typeof chordExt.position === 'number') ? chordExt.position : (this.findChordIndex ? this.findChordIndex(chordExt) : this.chordExtensions.indexOf(chordExt));
                        column.dataset.originalPosition = String(absoluteIndex);
                        column.dataset.chordId = chordExt.id || column.dataset.chordType;
                        if (!column.dataset.instanceId) {
                            column.dataset.instanceId = `${column.dataset.chordId}__${Date.now()}_${Math.floor(Math.random()*1e6)}`;
                        }
                    } catch (_) { /* non-fatal */ }
                    // Duration: each CHORDBOX represents N sixteenth-notes (default 16)
                    try {
                        let len16 = parseInt((chordExt && chordExt.len16 != null) ? chordExt.len16 : 16, 10);
                        if (!Number.isFinite(len16) || len16 <= 0) len16 = 16;
                        len16 = Math.max(1, Math.min(1024, len16|0));
                        chordExt.len16 = len16;
                        column.dataset.len16 = String(len16);
                        column.style.setProperty('--len16', String(len16));
                        column.style.flexGrow = String(len16);
                        column.style.flexShrink = '1';
                        column.style.flexBasis = '0px';
                    } catch(_){
                        column.style.flexGrow = '16';
                        column.style.flexShrink = '1';
                        column.style.flexBasis = '0px';
                    }
                    column.style.height = '100%';
                    column.style.border = 'none';
                    column.style.borderRadius = '0';
                    column.style.margin = '0';
                    column.style.padding = '0';

                    if (chordExt && chordExt.isSpacer) {
                        column.dataset.isSpacer = 'true';
                    }
                    
                    // Create header with chord name and action buttons
                    const header = document.createElement('div');
                    header.className = 'extension-header';
                    
                    // Create chord name span (inline-editable)
                    const chordName = document.createElement('span');
                    chordName.className = 'chord-name';
                    chordName.setAttribute('contenteditable', 'true');
                    chordName.setAttribute('spellcheck', 'false');

                    // Spacer (EMPTY) chordbox: represents silent time in the timeline and can be replaced by typing a chord name.
                    if (chordExt && chordExt.isSpacer) {
                        chordName.textContent = (chordExt.name && String(chordExt.name).trim()) ? chordExt.name : 'EMPTY';
                        chordName.style.color = '#ffeaa7';
                        chordName.style.fontWeight = '900';
                        chordName.title = 'EMPTY time block (type a chord name to replace)';
                    }
                    
                    // Check if this chord extension is locked and preserve its locked name
                    if (chordExt.isLocked && chordExt.lockedData) {
                        const lockedData = chordExt.lockedData;
                        const rootName = this.getNoteNames()[lockedData.lockedRoot] || lockedData.lockedRoot;
                        
                        // Use the locked name exactly as it was when locked
                        if (lockedData.chordName.match(/^[A-G][#b]?/)) {
                            chordName.textContent = lockedData.chordName;
                        } else {
                            chordName.textContent = `${rootName}${lockedData.chordName}`;
                        }
                        
                        chordName.style.color = '#4CAF50';
                        chordName.style.fontWeight = 'bold';
                        chordName.dataset.isLocked = 'true';
                        chordName.dataset.lockedName = chordName.textContent;
                        chordName.title = `ðŸ”’ LOCKED: ${rootName} root, ${lockedData.lockedTuning}TET, ${lockedData.lockedOsc1.type}/${lockedData.lockedOsc2.type} waves`;
                    } else {
                        // Regular unlocked chord - use current name
                        chordName.textContent = chordExt.name;
                    }
                    
                    // Create buttons container
                    const buttonsContainer = document.createElement('div');
                    buttonsContainer.className = 'header-buttons';
                    
                    // Create hide button (ALWAYS VISIBLE)
                    

                    // Per-column transpose controls
                    const downBtn = document.createElement('button');
                    downBtn.className = 'chord-action-button transpose-down';
                    downBtn.title = 'Transpose this chord down one step';
                    downBtn.textContent = 'â–¼';
                    const upBtn = document.createElement('button');
                    upBtn.className = 'chord-action-button transpose-up';
                    upBtn.title = 'Transpose this chord up one step';
                    upBtn.textContent = 'â–²';
                    // Prevent double-fire on touch; normalize modulo
                    let _pressGuard = false;
                    const norm = (v, m)=> ((v % m) + m) % m;
                    const applyLocalTranspose = (delta)=>{
                        if (_pressGuard) return; // avoid accidental double-fire on first tap
                        _pressGuard = true;
                        const edoNow = chordExt.fixedRootTuning || this.currentTuning || 24; // use column/root tuning
                        
                        console.log('=== LOCAL TRANSPOSE RESPELLING (v2) ===');
                        console.log('Transposing chord by', delta, 'steps in', edoNow, 'EDO');
                        console.log('this.currentTuning =', this.currentTuning);
                        console.log('Current intervals:', chordExt.intervals);
                        console.log('Current chord should be CEG in 24EDO: [0, 8, 14]');
                        console.log('Current fixedRootStepAbs:', chordExt.fixedRootStepAbs);
                        console.log('Current fixedRootStepAbs:', chordExt.fixedRootStepAbs);
                        
                        // Non-baking: adjust local transpose offset only
                        const prevLocal = parseInt(column.dataset.localTranspose || '0', 10) || 0;
                        const nextLocal = norm(prevLocal + delta, edoNow);
                        column.dataset.localTranspose = String(nextLocal);
                        chordExt.localTranspose = nextLocal; // persist to model

                        // Relabel using full chord computation like global transpose
                        const baseRoot = typeof chordExt.fixedRootStepAbs === 'number' ? chordExt.fixedRootStepAbs : 0;
                        const effRoot = norm((baseRoot % edoNow) + nextLocal, edoNow);
                        try {
                            if (chordExt.isCustom && Array.isArray(chordExt.intervals) && chordExt.intervals.length > 0) {
                                // Build absolute steps: transposed root + each interval from the transposed root
                                const absNow = [effRoot, ...chordExt.intervals.map(iv => norm(effRoot + iv, edoNow))];
                                const prefName = (chordExt && chordExt.preferredRootName)
                                    ? this._transposePreferredRootName(chordExt.preferredRootName, nextLocal, edoNow)
                                    : null;
                                const recomputed = this.computeFullChordNameFromAbsoluteSteps(
                                    absNow,
                                    edoNow,
                                    null,
                                    prefName,
                                    (chordExt && chordExt.preferredBassRel != null) ? chordExt.preferredBassRel : null
                                ) || chordExt.name;
                                chordName.textContent = recomputed;
                                chordName.dataset.lockedName = recomputed;
                                chordExt.name = recomputed;
                            } else {
                                const mRoot = (chordExt.name || '').match(/^([A-G])([#b]?)([\^vâ†‘â†“]*)(.*)$/);
                                const tail = mRoot ? (mRoot[4] || '') : '';
                                const pref = chordExt.preferredAccidental || this._getAccidentalPreference(chordExt.preferredRootName || chordExt.name);
                                const newRootName = this.getRootNameForStepWithPreference(effRoot, edoNow, pref) || String(effRoot);
                                const newName = `${newRootName}${tail}`.trim();
                                chordName.textContent = newName;
                                chordName.dataset.lockedName = newName;
                                chordExt.name = newName;
                            }
                        } catch(_) {}

                        // Re-render strings: trigger proper regeneration like global transpose does
                        const oldContainer = column.querySelector('.strings-column');
                        if (oldContainer) oldContainer.remove();
                        
                        // Regenerate this column using the same logic as regenerateAllColumnsPreservingLocks
                        const isLocked = this.lockedChords && this.lockedChords.has(column);
                        if (isLocked) {
                            const lockedChord = this.lockedChords.get(column);
                            this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals, lockedChord);
                        } else {
                            // For unlocked columns, regenerate using current global settings and the chord model
                            this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom || false);
                        }
                        try { this.currentActiveColumnEl = column; this.highlightKeyboardForColumn(column); } catch {}
                        Promise.resolve().then(()=>{ _pressGuard = false; });
                    };
                    const onPointer = (delta)=> (e)=>{ e.preventDefault(); e.stopPropagation(); applyLocalTranspose(delta); };
                    upBtn.addEventListener('pointerdown', onPointer(+1));
                    downBtn.addEventListener('pointerdown', onPointer(-1));

                    // Ensure per-column local transpose is initialized from model (default 0)
                    if (!column.dataset.localTranspose) column.dataset.localTranspose = String(chordExt.localTranspose || 0);

                    

                    // pointerdown covers mouse/touch/pen without double fires
                    
                    // Add buttons to container
                    // Keep only local transpose and piano lock
                    buttonsContainer.appendChild(downBtn);
                    buttonsContainer.appendChild(upBtn);
                    
                    header.appendChild(chordName);
                    header.appendChild(buttonsContainer);
                    
                    // Root-based header color (no greys)
                    try {
                        const isGreyish = (hex)=>{
                            try {
                                const m = String(hex||'').trim().match(/^#?([0-9a-f]{6})$/i);
                                if (!m) return false;
                                const n = parseInt(m[1], 16);
                                const r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                                return (Math.max(r,g,b) - Math.min(r,g,b)) < 12;
                            } catch(_) { return false; }
                        };
                        const safeColor = (c)=>{
                            if (!c || typeof c !== 'string') return null;
                            const v = c.trim();
                            if (!v) return null;
                            if (v.toLowerCase() === '#000000') return null;
                            if (isGreyish(v)) return null;
                            return v;
                        };
                        const isLocked = !!(chordExt && chordExt.isLocked && chordExt.lockedData);
                        const hasFixed = !!(chordExt && typeof chordExt.fixedRootStepAbs === 'number' && chordExt.fixedRootTuning);
                        let edoForRoot = this.currentTuning || 12;
                        let rootStep;
                        if (isLocked) {
                            edoForRoot = chordExt.lockedData.lockedTuning || edoForRoot;
                            const localDelta = ((+column.dataset.localTranspose || 0) % edoForRoot + edoForRoot) % edoForRoot;
                            rootStep = ((chordExt.lockedData.lockedRoot ?? 0) + localDelta + edoForRoot) % edoForRoot;
                        } else if (hasFixed) {
                            edoForRoot = chordExt.fixedRootTuning || edoForRoot;
                            const localDelta = ((+column.dataset.localTranspose || 0) % edoForRoot + edoForRoot) % edoForRoot;
                            rootStep = ((chordExt.fixedRootStepAbs ?? 0) + localDelta + edoForRoot) % edoForRoot;
                        } else {
                            const label = (chordName?.dataset?.lockedName || chordName?.textContent || '').trim();
                            const normLabel = this._normalizeChordSymbolsForParse ? this._normalizeChordSymbolsForParse(label) : label;
                            const m = normLabel.match(/^([A-Ga-g])([#b\-d]?)([\^v]*)/);
                            if (m) {
                                const semi = this.rootToSemitone(m[1].toUpperCase(), m[2] || '');
                                let step = Math.round((semi * edoForRoot) / 12);
                                const ups = (m[3].match(/\^/g) || []).length;
                                const downs = (m[3].match(/v/g) || []).length;
                                rootStep = ((step + ups - downs) % edoForRoot + edoForRoot) % edoForRoot;
                            } else if (chordExt && typeof chordExt.originalRoot === 'number') {
                                rootStep = ((chordExt.originalRoot % edoForRoot) + edoForRoot) % edoForRoot;
                            } else {
                                rootStep = this.currentRoot ?? 0;
                            }
                        }
                        const semi = this.stepToSemitone(rootStep, edoForRoot);
                        const accent = safeColor(this.getChromaticColorForSemitone(semi)) || '#ff0000';
                        const text = this.pickTextColor(accent);
                        header.style.background = accent;
                        header.style.backgroundImage = 'none';
                        header.style.borderBottom = `2px solid ${accent}`;
                        header.style.boxShadow = `0 0 10px ${accent}55`;
                        header.style.color = text;
                        header.style.border = `1px solid ${accent}`;
                    } catch(_) {}
                    
                    // Inline editing: Enter to apply, ESC to cancel
                    const applyTypedName = () => {
                        try {
                            const rawInput = (chordName.textContent || '').trim();
                            if (!rawInput) return;

                            // Support duration multiplier syntax in-place, e.g. "Am x4" -> one chordbox len16 = 64.
                            let chordText = rawInput;
                            let barsMult = null;
                            try {
                                const m = rawInput.match(/^(.*\S)\s+[xX]\s*(\d+)\s*$/);
                                if (m) {
                                    chordText = String(m[1] || '').trim();
                                    const n = Math.max(1, parseInt(m[2], 10) || 1);
                                    barsMult = n;
                                }
                            } catch(_){ }

                            const existingLen16 = (()=>{
                                try {
                                    const v = parseInt((column?.dataset?.len16) || (chordExt && chordExt.len16) || '16', 10);
                                    return (Number.isFinite(v) && v > 0) ? v : 16;
                                } catch(_){ return 16; }
                            })();
                            const targetLen16 = (barsMult != null)
                                ? Math.max(1, Math.min(1024, (barsMult * 16) | 0))
                                : existingLen16;

                            const added = (typeof this.addChordFromName === 'function') ? this.addChordFromName(chordText) : null;
                            if (!added || !added.chord) {
                                const prevOutline = chordName.style.outline;
                                chordName.style.outline = '2px solid #e74c3c';
                                setTimeout(()=> { chordName.style.outline = prevOutline; }, 600);
                                return;
                            }

                            const parsed = added.chord;
                            // addChordFromName appends; remove the appended copy and use it to replace in place
                            try {
                                const arr = this.chordExtensions || [];
                                if (arr[arr.length - 1] === parsed) arr.pop();
                                else {
                                    const k = arr.findIndex(c => c && parsed && c.id && c.id === parsed.id);
                                    if (k >= 0) arr.splice(k, 1);
                                }
                            } catch(_){ }

                            // Find the correct target chord (stable across reorders)
                            let idx = -1;
                            try {
                                const colId = column.dataset.chordId;
                                if (colId) idx = (this.chordExtensions || []).findIndex(c => c && c.id === colId);
                            } catch(_){ }
                            if (idx < 0) idx = (this.chordExtensions || []).indexOf(chordExt);
                            if (idx < 0) {
                                const maybe = parseInt(column.dataset.originalPosition || '-1', 10);
                                if (!isNaN(maybe) && maybe >= 0 && maybe < (this.chordExtensions || []).length) idx = maybe;
                            }
                            if (idx < 0) return;

                            // Rename = replace chord identity and RESET per-chord transpose/locks
                            parsed.position = chordExt.position;
                            parsed.localTranspose = 0;
                            parsed.len16 = targetLen16;
                            try {
                                parsed.isLocked = false;
                                parsed.lockedData = null;
                            } catch(_){ }
                            try {
                                if (this.lockedChords && this.lockedChords.has(column)) this.lockedChords.delete(column);
                            } catch(_){ }

                            (this.chordExtensions || []).splice(idx, 1, parsed);

                            column.dataset.chordId = parsed.id || column.dataset.chordId;
                            column.dataset.originalPosition = String(idx);
                            column.dataset.localTranspose = '0';

                            // Apply duration to DOM (drives visual width + SAVE)
                            try {
                                column.dataset.len16 = String(targetLen16);
                                column.style.setProperty('--len16', String(targetLen16));
                                column.style.flexGrow = String(targetLen16);
                                column.style.flexShrink = '1';
                                column.style.flexBasis = '0px';
                            } catch(_){ }

                            chordName.textContent = parsed.name;
                            chordName.dataset.lockedName = parsed.name;
                            try { column.dataset.lastIntervals = JSON.stringify(parsed.intervals || []); } catch(_){ }

                            const old = column.querySelector('.strings-column');
                            if (old) old.remove();
                            this.generateStringsForColumn(column, parsed.intervals, parsed.isCustom || false);
                            try { this.currentActiveColumnEl = column; } catch(_){ }
                            try { this.highlightKeyboardForColumn(column); } catch(_){ }
                            try { this.saveChordConfiguration?.(); } catch(_){ }
                            try { this.updateChordDisplay?.(); } catch(_){ }
                        } catch (err) { console.error('applyTypedName error:', err); }
                    };
                    chordName.addEventListener('keydown', (ev)=>{
                        if (ev.key === 'Enter') {
                            // ENTER = confirm only
                            ev.preventDefault();
                            applyTypedName();
                            chordName.blur();
                            return;
                        }

                        if (ev.key === 'Tab') {
                            // TAB = confirm + move/create
                            ev.preventDefault();
                            applyTypedName();

                            const cols = Array.from(document.querySelectorAll('#extensionColumns .extension-column'));
                            const idx = cols.indexOf(column);
                            const focusChordName = (colEl)=>{
                                try {
                                    const el = colEl && colEl.querySelector && colEl.querySelector('.extension-header .chord-name');
                                    if (!el || typeof el.focus !== 'function') return false;
                                    el.focus();
                                    const sel = window.getSelection && window.getSelection();
                                    if (sel && document.createRange) {
                                        const r = document.createRange();
                                        r.selectNodeContents(el);
                                        sel.removeAllRanges();
                                        sel.addRange(r);
                                    }
                                    return true;
                                } catch(_){ return false; }
                            };

                            if (ev.shiftKey) {
                                if (idx > 0) focusChordName(cols[idx - 1]);
                                return;
                            }

                            // If there's already a blank "New" chord immediately to the right, just focus it.
                            try {
                                const nextCol = (idx >= 0 && idx < cols.length - 1) ? cols[idx + 1] : null;
                                if (nextCol) {
                                    const nextId = nextCol?.dataset?.chordId ? String(nextCol.dataset.chordId) : null;
                                    const nextExt = nextId ? (this.chordExtensions || []).find(c => c && String(c.id) === nextId) : null;
                                    const isBlank = !!(nextExt && nextExt.isCustom && (!nextExt.intervals || nextExt.intervals.length === 0) && String(nextExt.name || '').trim().toLowerCase() === 'new');
                                    if (isBlank) {
                                        focusChordName(nextCol);
                                        return;
                                    }
                                }
                            } catch(_){ }
                            try {
                                const afterId = (column && column.dataset && column.dataset.chordId) ? String(column.dataset.chordId) : null;
                                if (afterId) this.createBlankChordColumn({ insertAfterId: afterId });
                                else this.createBlankChordColumn();
                            } catch(_){ }
                            return;
                        }

                        if (ev.key === 'Escape') { ev.preventDefault(); chordName.blur(); }
                    });
                    chordName.addEventListener('click', (e)=>{ e.stopPropagation(); });
                    chordName.addEventListener('mousedown', (e)=>{ e.stopPropagation(); });
                    chordName.addEventListener('touchstart', (e)=>{ e.stopPropagation(); }, {passive:true});

                    // Header short click: play chord/arp (handled by generic gesture router)
                    header.addEventListener('click', (e) => {
                        if (
                            e.target.classList.contains('lock-button') ||
                            e.target.classList.contains('chord-action-button') ||
                            e.target.tagName === 'BUTTON'
                        ) return;
                        this.handleClick(header, 'chord', e.clientX, e.clientY);
                    });
                    
                    column.appendChild(header);
                    
                    // Add elements to header
                    header.appendChild(chordName);
                    header.appendChild(buttonsContainer);
                    
                    // Remove duplicate simplified handler; playback handled above
                    
                    column.appendChild(header);
                    
                    // Persist the last intervals and ensure a default voicing variant for revoice
                    try { column.dataset.lastIntervals = JSON.stringify(chordExt.intervals || []); } catch(_){}
                    if (!column.dataset.voicingVariant) { column.dataset.voicingVariant = '0'; }

                    // Generate strings for this chord; prefer locked snapshot
                    if (chordExt && chordExt.isSpacer) {
                        // No strings: this is a silent time block.
                        const emptyBody = document.createElement('div');
                        emptyBody.className = 'strings-column';
                        emptyBody.style.flex = '1 1 auto';
                        emptyBody.style.display = 'flex';
                        emptyBody.style.alignItems = 'center';
                        emptyBody.style.justifyContent = 'center';
                        emptyBody.style.color = 'rgba(255,255,255,0.35)';
                        emptyBody.style.fontSize = '12px';
                        emptyBody.style.letterSpacing = '1px';
                        emptyBody.textContent = 'DROP / TYPE CHORD';
                        column.appendChild(emptyBody);
                    } else {
                        if (chordExt.isLocked && chordExt.lockedData) {
                            this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals, chordExt.lockedData);
                        } else {
                            this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom || false);
                        }
                    }
                    
                    // Enable long-press drag reordering
                    this.attachColumnDragHandlers(column);
                    if (useTwoRows) {
                        const half = Math.ceil(visibleExtensions.length / 2);
                        const targetRow = extensionIndex < half ? rowTop : rowBottom;
                        targetRow.appendChild(column);
                        const sc = column.querySelector('.strings-column');
                        if (sc) {
                            const headerEl = column.querySelector('.extension-header');
                            const headerPx = Math.max(56, headerEl ? headerEl.offsetHeight : 56);
                            sc.style.height = `calc(100% - ${headerPx}px)`;
                        }
                    } else {
                        container.appendChild(column);
                    }
                });
                
                // Establish deterministic play order (leftâ†’right; top row before bottom row)
                try {
                    const containerEl = document.getElementById('extensionColumns');
                    let ordered = [];
                    if (useTwoRows) {
                        const topCols = Array.from(rowTop.querySelectorAll('.extension-column'));
                        const bottomCols = Array.from(rowBottom.querySelectorAll('.extension-column'));
                        ordered = [...topCols, ...bottomCols];
                    } else {
                        ordered = Array.from(containerEl.querySelectorAll('.extension-column'));
                    }
                    this._orderedColumns = ordered;
                    ordered.forEach((col, idx)=>{ col.dataset.playIndex = String(idx); });
                    // If nothing is active or a previous active column is not in DOM, choose the first visible
                    if (!this.currentActiveColumnEl || !document.body.contains(this.currentActiveColumnEl)) {
                        this.currentActiveColumnEl = ordered[0] || null;
                    }
                } catch(_) {}

                // Add click handlers after rendering
                setTimeout(() => {
                    this.addSimpleClickHandlers();
                    this.restoreLockedChordStates(); // Restore locked chord states
                    this.restorePianoLockStates(); // Restore piano lock states
                    try { if (typeof window.initChordBoxDurationResize === 'function') window.initChordBoxDurationResize(); } catch(_){ }
                }, 100);
            }

            /**
             * regenerateChordGrid
             * Compatibility shim expected by newer persistence import path.
             * Attempts to regenerate the chord columns while preserving any
             * locked chord / piano lock state. Falls back progressively.
             */
            regenerateChordGrid() {
                try {
                    if (typeof this.preserveLockedChordsAndRegenerate === 'function') {
                        return this.preserveLockedChordsAndRegenerate();
                    }
                    if (typeof this.generateExtensionColumns === 'function') {
                        return this.generateExtensionColumns();
                    }
                    console.warn('regenerateChordGrid(): no chord generation function available');
                } catch (e) {
                    console.error('regenerateChordGrid() failed:', e);
                }
            }
            
            // Restore piano lock button states after column regeneration
            restorePianoLockStates() {
                if (!this.pianoLockedChords) return;

                // restoring piano lock states

                const columns = Array.from(document.querySelectorAll('.extension-column'));
                // Clear previous visual markers
                columns.forEach(c => c.classList.remove('piano-locked-col'));

                for (const [lockKey, data] of this.pianoLockedChords.entries()) {
                    const targetSig = (data && data.intervalsSig) ? String(data.intervalsSig) : '';
                    // Find first matching column by intervals signature and mark it as owner
                    const match = columns.find(col => {
                        try {
                            const rel = this.getChordStepsForColumn(col) || [];
                            const sig = Array.isArray(rel) ? rel.slice().map(n=>Number(n)||0).sort((a,b)=>a-b).join('.') : '';
                            return sig === targetSig;
                        } catch(_) { return false; }
                    });
                    if (match) {
                        try {
                            // Persist minimal flags on the column's chord data for other routines to read
                            const header = match.querySelector('.extension-header');
                            const cd = this.getChordDataFromColumn(match, header);
                            if (cd) {
                                cd.isPianoLocked = true;
                                cd.pianoLockedData = data;
                                cd.pianoLockKey = lockKey;
                            }
                        } catch(_) {}
                        match.classList.add('piano-locked-col');
                    }
                }
            }

            // Helper: is the currently active column piano-locked (osc/effects)?
            isActiveChordPianoLocked() {
                try {
                    const col = this.currentActiveColumnEl;
                    if (!col || !document.body.contains(col)) return false;
                    let chordData = null;
                    try {
                        const header = col.querySelector('.extension-header .chord-name');
                        if (typeof this.getChordDataFromColumn === 'function') {
                            chordData = this.getChordDataFromColumn(col, header);
                        }
                    } catch (_) {}
                    if (!chordData) {
                        chordData = {
                            name: col.dataset.chordType,
                            quality: this.currentQuality,
                            extensions: col.dataset.extensions ? col.dataset.extensions.split(',') : [],
                            intervals: []
                        };
                    }
                    const data = (typeof this.findPianoLockData === 'function') ? this.findPianoLockData(chordData) : null;
                    return !!data;
                } catch (_) {
                    return false;
                }
            }

            // Brief visual nudge on the piano-lock button when edits are blocked
            flashPianoLockFeedback() {
                try {
                    const col = this.currentActiveColumnEl;
                    if (!col) return;
                    const prevShadow = col.style.boxShadow;
                    const prevTransform = col.style.transform;
                    col.style.boxShadow = '0 0 16px rgba(139, 92, 246, 0.6)';
                    col.style.transform = 'scale(1.01)';
                    setTimeout(() => { col.style.boxShadow = prevShadow; col.style.transform = prevTransform; }, 200);
                } catch (_) {}
            }
            
            getIntervalColor(interval) {
                // Neon color coding for musical intervals with microtonal gradient support
                const normalizedInterval = ((interval % 12) + 12) % 12;

                // Requested palette mapping (0-11):
                // 0 White, 1 Deep Violet, 2 Bright Orange, 3 Blue, 4 Red,
                // 5 Cyan, 6 Black, 7 Green, 8 Magenta, 9 Bright Yellow,
                // 10 Dark Blue, 11 Lime Green
                const chromaticColors = [
                    { interval: 0, color: '#EEEEEE', name: 'Root' },           // White
                    { interval: 1, color: '#5A0D5D', name: 'm2/â™­9' },          // Deep Violet
                    { interval: 2, color: '#99A500', name: 'M2/9' },           // Bright Orange
                    { interval: 3, color: '#0000CC', name: 'm3' },             // Blue
                    { interval: 4, color: '#CC0000', name: 'M3' },             // Red
                    { interval: 5, color: '#00CCCC', name: 'P4/11' },          // Cyan
                    { interval: 6, color: '#C0C0C0', name: 'TT' },             // Silver (tritone)
                    { interval: 7, color: '#00CC00', name: 'P5' },             // Green
                    { interval: 8, color: '#CC00CC', name: 'm6/â™¯5' },          // Magenta
                    { interval: 9, color: '#EEEE00', name: 'M6/13' },          // Bright Yellow
                    { interval: 10, color: '#00008B', name: 'm7' },            // Dark Blue
                    { interval: 11, color: '#229D22', name: 'M7' },            // Lime Green
                ];

                // Exact chromatic matches
                for (let i = 0; i < chromaticColors.length; i++) {
                    const chromatic = chromaticColors[i];
                    if (Math.abs(normalizedInterval - chromatic.interval) < 0.05) {
                        return { color: chromatic.color, name: chromatic.name };
                    }
                }

                // Microtonal interpolation between adjacent chromatic steps
                for (let i = 0; i < chromaticColors.length; i++) {
                    const current = chromaticColors[i];
                    const next = chromaticColors[(i + 1) % chromaticColors.length];

                    let lowerBound = current.interval;
                    let upperBound = next.interval;
                    if (next.interval < current.interval) upperBound = next.interval + 12; // wrap

                    let testInterval = normalizedInterval;
                    if (upperBound > 12 && normalizedInterval < 6) testInterval = normalizedInterval + 12;

                    if (testInterval > lowerBound + 0.05 && testInterval < upperBound - 0.05) {
                        const position = (testInterval - lowerBound) / (upperBound - lowerBound);
                        const gradientColor = this.interpolateColors(current.color, next.color, position);
                        const cents = Math.round((normalizedInterval - Math.floor(normalizedInterval)) * 100);
                        const baseName = current.name.split('/')[0];
                        const gradientName = `${baseName}+${cents}Â¢`;
                        return { color: gradientColor, name: gradientName };
                    }
                }

                return { color: '#CCCCCC', name: 'Unknown' };
            }

            // Map an EDO step to nearest 12-TET semitone index (0..11)
            stepToSemitone(step, edo) {
                if (edo <= 0) return 0;
                const semi = Math.round((step * 12) / edo) % 12;
                return ((semi % 12) + 12) % 12;
            }
            // Map a 12-TET semitone (0..11) to the nearest step in a given EDO
            semitoneToStep(semi, edo) {
                if (!edo || edo <= 0) return 0;
                const s = Math.round(((semi % 12 + 12) % 12) * edo / 12);
                return ((s % edo) + edo) % edo;
            }
            
            // Root selection: leftmost (lowest) note unless a clear major/minor triad exists on another pitch;
            // slash only when bass is the (flat/neutral) seventh
            computeFullChordNameFromAbsoluteSteps(absSteps, edo = (this.currentTuning || 12), preferredBassAbs = null, preferredRootName = null, preferredBassRel = null){
                if (!Array.isArray(absSteps) || absSteps.length < 1) return '';
                // Use absolute steps as-is; global transpose should already be baked in by caller
                const steps = Array.from(new Set(absSteps.map(s => ((s % edo) + edo) % edo)));
                if (steps.length < 2) {
                    const rootOnly = steps[0] ?? 0;
                    return this.getRootNameForStep(rootOnly, edo);
                }

                // Bass candidate: prefer provided; else lowest by 12-TET approximation (leftmost)
                const bassAbs = (preferredBassAbs != null)
                    ? ((preferredBassAbs % edo) + edo) % edo
                    : steps.slice().sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo))[0];

                // If a preferred root spelling is provided, honor it.
                let preferredRootAbs = null;
                try {
                    if (preferredRootName) {
                        const normPref = this._normalizeChordSymbolsForParse(preferredRootName);
                        const m = normPref.match(/^([A-G])([#bâ™­â™¯ð„²ð„³d]?)([\^v]*)/);
                        if (m) {
                            let acc = m[2] || '';
                            let micro = m[3] || '';
                            // Treat half-flat/sharp as micro marks
                            if (acc === 'd' || acc === 'ð„³') { acc = ''; micro = 'v' + micro; }
                            if (acc === 'ð„²') { acc = ''; micro = '^' + micro; }
                            const semi = this.rootToSemitone(m[1], acc || '');
                            const baseStep = Math.round((semi * edo) / 12);
                            const ups = (micro.match(/\^/g) || []).length;
                            const downs = (micro.match(/v/g) || []).length;
                            const targetStep = ((baseStep + ups - downs) % edo + edo) % edo;
                            if (steps.includes(targetStep)) preferredRootAbs = targetStep;
                            else {
                                // Choose nearest by semitone distance
                                let best = null; let bestDist = Infinity;
                                for (const s of steps) {
                                    const d = Math.abs(this.stepToSemitone(s, edo) - this.stepToSemitone(targetStep, edo));
                                    if (d < bestDist) { bestDist = d; best = s; }
                                }
                                if (best != null) preferredRootAbs = best;
                            }
                        }
                    }
                } catch(_){ }

                // Choose root by simplest symbol and spelling, unless a preferred root was provided.
                let rootAbs = (preferredRootAbs != null) ? preferredRootAbs : bassAbs;
                const prefStyle = preferredRootName ? this._getAccidentalPreference(preferredRootName) : null;
                let rootName = this.getRootNameForStepWithPreference(rootAbs, edo, prefStyle);
                let symbol = this.getProperChordSymbol(steps.map(s => ((s - rootAbs) % edo + edo) % edo));
                if (preferredRootAbs == null) {
                    let best = null;
                    for (const cand of steps) {
                        const rels = steps.map(s => ((s - cand) % edo + edo) % edo);
                        const sym = this.getProperChordSymbol(rels);
                        const name = this.getRootNameForStepWithPreference(cand, edo, prefStyle);
                        const addCount = (String(sym).match(/add/g) || []).length;
                        const susCount = (String(sym).match(/sus/g) || []).length;
                        const accCount = (String(name).match(/[â™¯#â™­bð„²ð„³]/g) || []).length;
                        const microCount = (String(name).match(/[ð…‰ð…]/g) || []).length;
                        let score = String(sym).length + addCount * 4 + susCount * 2 + accCount * 2 + microCount * 1.5;
                        if (sym === '' || sym === 'm' || sym === '7' || sym === 'm7' || sym === 'maj7' || sym === 'n' || sym === 'n7') score -= 3;
                        if (!best || score < best.score) best = { cand, score, sym, name };
                    }
                    if (best) {
                        rootAbs = best.cand;
                        rootName = best.name;
                        symbol = best.sym;
                    }
                }

                // Slash policy: only for explicit slash chords (preferredBassRel provided)
                let slash = '';
                if (preferredBassRel != null) {
                    const bassAbsExplicit = ((rootAbs + preferredBassRel) % edo + edo) % edo;
                    const bassName = this.getRootNameForStep(bassAbsExplicit, edo);
                    slash = `/${bassName}`;
                }
                const rawLabel = `${rootName}${symbol}${slash}`;
                return rawLabel;
            }

            

            // Internal: choose the root within absSteps that yields the clearest 12-TET quality
            _chooseBestRootByQuality(absSteps, edo){
                const uniq = Array.from(new Set(absSteps.map(s => ((s % edo) + edo) % edo)));
                // Known quality targets in semitones (12-TET)
                const targets = [
                    {name:'maj', ints:[0,4,7], score:10},
                    {name:'min', ints:[0,3,7], score:10},
                    {name:'dim', ints:[0,3,6], score:8},
                    {name:'aug', ints:[0,4,8], score:8},
                    {name:'sus2',ints:[0,2,7], score:7},
                    {name:'sus4',ints:[0,5,7], score:7},
                ];
                let best = {root: uniq[0], score: -Infinity, rels12: null};
                // Precompute semitones for each abs step
                const semiMap = new Map();
                uniq.forEach(s => semiMap.set(s, this.stepToSemitone(s, edo)));
                uniq.forEach(root => {
                    const rootSemi = semiMap.get(root);
                    const rels12 = uniq.map(s => ((semiMap.get(s) - rootSemi + 12) % 12)).sort((a,b)=>a-b);
                    // Score against targets: exact subset/superset gets high score
                    let sMax = -1;
                    for (const t of targets) {
                        const tSet = new Set(t.ints);
                        const relSet = new Set(rels12);
                        const hitAll = t.ints.every(x => relSet.has(x));
                        if (hitAll) sMax = Math.max(sMax, t.score);
                    }
                    // Minor preference: if both maj/min ambiguous, keep the one whose lowest spelled triad is exact
                    if (sMax > best.score) best = {root, score: sMax, rels12};
                });
                // Fallback: pick by minimal semitone (previous behavior) if no quality matched
                if (best.score < 0) {
                    const r = uniq.slice().sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo))[0];
                    const rootSemi = this.stepToSemitone(r, edo);
                    const rels12 = uniq.map(s => ((this.stepToSemitone(s, edo) - rootSemi + 12) % 12)).sort((a,b)=>a-b);
                    return {root: r, score: 0, rels12};
                }
                return best;
            }

            // Universal pitch colors: C=RED, D=ORANGE, E=YELLOW, F=GREEN, G=BLUE, A=INDIGO, B=VIOLET
            _universalColorAnchors() {
                return [
                    { semi: 0,  name: 'C', color: '#FF0000' }, // Red
                    { semi: 2,  name: 'D', color: '#FFA500' }, // Orange
                    { semi: 4,  name: 'E', color: '#FFFF00' }, // Yellow
                    { semi: 5,  name: 'F', color: '#00FF00' }, // Green
                    { semi: 7,  name: 'G', color: '#0000FF' }, // Blue
                    { semi: 9,  name: 'A', color: '#4B0082' }, // Indigo
                    { semi: 11, name: 'B', color: '#8F00FF' }, // Violet
                    { semi: 12, name: 'C', color: '#FF0000' }, // wrap C for interpolation
                ];
            }
            _getUniversalColorForSemitoneFloat(semiFloat) {
                let x = semiFloat;
                while (x < 0) x += 12;
                while (x > 12) x -= 12;
                const anchors = this._universalColorAnchors();
                // exact anchor
                for (let i = 0; i < anchors.length - 1; i++) {
                    if (Math.abs(x - anchors[i].semi) < 1e-6) return { color: anchors[i].color, name: anchors[i].name };
                }
                // find segment
                let lo = anchors[0], hi = anchors[anchors.length - 1];
                for (let i = 0; i < anchors.length - 1; i++) {
                    const a = anchors[i], b = anchors[i+1];
                    if (x >= a.semi && x <= b.semi) { lo = a; hi = b; break; }
                }
                const span = Math.max(1e-6, hi.semi - lo.semi);
                const t = Math.min(1, Math.max(0, (x - lo.semi) / span));
                return { color: this.interpolateColors(lo.color, hi.color, t), name: t < 0.5 ? lo.name : hi.name };
            }
            getUniversalPitchColorForStep(step, edo) {
                if (!edo || edo <= 0) return { color: '#CCCCCC', name: '' };
                const semiFloat = (step * 12) / edo;
                return this._getUniversalColorForSemitoneFloat(((semiFloat % 12) + 12) % 12);
            }
            // Map semitone (integer) to universal color
            getChromaticColorForSemitone(semi) {
                const s = ((semi % 12) + 12) % 12;
                return this._getUniversalColorForSemitoneFloat(s).color;
            }

            // Simple contrast helper for header text
            pickTextColor(bgHex, light = '#FFFFFF', dark = '#000000') {
                const h = (bgHex || '#000000').replace('#','');
                const r = parseInt(h.substring(0,2),16) || 0;
                const g = parseInt(h.substring(2,4),16) || 0;
                const b = parseInt(h.substring(4,6),16) || 0;
                const brightness = (r*299 + g*587 + b*114) / 1000;
                return brightness > 150 ? dark : light;
            }
            
            interpolateColors(color1, color2, factor) {
                // Convert hex colors to RGB, interpolate, and convert back
                const hex1 = color1.replace('#', '');
                const hex2 = color2.replace('#', '');
                
                const r1 = parseInt(hex1.substr(0, 2), 16);
                const g1 = parseInt(hex1.substr(2, 2), 16);
                const b1 = parseInt(hex1.substr(4, 2), 16);
                
                const r2 = parseInt(hex2.substr(0, 2), 16);
                const g2 = parseInt(hex2.substr(2, 2), 16);
                const b2 = parseInt(hex2.substr(4, 2), 16);
                
                const r = Math.round(r1 + (r2 - r1) * factor);
                const g = Math.round(g1 + (g2 - g1) * factor);
                const b = Math.round(b1 + (b2 - b1) * factor);
                
                return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
            }

            generateStringsForColumn(column, intervals, isCustomChord = false) {
                // Resolve lock/model first so we can recover intervals if caller passed empty
                const lockedChord = this.lockedChords?.get(column);
                let model = null;
                try {
                    // Prefer stable ID mapping first
                    const id = column.dataset.chordId;
                    let idx = -1;
                    if (id) idx = (this.chordExtensions||[]).findIndex(c=> c && (String(c.id)===String(id)));
                    if (idx < 0 && column.dataset.originalPosition != null) {
                        const op = parseInt(column.dataset.originalPosition,10);
                        if (!isNaN(op) && op >= 0) idx = op;
                    }
                    if (idx >= 0) model = (this.chordExtensions||[])[idx];
                } catch(_) {}
                // Fallback: if no intervals were provided, recover them from the model
                if (!intervals || !Array.isArray(intervals) || intervals.length === 0) {
                    const recovered = model && Array.isArray(model.intervals) ? model.intervals : null;
                    if (recovered && recovered.length > 0) {
                        intervals = recovered;
                    }
                }
                // If still empty, render an empty strings container and exit
                if (!intervals || !Array.isArray(intervals) || intervals.length === 0) {
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                    const stringsContainer = document.createElement('div');
                    stringsContainer.className = 'strings-column';
                    // Compute dynamic header height for robust layout in two-row mode
                    const headerEl = column.querySelector('.extension-header');
                    const headerPx = Math.max(56, headerEl ? headerEl.offsetHeight : 56);
                    stringsContainer.style.cssText = `flex:1; overflow:hidden; padding:1px; height: calc(100% - ${headerPx}px); display:flex; flex-direction:column; justify-content:center; align-items:center; color:#8fb3d3; font-size:12px; opacity:0.8;`;
                    // Respect global invert-strings preference
                    try { if (document.documentElement.classList.contains('invert-strings')) stringsContainer.style.flexDirection = 'column-reverse'; } catch(_) {}
                    const hint = document.createElement('div');
                    hint.textContent = 'Tap keys to add notes';
                    stringsContainer.appendChild(hint);
                    column.appendChild(stringsContainer);
                    // Footer removed; ensure fit after insertion
                    this.ensureStringsFullyVisible(stringsContainer);
                    return;
                }

                // If exact frequencies were captured for this column, render snapshot and exit
                // But skip snapshot if a local per-column transpose is active, so arrows take effect
                const hasLocalTranspose = ((+column.dataset.localTranspose || 0) !== 0);
                if (lockedChord && Array.isArray(lockedChord.exactFrequencies) && lockedChord.exactFrequencies.length > 0 && !this._transposing && !hasLocalTranspose) {
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                    this.generateStringsWithExactFrequencies(column, lockedChord);
                    return;
                }
                
                // Use locked settings if available, otherwise use current settings
                let currentRoot, currentTuning;
                if (lockedChord) {
                    const edo = lockedChord.lockedTuning || this.currentTuning || 12;
                    const globalDelta = (this.transposeDelta || 0) % edo;
                    const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                    // Locked chords preserve exact pitch by default; do not apply globalDelta here
                    currentRoot = ((lockedChord.lockedRoot ?? 0) + localDelta + edo) % edo;
                    currentTuning = lockedChord.lockedTuning;
                } else {
                    // Prefer per-chord fixed root if present; apply deltas so audio follows arrows and global transpose
                    if (model && typeof model.fixedRootStepAbs === 'number' && model.fixedRootTuning) {
                        currentTuning = model.fixedRootTuning;
                        const edo = currentTuning || this.getTuningStepsPerOctave();
                        const globalDelta = (this.transposeDelta || 0) % edo;
                        const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                        console.log('AUDIO GENERATION DEBUG: fixedRootStepAbs =', model.fixedRootStepAbs, 'globalDelta =', globalDelta, 'localDelta =', localDelta, 'edo =', edo);
                        currentRoot = (((model.fixedRootStepAbs % edo) + globalDelta + localDelta) % edo + edo) % edo;
                        console.log('AUDIO GENERATION DEBUG: calculated currentRoot =', currentRoot);
                    } else {
                        // Start from current global context; header label parsing below may override
                        currentRoot = this.currentRoot;
                        currentTuning = this.currentTuning;
                    }
                }
                
                
                
                const noteNames = this.getNoteNames();
                const tuningSize = currentTuning || this.getTuningStepsPerOctave();

                // Ensure header label matches actual notes after local transpose (no global baked into label)
                // Skip locked chords (they preserve exact label)
                try {
                    if (!lockedChord) {
                        const nameEl = column.querySelector('.extension-header .chord-name');
                        if (nameEl && model && Array.isArray(model.intervals) && model.intervals.length > 0) {
                            const edoNow = this.currentTuning || tuningSize || 12;
                            const modelEdo = model.fixedRootTuning || edoNow;
                            const mapStep = (step, srcEdo, dstEdo) => {
                                const cents = ((step % srcEdo + srcEdo) % srcEdo) * (1200 / srcEdo);
                                const dst = Math.round(cents / (1200 / dstEdo));
                                return ((dst % dstEdo) + dstEdo) % dstEdo;
                            };
                            const localDeltaNow = ((+column.dataset.localTranspose || 0) % edoNow + edoNow) % edoNow;
                            const globalDeltaNow = ((this.transposeDelta || 0) % edoNow + edoNow) % edoNow;
                            const localDeltaModel = (modelEdo === edoNow) ? localDeltaNow : mapStep(localDeltaNow, edoNow, modelEdo);
                            const globalDeltaModel = (modelEdo === edoNow) ? globalDeltaNow : mapStep(globalDeltaNow, edoNow, modelEdo);
                            const baseRootModel = (typeof model.fixedRootStepAbs === 'number') ? ((model.fixedRootStepAbs % modelEdo) + modelEdo) % modelEdo : 0;
                            const effRootModel = (((baseRootModel) + localDeltaModel + globalDeltaModel) % modelEdo + modelEdo) % modelEdo;
                            // Build degree steps in model's EDO
                            const degreeStepsModel = model.isCustom
                                ? model.intervals.map(iv => ((iv % modelEdo) + modelEdo) % modelEdo)
                                : model.intervals.map(iv => this.mapIntervalToEDO(iv, modelEdo));
                            const absModel = [effRootModel, ...degreeStepsModel.map(d => (effRootModel + d) % modelEdo)];
                            const absNow = (modelEdo === edoNow) ? absModel.map(s => ((s%edoNow)+edoNow)%edoNow)
                                                                : absModel.map(s => mapStep(s, modelEdo, edoNow));
                            const shiftNow = (localDeltaNow + globalDeltaNow) % edoNow;
                            const prefName = (model && model.preferredRootName)
                                ? this._transposePreferredRootName(model.preferredRootName, shiftNow, edoNow)
                                : null;
                            const recomputedLabel = this.computeFullChordNameFromAbsoluteSteps(
                                absNow,
                                edoNow,
                                null,
                                prefName,
                                (model && model.preferredBassRel != null) ? model.preferredBassRel : null
                            );
                            if (recomputedLabel) {
                                nameEl.textContent = recomputedLabel;
                                nameEl.dataset.lockedName = recomputedLabel;
                                try { model.name = recomputedLabel; } catch(_) {}
                            }
                        }
                    }
                } catch(_) {}

                // For unlocked, non-fixed-root chords: derive pitch from base currentRoot plus global/local transpose deltas
                // This guarantees audio shifts by exact EDO steps on global transpose, independent of header text parsing.
                if (!lockedChord && !(model && typeof model.fixedRootStepAbs === 'number')) {
                    const edo = tuningSize;
                    const globalDelta = (this.transposeDelta || 0) % edo;
                    const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                    currentRoot = (((currentRoot ?? 0) + globalDelta + localDelta) % edo + edo) % edo;
                }

                try {
                    const headerNameEl = column.querySelector('.extension-header .chord-name');
                    const headerName = headerNameEl ? headerNameEl.textContent.trim() : '';
                    console.log('[AUDIO] header=', headerName, 'currentRoot=', currentRoot, 'currentTuning=', currentTuning, 'fixedRoot=', model?.fixedRootStepAbs, 'isCustomChord=', isCustomChord, 'intervals(steps)=', intervals);
                } catch {}

                // Ascending, octave-consistent voicing:
                // 1) Map intervals to EDO steps (or use directly for custom chords)
                // 2) Sort degrees within an octave by pitch (root -> third -> fifth -> ...)
                // 3) Repeat this ordered set across consecutive octaves to fill the column
                const degreeSteps = intervals.map(iv => isCustomChord ? ((iv % tuningSize)+tuningSize)%tuningSize : this.mapIntervalToEDO(iv, currentTuning));
                // Unique and sort by 12-TET semitone equivalence for consistent ordering
                const uniqueSteps = Array.from(new Set(degreeSteps));
                uniqueSteps.sort((a, b) => {
                    const sa = this.stepToSemitone(a, tuningSize);
                    const sb = this.stepToSemitone(b, tuningSize);
                    return sa - sb;
                });

                // Clamp rendered strings to a sane, visible musical range: C3..C8 inclusive.
                // (Fine tuning of oscillator octaves is done in OSCILLATOR/GEAR.)
                const MIN_RENDER_OCTAVE = 3;
                const MAX_RENDER_OCTAVE = 8;
                const baseOctave = MIN_RENDER_OCTAVE;
                const stringFreqs = [];
                const stringSeen = new Set();

                // Detect slash-chord bass to place as the very bottom voice (one octave below base)
                let slashBassStep = null;
                try {
                    const headerNameEl = column.querySelector('.extension-header .chord-name');
                    const headerName = headerNameEl ? headerNameEl.textContent.trim() : '';
                    const m = headerName.match(/^([A-G])([#b]?)[\^v]*.*\/(?:\s*)?([A-G])([#b]?)/);
                    if (m) {
                        const rootSemi = this.rootToSemitone(m[1], m[2]||'');
                        const bassSemi = this.rootToSemitone(m[3], m[4]||'');
                        const diffSemi = ((bassSemi - rootSemi) % 12 + 12) % 12;
                        slashBassStep = Math.round((diffSemi * tuningSize) / 12);
                    }
                } catch { /* ignore */ }

                // Prepare ordered steps (semitone ascending within octave)
                // We'll compute a special order for the FIRST group only so core tones
                // (root/3rd/5th/7th or their altered equivalents) appear before lifted extensions (â‰¥9).
                const orderedSteps = uniqueSteps.slice();

                // If enabled, split extended chords (â‰¥9) across two octaves in the first group
                // Strategy: keep root/3rd/5th/7th in baseOctave; push 9/11/13 (+alterations) up one octave
                let firstGroupOctaveOffsetMap = new Map();
                // Build mapping from EDO step -> original interval value (in semitones above root),
                // so we can classify core (<12) vs extensions (>=12). For custom chords, keep order as-is.
                let firstGroupOrderSteps = orderedSteps;
                if (this.splitExtendedChordsAcrossOctaves && !isCustomChord) {
                    const mapIvToStep = (iv) => this.mapIntervalToEDO(iv, currentTuning);
                    const stepInfoList = orderedSteps.map(edoStep => {
                        // find a representative original interval that maps to this step
                        let origin = intervals.find(iv => mapIvToStep(iv) === edoStep);
                        if (origin == null) {
                            // Fallback: estimate extended by semitone class (rare path)
                            const semi = this.stepToSemitone(edoStep, tuningSize);
                            origin = [1,2,3,5,6,8,9].includes(semi) ? 14 : 0; // treat as 9 or root-ish
                        }
                        // Treat #13 (22) specially: it collides with b7 in 12-TET; don't lift it.
                        const isExtended = (origin >= 12) && origin !== 22;
                        return { step: edoStep, semi: this.stepToSemitone(edoStep, tuningSize), origin, isExtended };
                    });

                    // Build first-group order: slash bass (if any) â†’ core â†’ extended
                    const coreList = stepInfoList
                        .filter(si => !si.isExtended && (slashBassStep == null || si.step !== slashBassStep))
                        .sort((a,b)=> a.semi - b.semi);
                    const extList = stepInfoList
                        .filter(si => si.isExtended && (slashBassStep == null || si.step !== slashBassStep))
                        .sort((a,b)=> a.semi - b.semi);
                    firstGroupOrderSteps = (slashBassStep != null ? [slashBassStep] : [])
                        .concat(coreList.map(si=>si.step))
                        .concat(extList.map(si=>si.step));

                    // Mark only the extended tones for the +1 octave lift in the first group
                    stepInfoList.forEach(si => { if (si.isExtended) firstGroupOctaveOffsetMap.set(si.step, 1); });
                }

                // Replicate the voicing across octaves C3..C8
                const replicateStride = this.splitExtendedChordsAcrossOctaves ? 2 : 1; // 2-oct stride for split voicing
                const totalOctaves = (MAX_RENDER_OCTAVE - MIN_RENDER_OCTAVE + 1);
                const totalReplicas = Math.max(1, Math.floor(totalOctaves / replicateStride));
                for (let r = 0; r < totalReplicas; r++) {
                    const replicateBaseOct = baseOctave + r * replicateStride;
                    const seq = firstGroupOrderSteps; // always apply coreâ†’extensions ordering per replica
                    for (let i = 0; i < seq.length; i++) {
                        const edoStep = seq[i];
                        // Normalize degree within an octave and track extra octaves for large extensions (e.g., 9/11/13)
                        const normStep = ((edoStep % tuningSize) + tuningSize) % tuningSize;
                        const extraFromDegree = Math.floor((edoStep - normStep) / tuningSize);

                        // Compute wrap relative to the column root
                        const total = currentRoot + normStep;
                        const wrapOctaves = Math.floor(total / tuningSize);
                        const step = ((total % tuningSize) + tuningSize) % tuningSize;

                        // For the first degree in this replica, if it's a slash bass, drop it one octave
                        const firstGroupBass = (slashBassStep != null && i === 0);
                        let octave = replicateBaseOct + extraFromDegree + wrapOctaves - (firstGroupBass ? 1 : 0);
                        // Apply split lift per replica for extensions (â‰¥9)
                        if (this.splitExtendedChordsAcrossOctaves && firstGroupOctaveOffsetMap.has(edoStep)) {
                            octave += firstGroupOctaveOffsetMap.get(edoStep) || 0;
                        }
                        // In compact-one mode, keep tones within a single-octave span around replicate base
                        if (!this.splitExtendedChordsAcrossOctaves) {
                            const maxOct = replicateBaseOct + 1; // slight upward spill for upper degrees
                            const minOct = replicateBaseOct;      // keep base as lower bound
                            octave = Math.min(maxOct, Math.max(minOct, octave));
                        }
                        // Hard clamp to render window (prevents ultra-high repeats)
                        if (octave < MIN_RENDER_OCTAVE || octave > MAX_RENDER_OCTAVE) continue;
                        // Do not suppress repeated roots; show all strings across octaves

                        const key = `${step}@${octave}`;
                        if (stringSeen.has(key)) continue;
                        stringSeen.add(key);
                        const freq = this.getFrequency(step, octave, currentTuning);
                        // Map back to an interval tag for display/coloring; fallback to semitone-derived
                        const intervalTag = intervals.find(iv => (isCustomChord ? iv : this.mapIntervalToEDO(iv, currentTuning)) === edoStep) ?? intervals[i % intervals.length];
                        stringFreqs.push({ freq, step, octave, interval: intervalTag });
                    }
                }
                
                // Initial ordering: follow current display orientation.
                // UP = high at top (descending), DOWN = low at top (ascending).
                const __orient = (this.strumOrientation || (this.strumMode === 'down' ? 'down' : 'up'));
                const __desc = (__orient !== 'down');
                stringFreqs.sort((a,b)=> __desc ? (b.freq - a.freq) : (a.freq - b.freq));

                // Calculate string sizing to fill full height of column
                const availableHeight = column.offsetHeight || 500; // Default height if not available
                const headerHeight = 40;
                const stringsHeight = availableHeight - headerHeight - 2; // Minimal padding
                const numStrings = stringFreqs.length;
                const stringHeight = Math.max(1, Math.floor(stringsHeight / numStrings) - 0.5); // Ensure strings are visible
                const stringMargin = 0.2; // Minimal margin
                
                // Create strings container that fills remaining space
                const stringsContainer = document.createElement('div');
                stringsContainer.className = 'strings-column';
                // Use real header height if available to avoid clipping
                const headerEl = column.querySelector('.extension-header');
                const headerPx = Math.max(56, headerEl ? headerEl.offsetHeight : headerHeight);
                const stringsHeightPx = Math.max(0, (column.offsetHeight || availableHeight) - headerPx - 2);
                stringsContainer.style.cssText = `
                    flex: 1;
                    overflow: hidden;
                    padding: 1px 1px 8px 1px; /* bottom bounding box */
                    height: calc(100% - ${headerPx}px);
                    display: flex;
                    flex-direction: column;
                    justify-content: flex-start; /* we'll distribute gaps manually */
                `;
                try { stringsContainer.style.gap = 'var(--string-gap, 1px)'; } catch(_){ }
                // Respect global invert-strings preference
                try { if (document.documentElement.classList.contains('invert-strings')) stringsContainer.style.flexDirection = 'column-reverse'; } catch(_) {}
                // Subtle root tint based on current root note color (very dark)
                try {
                    const semi = this.stepToSemitone(currentRoot, tuningSize);
                    const accent = this.getChromaticColorForSemitone(semi) || '#000000';
                    const tint = (hex => {
                        const m = /^#?([0-9a-f]{6})$/i.exec(hex || '');
                        if (!m) return 'rgba(0,0,0,0)';
                        const n = parseInt(m[1], 16);
                        let r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                        // heavy darken: keep only ~6-12 of 255
                        r = Math.max(6, Math.floor(r * 0.08));
                        g = Math.max(6, Math.floor(g * 0.08));
                        b = Math.max(6, Math.floor(b * 0.08));
                        return `linear-gradient(to bottom, rgba(${r},${g},${b},0.12), rgba(${r},${g},${b},0.08))`;
                    })(accent);
                    stringsContainer.style.setProperty('--root-tint-gradient', tint);
                    const headerEl = column.querySelector('.extension-header');
                    if (headerEl) headerEl.style.setProperty('--root-tint-gradient', tint);
                } catch (_) {}
                
                stringFreqs.forEach((stringData, stringIndex) => {
                    const row = document.createElement('div');
                    row.className = 'string';
                    row.dataset.index = stringIndex;
                    row.dataset.column = column.dataset.chordType || 'unknown';
                    row.dataset.frequency = stringData.freq;
                    row.dataset.noteIndex = stringData.step;
                    // Persist the interval for later recalculation (e.g., during auto-lock recompute)
                    row.dataset.interval = stringData.interval;
                    // Also persist octave and relative EDO step (interval mapped in current tuning)
                    // Store the interval relative to the chord's stored root (model.fixedRootStepAbs)
                    try {
                        const tuningSize = currentTuning || this.getTuningStepsPerOctave();
                        // For edoStep calculation, always use the stored model root (if available) as reference
                        let referenceRoot = 0;
                        if (model && typeof model.fixedRootStepAbs === 'number') {
                            referenceRoot = model.fixedRootStepAbs; // This should always be 0 for edited chords
                        }
                        // Calculate interval relative to the reference root
                        const relStep = ((stringData.step - currentRoot + referenceRoot) % tuningSize + tuningSize) % tuningSize;
                        row.dataset.edoStep = String(relStep);
                        console.log('STRING GENERATION: stringData.step =', stringData.step, 'currentRoot =', currentRoot, 'referenceRoot =', referenceRoot, 'relStep =', relStep);
                    } catch (_) {
                        // Fallback: omit if cannot compute
                    }
                    row.dataset.octave = String(stringData.octave);
                    // Tag middle octave rows (3â€“4) for subtle highlighting
                    try {
                        const oct = parseInt(row.dataset.octave, 10);
                        if (oct === 3 || oct === 4) row.classList.add('mid-octave');
                    } catch(_) {}

                    // Colors: universal pitch-based (C..B spectrum)
                    const uniColor = this.getUniversalPitchColorForStep(stringData.step, tuningSize);
                    const baseColor = uniColor.color;
                    const glowColor = (baseColor && baseColor.toLowerCase() === '#000000') ? '#555555' : baseColor;
                    row.dataset.glowColor = glowColor;

                    // Visible core
                    const core = document.createElement('div');
                    core.className = 'string-core';
                    core.style.background = baseColor;
                    core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;

                    row.title = `${noteNames[stringData.step] || `Note ${stringData.step}`} - Oct${stringData.octave} - ${stringData.freq.toFixed(1)}Hz`;

                    // Hover effects on core
                    row.addEventListener('mouseenter', () => {
                        core.style.transform = 'scaleY(1.25)';
                        core.style.boxShadow = `0 0 6px ${glowColor}, 0 0 14px ${glowColor}CC, 0 0 28px ${glowColor}88`;
                    });
                    row.addEventListener('mouseleave', () => {
                        core.style.transform = 'scaleY(1)';
                        core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;
                    });

                    // Attach core
                    row.appendChild(core);
                    stringsContainer.appendChild(row);

                    // Precompute vibration period and store on core
                    const period = this.computeVibrationPeriod(stringData.freq, stringData.step);
                    core.style.setProperty('--vib-period', period + 'ms');
                });
                // Append first, then fit and apply play mode
                column.appendChild(stringsContainer);
                // Footer removed; height already correct. Now ensure fit and stretch gaps to fill height.
                this.ensureStringsFullyVisible(stringsContainer);
                try { this._distributeStringGapsToFill(stringsContainer); } catch(_) {}
                requestAnimationFrame(()=>{ try { this._distributeStringGapsToFill(stringsContainer); } catch(_) {} });
                try { this.applyPlayModeToColumnVisual(column); } catch(_) {}

                // Cache the effective rendered root step for robust downstream logic (patterns/bass)
                // without depending on chord-name text parsing (which may include micro symbols).
                try {
                    const rootRow = stringsContainer.querySelector('.string[data-interval="0"]');
                    if (rootRow && rootRow.dataset && rootRow.dataset.noteIndex != null) {
                        column.dataset.namedRootStep = String(rootRow.dataset.noteIndex);
                        column.dataset.namedRootEdo = String(this.currentTuning || 12);
                    } else {
                        delete column.dataset.namedRootStep;
                        delete column.dataset.namedRootEdo;
                    }
                } catch(_) {}
            }

            // Shrink string heights uniformly if overflow would hide octaves
            ensureStringsFullyVisible(parent){
                if(!parent) return;
                const strings = Array.from(parent.querySelectorAll('.string'));
                if(!strings.length) return;
                const column = parent.closest('.extension-column') || parent;
                // small timeout ensures layout values are settled if heights were zero initially
                const adjust = ()=>{
                    const h = parent.clientHeight;
                    if (h <= 0) return;
                    const count = strings.length;
                    const minColor = 1;
                    const maxColor = Math.max(30, h || 0);
                    const maxGap = 2;
                    let gap = (count > 1) ? ((h - (minColor * count)) / (count - 1)) : 0;
                    if (!Number.isFinite(gap)) gap = 0;
                    gap = Math.max(0, Math.min(maxGap, gap));
                    let row = (h - (gap * (count - 1))) / count;
                    if (!Number.isFinite(row)) row = minColor;
                    row = Math.max(minColor, Math.min(maxColor, row));
                    try {
                        column.style.setProperty('--string-gap', `${gap.toFixed(2)}px`);
                        column.style.setProperty('--string-row', `${row.toFixed(2)}px`);
                        column.style.setProperty('--string-min', `${minColor}px`);
                        column.style.setProperty('--string-max', `${maxColor}px`);
                        parent.style.gap = 'var(--string-gap, 1px)';
                    } catch(_){ }
                    strings.forEach(s=>{ s.style.height = ''; s.style.marginTop = '0px'; });
                };
                // Run twice (immediate + next frame) to catch late layout
                adjust();
                requestAnimationFrame(adjust);
            }

            // Make rows span the full container by distributing vertical margins according to log-frequency distances.
            _distributeStringGapsToFill(parent) {
                if (!parent) return;
                try { this.ensureStringsFullyVisible(parent); } catch(_){ }
            }

            // Add footer with ARP/CHORD trigger buttons to a column
            addColumnFooter(column) {
                // Footer buttons removed - header tap now handles chord/ARP triggering
                // Remove any existing footer
                const existingFooter = column.querySelector('.extension-footer');
                if (existingFooter) existingFooter.remove();
                
                // No footer needed anymore - header handles all triggering
                
                // Update strings container height to use full space (no footer)
                const stringsContainer = column.querySelector('.strings-column');
                const headerEl = column.querySelector('.extension-header');
                if (stringsContainer && headerEl) {
                    const headerPx = Math.max(56, headerEl.offsetHeight);
                    // No footer height needed anymore
                    stringsContainer.style.height = `calc(100% - ${headerPx}px)`;
                }
            }

            // Footer-related functions removed - header now handles all triggering
            
            handleTriggerButtonClick(column, clientY) {
                // Only trigger if we're in a valid mode
                const isArpMode = this.arpEnabled && !this.chordsEnabled;
                const isChordMode = this.chordsEnabled && !this.arpEnabled;
                
                if (isArpMode) {
                    this.triggerArpForColumn(column, clientY);
                } else if (isChordMode) {
                    this.triggerChordForColumn(column, clientY);
                } else {
                    // No feedback needed since there are no buttons to flash anymore
                    console.log('ARP/CHORD mode is disabled - no action taken');
                }
            }

            // Trigger ARP for a specific column via footer button
            triggerArpForColumn(column, clientY) {
                // ARP only triggers when PLAY is active
                if (!this._isSequencing) {
                    // When PLAY is not active, just strum instead
                    const rect = column.getBoundingClientRect();
                    this.playChordStrum(column, { name: 'ARP' }, rect.top + 10, rect.bottom - 10);
                    return;
                }
                // Enable ARP mode temporarily if not already enabled
                const wasArpEnabled = this.arpEnabled;
                this.arpEnabled = true;
                
                // Use quantized chord change for proper timing
                this._scheduleQuantizedArpChordChange(column, clientY);
                
                // Visual feedback
                const arpButton = column.querySelector('.arp-trigger');
                if (arpButton) {
                    arpButton.classList.add('active');
                    setTimeout(() => arpButton.classList.remove('active'), 200);
                }
            }
            
            // Trigger CHORD for a specific column via footer button
            triggerChordForColumn(column, clientY) {
                // CHORD only triggers when PLAY is active
                if (!this._isSequencing) {
                    // When PLAY is not active, just strum instead
                    const rect = column.getBoundingClientRect();
                    this.playChordStrum(column, { name: 'CHORD' }, rect.top + 10, rect.bottom - 10);
                    return;
                }
                // Enable CHORD mode temporarily if not already enabled
                const wasChordsEnabled = this.chordsEnabled;
                this.chordsEnabled = true;
                
                // Use immediate chord execution (chords don't need transport sync like ARP)
                this._executeChordChange(column, clientY);
                
                // Visual feedback
                const chordButton = column.querySelector('.chord-trigger');
                if (chordButton) {
                    chordButton.classList.add('active');
                    setTimeout(() => chordButton.classList.remove('active'), 200);
                }
            }

            // ===== Play Mode helpers: compute sequence and apply visual order =====
            // Group strings by octave (ascending), each group sorted low->high by frequency
            groupStringsByOctave(rows){
                const byOct = new Map();
                for (const r of rows){
                    const o = parseInt(r.dataset.octave||'0',10);
                    if (!byOct.has(o)) byOct.set(o, []);
                    byOct.get(o).push(r);
                }
                const octKeys = Array.from(byOct.keys()).sort((a,b)=> a-b);
                const groups = octKeys.map(o=> byOct.get(o).sort((a,b)=> (parseFloat(a.dataset.frequency)||0)-(parseFloat(b.dataset.frequency)||0)));
                return { groups, octaves: octKeys };
            }

            // Helper: from a column and a y-position, determine the tapped octave number
            _getTappedOctave(columnElement, yClient){
                try {
                    const colRect = columnElement.getBoundingClientRect();
                    const container = columnElement.querySelector('.strings-column');
                    if (!container) return null;
                    const rows = Array.from(container.querySelectorAll('.string'));
                    if (rows.length === 0) return null;
                    const hitY = yClient - colRect.top;
                    let best = null; let bestDist = Infinity;
                    for (const r of rows){
                        const rr = r.getBoundingClientRect();
                        const center = (rr.top + rr.height/2) - colRect.top;
                        const d = Math.abs(center - hitY);
                        if (d < bestDist){ bestDist = d; best = r; }
                    }
                    if (!best) return null;
                    const o = parseInt(best.dataset.octave||'0',10);
                    return Number.isFinite(o) ? o : null;
                } catch(_) { return null; }
            }

            // Helper: compute simultaneous chord targets for "Chords" mode
            _computeChordsModeTargets(columnElement, tappedOctave){
                const out = { stringsInOctave: [], bassFreq: null };
                try {
                    const rows = Array.from(columnElement.querySelectorAll('.strings-column .string'));
                    if (rows.length === 0) return out;
                    const tuning = this.currentTuning || 12;
                    // 1) Pick chord tones whose dataset.octave === tappedOctave
                    out.stringsInOctave = rows.filter(r => parseInt(r.dataset.octave||'0',10) === tappedOctave);
                    if (out.stringsInOctave.length === 0) {
                        // Fallback: choose closest octave group
                        let best = null; let bestDelta = Infinity;
                        const byOct = new Map();
                        rows.forEach(r=>{
                            const o = parseInt(r.dataset.octave||'0',10);
                            if (!byOct.has(o)) byOct.set(o, []);
                            byOct.get(o).push(r);
                        });
                        for (const [o, arr] of byOct.entries()){
                            const d = Math.abs(o - tappedOctave);
                            if (d < bestDelta){ bestDelta = d; best = arr; }
                        }
                        if (best) out.stringsInOctave = best;
                    }
                    // 2) Add sustained root bass within G1..C3 range
                    const baseStep = (typeof this._getNamedColumnRootStep === 'function')
                        ? (this._getNamedColumnRootStep(columnElement) ?? this._getEffectiveColumnRootStep(columnElement))
                        : this._getEffectiveColumnRootStep(columnElement);
                    out.bassFreq = this._computeBassFreqInRange(baseStep, (typeof this._lastBassFreq==='number'?this._lastBassFreq:null), tuning);
                } catch(_) {}
                return out;
            }

            // Helper: compute the effective absolute root step for a column, honoring locks and transposes
            _getEffectiveColumnRootStep(columnElement){
                try {
                    const edoNow = this.currentTuning || 12;
                    const norm = (v,m)=> ((v % m) + m) % m;
                    const g = norm((this.transposeDelta || 0), edoNow);
                    const l = norm((+columnElement?.dataset?.localTranspose || 0), edoNow);
                    try { console.log('[ROOT] compute', { edoNow, g, l, col: columnElement?.dataset?.chordId || columnElement?.dataset?.originalPosition }); } catch(_){ }

                    // 1) Locked chord explicit root (absolute in its own tuning)
                    const locked = this.lockedChords?.get(columnElement);
                    if (locked && typeof locked.lockedRoot === 'number'){
                        const srcEdo = locked.lockedTuning || edoNow;
                        // Preserve exact cents across EDOs: convert stepâ†’centsâ†’step, avoiding 12â€‘TET rounding
                        const lockedNorm = ((locked.lockedRoot % srcEdo) + srcEdo) % srcEdo;
                        const stepHere = (lockedNorm * edoNow) / srcEdo; // may be fractional to preserve microtones
                        return norm(stepHere + l, edoNow); // locked follows only local transpose
                    }

                    // 2) Per-chord fixed root from model, if available
                    try {
                        const id = columnElement?.dataset?.chordId;
                        let idx = -1; if (id) idx = (this.chordExtensions||[]).findIndex(c=> c && (String(c.id)===String(id)));
                        if (idx < 0 && columnElement?.dataset?.originalPosition != null){
                            const op = parseInt(columnElement.dataset.originalPosition,10);
                            if (!isNaN(op) && op >= 0) idx = op;
                        }
                        const model = (idx>=0)? (this.chordExtensions||[])[idx] : null;
                        if (model && typeof model.fixedRootStepAbs === 'number'){
                            const srcEdo = model.fixedRootTuning || edoNow;
                            // Preserve exact cents across EDOs
                            const fixedNorm = ((model.fixedRootStepAbs % srcEdo) + srcEdo) % srcEdo;
                            const stepHere = (fixedNorm * edoNow) / srcEdo; // fractional allowed
                            const valFixed = norm(stepHere + g + l, edoNow);
                            try { console.log('[ROOT] fixedRootStepAbsâ†’', valFixed); } catch(_){ }
                            return valFixed;
                        }
                    } catch(_){ /* ignore */ }

                    // 2b) Derive root directly from rendered strings if possible (prefer exact root degree 0)
                    try {
                        const rootRow = columnElement?.querySelector?.('.strings-column .string[data-interval="0"]');
                        if (rootRow) {
                            const n = parseInt(rootRow.dataset?.noteIndex||'NaN',10);
                            if (Number.isFinite(n)) {
                                const valDirect = norm(n, edoNow);
                                try { console.log('[ROOT] from data-interval=0 rowâ†’', valDirect); } catch(_){ }
                                return valDirect;
                            }
                        }
                    } catch(_){ /* ignore */ }

                    // 3) Fallback: parse header name (root letter + accidental) to estimate absolute root step
                    //    This uses the current improved naming pipeline, so headers should reflect audible roots.
                    try {
                        const headerNameEl = columnElement?.querySelector?.('.extension-header .chord-name');
                        let header = headerNameEl ? (headerNameEl.dataset?.lockedName || headerNameEl.textContent || '') : '';
                        header = header.trim().replace(/^ðŸ”’\s*/, '');
                        // Support ASCII and unicode accidentals
                        const m = header.match(/^\s*([A-G])([#bâ™¯â™­]?)/);
                        if (m){
                            const acc = (m[2]||'').replace('â™¯','#').replace('â™­','b');
                            const semi = this.rootToSemitone(m[1], acc);
                            const stepHere = this.semitoneToStep(semi, edoNow);
                            const valHdr = norm(stepHere + g + l, edoNow);
                            try { console.log('[ROOT] from headerâ†’', valHdr); } catch(_){ }
                            return valHdr;
                        }
                    } catch(_){ /* ignore */ }

                    // 4) Fallback to current global root with deltas
                    const base = this.currentRoot || 0;
                    const valBase = norm(base + g + l, edoNow);
                    try { console.log('[ROOT] fallback currentRootâ†’', valBase); } catch(_){ }
                    return valBase;
                } catch(_) { return (this.currentRoot || 0); }
            }

            // Helper: compute the NOMINAL (named) root step for a column.
            // This intentionally ignores fixedRootStepAbs/lowest-note rooting so patterns + bass follow the chord label root.
            _getNamedColumnRootStep(columnElement){
                try {
                    const edoNow = this.currentTuning || 12;
                    const norm = (v,m)=> ((v % m) + m) % m;
                    // Locked columns preserve their own tuning/root; defer to _getEffectiveColumnRootStep.
                    try {
                        const isLocked = !!columnElement?.querySelector?.('.lock-button')?.classList?.contains('locked');
                        if (isLocked) return null;
                    } catch(_){ /* ignore */ }

                    // Prefer a cached numeric root captured during string generation,
                    // but only when it was computed in the current EDO.
                    try {
                        const rawStep = columnElement?.dataset?.namedRootStep;
                        const rawEdo = columnElement?.dataset?.namedRootEdo;
                        if (rawStep != null && rawStep !== '' && rawEdo != null && rawEdo !== '') {
                            const edoSrc = parseInt(rawEdo, 10);
                            const v = parseFloat(rawStep);
                            if (Number.isFinite(edoSrc) && edoSrc === edoNow && Number.isFinite(v)) {
                                return norm(v, edoNow);
                            }
                        }
                    } catch(_){ /* ignore */ }

                    // Best-effort: read the rendered root string (interval 0). This naturally includes
                    // current EDO + global/local transpose + any micro tuning already applied.
                    try {
                        const rootRow = columnElement?.querySelector?.('.strings-column .string[data-interval="0"]');
                        if (rootRow) {
                            const v = parseFloat(rootRow.dataset?.noteIndex || 'NaN');
                            if (Number.isFinite(v)) return norm(v, edoNow);
                        }
                    } catch(_){ /* ignore */ }

                    // Last-resort: parse header root name.
                    // IMPORTANT: do NOT add global/local transpose here; headers already reflect audible transposes.
                    try {
                        const headerNameEl = columnElement?.querySelector?.('.extension-header .chord-name');
                        let header = headerNameEl ? (headerNameEl.dataset?.lockedName || headerNameEl.textContent || '') : '';
                        header = String(header || '').trim().replace(/^ðŸ”’\s*/, '');
                        // Support ASCII/unicode accidentals + common micro marks used in this project.
                        const m = header.match(/^\s*([A-G])([#bâ™¯â™­]?)([\^vâ†‘â†“d]*)/);
                        if (!m) return null;
                        const acc = (m[2]||'').replace('â™¯','#').replace('â™­','b');
                        const semi = this.rootToSemitone(m[1], acc);
                        let step = this.semitoneToStep(semi, edoNow);
                        const micro = m[3] || '';
                        const ups = (micro.match(/[\^â†‘]/g) || []).length;
                        const downs = (micro.match(/[vâ†“d]/g) || []).length;
                        step = norm(step + ups - downs, edoNow);
                        return norm(step, edoNow);
                    } catch(_){
                        return null;
                    }
                } catch(_) {
                    return null;
                }
            }

            // Helper: pick a bass frequency for an absolute step within the musical range B1..C3 (inclusive).
            // Prefers continuity to the previous bass when provided; otherwise chooses mid-range.
            _computeBassFreqInRange(absStep, prevFreq = null, edo = (this.currentTuning || 12)){
                try {
                    const s = ((absStep % edo) + edo) % edo;
                    try { console.log('[BASS] rangeSelect absStep=', absStep, 'edo=', edo, 'prevFreq=', prevFreq); } catch(_){ }
                    // Bass range: B1 to C3 (restricted range)
                    const bStep = this.semitoneToStep(11, edo); // B
                    const cStep = this.semitoneToStep(0, edo); // C
                    const minF = this.getFrequency(bStep, 1, edo); // B1 (61.7 Hz)
                    const maxF = this.getFrequency(cStep, 3, edo); // C3 (130.8 Hz)
                    const candidates = [1,2,3]
                        .map(oct => ({ f: this.getFrequency(s, oct, edo), oct }))
                        .filter(x => isFinite(x.f) && x.f > 0);
                    // Strictly within bounds B1-C3
                    const within = candidates.filter(x => x.f >= Math.min(minF, maxF) && x.f <= Math.max(minF, maxF));
                    const pool = within.length ? within : [];  // Don't fall back to out-of-range notes
                    if (!pool.length) return null;
                    const chooseBy = (target)=> pool.reduce((best, x)=>{
                        const d = Math.abs(Math.log2(x.f) - target);
                        return (!best || d < best.d) ? {x, d} : best;
                    }, null).x.f;
                    if (prevFreq && isFinite(prevFreq) && prevFreq>0){
                        return chooseBy(Math.log2(prevFreq));
                    }
                    const mid = Math.log2(Math.sqrt(minF * maxF)); // center in log-space
                    return chooseBy(mid);
                } catch(_){ return null; }
            }
            
            // Helper: Convert chord root name (like "C", "F#", "Bb") to step number
            _chordRootNameToStep(rootName, edo = 12) {
                if (!rootName || typeof rootName !== 'string') return null;
                
                // Basic note mapping for 12-EDO (can be extended for other EDOs)
                const noteMap = {
                    'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5,
                    'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11,
                    // Support Unicode symbols
                    'Câ™¯': 1, 'Dâ™­': 1, 'Dâ™¯': 3, 'Eâ™­': 3, 'Fâ™¯': 6, 'Gâ™­': 6, 'Gâ™¯': 8, 'Aâ™­': 8, 'Aâ™¯': 10, 'Bâ™­': 10
                };
                
                const cleanRoot = rootName.trim().replace(/[^\w#â™¯â™­b]/g, '');
                const step12 = noteMap[cleanRoot];
                
                if (step12 === undefined) return null;
                
                // Convert from 12-EDO to target EDO
                return Math.round((step12 * edo) / 12);
            }
            
            // Helper: Update bass using specific chord root with GLIDE
            _updateBassWithChordRoot(columnElement, rootStep) {
                if (!this.bassEnabled || rootStep === null) return;
                
                try {
                    const edo = this.currentTuning || 12;
                    const target = this._computeBassFreqInRange(rootStep, (typeof this._heldBassLiveFreq==='number'?this._heldBassLiveFreq:null), edo);
                    
                    if (!isFinite(target) || target <= 0) return;
                    
                    // If there is no existing bass, start one
                    if (!this._heldBassVoice) {
                        // Locally save ADSR and panning, then restore after starting bass
                        const savedEnv1 = { ...this.envelope };
                        const savedEnv2 = { ...this.osc2Envelope };
                        const prevWidth = this.panning ? this.panning.width : null;
                        
                        try {
                            // Minimal, smooth bass envelope
                            this.envelope.attack = 0.005; this.envelope.decay = 0.05; this.envelope.sustain = 0.95; this.envelope.release = 0.08;
                            this.osc2Envelope.attack = 0.005; this.osc2Envelope.decay = 0.05; this.osc2Envelope.sustain = 0.95; this.osc2Envelope.release = 0.08;
                            // Force center pan
                            if (this.panning) this.panning.width = 0;
                            this.playFrequency(target, null, 'bass');
                        } finally {
                            // Restore settings
                            if (this.panning && prevWidth != null) this.panning.width = prevWidth;
                            Object.assign(this.envelope, savedEnv1);
                            Object.assign(this.osc2Envelope, savedEnv2);
                        }
                        
                        // Remember the exact frequency used for the bass pool
                        this._heldBassVoiceKey = target;
                        const v = this.activeBassOscillators.get(this._heldBassVoiceKey);
                        if (v) {
                            try { if (v.releaseTimeout) { clearTimeout(v.releaseTimeout); v.releaseTimeout = null; } } catch(_){ }
                            this._heldBassVoice = v; this._heldBassLiveFreq = target;
                        }
                    } else {
                        // Update existing bass to new frequency immediately
                        if (this._heldBassVoice && this._heldBassVoice.frequency) {
                            const ny = this.audioContext ? (this.audioContext.sampleRate/2) : 24000;
                            const safeMax = Math.max(1000, ny * 0.98);
                            const safeMin = 10;
                            const clamped = Math.max(safeMin, Math.min(safeMax, target));
                            this._heldBassVoice.frequency.setValueAtTime(clamped, this._heldBassVoice.frequency.context.currentTime);
                            this._heldBassLiveFreq = clamped;
                        }
                    }
                } catch(err) {
                    console.warn('Bass chord root update failed:', err);
                }
            }
            
            getPatternSequence(base, mode){
                // base: array of string elements ordered low->high (ascending by freq)
                const asc = base;
                const desc = base.slice().reverse();
                const altEnds = (arr)=>{ const a=arr.slice(); const out=[]; let i=0,j=a.length-1; while(i<=j){ if(i<=j) out.push(a[i++]); if(i<=j) out.push(a[j--]); } return out; };
                const altCenter = (arr)=>{ const a=arr.slice(); const mid=Math.floor((a.length-1)/2); const out=[]; let l=mid, r=mid+1; if(a.length%2===1){ out.push(a[mid]); l=mid-1; r=mid+1; } while(l>=0 || r<a.length){ if(r<a.length) out.push(a[r++]); if(l>=0) out.push(a[l--]); } return out; };
                switch(mode){
                    case 'low-high': return asc;
                    case 'high-low': return desc;
                    case 'alt-ends': return altEnds(asc);
                    case 'alt-center': return altCenter(asc);
                    default: return desc; // default visual top-high
                }
            }

            // Playback-oriented pattern builder: allows repeats (e.g., 123,234,345,456) within the swipe window
            getPatternPlaybackSequence(base, mode){
                // base: array of string elements ordered low->high WITHIN the gesture window
                const asc = base;
                const desc = base.slice().reverse();
                const altEnds = (arr)=>{ const a=arr.slice(); const out=[]; let i=0,j=a.length-1; while(i<=j){ if(i<=j) out.push(a[i++]); if(i<=j) out.push(a[j--]); } return out; };
                const altCenter = (arr)=>{ const a=arr.slice(); const mid=Math.floor((a.length-1)/2); const out=[]; let l=mid, r=mid+1; if(a.length%2===1){ out.push(a[mid]); l=mid-1; r=mid+1; } while(l>=0 || r<a.length){ if(r<a.length) out.push(a[r++]); if(l>=0) out.push(a[l--]); } return out; };
                if (typeof this.groupStringsByOctave === 'function'){
                    const { groups } = this.groupStringsByOctave(asc);
                    const out = [];
                    for (const g of groups){
                        switch(mode){
                            case 'low-high': out.push(...g); break;
                            case 'high-low': out.push(...g.slice().reverse()); break;
                            case 'alt-ends': out.push(...altEnds(g)); break;
                            case 'alt-center': out.push(...altCenter(g)); break;
                            default: out.push(...g.slice().reverse()); break; // default top-high
                        }
                    }
                    return out;
                }
                switch(mode){
                    case 'low-high': return asc.slice();
                    case 'high-low': return desc.slice();
                    case 'alt-ends': return altEnds(asc);
                    case 'alt-center': return altCenter(asc);
                    default: return desc.slice();
                }
            }

            // ===== ARP Engine =====
            _ensureArpDefaults(){
                if (this._arp) return;
                this._arp = {
                    bpm: 120,
                    quant: '1/16',
                    tuplet: 0,
                    chordQuant: '1/4',
                    chordsHold: 'bar:1',
                    npc: 3,
                    chordsNpc: 3,
                    pattern: 'up',
                    gatePct: 50,
                    // Sequence/chord state
                    active: false,
                    seq: [],
                    column: null,
                    span: { active:false, yMin:null, yMax:null, octMin:null, octMax:null },
                    startTickAlign: 0,
                    gateMs: 0,
                    pendingSwitch: null,
                    // Bass state
                    bassFreq: null,
                    bassVoice: null,
                    bassLiveFreq: null,
                    bassHold: true,
                    // Lead glide state
                    glide: false,
                    glideMs: null,
                    leadVoice: null,
                    leadLiveFreq: null
                };
                // Precompute a gateMs based on current tick length if transport exists
                const tickMs = this._arpTransport?.tickMs || 250;
                this._arp.gateMs = Math.max(5, Math.floor(((this._arp.gatePct||50)/100) * tickMs));
            }

            // Global ARP transport: keeps a shared bar-aligned clock so chord changes stay in time
            _ensureArpTransport(){
                if (this._arpTransport) return;
                this._arpTransport = {
                    running: false,
                    timer: null,
                    bpm: 120,
                    quant: '1/8',
                    tuplet: 0,
                    swingPct: (function(){
                        try { const v = localStorage.getItem('xen_swing_pct'); return Math.max(0, Math.min(75, v!=null? parseFloat(v): 0)); } catch(_) { return 0; }
                    })(),
                    isTriplet: false,
                    beatMs: 500,
                    tickMs: 250,
                    ticksPerBeat: 2,
                    beatsPerBar: 4,
                    ticksPerBar: 8,
                    tickCounter: 0,
                    absTickCounter: 0,
                    nextAt: 0,
                    lastActiveTick: 0,
                    lastActiveAbsTick: 0,
                    inactivityStopScheduled: false,
                    stopAtBarIndex: null,
                    metronomeOn: false,
                    _metroLastClickAt: 0,
                    holdStopAtAbsTick: null,
                    // Deferred settings application (apply atomically after 2 beats)
                    deferApplyAtAbsTick: null,
                    deferFlags: null,
                    pendingSwingPct: null
                };
            }

                // ===== Debug utilities =====
                _dbg(tag, ...args){
                    try{
                        if (!this._debug) return;
                        const ts = new Date().toISOString().split('T')[1].replace('Z','');
                        const msg = `[${ts}] ${tag}: ${args.map(a=>{
                            if (a == null) return String(a);
                            if (typeof a === 'object') {
                                try { return JSON.stringify(a); } catch { return String(a); }
                            }
                            return String(a);
                        }).join(' ')}`;
                        this._debugLogs.push(msg);
                        if (this._debugLogs.length > (this._debugMax||500)) this._debugLogs.splice(0, this._debugLogs.length - (this._debugMax||500));
                        if (this._debugConsole) {
                            const el = document.createElement('div');
                            el.textContent = msg;
                            this._debugConsole.appendChild(el);
                            this._debugConsole.scrollTop = this._debugConsole.scrollHeight;
                        }
                        // Mirror to devtools console for convenience
                        try { console.log(msg); } catch {}
                    } catch {}
                }
                setDebug(on){ this._debug = !!on; this._dbg('DEBUG', 'setDebug=', this._debug); }
                _installDebugPanel(){
                    if (!this._debugUI) return; // disabled per user request
                    if (this._debugPanelInstalled) return;
                    this._debugPanelInstalled = true;
                    const panel = document.createElement('div');
                    panel.id = 'omnidebug';
                    panel.style.cssText = 'position:fixed;right:8px;bottom:8px;width:420px;max-height:40vh;background:rgba(0,0,0,0.7);color:#0f0;font:12px/1.4 monospace;z-index:99999;border-radius:6px;box-shadow:0 2px 8px rgba(0,0,0,0.5);display:flex;flex-direction:column;';
                    const bar = document.createElement('div');
                    bar.style.cssText = 'display:flex;align-items:center;gap:8px;padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.1);';
                    const title = document.createElement('div'); title.textContent = 'XENON Debug'; title.style.flex='1';
                    const chk = document.createElement('input'); chk.type = 'checkbox'; chk.checked = !!this._debug; chk.title='Enable debug logging';
                    chk.addEventListener('change', ()=>{ this.setDebug(chk.checked); });
                    const clr = document.createElement('button'); clr.textContent = 'Clear'; clr.style.cssText='background:#222;color:#fff;border:1px solid #444;border-radius:3px;padding:2px 6px;cursor:pointer;';
                    clr.addEventListener('click', ()=>{ this._debugLogs.length=0; if (this._debugConsole) this._debugConsole.textContent=''; });
                    const dl = document.createElement('button'); dl.textContent = 'Download'; dl.style.cssText=clr.style.cssText;
                    dl.addEventListener('click', ()=>{
                        const blob = new Blob([this._debugLogs.join('\n')], {type:'text/plain'});
                        const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='xenon-debug.log'; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
                    });
                    bar.appendChild(title); bar.appendChild(chk); bar.appendChild(clr); bar.appendChild(dl);
                    const body = document.createElement('div'); body.style.cssText='overflow:auto;padding:8px;flex:1;';
                    this._debugConsole = body;
                    panel.appendChild(bar); panel.appendChild(body);
                    document.body.appendChild(panel);
                    // Flush any buffered logs
                    (this._debugLogs||[]).forEach(m=>{ const el=document.createElement('div'); el.textContent=m; body.appendChild(el); });
                    body.scrollTop = body.scrollHeight;
                }
            
            // PLAY button flashing functions
            _startPlayButtonFlashing() {
                // Stop any existing flashing
                this._stopPlayButtonFlashing();
                
                const playBtn = document.getElementById('playSeqBtn');
                if (!playBtn) return;
                
                // Get BPM and calculate beat interval
                const bpmEl = document.getElementById('universalBpm');
                const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                const beatMs = 60000 / Math.max(20, bpm);
                
                // Flash on every beat
                let isFlashing = false;
                this._playFlashTimer = setInterval(() => {
                    if (this._isSequencing) {
                        isFlashing = !isFlashing;
                        if (isFlashing) {
                            playBtn.style.backgroundColor = '#ff6b6b';
                            playBtn.style.color = '#fff';
                            playBtn.style.transform = 'scale(1.05)';
                        } else {
                            playBtn.style.backgroundColor = '';
                            playBtn.style.color = '';
                            playBtn.style.transform = '';
                        }
                    } else {
                        this._stopPlayButtonFlashing();
                    }
                }, beatMs / 2); // Flash twice per beat for visual clarity
            }
            
            _stopPlayButtonFlashing() {
                if (this._playFlashTimer) {
                    clearInterval(this._playFlashTimer);
                    this._playFlashTimer = null;
                }
                
                const playBtn = document.getElementById('playSeqBtn');
                if (playBtn) {
                    playBtn.style.backgroundColor = '';
                    playBtn.style.color = '';
                    playBtn.style.transform = '';
                }
            }
            
            _refreshArpTransportTiming(){
                this._ensureArpDefaults();
                this._ensureArpTransport();
                
                // Read current values from UI controls (universal only)
                const bpmEl = document.getElementById('universalBpm');
                const quantEl = document.getElementById('universalQuant');
                const swingEl = document.getElementById('universalSwing');
                
                const bpm = Math.max(20, Number(bpmEl?.value) || this._arp?.bpm || this._arpTransport.bpm || 120);
                const quant = quantEl?.value || this._arp?.quant || this._arpTransport.quant || '1/16';
                let swingPct = this._arpTransport.swingPct || 0;
                if (swingEl && swingEl.value != null) {
                    const sv = parseFloat(swingEl.value);
                    if (isFinite(sv)) swingPct = Math.max(0, Math.min(75, sv));
                }
                
                // Update _arp values to match UI
                if (this._arp) {
                    this._arp.bpm = bpm;
                    this._arp.quant = quant;
                }
                // Parse time signature now to compute bar math early
                const timeSignatureEl = document.getElementById('universalTimeSignature');
                const tsRaw = timeSignatureEl ? String(timeSignatureEl.value||'4/4') : '4/4';
                let tsNum = 4, tsDen = 4;
                try {
                    const [n,d] = tsRaw.split('/').map(v=>parseInt(v,10));
                    if (Number.isFinite(n) && n>0) tsNum = n;
                    if (Number.isFinite(d) && d>0) tsDen = d;
                } catch(_) {}
                // Support merged tuplet values via quant like "tuplet:7" or "tuplet:7/8"
                let tupletN = 0;
                let tupletDen = 4; // base against quarter unless specified
                if (typeof quant === 'string' && quant.startsWith('tuplet:')){
                    const spec = quant.slice(7);
                    const parts = spec.split('/');
                    const n = parseInt(parts[0],10);
                    const d = parts[1] != null ? parseInt(parts[1],10) : (tsDen || 4);
                    if (Number.isFinite(n) && n>0) tupletN = n; else tupletN = 0;
                    if (Number.isFinite(d) && d>0) tupletDen = d; else tupletDen = 4;
                } else {
                    tupletN = Math.max(0, this._arp?.tuplet || 0);
                    tupletDen = 4;
                }
                const beatMs = 60000 / bpm;
                let ticksPerBeat = 4; // default grid approximating 1/16
                let tickMs;
                if (tupletN > 0){
                    // Tuplet relative to note 1/tupletDen (quarter-relative base 4)
                    const noteMs = beatMs * (4/tupletDen);
                    tickMs = noteMs / tupletN;
                    ticksPerBeat = Math.max(1, Math.round(beatMs / tickMs));
                    this._arpTransport.isTriplet = false;
                } else {
                    const tri = q => q.endsWith('T');
                    const base = quant.replace('T','');
                    const map = { '1/1':1, '1/2':2, '1/4':4, '1/8':8, '1/16':16, '1/32':32 };
                    const div = map[base] || 16;
                    // quarter note is 1 beat; 1/div of whole note = (4/div) beats per tick
                    const beatsPerTick = tri(quant) ? ((4/div) * (2/3)) : (4/div);
                    ticksPerBeat = Math.max(1, Math.round(1/Math.max(1e-6, beatsPerTick)));
                    tickMs = beatMs * beatsPerTick;
                    this._arpTransport.isTriplet = tri(quant);
                }
                // Effective beats-per-bar in quarter-beats: N * 4 / D
                let effectiveBeatsPerBar = (tsNum * 4) / tsDen;
                // Allow DRUM or PATTERN LEN (data-length in 16ths) to override global bar length, enabling 12/16, 17/16, etc.
                try {
                    const length16 = (()=>{
                        const dGrid = document.getElementById('drumGrid');
                        const pGrid = document.getElementById('patternGrid');
                        const dRaw = dGrid ? parseInt(dGrid.dataset.length||'0',10) : 0;
                        const pRaw = pGrid ? parseInt(pGrid.dataset.length||'0',10) : 0;
                        const dVal = Number.isFinite(dRaw) ? dRaw : 0;
                        const pVal = Number.isFinite(pRaw) ? pRaw : 0;
                        // Prefer drum LEN if set, else pattern LEN
                        return dVal > 0 ? dVal : pVal;
                    })();
                    if (length16 && length16 > 0) {
                        // Convert 16th-count to quarter-beats: len/4
                        effectiveBeatsPerBar = length16 / 4;
                        this._arpTransport._timeSigOverriddenByLen = true;
                        this._arpTransport._len16PerBar = length16;
                    } else {
                        this._arpTransport._timeSigOverriddenByLen = false;
                        this._arpTransport._len16PerBar = null;
                    }
                } catch(_) { this._arpTransport._timeSigOverriddenByLen = false; this._arpTransport._len16PerBar = null; }
                // Capture ARP step period from top quantize before any LCM/clamping adjustments
                const arpTickMs = tickMs;
                // Base ticksPerBar from current grid
                let baseTicksPerBar = Math.max(1, Math.round((beatMs * effectiveBeatsPerBar) / tickMs));
                let ticksPerBar = baseTicksPerBar;
                // Adjust ticksPerBar to align with per-lane denominators (LCM across D values)
                try {
                    // Collect denominators D from drum lanes and pattern lanes
                    const Ds = new Set();
                    const lanes = document.querySelectorAll('.drum-lane');
                    const baseSteps = Math.max(4, Math.round((effectiveBeatsPerBar||4) * 4));
                    if (lanes && lanes.length){
                        lanes.forEach(lane => {
                            let D = baseSteps;
                            const qStr = lane.dataset?.quant || '';
                            if (qStr){ const m = qStr.match(/^(\d+)\/(\d+)$/); if (m){ const d=parseInt(m[2],10); if (Number.isFinite(d) && d>0) D=d; } else { const mn=qStr.match(/^(\d+)$/); if (mn){ const d=parseInt(mn[1],10); if (Number.isFinite(d)&&d>0) D=d; } } }
                            Ds.add(Math.max(1, D|0));
                        });
                    }
                    // Include denominators from NEW DRUM instances so their per-row Q stays sample-accurate.
                    try {
                        const insts = window._drumInstances || [];
                        if (insts && insts.length){
                            insts.forEach(inst=>{
                                const st = inst && inst.state;
                                const ls = st && Array.isArray(st.lanes) ? st.lanes : [];
                                ls.forEach(lane=>{
                                    let D = baseSteps;
                                    const qStr = (lane && lane.quant != null) ? String(lane.quant).trim() : '';
                                    if (qStr){
                                        const m = qStr.match(/^(\d+)\/(\d+)$/);
                                        if (m){ const d=parseInt(m[2],10); if (Number.isFinite(d) && d>0) D=d; }
                                        else { const mn=qStr.match(/^(\d+)$/); if (mn){ const d=parseInt(mn[1],10); if (Number.isFinite(d)&&d>0) D=d; } }
                                    }
                                    Ds.add(Math.max(1, Math.min(64, D|0)));
                                });
                            });
                        }
                    } catch(_) {}
                    const pGrid = document.getElementById('patternGrid');
                    if (pGrid){
                        const pLanes = pGrid.querySelectorAll('.pattern-lane');
                        pLanes.forEach(pl => {
                            let D = parseInt(pGrid.dataset.length||'16',10) || 16;
                            const qStr = pl.dataset?.quant || '';
                            if (qStr){ const m = qStr.match(/^(\d+)\/(\d+)$/); if (m){ const d=parseInt(m[2],10); if (Number.isFinite(d) && d>0) D=d; } else { const mn=qStr.match(/^(\d+)$/); if (mn){ const d=parseInt(mn[1],10); if (Number.isFinite(d)&&d>0) D=d; } } }
                            Ds.add(Math.max(1, D|0));
                        });
                    }
                    // Include BASS lane denominators as well so transport tick grid matches bass quantization
                    try {
                        const bGrid = document.getElementById('bassGrid');
                        if (bGrid){
                            const bLanes = bGrid.querySelectorAll('.bass-lane');
                            bLanes.forEach(ln => {
                                // Prefer actual number of cells (reflects current D) and fall back to dataset.quant
                                let D = Array.from(ln.querySelectorAll('.bass-step')).length || 16;
                                const qStr = ln.dataset?.quant || '';
                                const m = qStr.match(/^(\d+)\/(\d+)$/);
                                if (m){ const d=parseInt(m[2],10); if (Number.isFinite(d) && d>0) D=d; }
                                else { const mn=qStr.match(/^(\d+)$/); if (mn){ const d=parseInt(mn[1],10); if (Number.isFinite(d)&&d>0) D=d; } }
                                Ds.add(Math.max(1, Math.min(64, D|0)));
                            });
                        }
                    } catch(_) {}
                    if (Ds.size > 0){
                        // Compute lcm of collected denominators relative to base ticksPerBar
                        const gcd = (a,b)=> b ? gcd(b, a%b) : Math.abs(a);
                        const lcm2 = (a,b)=> Math.abs(a*b) / Math.max(1, gcd(a,b));
                        let lcm = 1; Ds.forEach(d => { lcm = lcm2(lcm, d); });
                        // Cap LCM to avoid excessive global tick rates; fallback to nearest multiple under cap
                        const MAX_TPB = 256; // cap ticks per bar for performance/stability
                        if (lcm > MAX_TPB) {
                            // Choose a multiple of baseTicksPerBar under cap as compromise
                            const mul = Math.max(1, Math.floor(MAX_TPB / baseTicksPerBar));
                            ticksPerBar = Math.max(1, baseTicksPerBar * mul);
                            this._arpTransport._lcmClamped = true;
                        } else {
                            // Ensure ticksPerBar is a multiple of lcm so each lane advances on integer ticks
                            if (ticksPerBar % lcm !== 0){
                                const mul = Math.ceil(ticksPerBar / lcm);
                                ticksPerBar = Math.max(ticksPerBar, lcm * mul);
                            }
                            this._arpTransport._lcmClamped = false;
                        }
                    }
                } catch(_) { }
                // Keep bar duration constant: adjust tickMs and ticksPerBeat proportionally
                if (ticksPerBar !== baseTicksPerBar){
                    const scale = ticksPerBar / baseTicksPerBar;
                    // New tickMs so that barMs remains beatMs*effectiveBeatsPerBar
                    const barMs = beatMs * effectiveBeatsPerBar;
                    tickMs = barMs / ticksPerBar;
                    // Scale ticksPerBeat so beat markers fall on exact boundaries
                    ticksPerBeat = Math.max(1, Math.round(ticksPerBeat * scale));
                }
                // Disable swing when using tuplets or triplets
                if (tupletN > 0 || this._arpTransport.isTriplet) swingPct = 0;
                this._arpTransport.swingPct = swingPct;
                const timeSignature = (this._arpTransport._timeSigOverriddenByLen && this._arpTransport._len16PerBar)
                    ? `${this._arpTransport._len16PerBar}/16`
                    : `${tsNum}/${tsDen}`;
                Object.assign(this._arpTransport, { bpm, quant, tuplet: tupletN, beatMs, tickMs, arpTickMs, ticksPerBeat, beatsPerBar: effectiveBeatsPerBar, ticksPerBar, timeSignature });
                // Update gate based on current tick
                const gateMs = Math.max(5, Math.floor(((this._arp?.gatePct||50)/100) * tickMs));
                this._arp.gateMs = gateMs;
            }

            _startArpTransport(){
                this._ensureArpTransport();
                this._refreshArpTransportTiming();
                this._checkLoopBehavior(); // Check loop setting on start
                if (this._arpTransport.running) return;
                this._arpTransport.running = true;
                // Ensure independent pattern transport runs with PLAY
                try {
                    if (window._patternTransport) {
                        const patternBtn = document.getElementById('patternBtn');
                        const patternEnabled = !!(patternBtn && patternBtn.classList.contains('active'));
                        if (!patternEnabled) {
                            // PATTERN must not run unless lit
                            try {
                                const pt0 = window._patternTransport;
                                if (pt0 && typeof pt0.stop === 'function') pt0.stop(false);
                                if (pt0) { pt0.running = false; if (typeof pt0.stopVoices === 'function') pt0.stopVoices(); }
                            } catch(_){ }
                        } else {
                        const pt = window._patternTransport;
                        if (pt.waitingForDeferred) {
                            pt.resumeAfterDeferred = true;
                        } else if (typeof pt.start === 'function') {
                            pt.start({ alignToTransport: true, preBufferMs: 80 });
                        } else {
                            pt.running = true;
                            pt.tickCounter = 0;
                            pt.absTickCounter = 0;
                            const now = (performance && performance.now) ? performance.now() : Date.now();
                            // Fire step 0 immediately (no delay)
                            pt.nextAt = now;
                            try { if (typeof pt.kick === 'function') pt.kick(); } catch(_){ }
                        }
                        }
                    }
                } catch(_){ }

                // Start all spawned Pattern instances with PLAY (they are driven by the master tick).
                try {
                    const instances = window._patternInstances || [];
                    instances.forEach(info=>{
                        const m = info && info.modal;
                        const pt = m && m._patternTransport;
                        if (!pt) return;
                        // Always start the transport so playheads stay in time; mute is handled by enabledFn.
                        if (pt.waitingForDeferred) {
                            pt.resumeAfterDeferred = true;
                        } else if (typeof pt.start === 'function') {
                            pt.start({ alignToTransport: true, preBufferMs: 80 });
                        } else {
                            pt.running = true;
                        }
                    });
                } catch(_){ }
                const now = (performance && performance.now) ? performance.now() : Date.now();
                const tickMs = this._arpTransport.tickMs;
                // Initialize ARP accumulators and counters
                if (this._arpTransport._arpAccumMs == null) this._arpTransport._arpAccumMs = 0;
                if (this._arpTransport.arpStepCounter == null) this._arpTransport.arpStepCounter = 0;
                // Align nextAt to the next subdivision to minimize latency and keep stable phase
                const rem = now % tickMs;
                this._arpTransport.nextAt = now + (rem ? (tickMs - rem) : 0);
                // Update absolute bar counter and reset plan if needed
                try {
                    const ticksPerBar = (this._arpTransport.ticksPerBar||1);
                    this._currentAbsBar = Math.floor((this._arpTransport.absTickCounter||0) / ticksPerBar);
                    if (this._lastPlannedBar < this._currentAbsBar) {
                        this._lastPlannedBar = this._currentAbsBar - 1;
                    }
                } catch(_){ }
                // Pre-schedule BASS NOTE 1 exactly at transport start so the first note lands on time and uses the current chord's root
                try {
                    // Do not emit any audio while a global start gate (count-in) is active.
                    const gateTick0 = (this._arpTransport && this._arpTransport.startGateAbsTick != null) ? (this._arpTransport.startGateAbsTick|0) : null;
                    const gateActive0 = (gateTick0 != null) && ((this._arpTransport.absTickCounter|0) < gateTick0);
                    if (!gateActive0) {
                        const bassBtn = document.getElementById('bassBtn');
                        const isBassEnabled = bassBtn && bassBtn.classList.contains('active');
                        if (isBassEnabled) {
                            const bassGrid = document.getElementById('bassGrid');
                            if (bassGrid) {
                            // Build target tokens for bass (LCM across row denominators, capped) so row polyrhythms align
                            const lanes = Array.from(bassGrid.querySelectorAll('.bass-lane'));
                            if (lanes.length > 0) {
                                const gcd = (a,b)=> b ? gcd(b, a % b) : Math.abs(a);
                                const lcm2 = (a,b)=> Math.abs(a*b) / Math.max(1, gcd(a,b));
                                let D_max = 1;
                                let D_target = 1;
                                lanes.forEach(ln => {
                                    let d = Array.from(ln.querySelectorAll('.bass-step')).length || 16;
                                    const qs = ln.dataset.quant||'';
                                    const m = qs.match(/^(\d+)\/(\d+)$/);
                                    if (m) { const dd = parseInt(m[2],10); if (Number.isFinite(dd) && dd>0) d = dd; }
                                    else { const mn = qs.match(/^(\d+)$/); if (mn){ const dd=parseInt(mn[1],10); if (Number.isFinite(dd) && dd>0) d = dd; } }
                                    d = Math.max(1, Math.min(64, d|0));
                                    D_max = Math.max(D_max, d);
                                    D_target = lcm2(D_target, d);
                                });
                                const CAP = 64;
                                if (D_target > CAP) D_target = (D_max <= CAP) ? D_max : CAP;
                                const tokensTarget = new Array(D_target).fill('x');
                                for (let row=0; row<lanes.length; row++){
                                    const stepsRow = Array.from(lanes[row].querySelectorAll('.bass-step'));
                                    const D_row = Math.max(1, stepsRow.length || 16);
                                    let i = 0;
                                    while (i < D_row) {
                                        const cell = stepsRow[i];
                                        if (cell && cell.classList.contains('active')){
                                            const npc = (9 - row);
                                            let len = parseInt(cell.dataset.len||'1',10)||1;
                                            if (!cell.dataset.len){
                                                let j = i + 1; while (j < D_row && stepsRow[j] && stepsRow[j].dataset.tie==='1'){ j++; }
                                                len = Math.max(1, j - i);
                                            }
                                            const startFrac = i / D_row;
                                            const endFrac = Math.min(D_row, i + len) / D_row;
                                            const k0 = Math.floor(startFrac * D_target);
                                            const k1 = Math.max(k0 + 1, Math.floor(endFrac * D_target));
                                            if (tokensTarget[k0] === 'x' || tokensTarget[k0] === '-') tokensTarget[k0] = String(npc);
                                            for (let k = k0 + 1; k < k1; k++) { if (tokensTarget[k] === 'x') tokensTarget[k] = '-'; }
                                            i += len;
                                        } else {
                                            i++;
                                        }
                                    }
                                }
                                // Persist to grid so the first scheduler tick doesn't rebuild and retrigger
                                bassGrid._tokensTarget = tokensTarget;
                                bassGrid._Dtarget = D_target;
                                // Determine first token at index 0 and schedule if it's a note (not '-', not 'x')
                                const first = tokensTarget[0];
                                if (first && first !== 'x' && first !== '-'){
                                    const npc = parseInt(first,10);
                                    if (Number.isFinite(npc) && npc>=1 && npc<=9){
                                        // Resolve frequency using current column's effective root and NPC mapping
                                        const col = (this._arp?.column) || this.currentActiveColumnEl || document.querySelector('.extension-column');
                                        const edo = this.currentTuning||12;
                                        const norm = (x)=> ((x%edo)+edo)%edo;
                                        const rootAbs = (typeof this._getEffectiveColumnRootStep === 'function' && col) ? this._getEffectiveColumnRootStep(col) : (this.currentRoot||0);
                                        let rel = [];
                                        try {
                                            const rows = Array.from(col.querySelectorAll('.strings-column .string'));
                                            const steps = rows.map(r=> parseInt(r.dataset.noteIndex,10)).filter(n=>Number.isFinite(n));
                                            const uniqRel = Array.from(new Set(steps.map(st=> norm(st - rootAbs))));
                                            if (typeof this.stepToSemitone === 'function') {
                                                rel = uniqRel.sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo));
                                            } else { rel = uniqRel.sort((a,b)=> a-b); }
                                        } catch(_) { rel = []; }
                                        const step = this._npcToChordStep(npc, rel);
                                        if (Number.isFinite(step)) {
                                            const uniq = Array.isArray(rel) ? rel.map(norm).sort((a,b)=>a-b).filter((v,i,a)=> i===0 || a[i-1]!==v) : [];
                                            const cycle = (uniq.length>0) ? Math.floor((Math.max(1,npc)-1)/uniq.length) : 0;
                                            const abs = norm(rootAbs + step);
                                            const baseOct = Math.max(1, Math.min(3, 1 + cycle));
                                            const f = this.getFrequency(abs, baseOct, edo);
                                            // Compute note length (# of '-' following first index)
                                            let noteLength = 1; for (let j = 1; j < tokensTarget.length; j++){ if (tokensTarget[j] === '-') noteLength++; else break; }
                                            const barMs = (this._arpTransport.beatMs||500) * (this._arpTransport.beatsPerBar||4);
                                            const gateMs = Math.max(10, Math.floor((barMs / D_target) * noteLength * 0.95));
                                            const delay = Math.max(0, (this._arpTransport.nextAt - now));
                                            setTimeout(()=>{
                                                try {
                                                    const bassBtn = document.getElementById('bassBtn');
                                                    const isBassEnabledNow = bassBtn && bassBtn.classList.contains('active');
                                                    if (!isBassEnabledNow) { try { this.stopAllActiveNotes && this.stopAllActiveNotes('bass'); } catch(_){} return; }
                                                } catch(_){}
                                                try { this.stopAllActiveNotes && this.stopAllActiveNotes('bass'); } catch(_){}
                                                try { this._duckExistingBassVoices(f, 25, 0.12); } catch(_){ }
                                                try { this.playFrequency(f, null, 'bass'); } catch(_){ }
                                                try { setTimeout(()=>{ try { this.stopFrequency(f, null, 'bass'); } catch(_){ } }, gateMs); } catch(_){ }
                                            }, delay);
                                            // Prevent duplicate trigger on first scheduler tick
                                            bassGrid._lastLocalStep = 0;
                                        }
                                    }
                                } else {
                                    // No note at first token; ensure scheduler can trigger when it appears later
                                    bassGrid._lastLocalStep = -1;
                                }
                            }
                            }
                        }
                    }
                } catch(_){ /* ignore pre-roll bass errors */ }
                const runTick = ()=>{
                    if (!this._arpTransport.running) return;
                    const t = (performance && performance.now) ? performance.now() : Date.now();
                    // Track bar boundaries for plan application (read current counter, don't increment here)
                    try {
                        const tpBeat = (this._arpTransport.ticksPerBeat||1);
                        const tpBar = (this._arpTransport.ticksPerBar||tpBeat* (this._arpTransport.beatsPerBar||4));
                        const abs = (this._arpTransport.absTickCounter||0);
                        const newBar = Math.floor(abs / Math.max(1,tpBar));
                        if (newBar !== this._currentAbsBar) {
                            this._currentAbsBar = newBar;
                            // Mark bar boundary for plan application
                            this._plan && (this._plan.applyFromBar = Math.max(this._plan.applyFromBar|0, newBar + this._plan.horizonBars));
                            this._dbg && this._dbg('PLAN:BAR', 'bar=', newBar, 'applyFrom=', this._plan?.applyFromBar);
                        }
                    } catch(_){ }
                    
                    // TICK-DRIVEN CHORD SCHEDULING: Check if it's time to switch to the next chord
                    // This replaces setTimeout-based scheduling to keep chords locked to drums/bass
                    try {
                        const switchTick = this._arpTransport._seqNextSwitchAbsTick;
                        const scheduleNextFn = this._arpTransport._seqScheduleNext;
                        const nowAbs = this._arpTransport.absTickCounter|0;
                        if (Number.isFinite(switchTick) && typeof scheduleNextFn === 'function' && nowAbs >= switchTick) {
                            // Clear the pending switch tick before calling to prevent re-entry
                            this._arpTransport._seqNextSwitchAbsTick = null;
                            // Call scheduleNext synchronously from the tick handler
                            try { scheduleNextFn(); } catch(e) { console.error('Tick-driven scheduleNext error:', e); }
                        }
                    } catch(_){ }
                    
                    // Removed hard bar-boundary fence so note releases can carry over across loop boundaries
                    // (No forced all-notes-off at bar start; tails release naturally.)
                    // Metronome click on beat, accented downbeat (beat indicators follow transport phase including swing)
                    try {
                        if (this._arpTransport.metronomeOn && !this._arpTransport.countInActive) {
                            const isBeat = (this._arpTransport.tickCounter % (this._arpTransport.ticksPerBeat||1)) === 0;
                            if (isBeat) {
                                const isDownbeat = this._arpTransport.tickCounter === 0;
                                const freq = isDownbeat ? 1400 : 1000;
                                const dur = Math.max(10, Math.min(40, Math.floor(this._arpTransport.tickMs * 0.35)));
                                this._clickMetronome(freq, dur);
                            }
                        }
                    } catch(_) { }

                    // START COUNT-IN: 4-beat audible/visual count-in while the global start gate is active.
                    // This is used when starting from STOPPED so drums/patterns/chords all begin together after the count.
                    try {
                        const tr = this._arpTransport;
                        if (tr && tr.countInActive && tr.countInEndAbsTick != null) {
                            const nowAbs = tr.absTickCounter|0;
                            const startAbs = (tr.countInStartAbsTick|0) || 0;
                            const endAbs = tr.countInEndAbsTick|0;
                            const tpBeat = Math.max(1, tr.ticksPerBeat||1);

                            if (nowAbs >= endAbs) {
                                tr.countInActive = false;
                                tr.countInStartAbsTick = null;
                                tr.countInEndAbsTick = null;
                                tr.countInLastBeat = 0;
                                try {
                                    const el = tr._countInEl || (tr._countInEl = document.getElementById('countInDisplay'));
                                    if (el) el.style.display = 'none';
                                } catch(_){ }
                            } else if (nowAbs >= startAbs && ((nowAbs - startAbs) % tpBeat) === 0) {
                                const beatIdx = (((nowAbs - startAbs) / tpBeat) | 0) + 1;
                                if (beatIdx !== (tr.countInLastBeat|0)) {
                                    tr.countInLastBeat = beatIdx;
                                    // Click: accented 1, lighter 2-4
                                    const freq = (beatIdx === 1) ? 1400 : 1000;
                                    const dur = Math.max(10, Math.min(45, Math.floor(tr.tickMs * 0.45)));
                                    this._clickMetronome(freq, dur);
                                    // UI: show 1..N
                                    try {
                                        const el = tr._countInEl || (tr._countInEl = document.getElementById('countInDisplay'));
                                        if (el) {
                                            el.textContent = String(beatIdx);
                                            el.style.display = 'flex';
                                        }
                                    } catch(_){ }
                                }
                            }
                        }
                    } catch(_){ }

                    // Apply any pending per-lane QUANT changes at a safe boundary (bar start)
                    try {
                        const tpBar = this._arpTransport.ticksPerBar || 16;
                        const isBarStart = (this._arpTransport.absTickCounter % tpBar) === 0;
                        if (isBarStart) {
                            const lanes = Array.from(document.querySelectorAll('.drum-lane'));
                            let needsRebuild = false;
                            lanes.forEach(lane=>{
                                const pq = lane.dataset.pendingQuant;
                                if (pq){ lane.dataset.quant = pq; delete lane.dataset.pendingQuant; needsRebuild = true; }
                            });
                            if (needsRebuild) {
                                try { this._updateDrumGridForTimeSignature(); } catch(_){ }
                                try { const pg=document.getElementById('patternGrid'); if(pg && typeof pg._attachHandlers==='function') pg._attachHandlers(); } catch(_){ }
                                // Lane denominators changed; update transport LCM-based ticksPerBar
                                try { this._refreshArpTransportTiming(); } catch(_){ }
                            }
                        }
                    } catch(_){ }

                    // Apply any pending SECTION switch at beat 1 (bar start)
                    try {
                        const tpBar = this._arpTransport.ticksPerBar || 16;
                        const isBarStart = (this._arpTransport.absTickCounter % tpBar) === 0;
                        const loopEl = document.getElementById('loopToggle') || document.getElementById('playLoop');
                        const loopEnabled = loopEl ? !!loopEl.checked : true;
                        const applyFn = (typeof this._applySectionSwitchById === 'function')
                            ? this._applySectionSwitchById
                            : (typeof window._applySectionSwitchById === 'function' ? window._applySectionSwitchById : null);
                        if (!loopEnabled && isBarStart && this._pendingSectionSwitchId && applyFn) {
                            applyFn(this._pendingSectionSwitchId);
                            this._pendingSectionSwitchId = null;
                        }
                    } catch(_){ }

                    // Apply any pending chord/arp switch if it's time
                    try {
                        if (this._arp?.pendingSwitch) {
                            const ps = this._arp.pendingSwitch;
                            const nowAbs = this._arpTransport.absTickCounter|0;
                            if (ps.atAbsTick != null && nowAbs >= ps.atAbsTick) {
                                try {
                                    const tr = this._arpTransport;
                                    if (tr) {
                                        tr._seqLastSwitchAbsTick = nowAbs;
                                        if (Number.isFinite(ps.holdTicks) && (ps.holdTicks|0) > 0) tr._seqLastHoldTicks = (ps.holdTicks|0);
                                        tr._seqLastColumn = ps.column || this._arp?.column || null;
                                    }
                                } catch(_){ }
                                // Removed hard cut at boundary during sequencing to allow natural releases across loops
                                // Align new sequence to current transport phase if requested
                                if (ps.alignPhaseToTickCounter) {
                                    this._arp.startTickAlign = this._arpTransport.tickCounter;
                                }
                                // Activate with prepared data
                                this._arp.seq = Array.isArray(ps.seq) ? ps.seq : (this._arp.seq||[]);
                                // Recompute bass at switch time based on the target column's effective root,
                                // preferring continuity to the currently sounding bass.
                                try {
                                    const col = ps.column || this._arp.column;
                                    const tuning = this.currentTuning || 12;
                                    const prev = (typeof this._arp?.bassLiveFreq === 'number' && this._arp.bassLiveFreq>0)
                                        ? this._arp.bassLiveFreq
                                        : (Number.isFinite(ps.bassFreq) ? ps.bassFreq : (this._arp?.bassFreq||null));
                                    if (col) {
                                        const step = (typeof this._getNamedColumnRootStep === 'function')
                                            ? (this._getNamedColumnRootStep(col) ?? this._getEffectiveColumnRootStep(col))
                                            : this._getEffectiveColumnRootStep(col);
                                        const bf = this._computeBassFreqInRange(step, prev, tuning);
                                        if (bf && isFinite(bf) && bf>0) {
                                            this._arp.bassFreq = bf;
                                        } else if (Number.isFinite(ps.bassFreq)) {
                                            this._arp.bassFreq = ps.bassFreq;
                                        }
                                    } else if (Number.isFinite(ps.bassFreq)) {
                                        this._arp.bassFreq = ps.bassFreq;
                                    }
                                } catch(_) {
                                    if (Number.isFinite(ps.bassFreq)) this._arp.bassFreq = ps.bassFreq;
                                }
                                this._arp.column = ps.column || this._arp.column;
                                try {
                                    if (this._arp && this._arp.column) this._setNowPlayingColumn(this._arp.column, { pulse: true });
                                } catch(_){ }
                                // Invalidate bass tokens so they rebuild on next tick with the new chord context
                                try {
                                    const bassGrid = document.getElementById('bassGrid');
                                    if (bassGrid) {
                                        delete bassGrid._tokensTarget;
                                        delete bassGrid._Dtarget;
                                        bassGrid._lastLocalStep = -1;
                                    }
                                } catch(_){ }
                                // Persist ascending map for morph mapping lookups post-switch
                                try { this._arp.mapAsc = Array.isArray(ps.mapAsc) ? ps.mapAsc.slice() : (this._arp.mapAsc||[]); } catch(_) {}
                                // Store morph state for GLIDE
                                if (ps.morph){
                                    this._arp.morph = {
                                        startAbsTick: nowAbs,
                                        source: Array.isArray(ps.morph.source)? ps.morph.source.slice():[],
                                        currentTargets: Array.isArray(ps.morph.target)? ps.morph.target.slice():[],
                                        target: Array.isArray(ps.morph.target)? ps.morph.target.slice():[]
                                    };
                                } else {
                                    this._arp.morph = null;
                                }
                                // Independent lanes: honor requested mode ('arp' or 'chord')
                                this._arp.mode = ps.mode || 'arp';
                                this._arp.npc = Number.isFinite(ps.npc) ? ps.npc : (this._arp.npc||3);
                                        if (ps.enableChord) {
                                    try {
                                        // Ensure chord voices sustain (no auto-release)
                                        this._sustainActive = true;
                                        let rows = Array.isArray(ps.chordRows) ? ps.chordRows : [];
                                                const anyActiveChord = !!(this.activeChordOscillators && this.activeChordOscillators.size > 0);
                                            // OSC (XENON) chords should keep gliding as before.
                                            // MIDI should still emit each chord change even when OSC glides.
                                            const midiEnabled = !!(window.midi && window.midi.enabled);
                                            const choirSlide = !!(this.chordsEnabled && this._arpTransport && this._arpTransport.running);
                                        // Choir-slide wants all chord tones (extensions) within one octave.
                                        try {
                                            if (choirSlide && ps.column && typeof this._buildFullChordOneOctaveRows === 'function') {
                                                const full = this._buildFullChordOneOctaveRows(ps.column);
                                                if (Array.isArray(full) && full.length) rows = full;
                                            }
                                        } catch(_) {}
                                                try {
                                                    if (window.DEBUG_CHOIR_SLIDE) {
                                                        console.log('[CHOIR] pendingSwitch chord', {
                                                            choirSlide,
                                                            anyActiveChord,
                                                            chordsEnabled: !!this.chordsEnabled,
                                                            arpEnabled: !!this.arpEnabled,
                                                            transportRunning: !!(this._arpTransport && this._arpTransport.running),
                                                            activeChordVoices: this.activeChordOscillators ? this.activeChordOscillators.size : 0,
                                                            trackedSlideVoices: this._chordSlideVoices ? this._chordSlideVoices.size : 0,
                                                            rows: rows.length,
                                                            atAbsTick: ps.atAbsTick,
                                                            nowAbsTick: (this._arpTransport ? (this._arpTransport.absTickCounter|0) : null)
                                                        });
                                                    }
                                                } catch(_) {}

                                        // Choir-slide: never retrigger chord voices on chord changes; only glide pitch.
                                        // (We still seed voices once on the first chord.)
                                        if (!choirSlide) {
                                            // Legacy behavior: hard switch chord layer each step
                                            try { this.stopAllActiveNotes('chord'); } catch(_){ }
                                            try { if (this._chordSlideVoices) this._chordSlideVoices.clear(); } catch(_){ }
                                        }

                                        // Calculate chord sustain duration.
                                        // Prefer the per-step `holdTicks` from the sequencer (len16-based),
                                        // and fall back to the legacy HOLD selector.
                                        let barMs = 2000; // fallback
                                        try {
                                            const tickMs = this._arpTransport?.tickMs || 0;
                                            const ht = ps && Number.isFinite(ps.holdTicks) ? (ps.holdTicks|0) : 0;
                                            if (tickMs > 0 && ht > 0) {
                                                barMs = Math.max(20, Math.round(ht * tickMs));
                                            } else {
                                                const bpm = this._arpTransport?.bpm || 120;
                                                const beatMs = 60000 / Math.max(20, bpm);
                                                const beatsPerBar = this._arpTransport?.beatsPerBar || 4;
                                                barMs = beatMs * beatsPerBar;
                                                // Use HOLD setting if available
                                                const holdSel = document.getElementById('universalHold') || document.getElementById('chordHold');
                                                if (holdSel) {
                                                    const holdVal = String(holdSel.value||'bar:1');
                                                    const [kind, valStr] = holdVal.split(':');
                                                    const n = Math.max(1, parseInt(valStr||'1',10));
                                                    barMs = (kind === 'beat') ? n*beatMs : n*barMs;
                                                }
                                            }
                                        } catch(_) {}

                                        // MIDI chord emission: send each chord change even when OSC is gliding.
                                        try {
                                            if (midiEnabled && window.midi && typeof window.midi.sendNoteOn === 'function') {
                                                const midi = window.midi;
                                                const outId = midi.outputForSource ? midi.outputForSource('chord') : null;
                                                const baseCh = (midi.channelMap && (midi.channelMap.chord || midi.channelMap.default)) ? (midi.channelMap.chord || midi.channelMap.default) : 3;
                                                const vel = (midi.perSourceVelocity && Number.isFinite(midi.perSourceVelocity.chord)) ? midi.perSourceVelocity.chord : (midi.defaultVelocity || 100);
                                                const perOct = (midi.perSourceOctave && Number.isFinite(midi.perSourceOctave.chord)) ? (midi.perSourceOctave.chord|0) : 0;
                                                const edo = this.currentTuning || 12;
                                                const cStep = (typeof this.semitoneToStep === 'function') ? this.semitoneToStep(0, edo) : 0;
                                                const gateMs = Math.max(10, Math.floor((barMs || 0) - 8));

                                                if (!this._midiChordNoteKeys) this._midiChordNoteKeys = new Set();
                                                // Hard-off any prior chord notes for clean changes
                                                try {
                                                    for (const key of this._midiChordNoteKeys) {
                                                        const parts = String(key).split('@');
                                                        const n = parseInt(parts[0]||'0',10);
                                                        const ch = parseInt(parts[1]||'0',10);
                                                        const port = parts[2] || null;
                                                        if (Number.isFinite(n) && Number.isFinite(ch)) midi.sendNoteOff(n, ch, port && port !== '*' ? port : null);
                                                    }
                                                } catch(_) {}
                                                this._midiChordNoteKeys.clear();

                                                const played = new Set();
                                                const bfLive = this._arp?.bassLiveFreq || this._heldBassLiveFreq || null;
                                                rows.forEach(r=>{
                                                    try {
                                                        if (!r) return;
                                                        let f = parseFloat(r?.dataset?.frequency);
                                                        if (bfLive && Number.isFinite(f) && f > 0 && Math.abs((f - bfLive)/bfLive) <= 5e-5) return; // avoid doubling bass
                                                        const step = parseInt(r.dataset.noteIndex,10);
                                                        const oct = parseInt(r.dataset.octave,10);
                                                        if (!Number.isFinite(step) || !Number.isFinite(oct)) return;
                                                        // Map EDO step+octave to MIDI note anchored at C4=60
                                                        let note = 60 + ((oct - 4) * edo) + (step - cStep);
                                                        note += perOct * 12;
                                                        // De-dupe by final normalized note+channel
                                                        const normed = midi.normalizeNoteChannel ? midi.normalizeNoteChannel(note, baseCh) : { note, channel: baseCh };
                                                        const n2 = normed.note|0; const ch2 = normed.channel|0;
                                                        const k = `${n2}@${ch2}@${outId||'*'}`;
                                                        if (played.has(k)) return;
                                                        played.add(k);
                                                        midi.sendNoteOn(n2, vel, ch2, outId);
                                                        this._midiChordNoteKeys.add(k);
                                                        setTimeout(()=>{
                                                            try {
                                                                if (this._midiChordNoteKeys && this._midiChordNoteKeys.has(k)) {
                                                                    midi.sendNoteOff(n2, ch2, outId);
                                                                    this._midiChordNoteKeys.delete(k);
                                                                }
                                                            } catch(_) {}
                                                        }, gateMs + 2);
                                                    } catch(_){ }
                                                });
                                            }
                                        } catch(_){ }

                                        // Seed chord voices if none are playing yet (first step)
                                        if (!anyActiveChord || !choirSlide) {
                                            const played = new Set();
                                            const bfLive = this._arp?.bassLiveFreq || this._heldBassLiveFreq || this._heldBassVoiceKey || null;
                                            const groupId = ((this._chordSlideGroupId||0)+1) >>> 0; this._chordSlideGroupId = groupId;
                                            const chordFreqs = []; // Track frequencies for scheduled stop
                                            rows.forEach(r=>{
                                                let f = parseFloat(r?.dataset?.frequency);
                                                if (!f || !isFinite(f) || f<=0){
                                                    try{
                                                        const step = parseInt(r.dataset.noteIndex,10);
                                                        const oct = parseInt(r.dataset.octave,10);
                                                        const tuning = this.currentTuning || 12;
                                                        if (Number.isFinite(step)) f = this.getFrequency(((step%tuning)+tuning)%tuning, Number.isFinite(oct)?oct:4, tuning);
                                                    }catch(_){ f = NaN; }
                                                }
                                                const isBass = !!(bfLive && Math.abs((f - bfLive)/bfLive) <= 5e-5);
                                                if (isFinite(f) && f>0 && !played.has(f) && !isBass){
                                                    played.add(f);
                                                    chordFreqs.push(f);
                                                    // Use dedicated CHORD oscillator lane
                                                    this.playFrequency(f, r, 'chord');
                                                    try { if (this._chordSlideVoices) this._chordSlideVoices.set(r, { startFreq: f, startLog2: Math.log2(f), groupId }); } catch(_){ }
                                                }
                                            });
                                        } else {
                                            // Voices already exist: glide them to the new chord targets
                                            try {
                                                const targets = (rows && rows.length) ? rows : (this._computeChordSlideTargets ? this._computeChordSlideTargets(ps.column) : []);
                                                const glideSec = (this._getChordSlideTimeSec && typeof this._getChordSlideTimeSec === 'function') ? this._getChordSlideTimeSec() : 0;
                                                try { if (window.DEBUG_CHOIR_SLIDE) console.log('[CHOIR] glide->targets', { glideSec, targets: targets.length }); } catch(_) {}
                                                this._retuneActiveChordVoicesToTargets && this._retuneActiveChordVoicesToTargets(targets, 0, glideSec);
                                            } catch(_){ }
                                        }
                                    } catch(_){ }
                                }
                                this._arp.active = true;
                                this._arp.pendingSwitch = null;
                                // If this chord landed on the start of the planned cycle, hard-resync the pattern transport phase
                                try {
                                    const psIsCycleStart = !!(ps && ps.isCycleStart);
                                    if (psIsCycleStart && window._patternTransport) {
                                        const pt = window._patternTransport;
                                        // Reset phase counters so the pattern restarts deterministically at cycle start
                                        pt.tickCounter = 0;
                                        pt.absTickCounter = 0;
                                        // Fire step 0 immediately at cycle start (no delay)
                                        const nowMs = (performance && performance.now ? performance.now() : Date.now());
                                        pt.preRollUntil = null;
                                        pt.nextAt = nowMs;
                                        // Ensure the loop is ticking if it was paused
                                        if (typeof pt.kick === 'function') pt.kick();
                                    }
                                    if (psIsCycleStart && this._pendingSectionSwitchId) {
                                        const loopEl = document.getElementById('loopToggle') || document.getElementById('playLoop');
                                        const loopEnabled = loopEl ? !!loopEl.checked : true;
                                        const applyFn = (typeof this._applySectionSwitchById === 'function')
                                            ? this._applySectionSwitchById
                                            : (typeof window._applySectionSwitchById === 'function' ? window._applySectionSwitchById : null);
                                        if (loopEnabled && applyFn) {
                                            applyFn(this._pendingSectionSwitchId);
                                            this._pendingSectionSwitchId = null;
                                        }
                                    }
                                } catch(_){ /* ignore pattern sync errors */ }
                                // Update held bass to follow ARP chord switches without gliding
                                try {
                                    if (this._arp?.column) {
                                        this._updateHeldBassForColumn(this._arp.column);
                                    }
                                } catch(_){ }
                            }
                        }
                    } catch(_) { }

                    // Apply any deferred settings at the scheduled transport boundary
                    try {
                        const dfAt = this._arpTransport.deferApplyAtAbsTick;
                        if (dfAt != null) {
                            const nowAbs = this._arpTransport.absTickCounter|0;
                            if (nowAbs >= dfAt) {
                                const flags = this._arpTransport.deferFlags || {};
                                // Transport/time updates (bpm/quant/swing/tuplet/time signature)
                                if (flags.transport || flags.swing || flags.grid) {
                                    if (flags.swing && this._arpTransport.pendingSwingPct != null) {
                                        this._arpTransport.swingPct = Math.max(0, Math.min(75, this._arpTransport.pendingSwingPct|0));
                                        this._arpTransport.pendingSwingPct = null;
                                    }
                                    try { this._refreshArpTransportTiming(); } catch(_) {}
                                }

                                // DRUMS-only updates (per-lane Q + DRUM LEN) apply on the bar boundary without rebuilding grids/transport.
                                if (flags.drums) {
                                    const isDefaultQuant = (qs, len)=>{
                                        const s = String(qs||'').trim();
                                        if (!s) return true;
                                        const m = s.match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
                                        if (m) {
                                            const N = parseInt(m[1],10), D = parseInt(m[2],10);
                                            return (Number.isFinite(N)&&Number.isFinite(D) && N===len && D===len);
                                        }
                                        const mn = s.match(/^\s*(\d+)\s*$/);
                                        if (mn) {
                                            const D = parseInt(mn[1],10);
                                            return Number.isFinite(D) && D === len;
                                        }
                                        return false;
                                    };

                                    // Apply pending DRUM LEN changes
                                    try {
                                        const grid = document.getElementById('drumGrid');
                                        if (grid && grid.dataset && grid.dataset.pendingLength) {
                                            const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                                            const newLen = Math.max(1, Math.min(maxLen, parseInt(grid.dataset.pendingLength||'0', 10) || 0));
                                            const oldLen = Math.max(1, Math.min(maxLen, parseInt(grid.dataset.length||'16', 10) || 16));
                                            if (newLen > 0 && newLen !== oldLen) {
                                                grid.dataset.length = String(newLen);

                                                try {
                                                    const lenVal = document.getElementById('drumLenValue');
                                                    const lenHint = document.getElementById('drumLenHint');
                                                    if (lenVal) { lenVal.textContent = String(newLen); try { delete lenVal.dataset.pending; } catch(_){ } }
                                                    if (lenHint) lenHint.textContent = `Cycle: ${newLen} steps`;
                                                } catch(_){ }

                                                // Update default per-lane quant (skip lanes that have explicit pendingQuant)
                                                try {
                                                    const lanes = Array.from(grid.querySelectorAll('.drum-lane'));
                                                    lanes.forEach(lane => {
                                                        if (!lane || (lane.dataset && lane.dataset.pendingQuant)) return;
                                                        if (isDefaultQuant(lane.dataset.quant, oldLen)) {
                                                            lane.dataset.quant = String(newLen);
                                                        }
                                                    });
                                                } catch(_){ }
                                            }
                                            try { delete grid.dataset.pendingLength; } catch(_){ }
                                        }
                                    } catch(_){ }

                                    // Apply any pending per-lane DRUM quant changes (restrict to DRUM grid only)
                                    try {
                                        const lanes = document.querySelectorAll('#drumGrid .drum-lane');
                                        if (lanes && lanes.length) {
                                            lanes.forEach(lane => {
                                                const pq = lane?.dataset?.pendingQuant;
                                                if (!pq) return;
                                                try { lane.dataset.quant = String(pq); } catch(_){ }
                                                try { delete lane.dataset.pendingQuant; } catch(_){ }
                                                try { delete lane._pendingQuant; } catch(_){ }
                                                // Refresh cached quant values for any helper code
                                                try {
                                                    const qs = String(lane.dataset.quant||'').trim();
                                                    let N = 0, D = 0;
                                                    const m = qs.match(/^(\d+)\/(\d+)$/);
                                                    if (m) { N = parseInt(m[1],10)||0; D = parseInt(m[2],10)||0; }
                                                    else { const mn = qs.match(/^(\d+)$/); if (mn) { D = parseInt(mn[1],10)||0; N = D; } }
                                                    if (!D) { D = parseInt(lane.style.getPropertyValue('--steps-per-bar')||'0',10) || 16; N = D; }
                                                    lane._quant = { N: Math.max(1, Math.min(N||D, D)), D: Math.max(1, D), str: qs || String(D) };
                                                } catch(_){ }
                                            });
                                        }
                                    } catch(_){ }
                                }
                                // Rebuild drum grid if time signature changed
                                if (flags.grid) {
                                    // Avoid heavy DOM rebuild inside the transport tick (prevents audio crackles)
                                    try {
                                        if (!this._arpTransport._gridRebuildQueued) {
                                            this._arpTransport._gridRebuildQueued = true;
                                            const self = this;
                                            setTimeout(()=>{
                                                try { self._updateDrumGridForTimeSignature(); } catch(_){ }
                                                try { self._arpTransport._gridRebuildQueued = false; } catch(_){ }
                                            }, 0);
                                        }
                                    } catch(_){ }
                                }

                                // Chord grid rebuilds (deferred): apply outside the transport tick.
                                if (flags.chordGrid) {
                                    try {
                                        if (!this._arpTransport._chordGridRebuildQueued) {
                                            this._arpTransport._chordGridRebuildQueued = true;
                                            const mode = flags.chordGrid;
                                            const self = this;
                                            setTimeout(() => {
                                                try {
                                                    if (mode === 'exact') {
                                                        if (typeof self.generateExactChordColumns === 'function') self.generateExactChordColumns({ force: true });
                                                    } else {
                                                        if (typeof self.generateExtensionColumns === 'function') self.generateExtensionColumns({ force: true });
                                                    }
                                                } catch(_){ }
                                                try { self._arpTransport._chordGridRebuildQueued = false; } catch(_){ }
                                            }, 0);
                                        }
                                    } catch(_){ }
                                }
                                // MIDI settings updates (channels, ports, octave, velocity)
                                if (flags.midi) {
                                    try {
                                        const velEl = document.getElementById('midiDefaultVelocity');
                                        if (velEl && window.midi) {
                                            const v = Math.max(1, Math.min(127, parseInt(velEl.value||'100',10)));
                                            window.midi.defaultVelocity = v;
                                        }
                                    } catch(_) {}
                                    try {
                                        const octEl = document.getElementById('midiOctaveOffset');
                                        if (octEl && window.midi) {
                                            window.midi.octaveOffset = parseInt(octEl.value||'0',10) || 0;
                                        }
                                    } catch(_) {}
                                    try {
                                        const secs = ['strum1','strum2','chord','arp','bass','bells'];
                                        for (const sec of secs) {
                                            const inEl = document.getElementById('midiIn-'+sec);
                                            if (inEl && window.midi) {
                                                window.midi.inputChannelMap[sec] = Math.max(0, Math.min(15, parseInt(inEl.value||'0',10)|0));
                                            }
                                            const outEl = document.getElementById('midiOut-'+sec);
                                            if (outEl && window.midi) {
                                                const sel = outEl.options[outEl.selectedIndex];
                                                const id = sel ? (sel.value || sel.getAttribute('data-id') || sel.textContent || '') : '';
                                                window.midi.outputPortMap[sec] = id || null;
                                            }
                                        }
                                    } catch(_) {}
                                }
                                // EDO tuning changes (deferred)
                                if (flags.edo != null) {
                                    try {
                                        if (typeof this.updateTuningSystem === 'function') {
                                            this.updateTuningSystem(flags.edo);
                                        }
                                        // If a sequence is loaded, regenerate it with the new EDO
                                        const textChordInput = document.getElementById('textChordInput');
                                        if (textChordInput && textChordInput.value.trim().length > 0) {
                                            if (typeof this.createSequenceFromTextarea === 'function') {
                                                console.log('ðŸ”„ Deferred regenerating chord sequence with new EDO:', flags.edo);
                                                this.createSequenceFromTextarea();
                                            }
                                        }
                                    } catch(_) {}
                                }
                                // ARP mode changes (deferred)
                                if (flags.arpMode) {
                                    try {
                                        const nextState = flags.arpMode;
                                        if (nextState === 'chords') { 
                                            this.chordsEnabled = true; 
                                            this.arpEnabled = false; 
                                        } else if (nextState === 'arp') { 
                                            this.chordsEnabled = false; 
                                            this.arpEnabled = true; 
                                        } else if (nextState === 'both') { 
                                            this.chordsEnabled = true; 
                                            this.arpEnabled = true; 
                                        } else { 
                                            this.chordsEnabled = false; 
                                            this.arpEnabled = false; 
                                        }
                                        this.syncPlayMode();
                                        this.updateModeUI();
                                        console.log('ðŸŽµ Deferred ARP mode change to:', nextState);
                                    } catch(_) {}
                                }
                                // Pattern transport updates (LEN/QUANT resync + pattern slot switch at bar boundary)
                                if (flags.pattern) {
                                    try {
                                        const pending = window._patternPendingChanges || {};
                                        const patternGrid = document.getElementById('patternGrid');
                                        const didLen = (pending.len != null);
                                        const didQuant = (pending.quant != null);
                                        const didNpc = (pending.npc != null);
                                        const didSlot = (pending.slot != null);
                                        const didSynth = !!pending.applyArpSynth;
                                        const didLaneQuant = !!(flags.pattern && flags.pattern.laneQuant);
                                        if (patternGrid) {
                                            const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                                            const targetLen = pending.len != null ? Math.max(1, Math.min(maxLen, parseInt(pending.len, 10) || pending.len)) : null;
                                            if (targetLen != null) {
                                                try { if (typeof patternGrid._rebuildLength === 'function') patternGrid._rebuildLength(targetLen); } catch(_){}
                                                try { delete pending.len; } catch(_){ }
                                            }
                                            if (pending.npc != null) {
                                                const targetNpc = Math.max(1, Math.min(64, parseInt(pending.npc, 10) || pending.npc));
                                                try { if (typeof patternGrid._rebuildNpc === 'function') patternGrid._rebuildNpc(targetNpc); } catch(_){ }
                                                try { delete pending.npc; } catch(_){ }
                                                try {
                                                    const npcEl = document.getElementById('universalNpc');
                                                    if (npcEl) {
                                                        npcEl.value = String(targetNpc);
                                                        npcEl.classList.remove('pending-change');
                                                        delete npcEl.dataset.pending;
                                                        delete npcEl.dataset.pendingValue;
                                                        npcEl.title = '';
                                                    }
                                                } catch(_){ }
                                            }
                                        }
                                        if (pending.quant != null) {
                                            const patternQuantSelect = document.getElementById('patternQuant');
                                            if (patternQuantSelect) {
                                                patternQuantSelect.classList.remove('pending-change');
                                                delete patternQuantSelect.dataset.pending;
                                            }
                                            try { delete pending.quant; } catch(_){ }
                                        }

                                        // Apply deferred per-row lane Q (N/D) at the bar boundary.
                                        if (patternGrid && didLaneQuant) {
                                            try {
                                                const lanes = Array.from(patternGrid.querySelectorAll('.pattern-lane'));
                                                let any = false;
                                                lanes.forEach(lane=>{
                                                    const pq = lane?.dataset?.pendingQuant;
                                                    if (!pq) return;
                                                    any = true;
                                                    try { lane.dataset.quant = String(pq); } catch(_){ }
                                                    try { delete lane.dataset.pendingQuant; } catch(_){ }
                                                    try { delete lane._pendingQuant; } catch(_){ }
                                                    try {
                                                        const qs = String(lane.dataset.quant||'').trim();
                                                        let N = 0, D = 0;
                                                        const m = qs.match(/^(\d+)\/(\d+)$/);
                                                        if (m) { N = parseInt(m[1],10)||0; D = parseInt(m[2],10)||0; }
                                                        else { const mn = qs.match(/^(\d+)$/); if (mn) { D = parseInt(mn[1],10)||0; N = D; } }
                                                        if (!D) { D = parseInt(patternGrid.dataset.length||'16',10) || 16; N = D; }
                                                        lane._quant = { N: Math.max(1, Math.min(N||D, D)), D: Math.max(1, D), str: qs || String(D) };
                                                        lane.style.setProperty('--steps-per-bar', String(lane._quant.D));
                                                    } catch(_){ }
                                                    try {
                                                        const qInput = lane.closest('.pattern-row')?.querySelector('.drum-quant input');
                                                        if (qInput) { delete qInput.dataset.pending; qInput.classList.remove('pending-change'); qInput.value = String(lane.dataset.quant||''); }
                                                    } catch(_){ }
                                                    try { window.rebuildPatternLaneForQuant && window.rebuildPatternLaneForQuant(lane, patternGrid); } catch(_){ }
                                                });

                                                if (any) {
                                                    try { if (typeof patternGrid._attachHandlers === 'function') patternGrid._attachHandlers(); } catch(_){ }
                                                    try { if (patternGrid._recomputePatternText) patternGrid._recomputePatternText(); } catch(_){ }
                                                    try {
                                                        const container = patternGrid.closest('.drum-grid-container');
                                                        if (container) {
                                                            const lanes2 = Array.from(container.querySelectorAll('.pattern-lane'));
                                                            const maxD = lanes2.reduce((mx,ln)=>{
                                                                const qs = String(ln.dataset.quant||'').trim();
                                                                let d = 0;
                                                                const m = qs.match(/^(\d+)\/(\d+)$/);
                                                                if (m) d = parseInt(m[2],10)||0;
                                                                else { const mn = qs.match(/^(\d+)$/); if (mn) d = parseInt(mn[1],10)||0; }
                                                                return Math.max(mx, d||0);
                                                            }, 0);
                                                            if (maxD > 0) container.style.setProperty('--bar-steps', String(maxD));
                                                        }
                                                    } catch(_){ }
                                                }
                                            } catch(_){ }
                                        }

                                        // Apply deferred pattern slot switch (grid + synth) on cycle boundary
                                        if (pending.slot != null) {
                                            const slot = Math.max(1, Math.min(128, parseInt(pending.slot, 10) || 1));
                                            try { if (typeof this._applyArpPatternNumber === 'function') this._applyArpPatternNumber(slot); } catch(_){ }
                                            if (pending.applyArpSynth) {
                                                try {
                                                    const st = this._arpSynthPatterns && this._arpSynthPatterns.get ? this._arpSynthPatterns.get(slot) : null;
                                                    if (st && typeof this._applyArpSynthUIState === 'function') this._applyArpSynthUIState(st);
                                                } catch(_){ }
                                            }
                                            // Clear pending marker on the pattern number input
                                            try {
                                                const patNumEl = document.getElementById('patternPatternNumber');
                                                if (patNumEl) {
                                                    patNumEl.value = String(slot);
                                                    delete patNumEl.dataset.pending;
                                                    delete patNumEl.dataset.pendingValue;
                                                    patNumEl.classList.remove('pending-change');
                                                    patNumEl.title = '';
                                                }
                                            } catch(_){ }
                                            try { this._pendingArpPatternNumber = null; } catch(_){ }
                                            try { this._lastArpPatternNumber = slot; } catch(_){ }
                                            try { delete pending.slot; } catch(_){ }
                                            try { delete pending.applyArpSynth; } catch(_){ }
                                        }

                                        // Only resync timing / manage pattern transport when LEN/QUANT changed
                                        const lenValueEl = document.getElementById('patternLenValue');
                                        if (lenValueEl && didLen) delete lenValueEl.dataset.pending;
                                        if (didLen || didQuant || didNpc) {
                                            try { if (typeof window.refreshPatternTransportTiming === 'function') window.refreshPatternTransportTiming(); } catch(_){ }
                                        }
                                        const pt = window._patternTransport;
                                        if (pt && (didLen || didQuant || didNpc)) {
                                            pt.waitingForDeferred = false;
                                            const omni = window.omnichord;
                                            const transportRunning = !!(omni && omni._arpTransport && omni._arpTransport.running);
                                            const shouldAutoStart = pt.resumeAfterDeferred || transportRunning;
                                            pt.resumeAfterDeferred = false;
                                            if (shouldAutoStart) {
                                                if (typeof pt.start === 'function') pt.start({ alignToTransport: true, preBufferMs: 80 });
                                                else {
                                                    const base = Math.max(1, pt.stepMs || 120);
                                                    const now = (performance && performance.now ? performance.now() : Date.now());
                                                    pt.tickCounter = 0;
                                                    pt.absTickCounter = 0;
                                                    pt.nextAt = now + base;
                                                    pt.running = true;
                                                    if (typeof pt.kick === 'function') pt.kick();
                                                }
                                            }
                                        }
                                        // Keep object if more pending changes remain; else clear
                                        try {
                                            const keys = Object.keys(pending || {});
                                            window._patternPendingChanges = keys.length ? pending : {};
                                        } catch(_){ window._patternPendingChanges = {}; }
                                    } catch(_) { window._patternPendingChanges = {}; }
                                }

                                // Panic mute release: unmute on the next bar boundary without stopping playback.
                                if (flags.panic) {
                                    try { if (typeof this._clearPanicMute === 'function') this._clearPanicMute(); } catch(_){ }
                                }
                                // Clear deferral state
                                this._arpTransport.deferApplyAtAbsTick = null;
                                this._arpTransport.deferFlags = null;
                            }
                        }
                    } catch(_) { }

                    // Auto-stop ARP after post-release HOLD duration if scheduled
                    try {
                        let drumsActive = !!document.querySelector('.drum-step.active');
                        if (!drumsActive) {
                            try {
                                const inst = window._drumInstances || [];
                                for (let i=0;i<inst.length;i++){
                                    const d = inst[i];
                                    if (!d || !d.enabled || !d.state || !Array.isArray(d.state.lanes)) continue;
                                    const lanes = d.state.lanes;
                                    let any = false;
                                    for (let r=0;r<Math.min(9, lanes.length); r++){
                                        const ln = lanes[r];
                                        if (ln && Array.isArray(ln.steps) && ln.steps.some(v=>!!v)) { any = true; break; }
                                    }
                                    if (any) { drumsActive = true; break; }
                                }
                            } catch(_){ }
                        }
                        if (!this._isSequencing && !drumsActive && this._arpTransport.holdStopAtAbsTick != null) {
                            const nowAbs = this._arpTransport.absTickCounter|0;
                            if (nowAbs >= this._arpTransport.holdStopAtAbsTick) {
                                this._dbg && this._dbg('ARP:HOLD:STOP', nowAbs);
                                this._arpTransport.holdStopAtAbsTick = null;
                                try { this._stopArp(); } catch(_) {}
                            }
                        }
                    } catch(_) { }

                    // Determine whether to advance ARP step this tick (follows top quantize)
                    let doArpStep = false;
                    try {
                        const aTick = this._arpTransport.arpTickMs || tickMs;
                        this._arpTransport._arpAccumMs += tickMs;
                        if (this._arpTransport._arpAccumMs + 1e-6 >= aTick) {
                            doArpStep = true;
                            // Support catching up if drift accumulates significantly
                            const over = this._arpTransport._arpAccumMs / aTick | 0;
                            this._arpTransport._arpAccumMs -= aTick * Math.max(1, over);
                        }
                    } catch(_) {}

                    // Global start gate: prevent any audio until the synchronized start tick
                    const _gateTick = (this._arpTransport && this._arpTransport.startGateAbsTick != null) ? (this._arpTransport.startGateAbsTick|0) : null;
                    const _nowAbsTick = this._arpTransport.absTickCounter|0;
                    const _gateActive = (_gateTick != null) && (_nowAbsTick < _gateTick);

                    // Play any active ARP voice only on ARP step boundaries (and only after start gate releases)
                        if (!
                            _gateActive &&
                            (this.arpEnabled || this.chordsEnabled) &&
                            doArpStep && this._arp && this._arp.active && this._arp.seq && this._arp.seq.length){
                            // Suppress per-tick gating while in chord mode; sustain is handled at switch time
                            if (this._arp.mode === 'chord'){
                                this._arpTransport.lastActiveTick = this._arpTransport.tickCounter;
                                this._arpTransport.lastActiveAbsTick = this._arpTransport.absTickCounter;
                                this._arpTransport.inactivityStopScheduled = false;
                                this._arpTransport.stopAtBarIndex = null;
                                // Skip the step-gate block entirely in chord mode
                            } else if (this._arp.mode === 'arp') {
                            // ARP mode: gate per tick (works in PLAY when ARP is enabled OR during sequencing)
                            const seq = this._arp.seq;
                            const stepIdx = this._arpTransport.arpStepCounter|0;
                            const seqIdx = ((stepIdx%seq.length)+seq.length)%seq.length;
                            const el = seq[seqIdx];
                            
                            // *** SUSTAIN handling: if el is '-', skip playing new notes (let previous note continue) ***
                            if (el === '-') {
                                // Sustain step: do nothing, let previous note continue
                                this._arpTransport.lastActiveTick = this._arpTransport.tickCounter;
                                this._arpTransport.lastActiveAbsTick = this._arpTransport.absTickCounter;
                                this._arpTransport.inactivityStopScheduled = false;
                                this._arpTransport.stopAtBarIndex = null;
                                // Continue without playing new note
                            } else if (el == null) {
                                // Rest step: do nothing but still advance
                                this._arpTransport.lastActiveTick = this._arpTransport.tickCounter;
                                this._arpTransport.lastActiveAbsTick = this._arpTransport.absTickCounter;
                                this._arpTransport.inactivityStopScheduled = false;
                                this._arpTransport.stopAtBarIndex = null;
                                // No early return; allow scheduler to continue
                            } else {
                            // In CUSTOM pattern mode, let the pattern grid drive melodic notes and skip ARP note playback.
                            if (this._patternModeCustom) {
                                this._arpTransport.arpStepCounter = (this._arpTransport.arpStepCounter + 1) >>> 0;
                            } else {
                            // Support chords-per-step: el can be a noteObj {node, npc, length} or array of noteObj
                            const playOne = (noteObj)=>{
                                // Handle both legacy format (plain node) and new format ({node, npc, length})
                                let node, noteLength;
                                if (noteObj && noteObj.node) {
                                    // New format with metadata
                                    node = noteObj.node;
                                    noteLength = noteObj.length;
                                } else {
                                    // Legacy format: plain node (fallback)
                                    node = noteObj;
                                    noteLength = 1;
                                }
                                
                                // Check if this note should be played (length > 0) or is a tie (length === 0)
                                if (noteLength === 0) {
                                    // This is a tie, don't retrigger
                                    return;
                                }
                                
                                // Use full tick time for gate calculation, multiplied by note length
                                const gateMs = this._arpTransport.tickMs * noteLength;
                                
                                let f = node ? parseFloat(node.dataset.frequency) : NaN;
                                if (!f || !isFinite(f) || f<=0){
                                    try{
                                        const step = parseInt(node.dataset.noteIndex,10);
                                        const oct = parseInt(node.dataset.octave,10);
                                        const tuning = this.currentTuning || 12;
                                        if (Number.isFinite(step)) f = this.getFrequency(((step%tuning)+tuning)%tuning, Number.isFinite(oct)?oct:4, tuning);
                                    }catch(_){ }
                                }
                                const bfLive = this._arp?.bassLiveFreq;
                                const isBassStep = !!(bfLive && Math.abs((f - bfLive) / bfLive) <= 5e-5);
                                if (f && isFinite(f) && f>0 && !isBassStep){
                                    // Store gate duration for MIDI hook to use
                                    this._lastArpGateMs = gateMs;
                                    this.playFrequency(f, null, 'arp');
                                    setTimeout(()=>{
                                        try {
                                            const bf = this._arp?.bassLiveFreq;
                                            if (!bf || Math.abs((f - bf)/bf) > 5e-5) {
                                                this.stopFrequency(f, null, 'arp');
                                            }
                                        } catch(_) { /* ignore */ }
                                    }, gateMs);
                                }
                            };
                            
                            if (Array.isArray(el)) {
                                // Chord: array of noteObj
                                el.forEach(noteObj => playOne(noteObj));
                            } else {
                                // Single noteObj
                                playOne(el);
                            }
                            // Advance ARP step counter after playing the step
                            this._arpTransport.arpStepCounter = (this._arpTransport.arpStepCounter + 1) >>> 0;
                            }
                            }
                            }

                            // Bass disabled in ARP slide per request
                            // Alternate panning on each step
                            try { if (this.panning && this.panning.mode === 'alternating') this.panning.alternateState = !this.panning.alternateState; } catch(_){ }
                            this._arpTransport.lastActiveTick = this._arpTransport.tickCounter;
                            this._arpTransport.lastActiveAbsTick = this._arpTransport.absTickCounter;
                            // Any new activity cancels a pending inactivity stop
                            this._arpTransport.inactivityStopScheduled = false;
                            this._arpTransport.stopAtBarIndex = null;
                            }
            // Drums: advance playhead and trigger on step boundaries (after start gate releases)
            try { if (!_gateActive) this._drumsOnTransportTick(); } catch(_) { }

            // Patterns: advance all pattern playheads on the same master tick
            try { if (!_gateActive) this._patternsOnTransportTick(); } catch(_) { }

            // Bass fallback disabled per request: do not auto-play bass at bar start when no pattern
            try { /* [BASS] Fallback disabled: no automatic downbeat bass when pattern is empty */ } catch(_) {}
                    // Advance transport tick and schedule next, correcting drift
                    this._arpTransport.tickCounter = (this._arpTransport.tickCounter + 1) % (this._arpTransport.ticksPerBar||64);
                    this._arpTransport.absTickCounter = (this._arpTransport.absTickCounter + 1) >>> 0; // keep as non-negative int
                    // Release start gate once we reach it
                    if (_gateActive && this._arpTransport.absTickCounter >= _gateTick) {
                        this._arpTransport.startGateAbsTick = null;
                    }
                    // Apply swing to the next interval if eligible with pair compensation
                    let nextDelta = this._arpTransport.tickMs;
                    const tpb = this._arpTransport.ticksPerBeat||1;
                    const swingPct = Math.max(0, Math.min(75, this._arpTransport.swingPct||0));
                    if (swingPct > 0 && (tpb % 2 === 0) && !this._arpTransport.isTriplet && (this._arpTransport.tuplet||0)===0) {
                        const withinBeat = this._arpTransport.tickCounter % tpb;
                        const prevWithin = ((this._arpTransport.tickCounter - 1 + tpb) % tpb);
                        const swingShift = (swingPct/100) * this._arpTransport.tickMs;
                        // Delay off-beats
                        if ((withinBeat % 2) === 1) {
                            nextDelta = this._arpTransport.tickMs + swingShift;
                        } else if ((prevWithin % 2) === 1) {
                            // Compensate immediately after an off-beat to keep average tempo stable
                            nextDelta = Math.max(0, this._arpTransport.tickMs - swingShift);
                        } else {
                            nextDelta = this._arpTransport.tickMs;
                        }
                    }
                    // Resync at bar boundaries to eliminate accumulated drift
                    if (this._arpTransport.tickCounter === 0) {
                        this._arpTransport.nextAt = t + nextDelta;
                    } else {
                        this._arpTransport.nextAt += nextDelta;
                    }
                    // If inactivity is scheduled and still no active ARP voice, stop after a full empty bar at bar boundary
                    // Keep transport running if metronome is on
                    const drumsActive2 = !!document.querySelector('.drum-step.active');
                    if (!this._arpTransport.metronomeOn && !drumsActive2 && this._arpTransport.inactivityStopScheduled && (!this._arp || !this._arp.active)){
                        const tpBar = this._arpTransport.ticksPerBar || 16;
                        const curBarIdx = Math.floor(this._arpTransport.absTickCounter / tpBar);
                        if (this._arpTransport.stopAtBarIndex != null && curBarIdx >= this._arpTransport.stopAtBarIndex && this._arpTransport.tickCounter === 0){
                            this._stopArpTransport();
                            return;
                        }
                    }
                    const delay = Math.max(0, this._arpTransport.nextAt - ((performance && performance.now) ? performance.now() : Date.now()));
                    this._arpTransport.timer = setTimeout(runTick, delay);
                };
                const firstDelay = Math.max(0, this._arpTransport.nextAt - now);
                this._arpTransport.timer = setTimeout(runTick, firstDelay);
            }

            _stopArpTransport(){
                if (!this._arpTransport) return;
                this._arpTransport.running = false;
                if (this._arpTransport.timer){ clearTimeout(this._arpTransport.timer); this._arpTransport.timer = null; }
                this._arpTransport.inactivityStopScheduled = false;
                try {
                    this._arpTransport.startGateAbsTick = null;
                    this._arpTransport.countInActive = false;
                    this._arpTransport.countInStartAbsTick = null;
                    this._arpTransport.countInEndAbsTick = null;
                    this._arpTransport.countInLastBeat = 0;
                } catch(_){ }
                try {
                    const el = document.getElementById('countInDisplay');
                    if (el) el.style.display = 'none';
                } catch(_){ }
                // Also stop Pattern transports (legacy + spawned Pattern instances)
                try { window.__xenStopAllPatterns && window.__xenStopAllPatterns(true); } catch(_){ }
            }

            _scheduleTransportStopAfterInactivity(){
                this._ensureArpTransport();
                if (this._arpTransport.inactivityStopScheduled) return;
                this._arpTransport.inactivityStopScheduled = true;
                // Compute the bar index after one full empty bar from now
                const tpBar = this._arpTransport.ticksPerBar || 16;
                const curBarIdx = Math.floor((this._arpTransport.absTickCounter || 0) / tpBar);
                this._arpTransport.stopAtBarIndex = curBarIdx + 1; // stop at the beginning of the next bar after an empty one
            }

            _parseQuantToMs(quant, bpm){
                try {
                    const beatMs = 60000 / Math.max(1, bpm);
                    const raw = String(quant||'').trim();
                    if (!raw) return beatMs; // default 1 beat
                    // Accept simplified integers like "16" (meaning 1/16) and optional triplet suffix, e.g., "8T"
                    const m = raw.match(/^\s*(\d+)\s*([tT])?\s*$/);
                    if (m) {
                        const div = Math.max(1, parseInt(m[1],10));
                        let dur = beatMs * (4 / div);
                        if (m[2]) dur *= 2/3; // triplet
                        return dur;
                    }
                    // Legacy formats like "1/16", "1/8T"
                    const tri = q => /[tT]$/.test(q);
                    const base = raw.replace(/[tT]$/,'');
                    const map = { '1/1':1, '1/2':2, '1/4':4, '1/8':8, '1/16':16, '1/32':32 };
                    const div = map[base] || 8;
                    let dur = beatMs * (4/div);
                    if (tri(raw)) dur *= 2/3; // triplet
                    return dur;
                } catch(_) {
                    const beatMs = 60000 / Math.max(1, bpm);
                    return beatMs * (4/8); // fallback to 1/8
                }
            }

            // Very short click routed to the existing voice chain (no reverb)
            _clickMetronome(freq, durMs){
                try {
                    if (!this.audioContext) return;
                    const ctx = this.audioContext;
                    const osc = ctx.createOscillator();
                    const amp = ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = Math.max(100, Math.min(3000, freq||1000));
                    amp.gain.value = 0.0001;
                    // Short click envelope
                    const now = ctx.currentTime;
                    amp.gain.setValueAtTime(0.0001, now);
                    amp.gain.exponentialRampToValueAtTime(0.5, now + 0.002);
                    amp.gain.exponentialRampToValueAtTime(0.0001, now + Math.max(0.015, (durMs||20)/1000));
                    // Route before reverb, to final mix dry path
                    osc.connect(amp);
                    amp.connect(this._drive ? this._drive.input : this.finalMixer || this.audioContext.destination);
                    osc.start();
                    osc.stop(now + Math.max(0.02, (durMs||20)/1000 + 0.005));
                } catch(_) { }
            }

            _buildArpSequence(rows, pattern, tappedStep){
                // Build an ascending/descending ladder across octaves starting from the root in the base octave
                // so NPC can exceed chord size: e.g., C3,E3,G3,C4,E4,G4 for NPC=6
                const safeAsc = rows.slice().sort((a,b)=> (parseFloat(a?.dataset?.frequency)||0)-(parseFloat(b?.dataset?.frequency)||0));
                const npc = Math.max(1, (this._getGlobalNpc ? this._getGlobalNpc() : (this._arp?.npc|0)) || 1);
                // Custom typed numeric pattern support: "1[23]1[23]1[56]1[x]" etc.
                try {
                    const txtEl = document.getElementById('universalPatternText');
                    const patternGrid = document.getElementById('patternGrid');
                    let txt = '';
                    
                    // Get pattern text from appropriate source
                    const universalPattern = document.getElementById('universalPattern');
                    if (universalPattern && universalPattern.value === 'custom') {
                        // CUSTOM mode: use text field
                        txt = txtEl ? String(txtEl.value||'').trim() : '';
                    } else {
                        // Non-CUSTOM modes: use computed pattern from grid dots
                        txt = (patternGrid && patternGrid._computedPattern) ? String(patternGrid._computedPattern).trim() : '';
                    }
                    
                    if (txt) {
                        // Build a 1-indexed pool from ascending ladder (spanning octaves already)
                        const pool = safeAsc;
                        const tokens = [];
                        const noteLengthMap = []; // Parallel array: noteLengthMap[stepIdx] = {npcNum: length, ...}
                        
                        // Get note length data from grid if available
                        const lengthData = (patternGrid && patternGrid._noteLengthData) || [];
                        
                        let i=0; const N = txt.length;
                        let stepIdx = 0; // Track which step we're parsing
                        
                        while (i<N) {
                            const ch = txt[i];
                            if (ch === ' ') { i++; continue; }
                            
                            // Get length data for this step
                            const stepLengths = lengthData[stepIdx] || {};
                            noteLengthMap[stepIdx] = {};
                            
                            if (ch === 'x' || ch === 'X') { 
                                tokens.push(null); 
                                stepIdx++;
                                i++; 
                                continue; 
                            }
                            if (ch === '-') { 
                                // *** SUSTAIN token: push special marker to indicate "hold previous note" ***
                                tokens.push('-'); 
                                stepIdx++;
                                i++; 
                                continue; 
                            }
                            if (ch === '[') {
                                i++;
                                const group = [];
                                while (i<N && txt[i] !== ']') {
                                    const c = txt[i];
                                    if (/[0-9]/.test(c)) {
                                        let num = c; i++;
                                        while (i<N && /[0-9]/.test(txt[i])) { num += txt[i++]; }
                                        const idx = parseInt(num,10);
                                        if (Number.isFinite(idx) && idx>=1 && idx<=pool.length) {
                                            const node = pool[idx-1];
                                            // Create wrapper object with NPC metadata
                                            const noteObj = {
                                                node: node,
                                                npc: idx,
                                                length: stepLengths[idx] || 1
                                            };
                                            group.push(noteObj);
                                            // Store length for this NPC at this step
                                            noteLengthMap[stepIdx][idx] = stepLengths[idx] || 1;
                                        }
                                        continue;
                                    } else if (c === 'x' || c === 'X') {
                                        // rest within group ignored (no sound)
                                        i++;
                                        continue;
                                    } else if (c === ' ') { i++; continue; }
                                    else { i++; }
                                }
                                if (i<N && txt[i] === ']') i++;
                                tokens.push(group.length? group : null);
                                stepIdx++;
                                continue;
                            }
                            if (/[0-9]/.test(ch)) {
                                let num = ch; i++;
                                while (i<N && /[0-9]/.test(txt[i])) { num += txt[i++]; }
                                const idx = parseInt(num,10);
                                if (Number.isFinite(idx) && idx>=1 && idx<=pool.length) {
                                    const node = pool[idx-1];
                                    // Create wrapper object with NPC metadata
                                    const noteObj = {
                                        node: node,
                                        npc: idx,
                                        length: stepLengths[idx] || 1
                                    };
                                    tokens.push(noteObj);
                                    // Store length for this NPC at this step
                                    noteLengthMap[stepIdx][idx] = stepLengths[idx] || 1;
                                } else {
                                    tokens.push(null);
                                }
                                stepIdx++;
                                continue;
                            }
                            // Unknown char: skip
                            i++;
                        }
                        // For custom typed patterns, play exactly the typed sequence.
                        // Transport modulo handles repetition at QUANT rate independent of bar length.
                        if (tokens.length > 0) {
                            // Store the length map for use during playback
                            if (this._arp) {
                                this._arp.noteLengthMap = noteLengthMap;
                            }
                            return tokens;
                        }
                    }
                } catch(_) {}
                const altEnds = (arr)=>{ const a=arr.slice(); const out=[]; let i=0,j=a.length-1; while(i<=j){ if(i<=j) out.push(a[i++]); if(i<=j) out.push(a[j--]); } return out; };
                const altCenter = (arr)=>{ const a=arr.slice(); const mid=Math.floor((a.length-1)/2); const out=[]; let l=mid, r=mid+1; if(a.length%2===1){ out.push(a[mid]); l=mid-1; r=mid+1; } while(l>=0 || r<a.length){ if(r<a.length) out.push(a[r++]); if(l>=0) out.push(a[l--]); } return out; };

                // Column + octave inventory (3..9)
                const firstEl = safeAsc[0];
                const column = firstEl?.closest ? firstEl.closest('.extension-column') : null;
                if (!column) {
                    // Fallback to simple slicing if we cannot resolve column (still start from lowest/root-like)
                    const asc = safeAsc;
                    const desc = asc.slice().reverse();
                    switch(pattern){
                        case 'up': return asc.slice(0, npc);
                        case 'down': return desc.slice(0, npc);
                        case 'updown': { 
                            const a = asc.slice(0, npc); 
                            if (a.length <= 1) return a;
                            const result = [];
                            // Add ascending sequence
                            result.push(...a);
                            // Add descending sequence (excluding first and last to avoid repeats)
                            if (a.length > 2) {
                                const desc = a.slice(1, -1).reverse();
                                result.push(...desc);
                            }
                            return result; // Proper up-down without repeating endpoints
                        }
                        case 'downup': { 
                            const d = desc.slice(0, npc); 
                            if (d.length <= 1) return d;
                            const result = [];
                            // Add descending sequence
                            result.push(...d);
                            // Add ascending sequence (excluding first and last to avoid repeats)
                            if (d.length > 2) {
                                const asc = d.slice(1, -1).reverse();
                                result.push(...asc);
                            }
                            return result; // Proper down-up without repeating endpoints
                        }
                        case 'alt-ends': return altEnds(asc).slice(0, npc);
                        case 'alt-center': return altCenter(asc).slice(0, npc);
                        case 'random': return asc.sort(()=>Math.random()-0.5).slice(0, npc);
                        default: return asc.slice(0, npc);
                    }
                }

                // Map desired step order from the tapped octave and rotate so the tapped degree is first
                // Unique desired steps (by EDO step) to avoid per-octave duplicates that block cross-octave extension
                let desiredSteps = safeAsc
                    .map(r => parseInt(r.dataset?.edoStep||'NaN',10))
                    .filter(n=>Number.isFinite(n));
                if (desiredSteps.length) {
                    const seen = new Set();
                    desiredSteps = desiredSteps.filter(st => { if (seen.has(st)) return false; seen.add(st); return true; });
                }
                if (desiredSteps.length){
                    const anchor = (Number.isFinite(tappedStep) ? tappedStep : desiredSteps[0]);
                    const idx = desiredSteps.indexOf(anchor);
                    if (idx > 0) desiredSteps = desiredSteps.slice(idx).concat(desiredSteps.slice(0, idx));
                }
                const allStrings = Array.from(column.querySelectorAll('.strings-column .string'));
                const byOct = new Map();
                allStrings.forEach(r=>{
                    const o = parseInt(r.dataset?.octave||'0',10);
                    if (o>=3 && o<=9){ if(!byOct.has(o)) byOct.set(o,[]); byOct.get(o).push(r); }
                });
                // Align each octave's rows to base order
                const alignOct = (o)=>{
                    const grp = (byOct.get(o)||[]).slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0)-(parseFloat(b.dataset.frequency)||0));
                    if (!grp.length) return [];
                    if (!desiredSteps.length) return grp;
                    const gMap = new Map(grp.map(r=> [parseInt(r.dataset.edoStep||'NaN',10), r]));
                    const out = [];
                    desiredSteps.forEach(st=>{ const rr = gMap.get(st); if(rr) out.push(rr); });
                    return out.length? out : grp;
                };
                // Determine base octave
                const baseOct = parseInt(safeAsc[0]?.dataset?.octave||'4',10);
                const ascOcts = []; for(let o=baseOct; o<=9; o++) ascOcts.push(o);
                const descOcts = []; for(let o=baseOct; o>=3; o--) descOcts.push(o);
                const ladderAsc = ascOcts.flatMap(o=> alignOct(o));
                const ladderDesc = descOcts.flatMap(o=> alignOct(o).slice().reverse());

                // Rotate ladders so the tapped degree in the base octave is first
                const baseGroup = alignOct(baseOct);
                const anchorStep = Number.isFinite(tappedStep) ? tappedStep : (baseGroup.length? parseInt(baseGroup[0]?.dataset?.edoStep||'NaN',10) : null);
                const anchorRow = baseGroup.find(r=> Number.isFinite(anchorStep) && parseInt(r.dataset?.edoStep||'NaN',10) === anchorStep) || baseGroup[0];
                const rotateToStart = (arr, el)=>{ const i = arr.indexOf(el); return (i>0) ? (arr.slice(i).concat(arr.slice(0,i))) : arr; };
                if (anchorRow){
                    // For 'up' variants we want ascending starting at anchor; for 'down' starting at anchor descending
                    // We rotate here; the switch(pattern) below will still apply up/down shapes and NPC trimming.
                    for (let k=0; k<1; k++) { /* no-op loop to keep scope clear */ }
                    // Replace ladders with rotated versions without mutating originals unexpectedly
                    var ladderAscRot = rotateToStart(ladderAsc, anchorRow);
                    var ladderDescRot = rotateToStart(ladderDesc, anchorRow);
                } else {
                    var ladderAscRot = ladderAsc;
                    var ladderDescRot = ladderDesc;
                }

                // Walk patterns: repeat directional motifs with boundary bounce (exclude endpoints on reversal)
                const buildWalk = (ladder, motif)=>{
                    // motif is an array of +1/-1 steps, e.g., [1,1,-1] (UUD) or [-1,-1,1] (DDU)
                    const L = ladder.length;
                    if (L === 0) return [];
                    if (L === 1) return ladder.slice(0, Math.min(npc, 1));
                    const out = [];
                    let idx = 0; // start at anchor (rotated start)
                    out.push(ladder[idx]);
                    let m = 0;
                    while (out.length < npc) {
                        let step = motif[m % motif.length];
                        let next = idx + step;
                        // Bounce at boundaries; exclude repeating endpoints on reversal
                        if (next >= L) {
                            // Hit top; reflect
                            next = L - 2; // step to the one below top
                            // Also adjust motif direction by flipping current step
                            step = -1;
                            m = (m + 1) % motif.length; // advance motif to keep rhythm-like feel
                        } else if (next < 0) {
                            // Hit bottom; reflect
                            next = 1; // step to the one above bottom
                            step = 1;
                            m = (m + 1) % motif.length;
                        } else {
                            m = (m + 1) % motif.length;
                        }
                        idx = next;
                        out.push(ladder[idx]);
                    }
                    return out;
                };

                switch(pattern){
                    case 'up': return ladderAscRot.slice(0, npc);
                    case 'down': return ladderDescRot.slice(0, npc);
                    case 'updown': {
                        const a = ladderAscRot.slice(0, npc);
                        if (a.length <= 1) return a;
                        const result = [];
                        // Add ascending sequence
                        result.push(...a);
                        // Add descending sequence (excluding first and last to avoid repeats)
                        if (a.length > 2) {
                            const desc = a.slice(1, -1).reverse();
                            result.push(...desc);
                        }
                        return result; // Proper up-down without repeating endpoints
                    }
                    case 'downup': {
                        const d = ladderDescRot.slice(0, npc);
                        if (d.length <= 1) return d;
                        const result = [];
                        // Add descending sequence
                        result.push(...d);
                        // Add ascending sequence (excluding first and last to avoid repeats)
                        if (d.length > 2) {
                            const asc = d.slice(1, -1).reverse();
                            result.push(...asc);
                        }
                        return result; // Proper down-up without repeating endpoints
                    }
                    case 'walk-up': return buildWalk(ladderAscRot, [1, 1, -1]); // UUD UUD ...
                    case 'walk-down': return buildWalk(ladderDescRot, [-1, -1, 1]); // DDU DDU ...
                    case 'alt-ends': return altEnds(ladderAscRot.length? ladderAscRot : ladderAsc).slice(0, npc);
                    case 'alt-center': return altCenter(ladderAscRot.length? ladderAscRot : ladderAsc).slice(0, npc);
                    case 'random': {
                        const base = ladderAscRot.length? ladderAscRot : ladderAsc;
                        return base.slice().sort(()=>Math.random()-0.5).slice(0, npc);
                    }
                    default: return ladderAscRot.length? ladderAscRot.slice(0, npc) : ladderAsc.slice(0, npc);
                }
            }

    _startArp(columnElement, clientY, preservePosition = false){
        this._dbg && this._dbg('ARP:START', columnElement?.dataset?.chordId || columnElement?.dataset?.originalPosition, 'clientY=', clientY, 'preserve=', preservePosition);
        
        // Preserve current NPC position if requested
        const preservedNPC = preservePosition && this._arp ? this._arp.currentNPC : null;
        const preservedTransportRunning = preservePosition && this._arpTransport ? this._arpTransport.running : false;
        
        this._ensureArpDefaults();
        this._ensureArpTransport();
        
        // Store the current column for same-chord detection
        this._arp.column = columnElement;
        // Suppress per-note panning auto-toggle while ARP owns alternation
        this._suppressPanningAutoToggle = true;
    // Per request: ensure no ARP bass is active while using ARP/slide
    try { if (this._arp?.bassVoice && this._arp?.bassLiveFreq) { this.stopFrequency(this._arp.bassLiveFreq, null, 'bass'); } } catch(_){ this._dbg && this._dbg('ARP:BASS:STOP:ERR'); }
    if (this._arp){ this._arp.bassVoice = null; this._arp.bassLiveFreq = null; this._arp.bassFreq = null; }
    // No bass updates from ARP start
        // Capture UI values
        try {
            const bpmEl = document.getElementById('universalBpm');
            const quantEl = document.getElementById('universalQuant');
            const patEl = document.getElementById('universalPattern');
            const npcEl = document.getElementById('universalNpc');
            const chordHoldEl = document.getElementById('chordHold');
            // Wire arpPattern change listener (universal)
            if (patEl && !patEl._wired){
                patEl._wired = true;
                patEl.addEventListener('change', ()=>{ this._arp.pattern = patEl.value || 'up'; });
            }
            // Wire global NPC change listener
            if (npcEl && !npcEl._wired){
                npcEl._wired = true;
                npcEl.addEventListener('change', ()=>{ this._arp.npc = Math.max(1, Math.min(64, parseInt(npcEl.value)||3)); });
            }
            if (bpmEl) this._arp.bpm = Math.max(20, Math.min(300, parseInt(bpmEl.value)||120)); this._dbg && this._dbg('ARP:UI', 'bpm=', this._arp.bpm);
            if (quantEl) {
                this._arp.quant = quantEl.value || '1/16';
                if (this._arp.quant.startsWith('tuplet:')){
                    const n = parseInt(this._arp.quant.split(':')[1],10);
                    this._arp.tuplet = Number.isFinite(n) && n>0 ? n : 0;
                } else {
                    this._arp.tuplet = 0;
                }
            }
            if (patEl) this._arp.pattern = patEl.value || 'up';
            if (npcEl) this._arp.npc = Math.max(1, Math.min(64, parseInt(npcEl.value)||3)); this._dbg && this._dbg('ARP:UI', 'npc=', this._arp.npc);
            if (chordHoldEl) this._arp.chordsHold = chordHoldEl.value || 'bar:1';
            this._arp.gatePct = 50;
            this._arp.glide = false; // glide removed
            this._arp.glideMs = 0;
        } catch(_){ }

        // Build note list for arpeggio range consistent with PLAY mode (octaves 3â€“9)
        // Respect a previously locked octave (from chord gesture) if present; else use the tapped octave and lock it for the ARP gesture
        let tappedOct = Number.isFinite(this._slideOctaveLock) ? this._slideOctaveLock : this._getTappedOctave(columnElement, clientY);
        if (!Number.isFinite(this._slideOctaveLock) && Number.isFinite(tappedOct)) this._slideOctaveLock = tappedOct;
        const rowsAll = Array.from(columnElement.querySelectorAll('.strings-column .string'));
        // Use C3-C9 octave window for PATTERN (pattern arpeggios use melodic range)
        const within = rowsAll.filter(r => {
            const o = parseInt(r.dataset.octave||'0',10);
            return o>=3 && o<=9; // C3â€“C9 range for pattern arpeggios
        });
    const npc = Math.max(1, (this._getGlobalNpc ? this._getGlobalNpc() : (this._arp.npc|0)));
        const pat = this._arp.pattern || 'up';
        // Determine tapped step within tapped octave for anchoring NPC palette
        let tappedStep = null;
        try {
            const y = clientY;
            // Find the row at this Y within the tapped octave
            const hit = document.elementFromPoint(columnElement.getBoundingClientRect().left + 1, y);
            const row = hit && hit.closest ? hit.closest('.string') : null;
            tappedStep = row ? parseInt(row.dataset?.edoStep||'NaN',10) : null;
        } catch(_) { tappedStep = null; }
        // Base ascending order for mapping (low->high), first npc items
        const asc = within.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0) - (parseFloat(b.dataset.frequency)||0));
        const mapAsc = asc.slice(0, npc);
    let seq = this._buildArpSequence(within, pat, tappedStep);
        this._dbg && this._dbg('ARP:SEQ', 'oct=', tappedOct, 'pat=', pat, 'npc=', npc, 'len=', seq.length);
        // Directional strum shift in ARP: move order by one note based on vertical motion
        try {
            if (typeof clientY === 'number'){
                const lastY = this._arp._lastStartY;
                const dy = (typeof lastY==='number') ? (clientY - lastY) : 0;
                this._arp._lastStartY = clientY;
                if (dy < -6 && seq.length>1){ // upward motion: rotate left
                    const first = seq.shift(); seq.push(first);
                } else if (dy > 6 && seq.length>1){ // downward motion: rotate right
                    const last = seq.pop(); seq.unshift(last);
                }
            }
        } catch(_){ }
    this._arp.seq = seq;
    // Bass disabled in ARP per request
        // Decide when to apply this change based on chord-change quant and bar position
    const tpBeat = this._arpTransport.ticksPerBeat || 1;
    const tpBar = this._arpTransport.ticksPerBar || (tpBeat*4);
    const curTick = this._arpTransport.tickCounter|0;
    const absTick = this._arpTransport.absTickCounter|0;
    // Align chord change to the next tick; if we're in the last beat of the bar, wait for the next bar downbeat
    const inLastBeatOfBar = curTick >= (tpBar - tpBeat);
    const ticksToNextBar = (tpBar - (curTick % tpBar)) % tpBar;
    const targetAbsTick = inLastBeatOfBar ? (absTick + ticksToNextBar) : (absTick + 1);
    const alignToCurrentPhase = false; // preserve transport phase so step index reflects current bar position

        // Prepare morph mapping for GLIDE mode: index-aligned sourceâ†’target sets (follow seq order)
        let targetFreqs = [];
        try {
            const tuning = this.currentTuning || 12;
            // Use the exact sequence order for morph targets so indices match transport step indices
            const seqForMorph = Array.isArray(seq) && seq.length ? seq : mapAsc;
            targetFreqs = seqForMorph.map(r=>{
                const step = parseInt(r.dataset.noteIndex,10);
                const oct = parseInt(r.dataset.octave,10);
                const s = ((step%tuning)+tuning)%tuning; return this.getFrequency(s, Number.isFinite(oct)?oct:4, tuning);
            }).filter(f=> isFinite(f) && f>0);
        } catch(_){ targetFreqs = []; }
        // Source set: previous targets if available; else current targets (no jump)
        let sourceFreqs = [];
        try { sourceFreqs = (this._arp?.morph?.currentTargets && Array.isArray(this._arp.morph.currentTargets) && this._arp.morph.currentTargets.length) ? this._arp.morph.currentTargets.slice(0, targetFreqs.length) : targetFreqs.slice(); } catch(_){ sourceFreqs = targetFreqs.slice(); }

        // Queue pending switch so transport applies exactly on time
    this._arp.pendingSwitch = {
            atAbsTick: targetAbsTick >>> 0,
            alignPhaseToTickCounter: alignToCurrentPhase,
            seq: seq,
            bassFreq: this._arp.bassFreq,
            column: columnElement,
            mapAsc: mapAsc,
            morph: {
                source: sourceFreqs,
                target: targetFreqs
            }
    };
    this._dbg && this._dbg('ARP:PENDING', 'atTick=', this._arp.pendingSwitch.atAbsTick, 'q=', this._arp.quant, 'hold=', this._arp.chordQuant);
        // Ensure transport is running so scheduled switch will occur (only when PLAY is active)
        if (this._isSequencing) {
            this._startArpTransport();
        }
        // Visual highlight now
        try { this.highlightKeyboardForColumn(columnElement); this.currentActiveColumnEl = columnElement; } catch(_){ }
    }

            // Wire UI for metronome toggle and chord-change quantization selector
            // Compute target rows for a chord slide based on nearest-voicing selection
        _getGlobalNpc(){
                try {
                    const n1 = parseInt(document.getElementById('universalNpc')?.value||'');
            const n = Number.isFinite(n1) ? n1 : (this._arp?.npc || 3);
            // Allow up to 64 notes per cycle to match UI and PLAY behavior
            return Math.max(1, Math.min(64, n|0));
                } catch(_) {
            return Math.max(1, Math.min(64, (this._arp?.npc||3)|0));
                }
            }
            _computeChordSlideTargets(targetColumnEl){
                this._dbg && this._dbg('SLIDE/TARGETS:start', targetColumnEl?.dataset?.chordId || targetColumnEl?.dataset?.originalPosition, 'octLock=', this._slideOctaveLock);
                try {
                    if (!targetColumnEl) return [];
                    const desiredDegrees = this._getChordDegreesForColumn(targetColumnEl);
                    // Determine tapped octave window if available; lock to the octave originally tapped for the gesture
                    const lockedOct = Number.isFinite(this._slideOctaveLock) ? this._slideOctaveLock : null;
                    const tappedOct = Number.isFinite(lockedOct) ? lockedOct : (Number.isFinite(this._lastTappedOctave) ? this._lastTappedOctave : (this._chordsModeAnchorOctave ?? 4));
                    const baseOct = Math.max(3, Math.min(9, tappedOct));
                    const npcTarget = this._getGlobalNpc();
                    // Collect candidate strings across octaves [3..9]
                    const allStrings = Array.from(targetColumnEl.querySelectorAll('.strings-column .string'))
                        .filter(s=>{ const o = parseInt(s.dataset.octave||'0',10); return Number.isFinite(o) && o>=3 && o<=9; });
                    // Fast path: build an ascending ladder across octaves aligned by desired degrees
                    const fOf = (el)=>{
                        try{
                            const tuning = this.currentTuning || 12;
                            const step = parseInt(el.dataset.noteIndex,10);
                            const oct = parseInt(el.dataset.octave,10);
                            if (!Number.isFinite(step) || !Number.isFinite(oct)) return NaN;
                            const s = ((step % tuning) + tuning) % tuning;
                            return this.getFrequency(s, oct, tuning);
                        }catch(_){ return NaN; }
                    };
                    const tuning = this.currentTuning || 12;
                    const degsOrdered = Array.from(new Set(desiredDegrees.map(iv=> ((iv%tuning)+tuning)%tuning)))
                        .sort((a,b)=> this.stepToSemitone(a, tuning) - this.stepToSemitone(b, tuning));
                    const byOct = new Map();
                    for (const s of allStrings){
                        const o = parseInt(s.dataset.octave||'0',10);
                        if (!byOct.has(o)) byOct.set(o, []);
                        byOct.get(o).push(s);
                    }
                    const alignOct = (o)=>{
                        const grp = (byOct.get(o)||[]).slice().sort((a,b)=> (fOf(a)||0)-(fOf(b)||0));
                        if (!grp.length) return [];
                        if (!degsOrdered.length) return grp;
                        const gMap = new Map(grp.map(r=> [((parseInt(r.dataset.interval,10)||0)%tuning + tuning)%tuning, r]));
                        const out = [];
                        degsOrdered.forEach(d=>{ const rr = gMap.get(d); if (rr) out.push(rr); });
                        return out.length ? out : grp;
                    };
                    const octsAsc = []; for (let o=baseOct; o<=9; o++) octsAsc.push(o);
                    const ladder = octsAsc.flatMap(o=> alignOct(o));
                    if (ladder.length){
                        const picked = ladder.slice(0, npcTarget);
                        picked.sort((a,b)=> (fOf(a)||0) - (fOf(b)||0));
                        this._dbg && this._dbg('SLIDE/TARGETS:end', 'count=', picked.length);
                        return picked;
                    }
                    // Fallback to single-octave logic below if no ladder could be formed
                    const strings = allStrings.filter(s=> parseInt(s.dataset.octave||'0',10)===baseOct);
                    // Group by degree to preserve chord tones; prefer nearest to previous voicing if known
                    const degSet = new Set(desiredDegrees.map(iv=> ((iv%tuning)+tuning)%tuning));
                    const byDeg = new Map();
                    for (const s of strings){
                        const d = parseInt(s.dataset.interval,10);
                        const key = ((d%tuning)+tuning)%tuning;
                        if (!degSet.has(key)) continue;
                        if (!byDeg.has(key)) byDeg.set(key, []);
                        byDeg.get(key).push(s);
                    }
                    // Sort each degree's candidates low->high to enable stable 1:1 mapping across slides
                    for (const [k, list] of byDeg.entries()){
                        list.sort((a,b)=> (fOf(a)||0) - (fOf(b)||0));
                    }
            // Build a 6-voice target by walking degrees in semitone order
            // Direction bias kept (affects choice order if multiple strings per degree within the same octave)
                    const dy = (typeof this._chordSlideLastDY==='number') ? this._chordSlideLastDY : 0;
                    const verticalBiasUp = dy < -2;   // moving up
                    const verticalBiasDown = dy > 2;  // moving down
                    const degs = Array.from(byDeg.keys()).sort((a,b)=> this.stepToSemitone(a, tuning) - this.stepToSemitone(b, tuning));
                    const picked = [];
            // First pass: prefer specific ordering of candidates per degree depending on bias
                    for (const d of degs){
                        if (picked.length>=npcTarget) break;
                        const list = byDeg.get(d) || [];
                        if (verticalBiasUp){
                            const hiPref = list.find(r=> parseInt(r.dataset.octave,10)===highOct);
                            if (hiPref) { picked.push(hiPref); continue; }
                            const lo = list.find(r=> parseInt(r.dataset.octave,10)===lowOct);
                            if (lo) picked.push(lo);
                        } else {
                            const lo = list.find(r=> parseInt(r.dataset.octave,10)===lowOct);
                            if (lo) picked.push(lo);
                        }
                    }
            // Second pass: fill remaining from the same octave pool
                    for (const d of degs){
                        if (picked.length>=npcTarget) break;
                        const list = byDeg.get(d) || [];
                        if (verticalBiasDown){
                            const lo2 = list.find(r=> parseInt(r.dataset.octave,10)===lowOct);
                            if (lo2 && !picked.includes(lo2)) { picked.push(lo2); continue; }
                const hi = list.find(r=> parseInt(r.dataset.octave,10)===highOct);
                if (hi && !picked.includes(hi)) picked.push(hi);
                        } else {
                            const hi = list.find(r=> parseInt(r.dataset.octave,10)===highOct);
                            if (hi && !picked.includes(hi)) picked.push(hi);
                        }
                    }
            // If still short, fill with nearest within window by frequency order (still within the single octave)
                    if (picked.length < npcTarget){
                        const pool = strings.slice().sort((a,b)=> (fOf(a)||0) - (fOf(b)||0));
                        for (const s of pool){ if (picked.length>=npcTarget) break; if (!picked.includes(s)) picked.push(s); }
                    }
                    // Sort final targets low->high to keep voice indices stable and avoid consolidation
                    picked.sort((a,b)=> (fOf(a)||0) - (fOf(b)||0));
                    this._dbg && this._dbg('SLIDE/TARGETS:end', 'count=', picked.length);
                    return picked;
                } catch(_) { return []; }
            }

            // Full chord (all unique degrees including extensions) inside a single octave.
            // Choir-slide uses this so every chord tone stays present (no collapsing down to one note).
            _buildFullChordOneOctaveRows(columnElement, preferredOctave = null){
                try {
                    if (!columnElement) return [];
                    const rowsAll = Array.from(columnElement.querySelectorAll('.strings-column .string'));
                    if (!rowsAll.length) return [];
                    const tuning = this.currentTuning || 12;

                    // Decide the octave to use: follow current sounding register when possible.
                    let oct = null;
                    if (Number.isFinite(preferredOctave)) {
                        oct = preferredOctave;
                    } else {
                        try {
                            const arr = [];
                            if (this._chordSlideVoices && this._chordSlideVoices.size) {
                                for (const [el] of this._chordSlideVoices.entries()) {
                                    const o = parseInt(el?.dataset?.octave||'NaN',10);
                                    if (Number.isFinite(o)) arr.push(o);
                                }
                            }
                            if (arr.length) {
                                const avg = arr.reduce((a,b)=>a+b,0)/arr.length;
                                oct = Math.round(avg);
                            }
                        } catch(_) {}
                    }
                    if (!Number.isFinite(oct)) oct = 4;
                    // Keep within CHORD lane register (playFrequency clamps CHORD to C3..C5)
                    oct = Math.max(3, Math.min(5, oct|0));

                    // Get chord degrees and effective root step.
                    const degs = (typeof this._getChordDegreesForColumn === 'function') ? (this._getChordDegreesForColumn(columnElement) || []) : [];
                    const uniqDegs = Array.from(new Set([0, ...(Array.isArray(degs)?degs:[])]))
                        .map(d=> ((d%tuning)+tuning)%tuning);
                    let rootStep = null;
                    try {
                        rootStep = (typeof this._getEffectiveColumnRootStep === 'function') ? this._getEffectiveColumnRootStep(columnElement) : null;
                    } catch(_) { rootStep = null; }
                    if (!Number.isFinite(rootStep)) {
                        try {
                            const low = rowsAll.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0)-(parseFloat(b.dataset.frequency)||0))[0];
                            rootStep = parseInt(low?.dataset?.noteIndex||'0',10);
                        } catch(_) { rootStep = 0; }
                    }
                    rootStep = ((rootStep%tuning)+tuning)%tuning;

                    const absSteps = Array.from(new Set(uniqDegs.map(d=> ((rootStep + d)%tuning + tuning)%tuning)));
                    absSteps.sort((a,b)=> this.stepToSemitone(a,tuning) - this.stepToSemitone(b,tuning));

                    const picked = [];
                    for (const step of absSteps){
                        const candidates = rowsAll.filter(r=> parseInt(r.dataset.noteIndex||'NaN',10) === step);
                        if (!candidates.length) continue;
                        let best = candidates.find(r=> parseInt(r.dataset.octave||'NaN',10) === oct) || null;
                        if (!best) {
                            best = candidates.slice().sort((a,b)=>{
                                const oa = parseInt(a.dataset.octave||'0',10);
                                const ob = parseInt(b.dataset.octave||'0',10);
                                return Math.abs(oa-oct) - Math.abs(ob-oct);
                            })[0] || null;
                        }
                        if (best && !picked.includes(best)) picked.push(best);
                    }
                    picked.sort((a,b)=> (parseFloat(a.dataset.frequency)||0) - (parseFloat(b.dataset.frequency)||0));
                    return picked;
                } catch(_) {
                    return [];
                }
            }

            // Retune currently active chord voices towards target rows.
            // Choir-slide mode wants per-voice nearest-neighbor mapping (targets may repeat), with timed pitch glides.
            _retuneActiveChordVoicesToTargets(targetRows, velocity=0, glideSec=0){
                this._dbg && this._dbg('SLIDE/RETUNE', 'voices=', this._chordSlideVoices?.size||0, 'targets=', targetRows?.length||0);
                if (!Array.isArray(targetRows) || targetRows.length===0) return;
                const ctxNow = this.audioContext?.currentTime || 0;
                const tuner = this.currentTuning || 12;
                // Gather active voices from the CHORD oscillator pool.
                // IMPORTANT: do not rely solely on _chordSlideVoices (it can drift across loop boundaries),
                // otherwise "extra" voices may go untracked and persist.
                const activePairs = [];
                const metaByEl = new Map();
                try {
                    if (this._chordSlideVoices && this._chordSlideVoices.size) {
                        for (const [el, meta] of this._chordSlideVoices.entries()) metaByEl.set(el, meta);
                    }
                } catch(_) {}

                const chOsc = (this.instruments && this.instruments.chord && this.instruments.chord.osc)
                    ? this.instruments.chord.osc
                    : (this.oscillators ? this.oscillators.osc1 : { octave: 0, detune: 0, coarse: 0 });
                const totalDetuneCents = (chOsc.detune || 0) + ((chOsc.coarse || 0) * (1200 / tuner));
                const chordMultiplier = Math.pow(2, (chOsc.octave || 0) + (totalDetuneCents / 1200));

                const pool = (this.activeChordOscillators && this.activeChordOscillators.size)
                    ? this.activeChordOscillators
                    : (this.activeOscillators || null);
                if (!pool || pool.size === 0) return;

                for (const [k, v] of pool.entries()) {
                    if (!v) continue;
                    const oscHz = (v.osc1 && v.osc1.frequency) ? Number(v.osc1.frequency.value) : NaN;
                    if (!isFinite(oscHz) || oscHz <= 0) continue;
                    const baseHz = oscHz / Math.max(1e-9, chordMultiplier);
                    if (!isFinite(baseHz) || baseHz <= 0) continue;
                    const el = v.element || null;
                    const meta = el ? (metaByEl.get(el) || null) : null;
                    activePairs.push({ stringEl: el, meta, voice: v, poolKey: k, curFreq: baseHz, curLog: Math.log2(baseHz) });
                }

                if (!activePairs.length) return;
                try {
                    if (window.DEBUG_CHOIR_SLIDE) {
                        console.log('[CHOIR] retune:activePairs', {
                            activePairs: activePairs.length,
                            trackedSlideVoices: this._chordSlideVoices ? this._chordSlideVoices.size : 0,
                            activeChordVoices: this.activeChordOscillators ? this.activeChordOscillators.size : 0,
                            glideSec: Math.max(0, Number(glideSec) || 0)
                        });
                    }
                } catch(_) {}
                // Sort sources and targets by frequency
                const sources = activePairs.slice().sort((a,b)=> a.curFreq - b.curFreq);
                const targets = targetRows.map(r=>{
                        try{
                            const tuning = this.currentTuning || 12;
                            const step = parseInt(r.dataset.noteIndex,10);
                            const oct = parseInt(r.dataset.octave,10);
                            if (!Number.isFinite(step) || !Number.isFinite(oct)) return { row:r, f: NaN };
                            const s = ((step % tuning)+tuning)%tuning;
                            const f = this.getFrequency(s, oct, tuning);
                            return { row:r, f };
                        }catch(_){ return { row:r, f: NaN }; }
                    })
                    .filter(t=> isFinite(t.f) && t.f>0)
                    .sort((a,b)=> a.f - b.f);
                if (!targets.length) return;
                const glide = Math.max(0, Number(glideSec) || 0);

                // Choir-slide should preserve *all* chord tones.
                // Use a distinct 1:1 mapping in frequency order (stable voicing, no collapsing).
                const mappings = [];
                const n = Math.min(sources.length, targets.length);
                for (let i=0; i<n; i++) mappings.push({ src: sources[i], trg: targets[i] });

                // If the chord gained tones, spawn new voices by forking from the nearest existing pitch.
                if (targets.length > sources.length) {
                    const pool = this.activeChordOscillators;
                    for (let ti = sources.length; ti < targets.length; ti++) {
                        const trg = targets[ti];
                        // choose nearest existing voice pitch
                        let nearest = sources[0];
                        let bestD = nearest ? Math.abs(nearest.curFreq - trg.f) : Infinity;
                        for (let si=1; si<sources.length; si++) {
                            const d = Math.abs(sources[si].curFreq - trg.f);
                            if (d < bestD) { bestD = d; nearest = sources[si]; }
                        }
                        const fromHz = nearest ? nearest.curFreq : trg.f;

                        // use a slightly detuned key to avoid stomping an existing pool key
                        let keyHz = fromHz;
                        try {
                            const bump = Math.pow(2, 3/1200); // ~3 cents
                            let tries = 0;
                            while (pool && pool.has(keyHz) && tries < 12) { keyHz *= bump; tries++; }
                        } catch(_) {}

                        try {
                            this.playFrequency(keyHz, trg.row, 'chord');
                            try {
                                if (this._chordSlideVoices) {
                                    this._chordSlideVoices.set(trg.row, { startFreq: keyHz, startLog2: Math.log2(Math.max(1e-6, keyHz)), groupId: (this._chordSlideGroupId||0) });
                                }
                            } catch(_) {}
                            // glide the newly spawned voice to its target
                            try {
                                const v = pool && pool.get(keyHz);
                                if (v) {
                                    const chOsc = (this.instruments && this.instruments.chord && this.instruments.chord.osc)
                                        ? this.instruments.chord.osc
                                        : (this.oscillators ? this.oscillators.osc1 : { octave: 0, detune: 0, coarse: 0 });
                                    const totalDetuneCents = (chOsc.detune || 0) + ((chOsc.coarse || 0) * (1200 / tuner));
                                    const fCh = trg.f * Math.pow(2, (chOsc.octave || 0) + (totalDetuneCents / 1200));
                                    const t0 = this.audioContext?.currentTime || 0;
                                    if (v.osc1?.frequency?.cancelScheduledValues) {
                                        const p = v.osc1.frequency;
                                        p.cancelScheduledValues(t0);
                                        p.setValueAtTime(Math.max(1e-6, Number(p.value)||fCh), t0);
                                        if (glide > 0) p.exponentialRampToValueAtTime(Math.max(1e-6, fCh), t0 + glide);
                                        else p.setValueAtTime(Math.max(1e-6, fCh), t0);
                                    }
                                    if (v.osc2?.frequency?.cancelScheduledValues) {
                                        const p = v.osc2.frequency;
                                        p.cancelScheduledValues(t0);
                                        p.setValueAtTime(Math.max(1e-6, Number(p.value)||fCh), t0);
                                        if (glide > 0) p.exponentialRampToValueAtTime(Math.max(1e-6, fCh), t0 + glide);
                                        else p.setValueAtTime(Math.max(1e-6, fCh), t0);
                                    }
                                }
                            } catch(_) {}
                        } catch(_) {}
                    }
                }

                // If the chord lost tones, stop extra voices after the glide window.
                if (sources.length > targets.length) {
                    const extras = sources.slice(targets.length);
                    for (const s of extras) {
                        const key = s.poolKey;
                        if (!Number.isFinite(key)) continue;
                        try {
                            const ms = Math.max(0, glide * 1000);
                            setTimeout(()=>{ try { this.stopFrequency(key, null, 'chord'); } catch(_){} }, ms + 10);
                        } catch(_) {}
                    }
                }

                for (const {src, trg} of mappings){
                    const v = src.voice;
                    const chOsc = (this.instruments && this.instruments.chord && this.instruments.chord.osc)
                        ? this.instruments.chord.osc
                        : (this.oscillators ? this.oscillators.osc1 : { octave: 0, detune: 0, coarse: 0 });
                    const totalDetuneCents = (chOsc.detune || 0) + ((chOsc.coarse || 0) * (1200 / tuner));
                    const fCh = trg.f * Math.pow(2, (chOsc.octave || 0) + (totalDetuneCents / 1200));
                    try {
                        try {
                            if (window.DEBUG_CHOIR_SLIDE) {
                                const curHz = v?.osc1?.frequency ? Number(v.osc1.frequency.value) : null;
                                console.log('[CHOIR] retune:voice', { fromHz: curHz, toHz: fCh, glideSec: glide });
                            }
                        } catch(_) {}
                        if (v.osc1?.frequency?.cancelScheduledValues){
                            const p = v.osc1.frequency;
                            p.cancelScheduledValues(ctxNow);
                            const cur = Math.max(1e-6, Number(p.value) || fCh);
                            p.setValueAtTime(cur, ctxNow);
                            if (glide > 0) p.exponentialRampToValueAtTime(Math.max(1e-6, fCh), ctxNow + glide);
                            else p.setValueAtTime(Math.max(1e-6, fCh), ctxNow);
                        }
                        if (v.osc2?.frequency?.cancelScheduledValues){
                            const p = v.osc2.frequency;
                            p.cancelScheduledValues(ctxNow);
                            const cur = Math.max(1e-6, Number(p.value) || fCh);
                            p.setValueAtTime(cur, ctxNow);
                            if (glide > 0) p.exponentialRampToValueAtTime(Math.max(1e-6, fCh), ctxNow + glide);
                            else p.setValueAtTime(Math.max(1e-6, fCh), ctxNow);
                        }
                        // Keep voiceâ†’row association current so later retune passes can correctly stop extras.
                        try { v.element = trg.row; } catch(_) {}
                    } catch(_){ this._dbg && this._dbg('SLIDE/RETUNE:ERR'); }
                }

                // Rebuild slide voice tracking to match the currently mapped target rows.
                // This prevents stale entries (or missing entries) from causing "hanging" notes across loops.
                try {
                    const nextMap = new Map();
                    for (const {src, trg} of mappings) {
                        const meta = src.meta || { startFreq: src.curFreq, startLog2: src.curLog, groupId: (this._chordSlideGroupId||0) };
                        nextMap.set(trg.row, meta);
                    }
                    this._chordSlideVoices = nextMap;
                } catch(_) {}
            }

            // Enhanced touch responsiveness system to prevent missed taps and improve sensitivity
            _enhanceTouchResponsiveness(touchEvent) {
                // Pre-mark touch targets to ensure they register properly
                Array.from(touchEvent.changedTouches || touchEvent.touches || []).forEach(touch => {
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (target) {
                        // Mark visual feedback immediately for responsive UI
                        target.classList.add('touch-active');
                        setTimeout(() => target.classList.remove('touch-active'), 150);
                        
                        // Pre-cache element relationships to avoid lookup delays during trigger
                        const stringEl = target.closest('[data-frequency]');
                        const columnEl = target.closest('.extension-column');
                        
                        if (stringEl && columnEl) {
                            // Store cached references for faster access during handleStringTrigger
                            stringEl._cachedColumn = columnEl;
                            stringEl._lastCacheTime = performance.now();
                        }
                    }
                });
                
                // Reset any existing throttling states for immediate responsiveness
                this._resetTouchThrottling();
            }
            
            // Reset touch throttling to allow immediate responses
            _resetTouchThrottling() {
                const now = performance.now();
                // Don't reset if we just did this very recently (prevents spam)
                if (this._lastThrottleReset && (now - this._lastThrottleReset) < 10) return;
                this._lastThrottleReset = now;
                
                // Clear throttling for more responsive subsequent touches
                document.querySelectorAll('[data-frequency]').forEach(stringEl => {
                    if (stringEl.lastTriggerTime && (now - stringEl.lastTriggerTime) > 15) {
                        // Allow immediate retrigger for strings that haven't been hit recently
                        stringEl.lastTriggerTime = Math.max(0, stringEl.lastTriggerTime - 15);
                    }
                });
            }

            // Throttled continuous update while sliding: retune active voices immediately
            _updateChordSlideContinuously(columnEl){
                this._dbg && this._dbg('SLIDE/CONT', columnEl?.dataset?.chordId || columnEl?.dataset?.originalPosition);
                const now = performance.now();
                const minInterval = 30; // ~33Hz max update
                if (this._lastChordSlideImmediateAt && (now - this._lastChordSlideImmediateAt) < minInterval) return;
                this._lastChordSlideImmediateAt = now;
                try {
                    const targets = this._computeChordSlideTargets(columnEl);
                    // Use immediate change (no glide)
                    this._retuneActiveChordVoicesToTargets(targets, 0);
                } catch(_){ }
                // Update held bass immediately
                try { this._updateHeldBassForColumn(columnEl); } catch(_){ this._dbg && this._dbg('BASS/HELD:update:ERR'); }
                try { this._markChordSlideActivity(); } catch(_){ }
            }
            // Mark CHORD slide activity and (re)schedule idle-stop
            _markChordSlideActivity(){
                this._lastChordSlideTime = performance.now();
                if (!this._chordSlideActive) return;
                try { clearTimeout(this._chordSlideIdleTimer); } catch(_) {}
                // Idle stop after base timeout (no glide timing needed)
                const baseIdle = Math.max(0, Number(this._chordSlideIdleMs) || 2000);
                const ms = Math.max(250, baseIdle);
                this._chordSlideIdleTimer = setTimeout(()=>{
                    try{
                        if (this.chordsEnabled && this._chordSlideActive) {
                            this.stopAllActiveNotes();
                            // Also clear any tracked bass voice so it can be restarted cleanly next time
                            this._chordBassVoice = null; this._lastBassFreq = null;
                            this._heldBassVoice = null; this._heldBassLiveFreq = null; this._heldBassVoiceKey = null;
                            this._sustainActive = false; this._chordsGestureActive = false; this._slideOctaveLock = null;
                        }
                    }catch(_){ }
                }, ms);
            }
            
            // Update PLAY/STOP button states based on SLIDE mode
            _updatePlayStopButtonStates() {
                try {
                    const playBtn = document.getElementById('playSeqBtn');
                    const stopBtn = document.getElementById('stopSeqBtn');
                    if (playBtn) {
                        playBtn.disabled = this._chordSlideEnabled;
                        playBtn.style.opacity = this._chordSlideEnabled ? '0.4' : '1';
                        playBtn.style.cursor = this._chordSlideEnabled ? 'not-allowed' : 'pointer';
                        playBtn.title = this._chordSlideEnabled ? 'PLAY disabled in SLIDE mode - use touch/click gestures' : 'Play one bar per chord (order)';
                    }
                    if (stopBtn) {
                        stopBtn.disabled = this._chordSlideEnabled;
                        stopBtn.style.opacity = this._chordSlideEnabled ? '0.4' : '1';
                        stopBtn.style.cursor = this._chordSlideEnabled ? 'not-allowed' : 'pointer';
                        stopBtn.title = this._chordSlideEnabled ? 'STOP disabled in SLIDE mode' : 'Stop sequencing immediately';
                    }
                } catch(_) {}
            }
            
            // ================== QUANTIZED CHORD CHANGES ==================
            
            // Check if chord changes should be quantized to the beat
            _shouldQuantizeChordChange() {
                // Enhanced touch sensitivity: prefer immediate response in touch mode
                // Check if we're in an active touch gesture - if so, be more permissive with immediate triggers
                const isTouchGesture = this.activeTouches && this.activeTouches.size > 0;
                
                // FORCE quantization to FULL BEATS (quarter notes), not subdivisions
                this._ensureArpTransport();
                this._refreshArpTransportTiming();
                const now = (performance && performance.now) ? performance.now() : Date.now();
                
                // Use beatMs instead of tickMs to quantize to full beats
                const beatMs = this._arpTransport?.beatMs || (60000 / (this._arpTransport?.bpm || 120));
                
                // Calculate time to next beat boundary
                let timeToNextBeat;
                if (this._arpTransport && this._arpTransport.running && Number.isFinite(this._arpTransport.nextAt)) {
                    // Find the next beat boundary from the current transport position
                    const currentTick = Math.floor((now - this._arpTransport.startAt) / (this._arpTransport.tickMs || 100));
                    const ticksPerBeat = this._arpTransport.ticksPerBeat || 4;
                    const nextBeatTick = Math.ceil((currentTick + 1) / ticksPerBeat) * ticksPerBeat;
                    const nextBeatTime = this._arpTransport.startAt + (nextBeatTick * this._arpTransport.tickMs);
                    timeToNextBeat = Math.max(0, nextBeatTime - now);
                } else {
                    // If not running, use mathematical beat alignment
                    const rem = now % beatMs;
                    timeToNextBeat = rem ? (beatMs - rem) : 0;
                }
                
                // Enhanced quantization window for touch responsiveness
                // Touch gestures get a larger immediate window (up to 25% of beat time vs 10%)
                const baseWindow = beatMs * 0.10;
                const touchWindow = isTouchGesture ? beatMs * 0.25 : baseWindow;
                const quantizationWindow = Math.min(120, Math.max(20, touchWindow));
                
                if (timeToNextBeat <= quantizationWindow) {
                    return { shouldQuantize: false, nextBeatMs: 0 };
                }
                return { shouldQuantize: true, nextBeatMs: timeToNextBeat };
            }

            // Schedule an ARP start to happen on the next quantized beat
            _scheduleQuantizedArpStart(columnElement, clientY, delayMs) {
                // Clear any pending quantized ARP change timer
                if (this._pendingQuantizedArpStart) {
                    try { clearTimeout(this._pendingQuantizedArpStart.timer); } catch(_){}
                    this._pendingQuantizedArpStart = null;
                }

                if (!columnElement || !Number.isFinite(delayMs) || delayMs <= 0) {
                    this._startArp(columnElement, clientY);
                    return;
                }

                console.log('[QUANTIZE] Scheduling ARP start in', Math.round(delayMs), 'ms on next beat');

                // Schedule the ARP start
                this._pendingQuantizedArpStart = {
                    columnElement,
                    clientY,
                    timer: setTimeout(() => {
                        try {
                            this._pendingQuantizedArpStart = null;
                            this._startArp(columnElement, clientY);
                            console.log('[QUANTIZE] Executed ARP start');
                        } catch(_) {}
                    }, delayMs)
                };
            }

            // Schedule a bass change to happen on the next quantized beat  
            _scheduleQuantizedBassChange(columnElement, delayMs) {
                // Clear any pending quantized bass change timer
                if (this._pendingQuantizedBassChange) {
                    try { clearTimeout(this._pendingQuantizedBassChange.timer); } catch(_){}
                    this._pendingQuantizedBassChange = null;
                }

                if (!columnElement || !Number.isFinite(delayMs) || delayMs <= 0) {
                    this._updateHeldBassForColumn(columnElement);
                    return;
                }

                console.log('[QUANTIZE] Scheduling BASS change in', Math.round(delayMs), 'ms on next beat');

                // Schedule the bass change
                this._pendingQuantizedBassChange = {
                    columnElement,
                    timer: setTimeout(() => {
                        try {
                            this._pendingQuantizedBassChange = null;
                            this._updateHeldBassForColumn(columnElement);
                            console.log('[QUANTIZE] Executed BASS change');
                        } catch(_) {}
                    }, delayMs)
                };
            }
            
            // Quantized wrapper for bass updates - checks if should quantize to beat
            _updateHeldBassForColumnQuantized(columnElement) {
                try {
                    const quantizedChange = this._shouldQuantizeChordChange();
                    if (quantizedChange.shouldQuantize) {
                        this._scheduleQuantizedBassChange(columnElement, quantizedChange.nextBeatMs);
                    } else {
                        this._updateHeldBassForColumn(columnElement);
                    }
                } catch(_) {
                    this._updateHeldBassForColumn(columnElement);
                }
            }
            
            // Schedule a chord change to happen on the next quantized beat
            _scheduleQuantizedChordChange(columnElement, clientY, _delayMs) {
                // Clear any pending quantized change timer (we switch to transport-aligned scheduling)
                if (this._pendingQuantizedChordChange) {
                    try { clearTimeout(this._pendingQuantizedChordChange.timer); } catch(_){}
                    this._pendingQuantizedChordChange = null;
                }

                if (!columnElement) return;

                // Stop current chord notes immediately to prepare for the change (bass is handled separately)
                // Choir-slide (CHORDS + PLAY): do NOT stop; keep voices alive so they can portamento to the next chord.
                const choirSlide = !!(this.chordsEnabled && this._arpTransport && this._arpTransport.running);
                if (!choirSlide) {
                    try {
                        if (this._chordSlideVoices && this._chordSlideVoices.size) {
                            const toStop = new Set();
                            this._chordSlideVoices.forEach(v => { if (v && Number.isFinite(v.startFreq)) toStop.add(v.startFreq); });
                            toStop.forEach(f => { try { this.stopFrequency(f, null, 'chord'); } catch(_){} });
                            this._chordSlideVoices.clear();
                        }
                        // Also proactively stop any lingering CHORD-lane voices to avoid overlap at the switch
                        try {
                            if (this.activeChordOscillators && this.activeChordOscillators.size) {
                                const keys = Array.from(this.activeChordOscillators.keys());
                                keys.forEach(k => { try { this.stopFrequency(k, null, 'chord'); } catch(_){} });
                            }
                        } catch(_) {}
                    } catch(_){ }
                }

                // Cancel any chord hold timer since we're switching chords
                if (this._chordHoldTimer) { try { clearTimeout(this._chordHoldTimer); } catch(_){} this._chordHoldTimer = null; }

                // Build ARP sequence and chord rows for the target column at the next transport beat
                try {
                    this._ensureArpTransport();
                    this._refreshArpTransportTiming();
                    const absTick = this._arpTransport.absTickCounter|0;
                    // Schedule to the very next transport tick (QUANT subdivision)
                    const targetAbsTick = (absTick + 1) >>> 0;

                    // Determine NPC and pattern
                    const npc = this._getGlobalNpc ? this._getGlobalNpc() : Math.max(1, Math.min(64, (this._arp?.npc||3)|0));
                    const pattern = (this._arp?.pattern) || 'up';

                    // Compute tapped step for anchoring from pointer Y if available
                    let tappedStep = null;
                    try {
                        const hit = document.elementFromPoint(columnElement.getBoundingClientRect().left + 1, clientY);
                        const row = hit && hit.closest ? hit.closest('.string') : null;
                        tappedStep = row ? parseInt(row.dataset?.edoStep||'NaN',10) : null;
                    } catch(_) { tappedStep = null; }

                    const rowsAll = Array.from(columnElement.querySelectorAll('.strings-column .string'));
                    const ascAll = rowsAll.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0) - (parseFloat(b.dataset.frequency)||0));
                    const ascHigh = ascAll.filter(r => (parseInt(r.dataset.octave||'0',10) >= 5));
                    const within = ascHigh.length ? ascHigh : ascAll; // prefer high register
                    const mapAsc = within.slice(0, npc);
                    const seq = this._buildArpSequence(within, pattern, tappedStep).slice(0, npc);

                    // Prepare morph mapping targets for smooth GLIDE transitions if enabled
                    let targetFreqs = [];
                    try {
                        const tuning = this.currentTuning || 12;
                        const seqForMorph = Array.isArray(seq) && seq.length ? seq : mapAsc;
                        targetFreqs = seqForMorph.map(r=>{
                            const step = parseInt(r.dataset.noteIndex,10);
                            const oct = parseInt(r.dataset.octave,10);
                            const s = ((step%tuning)+tuning)%tuning; return this.getFrequency(s, Number.isFinite(oct)?oct:4, tuning);
                        }).filter(f=> isFinite(f) && f>0);
                    } catch(_) { targetFreqs = []; }
                    let sourceFreqs = [];
                    try { sourceFreqs = (this._arp?.morph?.currentTargets && Array.isArray(this._arp.morph.currentTargets) && this._arp.morph.currentTargets.length) ? this._arp.morph.currentTargets.slice(0, targetFreqs.length) : targetFreqs.slice(); } catch(_){ sourceFreqs = targetFreqs.slice(); }

                    // Determine ARP/CHORD toggle state
                    const arpOn = !!this.arpEnabled;
                    const chordOn = !!this.chordsEnabled;
                    // UI NPC (per-lane)
                    const npcUI = npc;
                    let finalSeq = seq;
                    let finalMapAsc = mapAsc;
                    let chordRows = [];
                    let mode = 'arp';
                    let finalNpc = npcUI;

                    // Build bottom/top split when both are enabled
                    if (arpOn && chordOn) {
                        // Bottom NPC for chords
                        const chordCount = Math.max(1, Math.min(npcUI, ascAll.length));
                        chordRows = ascAll.slice(0, chordCount);
                        // Top NPC for arp with high-register preference
                        const arpCount = chordCount;
                        const arpCandidates = (ascHigh.length >= arpCount) ? ascHigh : ascAll;
                        const arpPool = arpCandidates.slice(-arpCount);
                        finalMapAsc = arpPool.slice();
                        finalSeq = this._buildArpSequence(arpPool, pattern, tappedStep).slice(0, arpCount);
                        finalNpc = arpCount;
                        mode = 'arp'; // run arp ticks while sustaining chord layer
                    } else if (chordOn && !arpOn) {
                        // CHORD only: build NPC high chord from the tapped note within C3..C5
                        const tapInfo = this._findTapRowInColumn(columnElement, clientY);
                        chordRows = this._buildNpcHighChordFromTap(columnElement, tapInfo, npcUI);
                        finalSeq = []; // no arp
                        finalMapAsc = [];
                        finalNpc = chordRows.length || npcUI;
                        mode = 'chord';
                    } else {
                        // ARP only: prefer high register as before, no chord layer
                        const arpCandidates = ascHigh.length ? ascHigh : ascAll;
                        const arpPool = arpCandidates.slice(0, npcUI);
                        finalMapAsc = arpPool.slice();
                        finalSeq = this._buildArpSequence(arpPool, pattern, tappedStep).slice(0, npcUI);
                        chordRows = [];
                        finalNpc = npcUI;
                        mode = 'arp';
                    }

                    // Queue a single pendingSwitch according to mode/toggles
                    this._arp.pendingSwitch = {
                        atAbsTick: targetAbsTick,
                        alignPhaseToTickCounter: true,
                        seq: finalSeq,
                        bassFreq: this._arp?.bassFreq,
                        column: columnElement,
                        mapAsc: finalMapAsc,
                        mode,
                        npc: finalNpc,
                        enableChord: chordOn,
                        chordRows,
                        morph: (finalSeq && finalSeq.length) ? { source: sourceFreqs, target: targetFreqs } : null
                    };
                    // Ensure transport is running to service the pending switch (only when PLAY is active)
                    if (this._isSequencing) {
                        this._startArpTransport();
                    }
                    // Visual indicator
                    try {
                        console.log('âŒ¨ï¸âŒ¨ï¸âŒ¨ï¸ About to call highlightKeyboardForColumn for:', columnElement?.dataset?.chordId);
                        this.highlightKeyboardForColumn(columnElement);
                        this.currentActiveColumnEl = columnElement;
                        console.log('âŒ¨ï¸âœ… highlightKeyboardForColumn completed successfully');
                    } catch(err){
                        console.error('âŒ¨ï¸âŒ highlightKeyboardForColumn FAILED:', err);
                    }
                    this._dbg && this._dbg('QUANT:PENDING', 'atAbsTick=', targetAbsTick, 'npc=', npc, 'pat=', pattern);
                } catch(e) {
                    console.error('Quantized scheduling failed, falling back to immediate:', e);
                    try { this._executeChordChange(columnElement, clientY); } catch(_){}
                }
            }
            
            // Execute the actual chord change: route through transport pendingSwitch for parity with PLAY
            _executeChordChange(columnElement, clientY) {
                console.log('ðŸŽ¸ðŸŽ¸ðŸŽ¸ _executeChordChange CALLED - columnElement:', columnElement?.dataset?.chordId);
                try {
                    this._scheduleQuantizedChordChange(columnElement, clientY, 0);
                } catch (e) {
                    // Fallback to immediate play if scheduling fails
                    try { this.playChordChordsMode(columnElement, clientY); } catch(_) {}
                }
            }
            
            // Schedule quantized chord change for ARP mode (preserves transport position and NPC)
            _scheduleQuantizedArpChordChange(columnElement, clientY) {
                if (!columnElement) return;
                
                // Check if we should quantize based on current transport state
                const quantizedChange = this._shouldQuantizeChordChange();
                
                // Calculate current NPC position from transport state
                let currentNPC = 0;
                if (this._arpTransport && this._arp && this._arp.seq) {
                    const idx = (this._arpTransport.tickCounter - (this._arp.startTickAlign || 0));
                    currentNPC = ((idx % this._arp.seq.length) + this._arp.seq.length) % this._arp.seq.length;
                }
                
                if (quantizedChange.shouldQuantize) {
                    // Clear any existing pending ARP chord change
                    if (this._pendingArpChordChange) {
                        try { clearTimeout(this._pendingArpChordChange.timer); } catch(_){}
                        this._pendingArpChordChange = null;
                    }
                    
                    // Schedule the chord change for the next quantized beat
                    this._pendingArpChordChange = {
                        columnElement: columnElement,
                        clientY: clientY,
                        preserveNPC: currentNPC,
                        timer: setTimeout(() => {
                            try {
                                // Switch to the new chord preserving ARP timing
                                this._startArp(columnElement, clientY, true); // true = preserve position
                                
                                // Adjust startTickAlign to maintain the same NPC position
                                if (this._arpTransport && this._arp && this._arp.seq && this._pendingArpChordChange) {
                                    const targetIdx = this._pendingArpChordChange.preserveNPC || 0;
                                    this._arp.startTickAlign = this._arpTransport.tickCounter - targetIdx;
                                }
                            } catch(e) {
                                // Fallback: just start the ARP normally
                                this._startArp(columnElement, clientY);
                            }
                            this._pendingArpChordChange = null;
                        }, quantizedChange.nextBeatMs)
                    };
                } else {
                    // Within quantization window - execute immediately but preserve position
                    this._startArp(columnElement, clientY, true); // true = preserve position
                    
                    // Adjust startTickAlign to maintain the same NPC position
                    if (this._arpTransport && this._arp && this._arp.seq) {
                        this._arp.startTickAlign = this._arpTransport.tickCounter - currentNPC;
                    }
                }
            }
            
            // Held bass: start a single sustained bass to the column's effective root within G1..C3.
            _updateHeldBassForColumn(columnElement){
                this._dbg && this._dbg('BASS/HELD:call', 'enabled=', this._heldBassEnabled, 'col=', columnElement?.dataset?.chordId || columnElement?.dataset?.originalPosition);
                if (this._heldBassEnabled === false || this.bassEnabled === false) return;
                
                // Skip automatic bass if bass modal has active patterns
                const bassGrid = document.getElementById('bassGrid');
                if (bassGrid && bassGrid._computedPattern) {
                    const hasActiveBassPattern = bassGrid._computedPattern.split(' ').some(token => token !== 'x');
                    if (hasActiveBassPattern) {
                        this._dbg && this._dbg('BASS/HELD:skip - bass modal has active patterns');
                        return;
                    }
                }
                try{
                    const edo = this.currentTuning || 12;
                    const step = (typeof this._getNamedColumnRootStep === 'function')
                        ? (this._getNamedColumnRootStep(columnElement) ?? this._getEffectiveColumnRootStep(columnElement))
                        : this._getEffectiveColumnRootStep(columnElement);
                    this._dbg && this._dbg('BASS/HELD:step', step, 'edo=', edo);
                    const target = this._computeBassFreqInRange(step, (typeof this._heldBassLiveFreq==='number'?this._heldBassLiveFreq:null), edo);
                    this._dbg && this._dbg('BASS/HELD:target', target);
                    if (!isFinite(target) || target<=0) return;
                    // If there is no existing bass, start one with minimal attack/release and centered pan
                    if (!this._heldBassVoice){
                        this._dbg && this._dbg('BASS/HELD:start', target);
                        // Locally save ADSR and panning width, then restore immediately after starting the bass
                        const savedEnv1 = { ...this.envelope };
                        const savedEnv2 = { ...this.osc2Envelope };
                        const prevWidth = this.panning ? this.panning.width : null;
                        try {
                            // Minimal, smooth bass envelope
                            this.envelope.attack = 0.005; this.envelope.decay = 0.05; this.envelope.sustain = 0.95; this.envelope.release = 0.08;
                            this.osc2Envelope.attack = 0.005; this.osc2Envelope.decay = 0.05; this.osc2Envelope.sustain = 0.95; this.osc2Envelope.release = 0.08;
                            // Force center pan by collapsing width temporarily
                            if (this.panning) this.panning.width = 0;
                            this.playFrequency(target, null, 'bass');
                        } finally {
                            // Restore panning width and global ADSR immediately to avoid affecting other voices
                            if (this.panning && prevWidth != null) this.panning.width = prevWidth;
                            Object.assign(this.envelope, savedEnv1);
                            Object.assign(this.osc2Envelope, savedEnv2);
                        }
                        // Track by the starting key; capture the voice now or shortly after if not yet present
                        this._heldBassVoiceKey = target;
                        const v = this.activeBassOscillators.get(this._heldBassVoiceKey);
                        if (v){
                            try { if (v.releaseTimeout) { clearTimeout(v.releaseTimeout); v.releaseTimeout = null; } } catch(_){ }
                            this._heldBassVoice = v; this._heldBassLiveFreq = target;
                            // Set up HOLD duration auto-release for bass
                            try {
                                const holdSelect = document.getElementById('universalHold');
                                const holdValue = holdSelect ? holdSelect.value : 'bar:1';
                                const [kind, valStr] = String(holdValue).split(':');
                                const n = Math.max(1, parseInt(valStr || '1', 10));
                                
                                // Calculate hold duration in milliseconds
                                const bpmEl = document.getElementById('universalBpm');
                                const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                                const beatMs = 60000 / Math.max(20, bpm);
                                
                                // Get time signature
                                const timeSignatureEl = document.getElementById('universalTimeSignature');
                                const timeSignature = timeSignatureEl ? timeSignatureEl.value : '4/4';
                                const [beatsPerBar] = timeSignature.split('/').map(Number);
                                const barMs = beatMs * (beatsPerBar || 4);
                                
                                const holdDurationMs = (kind === 'beat') ? n * beatMs : n * barMs;
                                v.releaseTimeout = setTimeout(() => {
                                    try {
                                        this.stopFrequency(target, null, 'bass');
                                        if (this._heldBassVoice === v) {
                                            this._heldBassVoice = null;
                                            this._heldBassLiveFreq = null;
                                            this._heldBassVoiceKey = null;
                                        }
                                    } catch(_) {}
                                }, holdDurationMs);
                            } catch(_) {}
                        } else {
                            setTimeout(()=>{
                                try{
                                    const vv = this.activeBassOscillators.get(this._heldBassVoiceKey);
                                    if (vv){
                                        try { if (vv.releaseTimeout) { clearTimeout(vv.releaseTimeout); vv.releaseTimeout = null; } } catch(_){ }
                                        this._heldBassVoice = vv; this._heldBassLiveFreq = target;
                                        // Set up HOLD duration auto-release for bass
                                        try {
                                            const holdSelect = document.getElementById('universalHold');
                                            const holdValue = holdSelect ? holdSelect.value : 'bar:1';
                                            const [kind, valStr] = String(holdValue).split(':');
                                            const n = Math.max(1, parseInt(valStr || '1', 10));
                                            
                                            // Calculate hold duration in milliseconds
                                            const bpmEl = document.getElementById('universalBpm');
                                            const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                                            const beatMs = 60000 / Math.max(20, bpm);
                                            
                                            // Get time signature
                                            const timeSignatureEl = document.getElementById('universalTimeSignature');
                                            const timeSignature = timeSignatureEl ? timeSignatureEl.value : '4/4';
                                            const [beatsPerBar] = timeSignature.split('/').map(Number);
                                            const barMs = beatMs * (beatsPerBar || 4);
                                            
                                            const holdDurationMs = (kind === 'beat') ? n * beatMs : n * barMs;
                                            vv.releaseTimeout = setTimeout(() => {
                                                try {
                                                    this.stopFrequency(target, null, 'bass');
                                                    if (this._heldBassVoice === vv) {
                                                        this._heldBassVoice = null;
                                                        this._heldBassLiveFreq = null;
                                                        this._heldBassVoiceKey = null;
                                                    }
                                                } catch(_) {}
                                            }, holdDurationMs);
                                        } catch(_) {}
                                    }
                                }catch(_){ }
                            }, 0);
                        }
                        return;
                    }
                    // Update existing bass to new target immediately
                    const v = this._heldBassVoice || (this._heldBassVoiceKey!=null ? this.activeBassOscillators.get(this._heldBassVoiceKey) : null);
                    const ctxNow = this.audioContext?.currentTime || 0;
                    const tuner = edo;
                    const f1 = target * Math.pow(2, this.oscillators.osc1.octave + ((this.oscillators.osc1.detune + (this.oscillators.osc1.coarse * (1200 / tuner))) / 1200));
                    const f2 = target * Math.pow(2, this.oscillators.osc2.octave + ((this.oscillators.osc2.detune + (this.oscillators.osc2.coarse * (1200 / tuner))) / 1200));
                    let updated = false;
                    try {
                        if (v.osc1?.frequency?.cancelScheduledValues && v.osc2?.frequency?.cancelScheduledValues) {
                            v.osc1.frequency.cancelScheduledValues(ctxNow);
                            v.osc1.frequency.setValueAtTime(f1, ctxNow);
                            v.osc2.frequency.cancelScheduledValues(ctxNow);
                            v.osc2.frequency.setValueAtTime(f2, ctxNow);
                            updated = true;
                        }
                    } catch(_){ updated = false; }
                    if (!updated) {
                        this._dbg && this._dbg('BASS/HELD:restartFallback');
                        // Fall back: stop the old held bass and restart at target
                        try { if (this._heldBassLiveFreq) this.stopFrequency(this._heldBassLiveFreq, null, 'bass'); } catch(_){ }
                        this._heldBassVoice = null; this._heldBassLiveFreq = null; this._heldBassVoiceKey = null;
                        try { this._updateHeldBassForColumn(columnElement); } catch(_){ }
                        return;
                    }
                    this._heldBassLiveFreq = target;
                    // Set up HOLD duration auto-release for updated bass
                    try {
                        const holdSelect = document.getElementById('universalHold');
                        const holdValue = holdSelect ? holdSelect.value : 'bar:1';
                        const [kind, valStr] = String(holdValue).split(':');
                        const n = Math.max(1, parseInt(valStr || '1', 10));
                        
                        // Calculate hold duration in milliseconds
                        const bpmEl = document.getElementById('universalBpm');
                        const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                        const beatMs = 60000 / Math.max(20, bpm);
                        
                        // Get time signature
                        const timeSignatureEl = document.getElementById('universalTimeSignature');
                        const timeSignature = timeSignatureEl ? timeSignatureEl.value : '4/4';
                        const [beatsPerBar] = timeSignature.split('/').map(Number);
                        const barMs = beatMs * (beatsPerBar || 4);
                        
                        const holdDurationMs = (kind === 'beat') ? n * beatMs : n * barMs;
                        if (v && v.releaseTimeout) {
                            clearTimeout(v.releaseTimeout);
                        }
                        if (v) {
                            v.releaseTimeout = setTimeout(() => {
                                try {
                                    this.stopFrequency(target, null, 'bass');
                                    if (this._heldBassVoice === v) {
                                        this._heldBassVoice = null;
                                        this._heldBassLiveFreq = null;
                                        this._heldBassVoiceKey = null;
                                    }
                                } catch(_) {}
                            }, holdDurationMs);
                        }
                    } catch(_) {}
                    this._dbg && this._dbg('BASS/HELD:updateOK', target);
                } catch(_){ }
            }
            // In CHORD slide: sustain a single bass voice and GLIDE it to the new effective root.
            _playChordSlideBassNow(columnElement){
                // Disabled per user request: no bass during chord slide
                return;
            }
            _wireTransportUI(){
                try {
                                // Hard reset transport so PLAY behaves identically every time
                                try {
                                    omnichord._stopArpTransport();
                                    omnichord._ensureArpTransport();
                                    const t = omnichord._arpTransport;
                                    if (t) {
                                        t.tickCounter = 0;
                                        t.absTickCounter = 0;
                                        t.nextAt = ((performance && performance.now) ? performance.now() : Date.now());
                                        t.running = false;
                                        t.inactivityStopScheduled = false;
                                        t.stopAtBarIndex = null;
                                    }
                                    if (omnichord._arp) {
                                        omnichord._arp.pendingSwitch = null;
                                        omnichord._arp.active = false;
                                        omnichord._arp.seq = [];
                                        omnichord._arp.startTickAlign = 0;
                                        omnichord._arp.morph = null;
                                    }
                                    // Stop any lingering voices so we start from silence
                                    try { omnichord.stopAllActiveNotes(); } catch(_){ }
                                    try { omnichord.stopAllDrums && omnichord.stopAllDrums(); } catch(_){ }
                                } catch(_){ }
                    // Chord/Slide Bass toggle replaced by universal bass button elsewhere
                } catch(_){ }
            }

            _stopArp(){
                this._dbg && this._dbg('ARP:STOP');
                if (!this._arp) return;
                // Stop independent pattern transport and active pattern voices immediately
                try {
                    if (window._patternTransport) {
                        const pt = window._patternTransport;
                        pt.running = false;
                        if (pt.activeVoices && pt.activeVoices.size){
                            for (const vid of Array.from(pt.activeVoices)){
                                const meta = pt[vid];
                                try { if (meta && typeof meta.stop === 'function') meta.stop(); } catch(_){ }
                                delete pt[vid];
                            }
                            pt.activeVoices.clear();
                        }
                        // Reset counters so next PLAY starts at the beginning of the pattern
                        try {
                            pt.tickCounter = 0;
                            pt.absTickCounter = 0;
                            const now = (performance && performance.now) ? performance.now() : Date.now();
                            const step = Math.max(1, pt.stepMs||120);
                            pt.nextAt = now + step;
                            // Mark loop inactive so a future kick can restart rAF
                            if (typeof pt._rafActive !== 'undefined') pt._rafActive = false;
                        } catch(_){ }
                    }
                } catch(_){ }
                // Deactivate the ARP voice but keep transport running; we'll stop after 1 bar if nothing resumes
                this._arp.active = false;
                this._arp.seq = [];
                this._arp.column = null;
                // Disable sustain so new notes return to normal envelope behavior outside PLAY chord-hold
                this._sustainActive = false;
                // Release any octave lock so next gesture can define a new one
                this._slideOctaveLock = null;
                // Stop sustained ARP voices (lead + bass)
                try {
                    if (this._arp.leadVoice && this._arp.leadLiveFreq){ this.stopFrequency(this._arp.leadLiveFreq, null); }
                } catch(_){ }
                try {
                    if (this._arp.bassVoice && this._arp.bassLiveFreq){
                        if (!this._arp.bassVoice.isGlobalBass) this.stopFrequency(this._arp.bassLiveFreq, null, 'bass');
                        // Wire Drum LEN controls (shared across lanes)
                        try {
                            const lenInc = document.getElementById('drumLenInc');
                            const lenDec = document.getElementById('drumLenDec');
                            const lenVal = document.getElementById('drumLenValue');
                            const lenHint = document.getElementById('drumLenHint');
                            const applyLen = (newLen)=>{
                                newLen = Math.max(1, Math.min(64, newLen|0));
                                grid.dataset.length = String(newLen);
                                if (lenVal) lenVal.textContent = String(newLen);
                                if (lenHint) lenHint.textContent = `Cycle: ${newLen} steps`;
                                // Rebuild each laneâ€™s columns and dividers (preserve simple on/off states)
                                const lanes = Array.from(grid.querySelectorAll('.drum-lane'));
                                lanes.forEach(lane=>{
                                    const oldSteps = Array.from(lane.querySelectorAll('.drum-step'));
                                    const snapshot = oldSteps.map(s=> ({ active: s.classList.contains('active') }));
                                    // remove old
                                    oldSteps.forEach(el=> el.remove());
                                    Array.from(lane.querySelectorAll('.beat-divider')).forEach(el=> el.remove());
                                    const ph = lane.querySelector('.drum-playhead'); if (ph) try { ph.remove(); } catch{}
                                    // set css var
                                    lane.style.setProperty('--steps-per-bar', String(newLen));
                                    // dividers
                                    const beats = Math.max(0, Math.floor(newLen/4));
                                    for (let b=1; b<beats; b++){ const div=document.createElement('div'); div.className='beat-divider'; div.style.left=`${(b/beats)*100}%`; lane.appendChild(div); }
                                    // steps
                                    for (let i=0;i<newLen;i++){
                                        const s=document.createElement('div'); s.className='drum-step'+((i%4===0)?' beat-accent':''); s.dataset.step=String(i);
                                        if (snapshot[i]?.active) s.classList.add('active');
                                        lane.appendChild(s);
                                    }
                                    const newPh=document.createElement('div'); newPh.className='drum-playhead'; newPh.style.left='0%'; lane.appendChild(newPh);
                                });
                                // Update container min-width scaling to largest D in drums
                                try {
                                    const container = document.getElementById('drumModal')?.querySelector('.drum-grid-container');
                                    if (container){
                                        const lanes = Array.from(grid.querySelectorAll('.drum-lane'));
                                        const maxD = lanes.reduce((mx,ln)=>{ const d=parseInt(ln.style.getPropertyValue('--steps-per-bar')||String(newLen),10)||newLen; return Math.max(mx,d); }, newLen);
                                        container.style.setProperty('--bar-steps', String(maxD));
                                        window._autoSizePatternModals && window._autoSizePatternModals(maxD);
                                    }
                                } catch(_){}
                                // Update transport timing so bar length immediately reflects LEN override (e.g., 12/16, 17/16)
                                try { this._refreshArpTransportTiming(); } catch(_){ }
                            };
                            if (lenInc && !lenInc._wired){ lenInc._wired=true; lenInc.addEventListener('click',()=> applyLen(Math.min(64,(parseInt(grid.dataset.length||'16',10)||16)+1))); }
                            if (lenDec && !lenDec._wired){ lenDec._wired=true; lenDec.addEventListener('click',()=> applyLen(Math.max(1,(parseInt(grid.dataset.length||'16',10)||16)-1))); }
                            if (lenVal && !lenVal.textContent) lenVal.textContent = grid.dataset.length||'16';
                        } catch(_){}
                    }
                } catch(_){ }
                this._arp.leadVoice = null; this._arp.leadLiveFreq = null;
                this._arp.bassVoice = null; this._arp.bassLiveFreq = null;
                // Re-enable per-note panning auto-toggle when ARP voice stops
                this._suppressPanningAutoToggle = false;
                // Schedule a timed hold-stop based on HOLD selector, aligned to bars or beats (skip while sequencing)
                try {
                    if (this._isSequencing) return; // sequencing drives progression explicitly
                    this._ensureArpTransport();
                    // Use universalHold (fallback to chordHold) as the unified HOLD source
                    const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                    const hold = holdEl ? String(holdEl.value||'bar:1') : 'bar:1';
                    const [kind, valStr] = String(hold).split(':');
                    const n = Math.max(1, parseInt(valStr||'1',10));
                    const tpBeat = this._arpTransport.ticksPerBeat || 1;
                    const tpBar = this._arpTransport.ticksPerBar || (tpBeat*4);
                    let ticks = tpBar; // default 1 bar
                    if (kind === 'beat') ticks = n * tpBeat; else if (kind === 'bar') ticks = n * tpBar;
                    const nowAbs = this._arpTransport.absTickCounter|0;
                    this._arpTransport.holdStopAtAbsTick = (nowAbs + ticks) >>> 0;
                    this._dbg && this._dbg('ARP:HOLD', hold, 'ticks=', ticks, 'stopAt=', this._arpTransport.holdStopAtAbsTick);
                } catch(_) {
                    // Fallback to inactivity stop if parsing fails
                    this._scheduleTransportStopAfterInactivity();
                }
            }

            // Reset all rendered string elements' dataset.frequency back to their original pitch
            // based on stored dataset.noteIndex (absolute step) and dataset.octave.
            _resetAllStringFrequencies(){
                this._dbg && this._dbg('RESET/STRINGS');
                try {
                    const tuning = this.currentTuning || 12;
                    document.querySelectorAll('.strings-column .string').forEach(row => {
                        const step = parseInt(row.dataset.noteIndex, 10);
                        const oct = parseInt(row.dataset.octave, 10);
                        if (!Number.isFinite(step) || !Number.isFinite(oct)) return;
                        const s = ((step % tuning) + tuning) % tuning;
                        const f = this.getFrequency(s, oct, tuning);
                        if (Number.isFinite(f) && f > 0) row.dataset.frequency = String(f);
                    });
                } catch(_) { /* no-op */ }
            }

            applyPlayModeToColumnVisual(column){
                this._dbg && this._dbg('VIS/APPLY', column?.dataset?.chordId || column?.dataset?.originalPosition, this.playMode);
                try {
                    const container = column.querySelector('.strings-column');
                    if (!container) return;
                    const rows = Array.from(container.querySelectorAll('.string'));
                    if (rows.length===0) return;
                    // Visual ordering follows strum orientation + strumMode pattern.
                    // UP/DOWN define orientation; ALT modes keep current orientation.
                    const orientation = (this.strumOrientation || (this.strumMode === 'down' ? 'down' : 'up'));
                    let mode = (orientation === 'down') ? 'low-high' : 'high-low';
                    if (this.strumMode === 'alt-centers') mode = 'alt-center';
                    if (this.strumMode === 'alt-ends') mode = 'alt-ends';
                    let seq = [];
                    if ((mode === 'alt-ends' || mode === 'alt-center') && typeof this.groupStringsByOctave === 'function'){
                        const { groups } = this.groupStringsByOctave(rows);
                        for (const g of groups){
                            if (mode === 'alt-ends'){
                                const a = g.slice(); let i=0, j=a.length-1; while(i<=j){ if(i<=j) seq.push(a[i++]); if(i<=j) seq.push(a[j--]); }
                            } else {
                                const a=g.slice(); const mid=Math.floor((a.length-1)/2); let l=mid, r=mid+1; if(a.length%2===1){ seq.push(a[mid]); l=mid-1; r=mid+1; } while(l>=0 || r<a.length){ if(r<a.length) seq.push(a[r++]); if(l>=0) seq.push(a[l--]); }
                            }
                        }
                    } else {
                        // Base ascending by frequency
                        const asc = rows.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0)-(parseFloat(b.dataset.frequency)||0));
                        seq = this.getPatternSequence(asc, mode);
                    }
                    // Apply CSS order and store play order index based on first occurrence
                    const seen = new Set(); let orderIdx = 0;
                    for (const el of seq){
                        if (seen.has(el)) continue;
                        seen.add(el);
                        el.style.order = String(orderIdx);
                        el.dataset.playOrder = String(orderIdx);
                        orderIdx++;
                    }
                    // Append any remaining rows not included
                    rows.forEach(el=>{
                        if (!seen.has(el)){
                            el.style.order = String(orderIdx);
                            el.dataset.playOrder = String(orderIdx);
                            orderIdx++;
                        }
                    });
                    // Recompute gap distribution based on the new visual order
                    try { this._distributeStringGapsToFill(container); } catch(_){ }
                } catch(e) { console.warn('applyPlayModeToColumnVisual failed:', e); }
            }

            applyPlayModeToAllColumns(){
                document.querySelectorAll('.extension-column').forEach(col=> this.applyPlayModeToColumnVisual(col));
                const prev = document.getElementById('previewChordColumn');
                if (prev) this.applyPlayModeToColumnVisual(prev);
            }
            
            adjustColorBrightness(hexColor, percent) {
                // Utility function to adjust color brightness
                const num = parseInt(hexColor.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
            
            hexToRgb(hex) {
                // Convert hex color to RGB values
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }
            
            mapIntervalToEDO(interval, tuning = null) {
                // Map 12-TET intervals to the nearest equivalent in the current EDO
                // This preserves diatonic relationships properly
                const tuningSize = tuning || this.getTuningStepsPerOctave();
                const currentTuning = tuning || this.currentTuning;
                
                if (currentTuning === 12) {
                    // For 12-TET, return the interval as-is
                    return Math.round(interval);
                }
                
                // For other EDOs, map to the nearest step that preserves musical relationships
                const exactStep = (interval * tuningSize) / 12;
                return Math.round(exactStep);
            }
            
            getBaseTriadForQuality(quality) {
                // Return standard diatonic intervals in semitones
                // These will be properly mapped to EDO steps by mapIntervalToEDO
                let intervals = [0]; // Root
                
                switch (quality) {
                    case 'major':
                        intervals.push(4); // Major third (4 semitones)
                        intervals.push(7); // Perfect fifth (7 semitones)
                        break;
                    case 'minor':
                        intervals.push(3); // Minor third (3 semitones)
                        intervals.push(7); // Perfect fifth (7 semitones)
                        break;
                    case 'neutral':
                        intervals.push(3.5); // Neutral third (3.5 semitones)
                        intervals.push(7); // Perfect fifth (7 semitones)
                        break;
                    case 'diminished':
                        intervals.push(3); // Minor third
                        intervals.push(6); // Diminished fifth
                        break;
                    case 'augmented':
                        intervals.push(4); // Major third
                        intervals.push(8); // Augmented fifth
                        break;
                    case 'sus2':
                        intervals.push(2); // Major second
                        intervals.push(7); // Perfect fifth
                        break;
                    case 'sus4':
                        intervals.push(5); // Perfect fourth
                        intervals.push(7); // Perfect fifth
                        break;
                    default:
                        intervals.push(4); // Default to major third
                        intervals.push(7); // Perfect fifth
                        break;
                }
                
                return intervals;
            }
            
            convertExtensionsToIntervals(extensions) {
                // Return extensions as semitone intervals that will be mapped by mapIntervalToEDO
                const intervals = [];
                
                extensions.forEach(ext => {
                    switch (ext) {
                        case '6':
                            intervals.push(9); // Major 6th (9 semitones)
                            break;
                        case '7':
                            intervals.push(10); // Minor 7th (10 semitones)
                            break;
                        case 'maj7':
                            intervals.push(11); // Major 7th (11 semitones)
                            break;
                        case '9':
                            intervals.push(10); // 7th (required for 9th chords)
                            intervals.push(14); // 9th (2 semitones up an octave = 14)
                            break;
                        case '11':
                            intervals.push(10); // 7th (required for 11th chords)
                            intervals.push(14); // 9th (often included in 11th chords)
                            intervals.push(17); // 11th (5 semitones up an octave = 17)
                            break;
                        case 's11':
                        case '#11':
                            intervals.push(10); // 7th
                            intervals.push(14); // 9th
                            intervals.push(18); // #11th (6 semitones up an octave = 18)
                            break;
                        case '13':
                            intervals.push(10); // 7th (required for 13th chords)
                            intervals.push(14); // 9th (usually included)
                            intervals.push(17); // 11th (usually included)
                            intervals.push(21); // 13th (9 semitones up an octave = 21)
                            break;
                        case 's13':
                        case '#13':
                            intervals.push(10); // 7th
                            intervals.push(14); // 9th
                            intervals.push(17); // 11th
                            intervals.push(22); // #13th (10 semitones up an octave = 22)
                            break;
                        case 'sus2':
                            intervals.push(2); // Major 2nd
                            break;
                        case 'sus4':
                            intervals.push(5); // Perfect 4th
                            break;
                        case 'add9':
                            intervals.push(14); // 9th (2 semitones up an octave, no 7th)
                            break;
                        case 'neutral7':
                            intervals.push(10); // Still minor 7th, but will be applied to neutral triads
                            break;
                        case 'neutral11':
                            intervals.push(10); // 7th
                            intervals.push(14); // 9th
                            intervals.push(17); // 11th
                            break;
                    }
                });
                
                return intervals;
            }

            // Attach long-press drag and dwell-to-swap on a column (initiation on header or free space only)
            attachColumnDragHandlers(column) {
                try {
                    const container = document.getElementById('extensionColumns');
                    if (!container || !column) return;
                    const header = column.querySelector('.extension-header');
                    if (!header) return;

                    // Capture omnichord instance for event handlers
                    const omnichord = this;

                    const LONG_PRESS_MS = 1000;
                    const DWELL_MS = 200;
                    const JITTER_PX = 6;
                    const STRUM_SWIPE_PX = 10;
                    const DELETE_THRESHOLD_PX = 5; // delete only if dragged to top of the viewport

                    let pressTimer = null;
                    let isDragging = false;
                    let startX = 0, startY = 0;
                    let grabOffsetX = 0, grabOffsetY = 0;
                    let placeholder = null;
                    let dwellTimer = null;
                    let deleteIntent = false;
                    let originalAbsIndex = null;
                    let lastSwapTarget = null;
                    let lastSwapTargetAbsIndex = null;
                    let startedOnHeader = false;
                    let headerSwipeStrumFired = false;
                    let preMoveListening = false;
                    let selectedOnPress = false;

                    const getPointer = (e) => (e.touches && e.touches[0]) || e;
                    const canStartFrom = (target) => {
                        // allow ONLY from header; block buttons
                        if (!target) return false;
                        if (target.closest('.chord-action-button') || target.closest('.lock-button')) return false;
                        return !!target.closest('.extension-header');
                    };

                    const isLoopEnabled = () => {
                        try {
                            const loopToggle = document.getElementById('loopToggle');
                            return loopToggle ? !!loopToggle.checked : true;
                        } catch (_){
                            return true;
                        }
                    };

                    const stopPreMove = () => {
                        if (!preMoveListening) return;
                        preMoveListening = false;
                        try { window.removeEventListener('mousemove', onPreMove, true); } catch(_){ }
                        try { window.removeEventListener('touchmove', onPreMove, true); } catch(_){ }
                    };

                    const selectChordOnContact = (clientY) => {
                        // "Even touch" on header should select the chord immediately when CHORDS is lit.
                        try {
                            omnichord.currentActiveColumnEl = column;
                        } catch(_){ }
                        try { if (omnichord && omnichord._arp) omnichord._arp.column = column; } catch(_){ }
                        try {
                            omnichord.highlightKeyboardForColumn && omnichord.highlightKeyboardForColumn(column);
                        } catch(_){ }

                        // Suppress the legacy touch-gesture system's "tap = strum" for this header contact.
                        try { header.dataset.xenSuppressTapStrumTs = String(Date.now()); } catch(_){ }

                        // If PLAY is running, actually switch the sustained chord immediately.
                        try {
                            if (omnichord && omnichord.chordsEnabled && omnichord._isSequencing && typeof omnichord._executeChordChange === 'function') {
                                omnichord._executeChordChange(column, clientY);
                            }
                        } catch(_){ }
                    };

                    const swapNodes = (a, b) => {
                        if (!a || !b || a === b) return;
                        const aMarker = document.createElement('div');
                        const bMarker = document.createElement('div');
                        const parent = a.parentNode;
                        if (!parent || !b.parentNode) return;
                        parent.insertBefore(aMarker, a);
                        parent.insertBefore(bMarker, b);
                        parent.replaceChild(b, aMarker);
                        parent.replaceChild(a, bMarker);
                    };

                    const onPressStart = (e) => {
                        // Avoid starting drag while editing a header text
                        const t = e.target;
                        if (t && (t.getAttribute && t.getAttribute('contenteditable') === 'true')) return;
                        if (!canStartFrom(e.target)) return;
                        const p = getPointer(e);
                        startX = p.clientX; startY = p.clientY;
                        startedOnHeader = !!(e.target && e.target.closest && e.target.closest('.extension-header'));
                        headerSwipeStrumFired = false;
                        selectedOnPress = false;

                        // Immediate chord select on contact when CHORDS is lit.
                        try {
                            if (startedOnHeader && omnichord && omnichord.chordsEnabled) {
                                const rect = column.getBoundingClientRect();
                                const midY = rect.top + rect.height * 0.5;
                                selectChordOnContact(midY);
                                selectedOnPress = true;
                            }
                        } catch(_){ }

                        // Listen for movement before long-press fires so we can
                        // treat header down-swipe as strum in NOT-LOOP.
                        if (!preMoveListening) {
                            preMoveListening = true;
                            try { window.addEventListener('mousemove', onPreMove, { passive: false, capture: true }); } catch(_){ }
                            try { window.addEventListener('touchmove', onPreMove, { passive: false, capture: true }); } catch(_){ }
                        }
                        // Start drag timer - will be cancelled if tap ends quickly
                        pressTimer = setTimeout(() => beginDrag(p), LONG_PRESS_MS);
                    };

                    const cancelPress = () => { if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; } };

                    const onPreMove = (e) => {
                        if (!pressTimer || isDragging) return;
                        const p = getPointer(e);
                        const dx = p.clientX - startX;
                        const dy = p.clientY - startY;

                        // NOT-LOOP: header down-swipe should STRUM, not drag.
                        if (!isLoopEnabled() && startedOnHeader && !headerSwipeStrumFired) {
                            const mostlyVertical = Math.abs(dy) > (Math.abs(dx) * 1.2);
                            if (dy > STRUM_SWIPE_PX && mostlyVertical) {
                                headerSwipeStrumFired = true;
                                cancelPress();
                                stopPreMove();
                                try { omnichord.currentActiveColumnEl = column; } catch(_){ }
                                try { omnichord.highlightKeyboardForColumn && omnichord.highlightKeyboardForColumn(column); } catch(_){ }
                                // Ensure chord is selected (if not already selected on contact).
                                try {
                                    if (!selectedOnPress && omnichord && omnichord.chordsEnabled) {
                                        const rect = column.getBoundingClientRect();
                                        const midY = rect.top + rect.height * 0.5;
                                        selectChordOnContact(midY);
                                    }
                                } catch(_){ }
                                try { omnichord.playChordStrum && omnichord.playChordStrum(column, null, startY, p.clientY); } catch(_){ }
                                try { e.preventDefault(); } catch(_){ }
                                return;
                            }
                        }

                        // Any movement cancels pending long-press drag.
                        if (Math.abs(dx) > JITTER_PX || Math.abs(dy) > JITTER_PX) {
                            cancelPress();
                            stopPreMove();
                        }
                    };

                    const maybeCancelOnMove = (e) => {
                        if (!pressTimer) return;
                        const p = getPointer(e);
                        if (Math.abs(p.clientX - startX) > JITTER_PX || Math.abs(p.clientY - startY) > JITTER_PX) cancelPress();
                    };

                    const beginDrag = (p) => {
                        isDragging = true;
                        stopPreMove();
                        column.classList.add('dragging');
                        const rect = column.getBoundingClientRect();
                        grabOffsetX = p.clientX - rect.left;
                        grabOffsetY = p.clientY - rect.top;
                        column.style.width = rect.width + 'px';
                        column.style.height = rect.height + 'px';
                        column.style.position = 'fixed';
                        column.style.zIndex = 9999;
                        column.style.pointerEvents = 'none';
                        column.style.transform = 'scale(1.03)';
                        column.style.boxShadow = '0 12px 22px rgba(0,0,0,0.35)';

                        placeholder = document.createElement('div');
                        placeholder.className = 'extension-column placeholder';
                        placeholder.style.width = rect.width + 'px';
                        placeholder.style.height = rect.height + 'px';
                        placeholder.style.flex = '1';
                        placeholder.style.border = '2px dashed rgba(255,255,255,0.3)';
                        column.parentNode.insertBefore(placeholder, column);

                        // Capture the absolute index for the dragged column (for data swap)
                        try {
                            if (this.getIndexFromColumn) {
                                originalAbsIndex = this.getIndexFromColumn(column);
                            } else if (column.dataset && column.dataset.originalPosition) {
                                originalAbsIndex = parseInt(column.dataset.originalPosition, 10);
                            } else {
                                originalAbsIndex = Array.from(container.querySelectorAll('.extension-column')).indexOf(column);
                            }
                        } catch (_) { originalAbsIndex = null; }
                        lastSwapTarget = null;
                        lastSwapTargetAbsIndex = null;

                        moveDrag(p);
                        window.addEventListener('mousemove', onMove, { passive: false });
                        window.addEventListener('touchmove', onMove, { passive: false });
                        window.addEventListener('mouseup', onEnd);
                        window.addEventListener('touchend', onEnd);
                    };

                    const moveDrag = (p) => {
                        const x = p.clientX - grabOffsetX;
                        const y = p.clientY - grabOffsetY;
                        column.style.left = x + 'px';
                        column.style.top = y + 'px';

                        // delete intent near top
                        // Only flag delete when pointer is near the very top of the viewport
                        const shouldDelete = (p.clientY <= DELETE_THRESHOLD_PX);
                        if (shouldDelete !== deleteIntent) {
                            deleteIntent = shouldDelete;
                            column.classList.toggle('delete-intent', deleteIntent);
                        }

                        const siblings = Array.from(container.querySelectorAll('.extension-column'))
                            .filter(el => el !== column && !el.classList.contains('placeholder'));
                        let over = siblings.find(el => {
                            const r = el.getBoundingClientRect();
                            return p.clientX > r.left && p.clientX < r.right && p.clientY > r.top && p.clientY < r.bottom;
                        });

                        // Fallback using elementFromPoint for reliability across browsers
                        if (!over) {
                            const hit = document.elementFromPoint(p.clientX, p.clientY);
                            const hitCol = hit && hit.closest ? hit.closest('.extension-column') : null;
                            if (hitCol && hitCol !== column && !hitCol.classList.contains('placeholder')) {
                                over = hitCol;
                            }
                        }

                        if (over) {
                            if (!dwellTimer) {
                dwellTimer = setTimeout(() => {
                                    if (!placeholder || !over.parentNode) return;
                                    if (over !== lastSwapTarget) {
                                        swapNodes(placeholder, over);
                                        lastSwapTarget = over;
                                        try {
                                            lastSwapTargetAbsIndex = this.getIndexFromColumn ? this.getIndexFromColumn(over) : (over.dataset && over.dataset.originalPosition ? parseInt(over.dataset.originalPosition, 10) : null);
                                        } catch(_) { lastSwapTargetAbsIndex = null; }
                    // Allow subsequent swaps by resetting the dwell timer state
                    clearTimeout(dwellTimer);
                    dwellTimer = null;
                                    }
                                }, DWELL_MS);
                            }
                        } else if (dwellTimer) {
                            clearTimeout(dwellTimer); dwellTimer = null;
                        }
                    };

                    const onMove = (e) => { if (!isDragging && pressTimer) { maybeCancelOnMove(e); return; } if (!isDragging) return; const p = getPointer(e); moveDrag(p); e.preventDefault(); };

                    const onEnd = () => {
                        cancelPress();
                        stopPreMove();
                        window.removeEventListener('mousemove', onMove);
                        window.removeEventListener('touchmove', onMove);
                        window.removeEventListener('mouseup', onEnd);
                        window.removeEventListener('touchend', onEnd);
                        if (dwellTimer) { clearTimeout(dwellTimer); dwellTimer = null; }

                        column.classList.remove('dragging');
                        column.style.position = '';
                        column.style.left = '';
                        column.style.top = '';
                        column.style.zIndex = '';
                        column.style.pointerEvents = '';
                        column.style.transform = '';
                        column.style.boxShadow = '';
                        column.style.width = '';
                        column.style.height = '';

            if (deleteIntent) {
                            deleteIntent = false;
                            // remove column and update data (do not recreate nodes for others)
                            const idx = this.getIndexFromColumn ? this.getIndexFromColumn(column) : Array.from(container.children).indexOf(column);
                            if (idx > -1) {
                                this.chordExtensions.splice(idx, 1);
                                column.remove();
                                this.normalizeChordPositions?.();
                                this.saveChordConfiguration?.();
                                // Regenerate to recalc columns and ensure gap removal and sizing
                                try {
                                    if (typeof this.preserveLockedChordsAndRegenerate === 'function') {
                                        this.preserveLockedChordsAndRegenerate();
                                    } else if (typeof this.generateExactChordColumns === 'function' && (this.chordExtensions||[]).some(c=>c.isCustom)) {
                                        this.generateExactChordColumns();
                                    } else if (typeof this.generateExtensionColumns === 'function') {
                                        this.generateExtensionColumns();
                                    }
                                    // Ensure gaps are closed
                                    if (typeof this._rebuildChordGridAfterDeletion === 'function') {
                                        this._rebuildChordGridAfterDeletion();
                                    }
                                } catch(_) {}
                            }
                            if (placeholder) placeholder.remove();
                            return;
                        }

                        if (placeholder && placeholder.parentNode) {
                            placeholder.parentNode.insertBefore(column, placeholder);
                            placeholder.remove();
                        }

                        // Rebuild data order from DOM to reflect the final visual order (works for single swap or cascades)
                        const orderedEls = Array.from(container.querySelectorAll('.extension-column'));
                        if (Array.isArray(this.chordExtensions) && orderedEls.length) {
                            const newArray = [];
                            for (let i = 0; i < orderedEls.length; i++) {
                                const el = orderedEls[i];
                                const oldIdx = el.dataset && el.dataset.originalPosition ? parseInt(el.dataset.originalPosition, 10) : i;
                                const model = this.chordExtensions[oldIdx] ?? this.chordExtensions[i];
                                if (model) {
                                    model.position = i;
                                    newArray.push(model);
                                    // Update dataset to new index for consistent future operations
                                    try { window._ensureModalAspectResize && window._ensureModalAspectResize(modal); } catch(_) {}
                                    try { el.dataset.originalPosition = String(i); } catch(_) {}
                                }
                            }
                            if (newArray.length === this.chordExtensions.length) {
                                this.chordExtensions = newArray;
                                this.normalizeChordPositions?.();
                                this.saveChordConfiguration?.();
                                // Ensure the visible header names/lock states match the new underlying model order
                                if (typeof this.syncColumnHeaderToModel === 'function') {
                                    for (let i = 0; i < orderedEls.length; i++) {
                                        try { this.syncColumnHeaderToModel(orderedEls[i], this.chordExtensions[i]); } catch(_) {}
                                    }
                                }
                            }
                        }
                    };

                    const onPressEnd = (e) => {
                        // If we already fired a header swipe-strum, do not treat as tap.
                        if (headerSwipeStrumFired) {
                            headerSwipeStrumFired = false;
                            cancelPress();
                            stopPreMove();
                            return;
                        }
                        // If press timer is still running, this was a quick tap
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                            stopPreMove();

                            // If we already selected on contact, don't re-trigger on release.
                            if (selectedOnPress) {
                                selectedOnPress = false;
                                return;
                            }
                            
                            // Don't interfere with header action buttons
                            if (
                                e.target.classList.contains('lock-button') ||
                                e.target.classList.contains('chord-action-button') ||
                                e.target.tagName === 'BUTTON'
                            ) {
                                return;
                            }
                            
                            console.log('?? Header quick tap - triggering chord/ARP');
                            
                            // Use the same logic as the footer trigger button
                            const rect = column.getBoundingClientRect();
                            const midY = rect.top + rect.height * 0.5;
                            omnichord.handleTriggerButtonClick(column, midY);
                        }
                    };

                    // Initiation only from header or free space
                    header.addEventListener('mousedown', (e) => { if (e.button !== 0) return; onPressStart(e); });
                    header.addEventListener('touchstart', (e) => { onPressStart(e); }, { passive: true });
                    header.addEventListener('mouseup', (e) => { onPressEnd(e); });
                    header.addEventListener('touchend', (e) => { onPressEnd(e); });

                } catch (err) { console.error('attachColumnDragHandlers error:', err); }
            }
            
            getTuningStepsPerOctave() {
                // Handle custom tuning objects
                if (typeof this.currentTuning === 'object' && this.currentTuning.type === 'custom') {
                    // For non-octave tunings, we need to calculate how many steps make an octave
                    const [num, den] = this.currentTuning.ratio;
                    const ratioInOctaves = Math.log2(num / den);
                    return this.currentTuning.divisions / ratioInOctaves;
                }
                
                if (typeof this.currentTuning === 'string') {
                    switch(this.currentTuning) {
                        case 'carlos-alpha': return 78.0;
                        case 'carlos-beta': return 18.8;
                        case 'carlos-gamma': return 34.1895;
                        case 'carlos-delta': return 10.024;
                        case 'lucy': return 6.283; // approximately 2p
                        case 'pythagorean':
                        case 'just':
                        case 'meantone':
                            return 12;
                        case 'arabic': return 24;
                        case 'gamelan-pelog': return 7;
                        case 'gamelan-slendro': return 5;
                        default: return 12;
                    }
                }
                return this.currentTuning;
            }

            // Synchronize a column's header text and lock UI to the provided chord model
            syncColumnHeaderToModel(column, chordModel) {
                if (!column || !chordModel) return;
                const chordNameEl = column.querySelector('.chord-name');
                const lockBtn = column.querySelector('.lock-button');
                if (!chordNameEl) return;

                if (chordModel.isLocked && chordModel.lockedData) {
                    const locked = chordModel.lockedData;
                    const rootName = (this.getNoteNames()[locked.lockedRoot] || locked.lockedRoot);
                    if (locked.chordName && /^[A-G][#b]?/.test(locked.chordName)) {
                        chordNameEl.textContent = locked.chordName;
                    } else if (locked.chordName) {
                        chordNameEl.textContent = `${rootName}${locked.chordName}`;
                    } else {
                        chordNameEl.textContent = `${rootName}${chordModel.name || ''}`;
                    }
                    chordNameEl.style.color = '#4CAF50';
                    chordNameEl.style.fontWeight = 'bold';
                    chordNameEl.dataset.isLocked = 'true';
                    chordNameEl.dataset.lockedName = chordNameEl.textContent;
                    if (lockBtn) {
                        lockBtn.innerHTML = 'ðŸ”’';
                        lockBtn.classList.add('locked');
                        lockBtn.title = `LOCKED to ${rootName} root with all settings`;
                    }
                } else {
                    chordNameEl.textContent = (chordModel.name || '');
                    chordNameEl.style.color = '';
                    chordNameEl.style.fontWeight = '';
                    chordNameEl.dataset.isLocked = '';
                    chordNameEl.dataset.lockedName = '';
                    if (lockBtn) {
                        lockBtn.innerHTML = 'ðŸ”“';
                        lockBtn.classList.remove('locked');
                        lockBtn.title = 'Lock complete sonic snapshot';
                    }
                }
            }

            addSimpleClickHandlers() {
                // Simple click handlers no longer needed - drag system handles tap and hold
                // debug removed
            }

            stopAllActiveNotes(sourceType = null) {
                // Optional sourceType allows targeted stops (many call sites pass 'bass'/'chord'/etc).
                // When sourceType is omitted/null, stop everything (preserving global bass as before).
                const type = (typeof sourceType === 'string' && sourceType) ? sourceType : null;

                // Fast path: targeted stop using stopFrequency so envelopes are applied correctly.
                if (type) {
                    let pool = null;
                    switch (type) {
                        case 'default': pool = this.activeOscillators; break;
                        case 'strum': pool = this.activeStrumOscillators; break;
                        case 'bells': pool = this.activeBellsOscillators; break;
                        case 'chord': pool = this.activeChordOscillators; break;
                        case 'arp': pool = this.activeArpOscillators; break;
                        case 'bass': pool = this.activeBassOscillators; break;
                        default: pool = null; break;
                    }
                    if (pool && pool.size) {
                        const keys = Array.from(pool.keys());
                        for (const k of keys) {
                            try {
                                const info = pool.get(k);
                                // If we are explicitly stopping bass, do not preserve global bass.
                                this.stopFrequency(k, info?.element || null, type);
                            } catch (_) {}
                        }
                    }
                    // Clear held-bass references if we stopped bass
                    if (type === 'bass') {
                        try { this._heldBassVoice = null; this._heldBassLiveFreq = null; this._heldBassVoiceKey = null; } catch(_){ }
                    }
                    return;
                }

                // Stop everything (legacy behavior)
                try {
                    this.stopAllStrings();
                } catch (_) {
                    // Fallback: manual release for any remaining entries in all oscillator pools
                    const now = this.audioContext ? this.audioContext.currentTime : 0;
                    const allPools = [
                        this.activeOscillators,
                        this.activeStrumOscillators,
                        this.activeBellsOscillators,
                        this.activeChordOscillators,
                        this.activeArpOscillators,
                        this.activeBassOscillators
                    ];

                    for (const pool of allPools) {
                        if (!pool) continue;
                        for (const [id, info] of pool) {
                            // Preserve the independent global bass
                            if (info && info.isGlobalBass) continue;
                            try {
                                if (info.osc1Envelope) {
                                    info.osc1Envelope.gain.cancelScheduledValues(now);
                                    info.osc1Envelope.gain.setValueAtTime(info.osc1Envelope.gain.value, now);
                                    info.osc1Envelope.gain.linearRampToValueAtTime(0, now + (this.envelope?.release || 0.2));
                                }
                                if (info.osc2Envelope) {
                                    info.osc2Envelope.gain.cancelScheduledValues(now);
                                    info.osc2Envelope.gain.setValueAtTime(info.osc2Envelope.gain.value, now);
                                    info.osc2Envelope.gain.linearRampToValueAtTime(0, now + (this.osc2Envelope?.release || 0.2));
                                }
                                const maxRel = Math.max(this.envelope?.release || 0.2, this.osc2Envelope?.release || 0.2);
                                if (info.osc1) info.osc1.stop(now + maxRel);
                                if (info.osc2) info.osc2.stop(now + maxRel);
                            } catch {}
                            pool.delete(id);
                        }
                    }
                }
                // Clear held-bass references so a fresh one can be started next time
                try { this._heldBassVoice = null; this._heldBassLiveFreq = null; this._heldBassVoiceKey = null; } catch(_){ }
                // Also stop any active drum voices
                try { this.stopAllDrums && this.stopAllDrums(); } catch(_){ }
            }

            _isPointerOverModal(evt) {
                try {
                    const t = evt?.touches && evt.touches[0] ? evt.touches[0]
                        : (evt?.changedTouches && evt.changedTouches[0] ? evt.changedTouches[0] : null);
                    const x = Number.isFinite(evt?.clientX) ? evt.clientX : (t ? t.clientX : null);
                    const y = Number.isFinite(evt?.clientY) ? evt.clientY : (t ? t.clientY : null);
                    if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
                    const el = document.elementFromPoint(x, y);
                    if (!el) return false;
                    return !!el.closest('.floating-modal, .modal-overlay, .modal-content');
                } catch(_) { return false; }
            }

            handleStringTrigger(event, touchId = null) {
                // Do not strum when interacting with modals/overlays
                if (this._isPointerOverModal(event)) return;
                // During sequencing, just allow STRUM mode - don't affect sequence progression
                if (this._isSequencing) {
                    // Force STRUM mode during sequencing
                    if (this.playMode !== 'strum') {
                        this.playMode = 'strum';
                        this.updatePlayModeButtons();
                    }
                }
                
                // Ensure AudioContext is running on every swipe sample for reliability
                try {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume().catch(()=>{});
                    }
                } catch(_) {}
                const elements = document.elementsFromPoint(event.clientX, event.clientY);
                const stringElement = elements.find(el => el.classList.contains('string'));
                
                if (stringElement) {
                    // If a blank chord is pending and user is strumming another column, inherit immediately
                    try {
                        if (this.pendingBlankChordId && this.pendingBlankChordStrumEligible) {
                            const srcCol = stringElement.closest && stringElement.closest('.extension-column');
                            const pendingCol = document.querySelector(`.extension-column[data-chord-id='${this.pendingBlankChordId}']`);
                            const isSame = pendingCol && srcCol && pendingCol === srcCol;
                            if (srcCol && pendingCol && !isSame) {
                                const headerName = srcCol.querySelector('.extension-header .chord-name')?.textContent?.trim() || '';
                                if (headerName !== '|') {
                                    const relSteps = this.getChordStepsForColumn(srcCol);
                                    const edo = this.currentTuning || 12;
                                    const absSteps = relSteps.map(s=> ((s % edo)+edo)%edo);
                                    const best = this._chooseBestRootByQuality(absSteps, edo);
                                    const rootAbs = best.root;
                                    const normalized = absSteps.map(s=> ((s - rootAbs)%edo+edo)%edo).sort((a,b)=> this.stepToSemitone(a,edo)-this.stepToSemitone(b,edo));
                                    const idx = (this.chordExtensions||[]).findIndex(c=> String(c.id)===String(this.pendingBlankChordId));
                                    if (idx >= 0) {
                                        const model = this.chordExtensions[idx];
                                        model.intervals = normalized;
                                        model.fixedRootStepAbs = rootAbs;
                                        model.fixedRootTuning = edo;
                                        const newName = this.computeFullChordNameFromAbsoluteSteps([rootAbs, ...normalized.map(x=> (rootAbs + x)%edo)], edo);
                                        model.name = newName;
                                        try {
                                            const nameEl = pendingCol.querySelector('.extension-header .chord-name');
                                            if (nameEl) { nameEl.textContent = newName; nameEl.dataset.lockedName = newName; }
                                            const old = pendingCol.querySelector('.strings-column');
                                            if (old) old.remove();
                                            this.generateStringsForColumn(pendingCol, model.intervals, true);
                                            this.highlightKeyboardForColumn(pendingCol);
                                            this.currentActiveColumnEl = pendingCol;
                                        } catch(_) {}
                                        this.pendingBlankChordId = null;
                                        this.pendingBlankChordStrumEligible = false;
                                        try { this.saveChordConfiguration(); } catch(_) {}
                                    }
                                }
                            } else {
                                // Any strum after [+] without duplication disarms the one-shot copy
                                this.pendingBlankChordStrumEligible = false;
                            }
                        }
                    } catch(_) {}
                    const stringIndex = stringElement.dataset.index;
                    const column = parseInt(stringElement.dataset.column) || stringElement.dataset.column;
                    // Build a stable key for this string in its column
                    const stringKey = `${column}|${stringIndex}`;
                    // Identify pointer: mouse vs specific touch id (derive from event if needed)
                    let pointerKey;
                    if (touchId !== null && touchId !== undefined) {
                        pointerKey = `t${touchId}`;
                    } else if (event && typeof event === 'object' && 'identifier' in event && event.identifier !== undefined && event.identifier !== null) {
                        pointerKey = `t${event.identifier}`;
                    } else {
                        pointerKey = 'mouse';
                    }
                    const lastKey = this._pointerLastStringKey.get(pointerKey);
                    const trackingSet = touchId !== null ? 
                        this.activeTouches.get(touchId)?.triggeredStrings : 
                        this.triggeredStrings;
                    
                    // Throttle triggering per string to avoid audio spam but maintain responsiveness
                    const now = performance.now();
                    const lastTrigger = stringElement.lastTriggerTime || 0;
                    const minInterval = 35; // 35ms minimum between triggers per string (â‰¤28/s) - improved touch sensitivity
                    
                    // Skip retrigger if same pointer is still on the same string and sustain gesture is active
                    const sameStringAsLast = (lastKey === stringKey);
                    if (!sameStringAsLast && (now - lastTrigger > minInterval)) {
                        this.currentPlayingColumn = column;
                        // Try to cache actual column element and light keyboard - enhanced with pre-cached lookup
                        try {
                            let columnEl = null;
                            // Use cached column if available and recent (performance optimization)
                            if (stringElement._cachedColumn && stringElement._lastCacheTime && 
                                (now - stringElement._lastCacheTime) < 200) {
                                columnEl = stringElement._cachedColumn;
                            } else {
                                // Fallback to DOM lookup
                                columnEl = stringElement.closest('.extension-column');
                                if (!columnEl && typeof column === 'string') {
                                    columnEl = document.querySelector(`.extension-column[data-chord-type='${column}']`);
                                }
                                // Cache for next time
                                if (columnEl) {
                                    stringElement._cachedColumn = columnEl;
                                    stringElement._lastCacheTime = now;
                                }
                            }
                            if (columnEl) {
                                this.currentActiveColumnEl = columnEl;
                                this.highlightKeyboardForColumn(columnEl);
                            }
                        } catch(_) {}
                        const frequency = parseFloat(stringElement.dataset.frequency);
                        // ALWAYS use 'strum' source type for strumming - strings only, never triggers chord/arp/bass
                        const sourceType = 'strum';
                        this.playFrequency(frequency, stringElement, sourceType);
                        this.updateCurrentChord(column);
                        
                        stringElement.lastTriggerTime = now;
                        // Update last-hit key for this pointer
                        this._pointerLastStringKey.set(pointerKey, stringKey);
                        
                        // Add to tracking for cleanup
                        if (trackingSet) {
                            trackingSet.add(stringIndex);
                            // Quick removal to allow retriggering
                            setTimeout(() => {
                                trackingSet.delete(stringIndex);
                            }, 20);
                        }
                    }
                }
            }

            handlePaletteStringTrigger(event) {
                const elements = document.elementsFromPoint(event.clientX, event.clientY);
                const stringElement = elements.find(el => el.classList.contains('string') && el.dataset.paletteIndex !== undefined);
                
                if (stringElement) {
                    const stringIndex = stringElement.dataset.index;
                    const paletteIndex = stringElement.dataset.paletteIndex;
                    const rawFrequency = stringElement.dataset.frequency;
                    
                    // Throttle triggering per string to avoid audio spam but maintain responsiveness
                    const now = performance.now();
                    const lastTrigger = stringElement.lastTriggerTime || 0;
                    const minInterval = 35; // 35ms minimum between triggers per string (â‰¤28/s) - improved touch sensitivity
                    
                    if (now - lastTrigger > minInterval && !this.paletteTriggeredStrings.has(stringIndex)) {
                        const frequency = parseFloat(rawFrequency);
                        
                        if (!isNaN(frequency) && isFinite(frequency)) {
                            this.playFrequency(frequency, stringElement, 'chord');
                            
                            stringElement.lastTriggerTime = now;
                            this.paletteTriggeredStrings.add(stringIndex);
                            
                            // Quick removal to allow retriggering
                            setTimeout(() => {
                                this.paletteTriggeredStrings.delete(stringIndex);
                            }, 20);
                        } else {
                            // invalid frequency - no-op
                        }
                    }
                }
            }

            updateCurrentChord(column) {
                // Resolve the column element from dataset.column (chordType) or fallback to closest
                let columnElement = document.querySelector(`[data-chord-type="${column}"]`) || document.querySelector(`[data-column="${column}"]`);
                if (!columnElement) {
                    try { columnElement = document.querySelector(`.extension-column[data-chord-type='${column}']`); } catch(_){}
                }
                // If user was creating a new chord, auto-save it before switching context
                if (this.chordCreationMode && this.selectedIntervals && this.selectedIntervals.length > 1) {
                    try {
                        const edo = this.currentTuning || 12;
                        const absSteps = this.selectedIntervals.map(iv => ((iv % edo) + edo) % edo);
                        const pendingName = this.computeFullChordNameFromAbsoluteSteps(absSteps, edo);
                        this.finalizePreviewChord(pendingName);
                        this.chordCreationMode = false;
                    } catch(e) { /* ignore */ }
                }
                // Apply piano-locked preset if one exists for this chord's structure
                if (columnElement && this.pianoLockedChords && this.pianoLockedChords.size > 0) {
                    try {
                        const headerElement = columnElement.querySelector('.extension-header');
                        const chordData = this.getChordDataFromColumn(columnElement, headerElement);
                        if (chordData) {
                            const lock = this.findPianoLockData(chordData);
                            if (lock) {
                                this.applyPianoLockedSettings(lock);
                                // Preload/warm this chord for instant play
                                try { this.preloadPianoLockedChord(columnElement); } catch(_) {}
                            }
                        }
                    } catch(_) {}
                }
                // Mark active column for keyboard interactions
                this.currentPlayingColumn = column;
                // Cache the active column element for keyboard-driven live edits
                this.currentActiveColumnEl = columnElement || this.currentActiveColumnEl;
                // Light keyboard notes for the active chord if possible
                try { if (columnElement) this.highlightKeyboardForColumn(columnElement); } catch(_) {}
            }

            playChordStrum(columnElement, chordData, startY, endY) {
                try {
                    const loopToggle = document.getElementById('loopToggle');
                    const loopEnabled = loopToggle ? !!loopToggle.checked : true;
                    if (!loopEnabled && columnElement && columnElement.classList && columnElement.classList.contains('extension-column')) {
                        this.currentActiveColumnEl = columnElement;
                        if (this._arp) this._arp.column = columnElement;
                    }
                } catch(_){ }
                try {
                    if (this._isSequencing && columnElement && columnElement.classList && columnElement.classList.contains('extension-column')) {
                        this._lastPlayGestureColumnEl = columnElement;
                    }
                } catch(_){ }
                try {
                    const calcModal = document.getElementById('keyboardModal');
                    if (calcModal && calcModal.style.display !== 'none' && columnElement) {
                        this._loadCalcFromColumn(columnElement);
                        this.refreshCalcUI();
                    }
                } catch(_){ }
                // Chords mode: play all tones simultaneously in tapped octave + bass root, sustain until release
                // Only activate CHORDS mode when PLAY is active (isSequencing) - otherwise just strum
                if ((this.playMode || 'high-low') === 'chords' && this._isSequencing) {
                    const tapY = (typeof startY === 'number' && typeof endY === 'number') ? (startY + endY) / 2 : (columnElement?.getBoundingClientRect()?.top || 0);
                    this.playChordChordsMode(columnElement, tapY);
                    return;
                }
                // Ensure audio is ready once for this strum
                if (typeof this.ensureAudioContext === 'function') {
                    // Fire and forget; individual notes also guard, but this minimizes per-note overhead
                    this.ensureAudioContext().catch(()=>{});
                }
                // If there's a newly created blank chord pending, and the user strums another chord first,
                // inherit that strummed chord's tones into the pending blank chord.
                try {
                    if (this.pendingBlankChordId && this.pendingBlankChordStrumEligible && columnElement) {
                        const pendingId = this.pendingBlankChordId;
                        // Locate the pending column/model
                        const pendingCol = document.querySelector(`.extension-column[data-chord-id='${pendingId}']`);
                        const pendingIdx = (this.chordExtensions||[]).findIndex(c=> String(c.id)===String(pendingId));
                        const isPendingBlank = pendingIdx >= 0 && Array.isArray(this.chordExtensions[pendingIdx].intervals) && this.chordExtensions[pendingIdx].intervals.length === 0;
                        // Ensure we're not strumming the pending column itself
                        const isSameCol = pendingCol && pendingCol === columnElement;
                        // Avoid copying from separators
                        const headerName = columnElement.querySelector('.extension-header .chord-name')?.textContent?.trim() || '';
                        const isSeparator = headerName === '|';
                        if (isPendingBlank && !isSameCol && !isSeparator) {
                            const relSteps = this.getChordStepsForColumn(columnElement);
                            const edo = this.currentTuning || 12;
                            // Choose lowest by 12TET quality and normalize
                            const absSteps = relSteps.map(s=> ((s % edo)+edo)%edo);
                            const best = this._chooseBestRootByQuality(absSteps, edo);
                            const rootAbs = best.root;
                            const normalized = absSteps.map(s=> ((s - rootAbs)%edo+edo)%edo).sort((a,b)=> this.stepToSemitone(a,edo)-this.stepToSemitone(b,edo));
                            // Write into pending model
                            const model = this.chordExtensions[pendingIdx];
                            model.intervals = normalized;
                            model.fixedRootStepAbs = rootAbs;
                            model.fixedRootTuning = edo;
                            const newName = this.computeFullChordNameFromAbsoluteSteps([rootAbs, ...normalized.map(x=> (rootAbs + x)%edo)], edo);
                            model.name = newName;
                            // Update pending column UI
                            if (pendingCol) {
                                try {
                                    const nameEl = pendingCol.querySelector('.extension-header .chord-name');
                                    if (nameEl) { nameEl.textContent = newName; nameEl.dataset.lockedName = newName; }
                                    const old = pendingCol.querySelector('.strings-column');
                                    if (old) old.remove();
                                    this.generateStringsForColumn(pendingCol, model.intervals, true);
                                    this.highlightKeyboardForColumn(pendingCol);
                                    this.currentActiveColumnEl = pendingCol;
                                } catch(_) {}
                            }
                            // Clear pending flag to avoid further copies
                            this.pendingBlankChordId = null;
                            this.pendingBlankChordStrumEligible = false;
                            // Persist
                            try { this.saveChordConfiguration(); } catch(_) {}
                        }
                        if (isSameCol || isSeparator) {
                            // Any strum after [+] without duplication disarms the one-shot copy
                            this.pendingBlankChordStrumEligible = false;
                        }
                    }
                } catch(_) {}
                // Check if this chord is locked
                let originalSettings = null;
                const lockedChord = this.lockedChords?.get(columnElement);
                
                // Resolve piano-locked settings for this chord (keyed by chord SHAPE)
                let pianoLockedData = null;
                try {
                    // Prefer direct intervals from rendered strings to build a stable shape
                    const relSteps = this.getChordStepsForColumn(columnElement);
                    const chordForLock = {
                        name: (columnElement.querySelector('.extension-header .chord-name')?.textContent||'').trim(),
                        quality: this.currentQuality,
                        intervals: Array.isArray(relSteps) ? relSteps : []
                    };
                    pianoLockedData = this.findPianoLockData(chordForLock);
                } catch(_) {}
                
                if (lockedChord) {
                    if (window.DEBUG_AUDIO) console.log('?? Playing locked chord:', lockedChord.chordName, 'locked to root:', lockedChord.lockedRoot);
                    // Store current settings
                    originalSettings = this.captureCurrentSettings();
                    // Apply locked settings
                    this.applyLockedChordSettings(lockedChord);
                    
                    // Always make sure we're using the locked root for playback
                    if (this.currentRoot !== lockedChord.lockedRoot) {
                        if (window.DEBUG_AUDIO) console.log('?? Overriding current root', this.currentRoot, 'with locked root:', lockedChord.lockedRoot, 'for playback');
                        this.currentRoot = lockedChord.lockedRoot;
                    }
                } else if (pianoLockedData) {
                    // Apply piano-locked settings (oscillator & effects only)
                    if (window.DEBUG_AUDIO) console.log('ðŸŽ¹ Playing chord with piano-locked settings:', pianoLockedData.chordName);
                    this.applyPianoLockedSettings(pianoLockedData);
                }
                
                // Get all strings in the column
                const strings = Array.from(columnElement.querySelectorAll('.string'));
                if (strings.length === 0) return;
                
                // Calculate which strings to play based on start and end positions
                const columnRect = columnElement.getBoundingClientRect();
                const relativeStartY = startY - columnRect.top;
                const relativeEndY = endY - columnRect.top;
                
                // Determine strum direction and range
                const strumDown = relativeEndY > relativeStartY;
                const minY = Math.min(relativeStartY, relativeEndY);
                const maxY = Math.max(relativeStartY, relativeEndY);
                
                // Filter strings that fall within the strum range
                let stringsToPlay = strings.filter(string => {
                    const stringRect = string.getBoundingClientRect();
                    const stringY = stringRect.top + stringRect.height / 2 - columnRect.top;
                    return stringY >= minY && stringY <= maxY;
                });
                // Fallback: if the gesture window captured no strings (e.g., tiny swipe), play them all
                if (stringsToPlay.length === 0) stringsToPlay = strings;
                
                // Build playback sequence from the subset within the gesture window.
                // Legacy behavior: STRUM mode defines orientation/pattern; swipe direction defines traversal.
                // If a new chord is strummed, fade any old strum voices that are not common tones.
                try { this._markUserActivity(); } catch(_){ }
                let strumNewFreqs = [];
                try {
                    stringsToPlay.forEach(s=>{
                        let f = parseFloat(s.dataset.frequency);
                        if (!Number.isFinite(f) || f <= 0) {
                            const step = parseInt(s.dataset.noteIndex, 10);
                            const oct = parseInt(s.dataset.octave, 10);
                            const tuning = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                            if (Number.isFinite(step)) f = this.getFrequency(((step % tuning) + tuning) % tuning, Number.isFinite(oct) ? oct : 4, tuning);
                        }
                        if (Number.isFinite(f) && f > 0) strumNewFreqs.push(f);
                    });
                } catch(_){ }
                const isNewStrumChord = (columnElement !== this._lastStrumColumnEl);
                if (isNewStrumChord) {
                    try { this._fadeVoicesNotInSet(this.activeStrumOscillators, 'strum', strumNewFreqs, 3, 0.25); } catch(_){ }
                    this._lastStrumColumnEl = columnElement;
                }
                const baseTopToBottom = stringsToPlay.slice().sort((a,b)=>{
                    const ra = a.getBoundingClientRect();
                    const rb = b.getBoundingClientRect();
                    return (ra.top + ra.height/2) - (rb.top + rb.height/2);
                });
                const baseDir = strumDown ? baseTopToBottom : baseTopToBottom.slice().reverse();

                const altEnds = (arr)=>{ const a=arr.slice(); const out=[]; let i=0,j=a.length-1; while(i<=j){ if(i<=j) out.push(a[i++]); if(i<=j) out.push(a[j--]); } return out; };
                const altCenter = (arr)=>{ const a=arr.slice(); const mid=Math.floor((a.length-1)/2); const out=[]; let l=mid, r=mid+1; if(a.length%2===1){ out.push(a[mid]); l=mid-1; r=mid+1; } while(l>=0 || r<a.length){ if(r<a.length) out.push(a[r++]); if(l>=0) out.push(a[l--]); } return out; };

                let playbackSeq = baseDir;
                if (this.strumMode === 'alt-ends') playbackSeq = altEnds(baseDir);
                else if (this.strumMode === 'alt-centers') playbackSeq = altCenter(baseDir);
                if (!Array.isArray(playbackSeq) || playbackSeq.length === 0) playbackSeq = baseDir;

                const originalCount = stringsToPlay.length;
                stringsToPlay = playbackSeq;
                
                // Per-string delay controls perceptibility of order; if we expanded notes (repeats), squeeze to same span
                const baseDelay = Number.isFinite(this.strumDelayMs) ? this.strumDelayMs : 20;
                const factor = Math.max(1, stringsToPlay.length / Math.max(1, originalCount));
                const strumDelay = baseDelay / factor;
                const strumSpanMs = Math.max(0, (stringsToPlay.length - 1) * strumDelay);

                // Highlight keys corresponding to the strummed notes (pitch classes)
                let strumHighlighted = false;
                try {
                    const srcEdo = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                    const stepSet = new Set();
                    stringsToPlay.forEach(s => {
                        const step = parseInt(s.dataset.noteIndex, 10);
                        if (Number.isFinite(step)) stepSet.add(((step % srcEdo) + srcEdo) % srcEdo);
                    });
                    if (stepSet.size) {
                        this.highlightKeyboardForSteps(Array.from(stepSet), srcEdo);
                        strumHighlighted = true;
                    }
                } catch(_){ }
                
                stringsToPlay.forEach((string, index) => {
                    setTimeout(() => {
                        let frequency = parseFloat(string.dataset.frequency);
                        if (!frequency || isNaN(frequency) || !isFinite(frequency) || frequency <= 0) {
                            // Compute a safe fallback from stored step/octave
                            try {
                                const step = parseInt(string.dataset.noteIndex, 10);
                                const oct = parseInt(string.dataset.octave, 10);
                                const tuning = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                                if (Number.isFinite(step)) {
                                    frequency = this.getFrequency(((step % tuning) + tuning) % tuning, Number.isFinite(oct) ? oct : 4, tuning);
                                }
                            } catch(_) {}
                        }
                        if (frequency && !isNaN(frequency) && isFinite(frequency) && frequency > 0) {
                            if (isNewStrumChord && this._hasActiveFreq(this.activeStrumOscillators, frequency, 3)) return;
                            // Route STRUM notes to the dedicated pool so they don't interfere with CHORD voices
                            this.playFrequency(frequency, string, 'strum');
                            
                            // Minimal visual feedback for speed on core only
                            const core = string.querySelector('.string-core');
                            if (core) {
                                core.style.transform = 'scaleY(1.15)';
                                core.style.filter = 'brightness(1.12)';
                                setTimeout(() => {
                                    core.style.transform = 'scaleY(1)';
                                    core.style.filter = 'brightness(1)';
                                }, 90);
                            }
                        }
                    }, index * strumDelay);
                });

                // Let the per-note auto-release handle note lengths so attacks have time to be heard
                // (Previously we forced an early stop at ~200ms which could mute long attacks.)

                // Restore chord-tone highlighting after the strum completes
                try {
                    const restoreHighlight = () => {
                        try { this.highlightKeyboardForColumn(columnElement); this.currentActiveColumnEl = columnElement; } catch(_) {}
                    };
                    if (strumHighlighted) setTimeout(restoreHighlight, Math.max(120, strumSpanMs));
                    else restoreHighlight();
                } catch(_) {}
                
                // Restore original settings if this was a locked chord
                if (originalSettings) {
                    // Defer restoration until after the strum completes and notes pass their attack/decay
                    const noteADMs = Math.max(
                        (this.envelope.attack + this.envelope.decay) * 1000,
                        (this.osc2Envelope.attack + this.osc2Envelope.decay) * 1000
                    );
                    const restoreDelay = Math.max(250, strumSpanMs + noteADMs + 50);
                    setTimeout(() => {
                        this.restoreSettings(originalSettings);
                        if (window.DEBUG_AUDIO) console.log('?? Restored original settings after locked chord playback');
                    }, restoreDelay);
                }
            }

            // New: Chords Play Mode implementation
            playChordChordsMode(columnElement, clientY){
                if (window.DEBUG_AUDIO) console.log('ðŸŽºðŸŽºðŸŽº playChordChordsMode CALLED - columnElement:', columnElement?.dataset?.chordId);
                if (!columnElement) return;
                try { this._markUserActivity(); } catch(_){ }
                
                try { this.ensureAudioContext && this.ensureAudioContext(); } catch(_){}
                
                // Different sustain behavior for sequencing vs manual play
                if (this._isSequencing) {
                    // During sequencing: don't set indefinite sustain, let HOLD duration control it
                    this._sustainActive = false;
                    this._chordsGestureActive = true;
                } else {
                    // Manual play: sustain gate active until mouseup/touchend
                    this._sustainActive = true;
                    this._chordsGestureActive = true;
                }
                // Mark slide active if enabled so tap-to-slide works immediately on subsequent taps
                this._chordSlideActive = !!this._chordSlideEnabled;
                // Lock the tapped octave for the duration of this gesture
                try {
                    const tappedForLock = this._getTappedOctave(columnElement, clientY);
                    if (this._slideOctaveLock == null && Number.isFinite(tappedForLock)) this._slideOctaveLock = tappedForLock;
                } catch(_) {}
                // Immediately update held bass to start gliding as the chord is engaged
                try { this._updateHeldBassForColumn(columnElement); } catch(_) { }
                // Reset any prior detunes from previous slides
                try { this._resetAllStringFrequencies(); } catch(_) { }
                // Prepare slide state
                this._chordSlideVoices && this._chordSlideVoices.clear && this._chordSlideVoices.clear();
                this._chordSlideStartColumn = columnElement;
                if (this._chordSlideActive){
                    this._chordSlideHoverColumn = columnElement;
                    this._chordSlideCommittedColumn = columnElement;
                    this._chordSlideHoverSince = performance.now();
                    this._markChordSlideActivity();
                }
                // Reset pointer last-hit so over-strum can begin cleanly
                try { this._pointerLastStringKey.set('mouse', null); } catch(_){ }

                // Build an NPC high chord from the tapped note within octaves C3..C5
                const npcLimit = this._getGlobalNpc ? this._getGlobalNpc() : (this._arp?.chordsNpc || this._arp?.npc || 3);
                const tapInfo = this._findTapRowInColumn(columnElement, clientY);
                let rowsToPlay = this._buildNpcHighChordFromTap(columnElement, tapInfo, npcLimit);

                // If a new chord is triggered, fade any old chord voices that are not common tones.
                const isNewChord = (columnElement !== this._lastChordColumnEl);
                if (isNewChord) {
                    try {
                        const newFreqs = [];
                        rowsToPlay.forEach(r=>{
                            let f = parseFloat(r.dataset.frequency);
                            if (!Number.isFinite(f) || f <= 0){
                                const step = parseInt(r.dataset.noteIndex,10);
                                const oct = parseInt(r.dataset.octave,10);
                                const tuning = this.currentTuning || 12;
                                if (Number.isFinite(step)) f = this.getFrequency(((step%tuning)+tuning)%tuning, Number.isFinite(oct)?oct:4, tuning);
                            }
                            if (Number.isFinite(f) && f>0) newFreqs.push(f);
                        });
                        this._fadeVoicesNotInSet(this.activeChordOscillators, 'chord', newFreqs, 3, 0.25);
                    } catch(_){ }
                    this._lastChordColumnEl = columnElement;
                }

        // Play selection simultaneously
        const groupId = ((this._chordSlideGroupId||0)+1) >>> 0; this._chordSlideGroupId = groupId;
        rowsToPlay.forEach(string => {
                    let frequency = parseFloat(string.dataset.frequency);
                    if (!frequency || !isFinite(frequency) || frequency <= 0){
                        try {
                            const step = parseInt(string.dataset.noteIndex,10);
                            const oct = parseInt(string.dataset.octave,10);
                            const tuning = this.currentTuning || 12;
                            if (Number.isFinite(step)) frequency = this.getFrequency(((step%tuning)+tuning)%tuning, Number.isFinite(oct)?oct:4, tuning);
                        } catch(_){ }
                    }
                        if (frequency && isFinite(frequency) && frequency>0){
                        if (isNewChord && this._hasActiveFreq(this.activeChordOscillators, frequency, 3)) return;
                    this.playFrequency(frequency, string, 'chord');
            try { if (this._chordSlideVoices) this._chordSlideVoices.set(string, { startFreq: frequency, startLog2: Math.log2(frequency), groupId }); } catch(_){ }
                        try{ string.classList.add('active'); setTimeout(()=> string.classList.remove('active'), 120); }catch(_){ }
                    }
                });

                // Ensure held bass is aligned after voices start (double-call is safe and ensures catch-up)
                try { this._updateHeldBassForColumn(columnElement); } catch(_){ }

                // Remember last voicing (use log2 frequency positions for distance)
                if (rowsToPlay && rowsToPlay.length){
                    const toPitch = (el)=>{
                        const f = parseFloat(el.dataset.frequency);
                        return (f && f>0) ? Math.log2(f) : null;
                    };
                    const pitches = rowsToPlay.map(toPitch).filter(v=> v!=null).sort((a,b)=>a-b);
                    const avgOct = (()=>{
                        const arr = rowsToPlay.map(r=> parseFloat(r.dataset.octave)).filter(Number.isFinite);
                        if (!arr.length) return 4;
                        return arr.reduce((a,b)=>a+b,0)/arr.length;
                    })();
                    this._lastChordVoicing = { pitches, avgOctave: avgOct };
                }

                try { this.highlightKeyboardForColumn(columnElement); this.currentActiveColumnEl = columnElement; } catch(_){}
                
                // Add automatic HOLD duration for CHORD mode
                try {
                    // Clear any existing chord hold timer
                    if (this._chordHoldTimer) {
                        clearTimeout(this._chordHoldTimer);
                        this._chordHoldTimer = null;
                    }
                    
                    // Get HOLD duration from universal control
                    const holdSelect = document.getElementById('universalHold') || document.getElementById('chordHold');
                    const holdValue = holdSelect ? holdSelect.value : 'bar:1';
                    const [kind, valStr] = String(holdValue).split(':');
                    const n = Math.max(1, parseInt(valStr || '1', 10));
                    
                    // Calculate hold duration in milliseconds
                    const bpmEl = document.getElementById('universalBpm');
                    const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                    const beatMs = 60000 / Math.max(20, bpm);
                    
                    // Get time signature with denominator awareness
                    const timeSignatureEl = document.getElementById('universalTimeSignature');
                    const tsRaw = timeSignatureEl ? String(timeSignatureEl.value||'4/4') : '4/4';
                    let tsNum=4, tsDen=4; try { const [n,d] = tsRaw.split('/').map(x=>parseInt(x,10)); if(Number.isFinite(n)&&n>0) tsNum=n; if(Number.isFinite(d)&&d>0) tsDen=d; } catch(_) {}
                    const beatsPerBar = (tsNum * 4) / tsDen;
                    const barMs = beatMs * beatsPerBar;
                    // HOLD strictly defines duration; enforce minimum of one quant step (1/8) so fastest change is 1/8 note
                    const quantMinMs = beatMs * 0.5; // 1/8 of 4/4 beat
                    const baseHoldMs = (kind === 'beat') ? n * beatMs : n * barMs;
                    const holdMs = Math.max(quantMinMs, baseHoldMs);
                    
                    // Set timer to automatically release chord after HOLD duration
                    this._chordHoldTimer = setTimeout(() => {
                        if (this._sustainActive && this._chordsGestureActive) {
                            this._sustainActive = false;
                            this._chordsGestureActive = false;
                            this._slideOctaveLock = null;
                            this.stopAllActiveNotes();
                        }
                        this._chordHoldTimer = null;
                    }, holdMs);
                } catch(err) {
                    console.warn('CHORD hold duration setup failed:', err);
                }
            }

            // Determine all chord degrees (EDO steps) for a column's chord model
            _getChordDegreesForColumn(column){
                try {
                    const id = column.dataset.chordId;
                    let idx = -1;
                    if (id) idx = (this.chordExtensions || []).findIndex(c => (String(c.id)===String(id)));
                    if (idx < 0 && column.dataset.originalPosition != null) {
                        const op = parseInt(column.dataset.originalPosition,10);
                        if (!isNaN(op) && op >= 0) idx = op;
                    }
                    const model = (idx>=0)? this.chordExtensions[idx] : null;
                    const EDO = (model?.fixedRootTuning) || this.currentTuning || 12;
                    let ints = Array.isArray(model?.intervals) ? model.intervals.slice() : [];
                    if (!ints.length) {
                        // Try derive from rendered steps
                        ints = this.getChordStepsForColumn(column);
                    }
                    // Unique and sort by semitone equivalence for stable order
                    const uniq = Array.from(new Set(ints)).map(s=> ((s%EDO)+EDO)%EDO);
                    uniq.sort((a,b)=> this.stepToSemitone(a, EDO) - this.stepToSemitone(b, EDO));
                    return uniq;
                } catch(_) {
                    // Fallback to a major triad mapping if model lookup fails
                    return [0,4,7].map(semi=> Math.round((semi * (this.currentTuning||12))/12));
                }
                // Schedule idle stop after activity
                try { this._markChordSlideActivity(); } catch(_){ }
            }

            // Find the closest string row to a tap inside a column
            _findTapRowInColumn(columnElement, clientY) {
                try {
                    if (!columnElement) return null;
                    const colRect = columnElement.getBoundingClientRect();
                    const container = columnElement.querySelector('.strings-column');
                    if (!container) return null;
                    const rows = Array.from(container.querySelectorAll('.string'));
                    if (!rows.length) return null;
                    const relY = clientY - colRect.top;
                    let best = null, bestDist = Infinity;
                    for (const r of rows) {
                        const rr = r.getBoundingClientRect();
                        const cy = (rr.top + rr.height/2) - colRect.top;
                        const d = Math.abs(cy - relY);
                        if (d < bestDist) { bestDist = d; best = r; }
                    }
                    if (!best) return null;
                    const edo = this.currentTuning || 12;
                    const oct = parseInt(best.dataset.octave||'NaN', 10);
                    let step = parseInt(best.dataset.edoStep||best.dataset.interval||'NaN', 10);
                    if (!Number.isFinite(step)) {
                        const nAbs = parseInt(best.dataset.noteIndex||'NaN', 10);
                        if (Number.isFinite(nAbs)) {
                            const rootAbs = this._getEffectiveColumnRootStep(columnElement);
                            step = ((nAbs - rootAbs) % edo + edo) % edo;
                        }
                    } else {
                        step = ((step % edo) + edo) % edo;
                    }
                    const f = parseFloat(best.dataset.frequency||'NaN');
                    return { row: best, octave: Number.isFinite(oct)?oct:null, step: Number.isFinite(step)?step:null, freq: Number.isFinite(f)?f:null };
                } catch(_) { return null; }
            }

            // Build NPC chord tones constrained to a single octave (C3..C5), respecting transpose and voice-leading
            _buildNpcHighChordFromTap(columnElement, tapInfo, npc) {
                try {
                    const out = [];
                    if (!columnElement || !tapInfo || !tapInfo.row) return out;
                    const edo = this.currentTuning || 12;
                    const all = Array.from(columnElement.querySelectorAll('.strings-column .string'));
                    if (!all.length) return out;

                    // Map rows by (octave|relativeStep) where relativeStep is against current effective root
                    const byKey = new Map();
                    const effRoot = this._getEffectiveColumnRootStep(columnElement);
                    for (const r of all) {
                        const o = parseInt(r.dataset.octave||'NaN', 10);
                        if (!Number.isFinite(o)) continue;
                        const nAbs = parseInt(r.dataset.noteIndex||'NaN', 10);
                        if (!Number.isFinite(nAbs)) continue;
                        const st = ((nAbs - effRoot) % edo + edo) % edo;
                        byKey.set(o + '|' + st, r);
                    }

                    // Desired degrees (unique, semitone-ordered), relative to the chord model (and thus effRoot)
                    let degs = this._getChordDegreesForColumn(columnElement) || [];
                    degs = Array.from(new Set(degs.map(s => ((s%edo)+edo)%edo)));
                    degs.sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo));

                    const want = Math.max(1, Math.min(64, npc|0));
                    const take = Math.min(want, degs.length);

                    // Determine a single target octave in [3..5] for all tones
                    const octFromTap = Number.isFinite(tapInfo.octave) ? tapInfo.octave : 4;
                    const lastAvg = (this._lastChordVoicing && Number.isFinite(this._lastChordVoicing.avgOctave))
                        ? this._lastChordVoicing.avgOctave : null;
                    const clamp35 = (o)=> Math.max(3, Math.min(5, o|0));

                    // Candidate octave order: nearest to last voicing, then tap, then center (4), then edges
                    const cand = [];
                    if (lastAvg != null) cand.push(clamp35(Math.round(lastAvg)));
                    cand.push(clamp35(octFromTap));
                    cand.push(4, 3, 5);
                    // Deduplicate preserving order
                    const candOcts = Array.from(new Set(cand));

                    // Try to find an octave that contains all requested degrees
                    let chosenRows = null;
                    let bestPartial = { rows: [], matches: -1, octave: null };
                    for (const o of candOcts) {
                        const rows = [];
                        let matches = 0;
                        for (let i=0;i<take;i++){
                            const d = degs[i];
                            const r = byKey.get(o + '|' + d);
                            if (r) { rows.push(r); matches++; }
                        }
                        if (matches === take) { chosenRows = rows; break; }
                        if (matches > bestPartial.matches) bestPartial = { rows, matches, octave: o };
                    }

                    if (!chosenRows) {
                        // Use the octave with the most matches to keep voicing consistent within a single octave
                        chosenRows = bestPartial.rows;
                    }

                    return Array.isArray(chosenRows) ? chosenRows.slice(0, take) : [];
                } catch(_) { return []; }
            }

            // Choose a voicing minimizing motion to previous chord and constrained to maxSpanOct octaves
            _pickNearestVoicingRows(column, desiredIntervals, anchorOct, lastLogPitches, maxSpanOct = 1.5){
                try {
                    const rows = Array.from(column.querySelectorAll('.strings-column .string'));
                    if (!rows.length) return [];
                    const tuning = this.currentTuning || 12;

                    // Degree -> candidate rows
                    const byDeg = new Map();
                    desiredIntervals.forEach(iv=> byDeg.set(((iv%tuning)+tuning)%tuning, []));
                    for (const r of rows){
                        const deg = parseInt(r.dataset.interval,10);
                        const oct = parseInt(r.dataset.octave,10);
                        if (!Number.isFinite(deg) || !Number.isFinite(oct)) continue;
                        const key = ((deg%tuning)+tuning)%tuning;
                        if (!byDeg.has(key)) continue;
                        // Exclude octave 2 from voice-leading candidates
                        if (oct >= 3) byDeg.get(key).push(r);
                    }
                    const degs = Array.from(byDeg.keys());
                    if (degs.length === 0) return [];
            // Sort candidates per degree by octave, then proximity to anchor
                    for (const [k, list] of byDeg.entries()){
                        list.sort((a,b)=>{
                            const oa = parseInt(a.dataset.octave,10)||0;
                            const ob = parseInt(b.dataset.octave,10)||0;
                if (oa !== ob) return oa - ob;
                return Math.abs(oa - anchorOct) - Math.abs(ob - anchorOct);
                        });
                    }

                    // Order degrees by semitone ascending for stable mapping to sorted previous pitches
                    degs.sort((a,b)=> this.stepToSemitone(a, tuning) - this.stepToSemitone(b, tuning));

                    // Build target pitch vector (log2) aligned to degree order
                    const buildTargets = (N)=>{
                        if (!Array.isArray(lastLogPitches) || lastLogPitches.length===0){
                            return null; // anchor-driven selection only
                        }
                        const prev = lastLogPitches.slice().sort((x,y)=>x-y);
                        const M = prev.length;
                        if (M === N) return prev;
                        const T = new Array(N);
                        // Map indices proportionally
                        for (let i=0;i<N;i++){
                            const t = (i*(M-1))/(N-1);
                            const lo = Math.floor(t), hi = Math.ceil(t);
                            if (lo===hi) T[i] = prev[lo]; else T[i] = (prev[lo] + prev[hi]) / 2;
                        }
                        return T;
                    };
                    const targets = buildTargets(degs.length);

                    // Greedy selection: per degree, choose row closest to target; avoid reusing the same element
                    const chosen = [];
                    const used = new Set();
                    const log2f = (el)=>{ const f=parseFloat(el.dataset.frequency)||0; return (f>0)? Math.log2(f) : null; };
                    degs.forEach((deg, i)=>{
                        const list = byDeg.get(deg) || [];
                        let best = null, bestCost = Infinity;
                        for (const r of list){
                            if (used.has(r)) continue;
                            const p = log2f(r); if (p==null) continue;
                            const oct = parseInt(r.dataset.octave,10)||0;
                            let cost;
                            if (targets){
                                cost = Math.abs(p - targets[i]) + 0.25*Math.abs(oct - anchorOct);
                            } else {
                                cost = Math.abs(oct - anchorOct) + 0.001*Math.abs((parseFloat(r.dataset.frequency)||0) - 0);
                            }
                            if (cost < bestCost){ bestCost = cost; best = r; }
                        }
                        if (best){ used.add(best); chosen.push(best); }
                    });
                    if (!chosen.length) return [];

                    // Span control with octave rolling
                    const toPitches = ()=> chosen.map(log2f).filter(v=>v!=null).sort((a,b)=>a-b);
                    const withinSpan = ()=>{
                        const octs = chosen.map(r=> parseInt(r.dataset.octave,10)||0).sort((a,b)=>a-b);
                        if (!octs.length) return true;
                        return (octs[octs.length-1] - octs[0]) <= maxSpanOct + 1e-6;
                    };
                    const tryShift = (index, dir)=>{
                        // dir: +1 move up to next higher candidate; -1 move down
                        const deg = degs[index];
                        const list = byDeg.get(deg) || [];
                        if (!list.length) return false;
                        const cur = chosen[index];
                        const pos = list.indexOf(cur);
                        let nextIdx = pos + dir;
                        while (nextIdx>=0 && nextIdx<list.length){
                            const cand = list[nextIdx];
                            if (!cand || chosen.includes(cand)) { nextIdx += dir; continue; }
                            chosen[index] = cand; return true;
                        }
                        return false;
                    };

                    let guard = 0;
                    while (!withinSpan() && guard < 16){
                        guard++;
                        const octs = chosen.map(r=> parseInt(r.dataset.octave,10)||0).sort((a,b)=>a-b);
                        const meanOct = octs.reduce((a,b)=>a+b,0)/octs.length;
                        // If drifting upward, raise the lowest degree; else lower the highest (within 3..5)
                        if (meanOct >= anchorOct){
                            // find index of chosen with lowest pitch
                            let minIdx = 0; let minVal = Infinity;
                            chosen.forEach((r,i)=>{ const v = parseInt(r.dataset.octave,10)||0; if (v<minVal){ minVal=v; minIdx=i; } });
                            if (!tryShift(minIdx, +1)) break;
                        } else {
                            let maxIdx = 0; let maxVal = -Infinity;
                            chosen.forEach((r,i)=>{ const v = parseInt(r.dataset.octave,10)||0; if (v>maxVal){ maxVal=v; maxIdx=i; } });
                            if (!tryShift(maxIdx, -1)) break;
                        }
                    }
                    return chosen;
                } catch(_) { return []; }
            }

            // Compute the set of current chord tones (relative steps) for a column
            getChordStepsForColumn(column){
                if (!column) return [];
                const lockedChord = this.lockedChords?.get(column);
                let tuningSize = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                // Gather distinct relative steps from rendered strings
                const strings = Array.from(column.querySelectorAll('.strings-column .string'));
                const relSteps = new Set();
                strings.forEach(row => {
                    const stepStr = row.dataset.edoStep;
                    if (stepStr != null) {
                        const s = ((parseInt(stepStr,10) % tuningSize)+tuningSize)%tuningSize;
                        relSteps.add(s);
                    } else {
                        // Fallback: compute from noteIndex and current root
                        const noteIdx = parseInt(row.dataset.noteIndex,10);
                        const root = this.currentRoot || 0;
                        const s = ((noteIdx - root) % tuningSize + tuningSize) % tuningSize;
                        relSteps.add(s);
                    }
                });
                return Array.from(relSteps.values());
            }

            // Light the keyboard keys/dots that match the current chord tones
            highlightKeyboardForSteps(steps, stepsEdo = null){
                const kb = document.querySelector('#rootGrid .piano-keyboard, #modalRootGrid .piano-keyboard');
                if (!kb) return;
                const kbEdo = this.currentTuning || 12;
                const srcEdo = (stepsEdo || kbEdo);
                const list = Array.isArray(steps) ? steps : Array.from(steps || []);

                // Clear previous marks
                kb.querySelectorAll('[data-step]').forEach(el=>{
                    el.classList.remove('chord-tone');
                    try { el.style.boxShadow = ''; el.style.outlineColor = ''; } catch(_){ }
                });

                if (!list.length) return;

                const norm = (v,m)=> ((v % m) + m) % m;
                list.forEach(step=>{
                    if (!Number.isFinite(step)) return;
                    let kbAbs = norm(step, srcEdo);
                    if (srcEdo !== kbEdo) {
                        const cents = (kbAbs * 1200) / srcEdo;
                        kbAbs = Math.round((cents * kbEdo) / 1200);
                        kbAbs = norm(kbAbs, kbEdo);
                    }
                    const semi = this.stepToSemitone(kbAbs, kbEdo);
                    const color = this.getChromaticColorForSemitone(semi);
                    if (kbEdo === 12) {
                        kb.querySelectorAll('[data-step]').forEach(el=>{
                            const ds = parseInt(el.dataset.step,10);
                            if ((ds % 12) === (kbAbs % 12)) {
                                el.classList.add('chord-tone');
                                try {
                                    el.style.boxShadow = `0 0 10px 3px ${color}99, 0 0 18px 6px ${color}55`;
                                    el.style.outlineColor = color;
                                } catch(_){ }
                            }
                        });
                    } else {
                        kb.querySelectorAll(`[data-step='${kbAbs}']`).forEach(el=>{
                            el.classList.add('chord-tone');
                            try {
                                el.style.boxShadow = `0 0 10px 3px ${color}99, 0 0 18px 6px ${color}55`;
                                el.style.outlineColor = color;
                            } catch(_){ }
                        });
                    }
                });
            }

            highlightKeyboardForColumn(column){
                // Throttle: only (re)highlight when the effective chord identity changes
                try {
                    const chordId = (column && (column.dataset.chordId || column.dataset.originalPosition))
                        ? String(column.dataset.chordId || column.dataset.originalPosition)
                        : (column ? (column.querySelector('.extension-header .chord-name')?.textContent||'').trim() : '');
                    let stepsSig = '';
                    try {
                        const rows = column ? Array.from(column.querySelectorAll('.strings-column .string')) : [];
                        // Include relative step (edoStep) and octave to reflect voicing shape
                        stepsSig = rows.map(r => `${r.dataset.edoStep ?? 'x'}@${r.dataset.octave ?? ''}`).join('|');
                    } catch(_) { stepsSig = ''; }
                    const g = (this.transposeDelta||0)|0;
                    const l = column ? ((+column.dataset.localTranspose||0)|0) : 0;
                    const edo = (this.currentTuning||12)|0;
                    const key = `id:${chordId}|steps:${stepsSig}|g:${g}|l:${l}|edo:${edo}`;
                    if (this._lastHighlightKey === key) return; // skip redundant highlights during strums
                    this._lastHighlightKey = key;
                } catch(_) {}
                console.log('=== HIGHLIGHT FUNCTION CALLED ===');
                console.log('this.transposeDelta at start of highlight function:', this.transposeDelta);
                console.log('column:', column);
                
                const kb = document.querySelector('#rootGrid .piano-keyboard, #modalRootGrid .piano-keyboard');
                if (!kb || !column) {
                    console.log('Missing kb or column:', {kb: !!kb, column: !!column});
                    return;
                }
                
                // Get chord model and optional locked snapshot
                const kbEdo = this.currentTuning || 12;
                let chordIntervals = [];
                let tuningSize = kbEdo;
                let baseRoot = 0;
                let model = null;
                const lockedChord = this.lockedChords?.get(column) || null;

                try {
                    const id = column.dataset.chordId;
                    let candidate = null;
                    if (id) {
                        candidate = (this.chordExtensions || []).find(c => String(c.id) === String(id));
                    }
                    if (!candidate && column.dataset.originalPosition != null) {
                        const op = parseInt(column.dataset.originalPosition,10);
                        if (!isNaN(op) && op >= 0) candidate = this.chordExtensions?.[op] || null;
                    }
                    // Final fallback by visible name, only among non-repeat entries
                    if (!candidate) {
                        const label = (column.querySelector('.extension-header .chord-name')?.textContent || '').trim();
                        candidate = (this.chordExtensions || []).find(c => !c?.isRepeatMarker && String(c?.name||'').trim() === label) || null;
                    }
                    // Guard against accidentally selecting repeat markers or malformed entries
                    if (candidate && candidate.isRepeatMarker) {
                        console.warn('HIGHLIGHT: resolved candidate is a repeat marker, ignoring for model:', candidate.name);
                        candidate = null;
                    }
                    model = candidate || null;
                    console.log('HIGHLIGHT DEBUG: model =', model, 'lockedChord =', !!lockedChord);
                    if (model) {
                        console.log('HIGHLIGHT DEBUG: model.fixedRootStepAbs =', model.fixedRootStepAbs, 'model.intervals =', model.intervals, 'model.fixedRootTuning =', model.fixedRootTuning);
                    }
                } catch(e) { console.error('HIGHLIGHT ERROR (model lookup):', e); }
                        try { window._ensureModalAspectResize && window._ensureModalAspectResize(modal); } catch(_) {}

                if (model && Array.isArray(model.intervals)) {
                    chordIntervals = [...model.intervals];
                    tuningSize = model.fixedRootTuning || kbEdo;
                } else {
                    // Fallback to rendered steps if model missing
                    chordIntervals = this.getChordStepsForColumn(column);
                    tuningSize = kbEdo;
                }

                // Compute effective baseRoot to align lights with audio/name
                const edo = tuningSize;
                const norm = (v,m)=> ((v % m) + m) % m;
                const g = norm((this.transposeDelta || 0), edo);
                const l = norm((+column.dataset.localTranspose || 0), edo);

                if (lockedChord && typeof lockedChord.lockedRoot === 'number') {
                    // Locked chords preserve exact pitch; follow local transpose only
                    baseRoot = norm((lockedChord.lockedRoot || 0) + l, edo);
                } else if (model && typeof model.fixedRootStepAbs === 'number' && model.fixedRootTuning) {
                    baseRoot = norm((model.fixedRootStepAbs % edo) + g + l, edo);
                } else {
                    baseRoot = norm((this.currentRoot || 0) + g + l, edo);
                }
                console.log('HIGHLIGHT ROOT:', {baseRoot, edo, g, l, tuningSize});
                
                // Clear previous chord-tone marks and any inline glow
                kb.querySelectorAll('[data-step]').forEach(el=>{
                    el.classList.remove('chord-tone');
                    try { el.style.boxShadow = ''; el.style.outlineColor = ''; } catch(_){}
                });

                // Apply colored glow per chord tone (by pitch class/semitone color)
                chordIntervals.forEach(rel =>{
                    // Compute absolute step: baseRoot + interval
                    const abs = ((baseRoot + rel) % tuningSize + tuningSize) % tuningSize;
                    console.log('HIGHLIGHT APPLY: rel =', rel, 'baseRoot =', baseRoot, 'abs =', abs);
                    
                    // Map to keyboard EDO if needed
                    let kbAbs = abs;
                    if (tuningSize !== kbEdo) {
                        const cents = (abs * 1200) / tuningSize;
                        kbAbs = Math.round((cents * kbEdo) / 1200);
                        kbAbs = ((kbAbs % kbEdo) + kbEdo) % kbEdo;
                    }
                    
                    const semi = this.stepToSemitone(kbAbs, kbEdo);
                    const color = this.getChromaticColorForSemitone(semi);
                    if (kbEdo === 12) {
                        // Match any element whose data-step % 12 equals kbAbs % 12
                        kb.querySelectorAll('[data-step]').forEach(el=>{
                            const ds = parseInt(el.dataset.step,10);
                            if ((ds % 12) === (kbAbs % 12)) {
                                el.classList.add('chord-tone');
                                try {
                                    el.style.boxShadow = `0 0 10px 3px ${color}99, 0 0 18px 6px ${color}55`;
                                    el.style.outlineColor = color;
                                } catch(_){ }
                            }
                        });
                    } else {
                        kb.querySelectorAll(`[data-step='${kbAbs}']`).forEach(el=>{
                        el.classList.add('chord-tone');
                        try {
                            el.style.boxShadow = `0 0 10px 3px ${color}99, 0 0 18px 6px ${color}55`;
                            el.style.outlineColor = color;
                        } catch(_){ }
                    });
                    }
                });
            }

            // Resolve the active column element to mutate when editing via keyboard
            getActiveColumnElement(){
                if (this.currentActiveColumnEl && document.body.contains(this.currentActiveColumnEl)) return this.currentActiveColumnEl;
                // Fallback: use currentPlayingColumn id
                if (this.currentPlayingColumn != null) {
                    const el = document.querySelector(`[data-column="${this.currentPlayingColumn}"]`);
                    if (el) return el;
                }
                // No active column
                return null;
            }

            // Lookup a chord column DOM element by its stable id
            getColumnByChordId(id){
                if (!id) return null;
                try { return document.querySelector(`.extension-column[data-chord-id='${id}']`); } catch(_) { return null; }
            }

            // Toggle an absolute keyboard step in the currently active chord
            toggleNoteInActiveChord(absStep){
                console.log('=== TOGGLE NOTE DEBUG START ===');
                console.log('toggleNoteInActiveChord called with absStep:', absStep);
                console.log('Current transposeDelta:', this.transposeDelta);
                console.log('Current currentTuning:', this.currentTuning);
                console.log('Current chordCreationMode:', this.chordCreationMode);
                // Re-entrancy guard
                if (this._toggling) return; this._toggling = true; setTimeout(()=>{ this._toggling = false; }, 0);
                const column = this.getActiveColumnElement();
                if (!column) return;
                // Allow editing even if previously locked (universal editor model)
                // Determine tuning and base root for this column
                const lockedChord = this.lockedChords?.get(column) || null;
                let tuningSize = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                // Compute base root exactly like highlight/audio, in EFFECTIVE space (includes transpose as applicable)
                let baseRoot = 0;
                let resolvedModel = null;
                try {
                    // Resolve chord model if present
                    let idxModel = column.dataset.originalPosition != null ? parseInt(column.dataset.originalPosition,10) : -1;
                    if (isNaN(idxModel) || idxModel < 0) {
                        const id = column.dataset.chordId;
                        idxModel = (this.chordExtensions || []).findIndex(c => (c.id===id));
                    }
                    const chordModel = (idxModel>=0)? this.chordExtensions[idxModel] : null;
                    resolvedModel = chordModel;
                    console.log('BASEROOT CALCULATION: lockedChord =', !!lockedChord, 'chordModel =', !!chordModel);
                    console.log('BASEROOT CALCULATION: this.currentRoot =', this.currentRoot, 'this.transposeDelta =', this.transposeDelta);
                    if (lockedChord) {
                        const edo = lockedChord.lockedTuning || tuningSize;
                        const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                        baseRoot = ((lockedChord.lockedRoot ?? 0) + localDelta) % edo;
                        tuningSize = edo;
                        console.log('BASEROOT CALCULATION: lockedChord path, baseRoot =', baseRoot);
                    } else if (chordModel && typeof chordModel.fixedRootStepAbs === 'number' && chordModel.fixedRootTuning) {
                        tuningSize = chordModel.fixedRootTuning;
                        const edo = tuningSize;
                        const g = ((this.transposeDelta || 0) % edo + edo) % edo; // INCLUDE global transpose to match effective clicks
                        const l = ((+column.dataset.localTranspose || 0) % edo + edo) % edo; // INCLUDE local transpose
                        baseRoot = (((chordModel.fixedRootStepAbs % edo) + g + l) % edo + edo) % edo;
                        console.log('BASEROOT CALCULATION: fixedRoot path, fixedRootStepAbs =', chordModel.fixedRootStepAbs, 'g =', g, 'l =', l, 'baseRoot =', baseRoot);
                    } else {
                        const edo = tuningSize;
                        const g = ((this.transposeDelta || 0) % edo + edo) % edo; // INCLUDE global transpose
                        const l = ((+column.dataset.localTranspose || 0) % edo + edo) % edo; // INCLUDE local transpose
                        const start = (this.currentRoot ?? 0) % edo;
                        baseRoot = (((start + g + l) % edo) + edo) % edo;
                        console.log('BASEROOT CALCULATION: default path, start =', start, 'g =', g, 'l =', l, 'baseRoot =', baseRoot);
                    }
                } catch {}
                // If this is a blank custom chord, the first note becomes the root
                try {
                    const chordModel = resolvedModel;
                    const isBlank = !!(chordModel && chordModel.isCustom && (!Array.isArray(chordModel.intervals) || chordModel.intervals.length === 0)
                        && !(typeof chordModel.fixedRootStepAbs === 'number'));
                    if (!lockedChord && isBlank) {
                        const edo = tuningSize || this.currentTuning || 12;
                        const g = ((this.transposeDelta || 0) % edo + edo) % edo;
                        const l = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                        const abs = ((absStep % edo) + edo) % edo;
                        const rootModel = ((abs - g - l) % edo + edo) % edo;
                        chordModel.fixedRootStepAbs = rootModel;
                        chordModel.fixedRootTuning = edo;
                        chordModel.isCustom = true;
                        chordModel.intervals = [0];
                        chordModel.lastTuning = edo;
                        if (!Array.isArray(chordModel.originalIntervals) || !chordModel.originalIntervals.length) {
                            chordModel.originalIntervals = [0];
                        }
                        baseRoot = abs;
                    }
                } catch(_) {}
                // Define keyboard EDO for reference
                const kbEdo = this.currentTuning || 12;
                // If the chord's model EDO differs from the keyboard, migrate the chord model to the keyboard EDO first
                // so that adding micro-steps never snaps back to the old EDO grid.
                if (!lockedChord && kbEdo !== tuningSize) {
                    try {
                        let idx = column.dataset.originalPosition != null ? parseInt(column.dataset.originalPosition,10) : this.findChordPosition?.(column) ?? -1;
                        if (isNaN(idx) || idx < 0) {
                            const id = column.dataset.chordId;
                            idx = (this.chordExtensions || []).findIndex(c => (c.id===id));
                        }
                        if (idx >= 0) {
                            const chordModel = this.chordExtensions[idx];
                            const mapStep = (s, fromEdo, toEdo) => {
                                const cents = (s * 1200) / fromEdo;
                                return ((Math.round((cents * toEdo) / 1200) % toEdo) + toEdo) % toEdo;
                            };
                            // Migrate relative intervals
                            if (Array.isArray(chordModel.intervals)) {
                                chordModel.intervals = chordModel.intervals.map(v => mapStep(((v % tuningSize)+tuningSize)%tuningSize, tuningSize, kbEdo));
                            }
                            // Migrate fixed root if present; otherwise map baseRoot
                            if (typeof chordModel.fixedRootStepAbs === 'number' && chordModel.fixedRootTuning) {
                                chordModel.fixedRootStepAbs = mapStep(((chordModel.fixedRootStepAbs % tuningSize)+tuningSize)%tuningSize, tuningSize, kbEdo);
                                chordModel.fixedRootTuning = kbEdo;
                            } else {
                                baseRoot = mapStep(baseRoot, tuningSize, kbEdo);
                            }
                            chordModel.isCustom = true;
                            // Adopt new tuning size for subsequent calculations
                            tuningSize = kbEdo;
                        }
                    } catch(_) {}
                }
                let absInTarget = ((absStep % tuningSize)+tuningSize)%tuningSize;
                // Compute relative step to toggle
                const rel = ((absInTarget - baseRoot) % tuningSize + tuningSize) % tuningSize;
                console.log('=== INTERVAL CALCULATION ===');
                console.log('toggleNoteInActiveChord: absStep =', absStep, 'baseRoot =', baseRoot, 'rel =', rel, 'tuningSize =', tuningSize);
                console.log('absInTarget =', absInTarget);
                // Get the chord model behind this column
                let idx = column.dataset.originalPosition != null ? parseInt(column.dataset.originalPosition,10) : this.findChordPosition?.(column) ?? -1;
                if (isNaN(idx) || idx < 0 || idx >= (this.chordExtensions?.length||0)) {
                    // Attempt alternative: match by dataset.chordId
                    const id = column.dataset.chordId;
                    idx = (this.chordExtensions || []).findIndex(c => (c.id===id));
                }
                if (idx < 0) return;
                const chordModel2 = this.chordExtensions[idx];
                if (!chordModel2) return;
                const prevIntervals = (chordModel2 && Array.isArray(chordModel2.intervals)) ? chordModel2.intervals.slice() : [];
                const wasCustom = !!(chordModel2 && chordModel2.isCustom);
                // Work on a set of intervals in this tuning; intervals are already EDO steps for customs
                const set = new Set((chordModel2.intervals || []).map(v => ((v % tuningSize)+tuningSize)%tuningSize));
                console.log('=== CHORD MODEL DEBUG ===');
                console.log('chordModel2.intervals (before) =', chordModel2.intervals);
                console.log('chordModel2.fixedRootStepAbs =', chordModel2.fixedRootStepAbs);
                console.log('toggleNoteInActiveChord: current intervals before toggle =', Array.from(set));
                // Toggle presence including the current root; allow removing it to enable re-rooting by lowest note
                const preSize = set.size;
                const hadRel = set.has(rel);
                if (hadRel) set.delete(rel); else set.add(rel);
                // If this was the first tone added to a truly blank chord, make that tone the root immediately
                if (preSize === 0 && !hadRel && set.size === 1) {
                    // Override baseRoot to the clicked absolute step so naming matches what you hear
                    baseRoot = absInTarget;
                    // Reset intervals so the selected tone is the root (0)
                    set.clear();
                    set.add(0);
                    try { console.log('FIRST NOTE: set root to abs', baseRoot, 'and zeroed intervals'); } catch(_) {}
                }
                // ONLY re-root if we're in chord creation mode ([+] button) and the chord truly only has a root note
                // Do NOT re-root chords loaded from SEQ or other sources that already have full intervals
                else if (preSize === 1 && !hadRel && this.chordCreationMode) {
                    const prevWasExactlyZero = (prevIntervals.length === 1) && ((((prevIntervals[0] % tuningSize)+tuningSize)%tuningSize) === 0);
                    const isNonZeroClick = (((rel % tuningSize)+tuningSize)%tuningSize) !== 0;
                    if (prevWasExactlyZero && isNonZeroClick && !wasCustom) {
                        baseRoot = absInTarget;
                        set.clear();
                        set.add(0);
                    }
                }
                console.log('toggleNoteInActiveChord: intervals after toggle =', Array.from(set));
                // Allow empty set temporarily (blank chord) until user adds notes
                const relSorted = Array.from(set.values()).sort((a,b)=>{
                    const sa = this.stepToSemitone(a, tuningSize);
                    const sb = this.stepToSemitone(b, tuningSize);
                    return sa - sb;
                });
                if (relSorted.length === 0) {
                    chordModel2.intervals = [];
                    delete chordModel2.fixedRootStepAbs;
                    delete chordModel2.fixedRootTuning;
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                    this.generateStringsForColumn(column, [], true);
                    try {
                        const nameEl = column.querySelector('.extension-header .chord-name');
                        nameEl.textContent = 'New';
                        nameEl.dataset.lockedName = nameEl.textContent;
                    } catch {}
                    try { this.highlightKeyboardForColumn(column); } catch {}
                    // If this emptied chord is the latest created, mark it pending again for inheritance
                    try {
                        const thisId = column.dataset.chordId;
                        if (thisId) {
                            this.pendingBlankChordId = thisId;
                            this.pendingBlankChordStrumEligible = false;
                        }
                    } catch(_) {}
                    this._scheduleEditSave(column);
                    return;
                }
                // Choose a musical root by best quality in 12-TET space, then normalize
                const absSet = relSorted.map(v => ((baseRoot + v) % tuningSize + tuningSize) % tuningSize);
                // Normalize RELATIVE to the effective baseRoot so we don't bake transpose into stored intervals
                const preservedRoot = ((baseRoot % tuningSize) + tuningSize) % tuningSize;
                const normalized = absSet.map(s => ((s - preservedRoot) % tuningSize + tuningSize) % tuningSize).sort((a,b)=>{
                    const sa = this.stepToSemitone(a, tuningSize);
                    const sb = this.stepToSemitone(b, tuningSize);
                    return sa - sb;
                });
                console.log('NORMALIZATION DEBUG: absSet =', absSet, 'preservedRoot =', preservedRoot, 'normalized =', normalized);
                chordModel2.intervals = normalized;
                // Store the untransposed absolute base root to avoid double-applying g/l later
                console.log('FIXEDROOT RECALC: About to recalculate fixedRootStepAbs');
                console.log('FIXEDROOT RECALC: preservedRoot =', preservedRoot, 'baseRoot =', baseRoot);
                console.log('FIXEDROOT RECALC: OLD fixedRootStepAbs =', chordModel2.fixedRootStepAbs);
                try {
                    const edoStore = tuningSize;
                    const norm = (v,m)=> ((v % m) + m) % m;
                    const g = norm((this.transposeDelta || 0), edoStore);
                    const lcl = norm((+column.dataset.localTranspose || 0), edoStore);
                    chordModel2.fixedRootStepAbs = norm(preservedRoot - g - lcl, edoStore);
                    console.log('FIXEDROOT RECALC: g =', g, 'lcl =', lcl);
                    console.log('FIXEDROOT RECALC: NEW fixedRootStepAbs =', chordModel2.fixedRootStepAbs);
                } catch(_) {
                    chordModel2.fixedRootStepAbs = preservedRoot;
                }
                chordModel2.fixedRootTuning = tuningSize;
                // Treat any chord that has been edited from the keyboard as a custom chord in EDO steps
                chordModel2.isCustom = true;
                console.log('=== FINAL RESULT ===');
                console.log('TOGGLE NOTE END: Updated chord fixedRootStepAbs =', chordModel2.fixedRootStepAbs, 'intervals =', chordModel2.intervals);
                console.log('=== TOGGLE NOTE DEBUG END ===');
                // Build absolute steps for naming in EFFECTIVE space so the header shows the heard root (includes local/global)
                const absForName = [baseRoot, ...normalized.map(x=> ((baseRoot + x) % tuningSize + tuningSize) % tuningSize)];
                const newName = this.computeFullChordNameFromAbsoluteSteps(absForName, tuningSize);
                // Update header text to always include computed root (from lowest note)
                try {
                    const nameEl = column.querySelector('.extension-header .chord-name');
                    nameEl.textContent = newName;
                    nameEl.dataset.lockedName = nameEl.textContent;
                } catch {}
                // Persist the new name on the chord model so future regenerations keep it
                try { chordModel2.name = newName; } catch {}
                // First time we add notes to the pending blank chord, clear the pending flag
                try {
                    if (this.pendingBlankChordId && String(column.dataset.chordId) === String(this.pendingBlankChordId)) {
                        this.pendingBlankChordId = null;
                        this.pendingBlankChordStrumEligible = false;
                    }
                } catch(_) {}
                // Regenerate strings for this column only; drop exact snapshot so changes apply
                if (lockedChord && lockedChord.exactFrequencies) lockedChord.exactFrequencies = [];
                const oldContainer = column.querySelector('.strings-column');
                if (oldContainer) oldContainer.remove();
                if (lockedChord) this.generateStringsForColumnWithLockedSettings(column, chordModel2.intervals, lockedChord);
                else this.generateStringsForColumn(column, chordModel2.intervals, chordModel2.isCustom||false);
                // Refresh keyboard highlight
                try { this.highlightKeyboardForColumn(column); } catch {}
                this._scheduleEditSave(column);
                // Lightly preview the updated chord
                try {
                    const rows = Array.from(column.querySelectorAll('.strings-column .string'));
                    rows.slice(0, Math.min(rows.length, 6)).forEach((row, i)=>{
                        const f = parseFloat(row.dataset.frequency);
                        if (!isNaN(f)) setTimeout(()=> this.playFrequency(f, row, 'chord'), i*10);
                    });
                } catch {}
            }

            async playFrequency(frequency, element, sourceType = 'default', velocityOverride = null) {
                if (window.DEBUG_AUDIO) console.log('playFrequency called with:', frequency, 'Hz', element ? 'element present' : 'no element', 'source:', sourceType);
                
                // START TRANSPORT CLOCK once if needed; don't re-phase while already running
                // ONLY start transport when PLAY is active (isSequencing) - never during strum-only mode
                try {
                    if (this._isSequencing) {
                        const running = !!(this._arpTransport && this._arpTransport.running);
                        if ((this.chordsEnabled || this.arpEnabled) && !running) {
                            this._startArpTransport();
                        }
                    }
                } catch(_) {}
                
                // Validate frequency before processing
                if (!frequency || isNaN(frequency) || !isFinite(frequency) || frequency <= 0) {
                    console.error('Invalid frequency passed to playFrequency:', frequency);
                    return;
                }

                // Ensure AudioContext is ready
                const audioReady = await this.ensureAudioContext();
                if (!audioReady) {
                    console.warn('AudioContext not ready, skipping playback');
                    return;
                }
                
                // Select appropriate oscillator pool and per-instrument config
                const rawType = String(sourceType || 'default');
                const baseType = rawType.startsWith('arp') ? 'arp' : rawType;
                const instrumentKey = rawType;
                let oscillatorPool; let inst = null; let octaveOffset = 0;
                switch (baseType) {
                    case 'strum':
                        oscillatorPool = this.activeStrumOscillators; inst = { a: this.instruments.strum1, b: this.instruments.strum2 };
                        // STRUM notes play one octave higher during PLAY mode
                        octaveOffset = this._isSequencing ? 1 : 0; break;
                    case 'bells':
                        oscillatorPool = this.activeBellsOscillators; inst = { a: this.instruments.bells, b: null }; break;
                    case 'chord':
                        oscillatorPool = this.activeChordOscillators; inst = { a: this.instruments.chord, b: null }; break;
                    case 'arp':
                        oscillatorPool = this.activeArpOscillators; inst = { a: (this.instruments[instrumentKey] || this.instruments.arp), b: null }; break;
                    case 'bass':
                        oscillatorPool = this.activeBassOscillators; inst = { a: this.instruments.bass, b: null }; break;
                    default:
                        oscillatorPool = this.activeOscillators; inst = { a: this.instruments.strum1, b: this.instruments.strum2 }; break;
                }
                // Per-window JAM oscillator overrides
                try {
                    if (baseType === 'bells' && safeElement && safeElement.__bellsInst) {
                        inst = { a: safeElement.__bellsInst, b: null };
                    }
                } catch(_){ }
                
                // Enforce instrument pitch ranges
                const tuning = this.currentTuning || 12;
                const cStep = this.semitoneToStep(0, tuning);
                const c1 = this.getFrequency(cStep, 1, tuning);
                const c3 = this.getFrequency(cStep, 3, tuning);
                const c5 = this.getFrequency(cStep, 5, tuning);
                const c9 = this.getFrequency(cStep, 9, tuning);
                const nyquist = this.audioContext ? (this.audioContext.sampleRate / 2) : 24000;
                const safeMax = Math.max(1000, nyquist * 0.98);
                const safeMin = 10;
                let fClamped = frequency;
                if (baseType === 'bass') {
                    // Clamp to C1..C3 via nearest octave displacement
                    const min = Math.min(c1, c3), max = Math.max(c1, c3);
                    while (fClamped < min) fClamped *= 2;
                    while (fClamped > max) fClamped /= 2;
                } else if (baseType === 'chord') {
                    // CHORDS low register: C3..C5
                    const min = Math.min(c3, c5), max = Math.max(c3, c5);
                    while (fClamped < min) fClamped *= 2;
                    while (fClamped > max) fClamped /= 2;
                } else if (baseType === 'arp' || baseType === 'strum' || baseType === 'bells') {
                    // Lead/strum range: C3..C9
                    const min = Math.min(c3, c9), max = Math.max(c3, c9);
                    while (fClamped < min) fClamped *= 2;
                    while (fClamped > max) fClamped /= 2;
                }
                // Apply octave offset then clamp once more to instrument range and Nyquist
                let adjustedFrequency = fClamped * Math.pow(2, octaveOffset);
                if (baseType === 'bass') {
                    const min = Math.min(c1, c3), max = Math.max(c1, c3);
                    while (adjustedFrequency < min) adjustedFrequency *= 2;
                    while (adjustedFrequency > max) adjustedFrequency /= 2;
                } else if (baseType === 'chord') {
                    const min = Math.min(c3, c5), max = Math.max(c3, c5);
                    while (adjustedFrequency < min) adjustedFrequency *= 2;
                    while (adjustedFrequency > max) adjustedFrequency /= 2;
                } else if (baseType === 'arp' || baseType === 'strum' || baseType === 'bells') {
                    const min = Math.min(c3, c9), max = Math.max(c3, c9);
                    while (adjustedFrequency < min) adjustedFrequency *= 2;
                    while (adjustedFrequency > max) adjustedFrequency /= 2;
                }
                // Final safety clamp to avoid aliasing
                adjustedFrequency = Math.max(safeMin, Math.min(safeMax, adjustedFrequency));
                
                // Apply volume level based on source type (chords 25% quieter)
                let volumeMultiplier = 1.0;
                switch (baseType) {
                    case 'chord':
                        volumeMultiplier = 0.75; // 25% quieter
                        break;
                    case 'strum':
                    case 'arp':
                    case 'bass':
                    default:
                        volumeMultiplier = 1.0; // Full volume
                        break;
                }

                // Apply per-note velocity (override wins; otherwise infer from element dataset/class).
                const clampVel = (v) => {
                    const n = parseInt(v, 10);
                    return Number.isFinite(n) ? Math.max(0, Math.min(127, n)) : null;
                };
                let velValue = clampVel(velocityOverride);
                if (velValue == null) {
                    try {
                        const fromEl = window.getStepVelocity ? window.getStepVelocity(element) : null;
                        velValue = clampVel(fromEl);
                    } catch(_) {}
                }
                const velocityMultiplier = (velValue == null) ? 1.0 : Math.max(0, Math.min(1, velValue / 127));
                
                if (window.DEBUG_AUDIO) console.log(`[${sourceType.toUpperCase()}] Playing ${frequency}Hz -> ${adjustedFrequency}Hz (octave offset: ${octaveOffset}, volume: ${Math.round(volumeMultiplier * 100)}%)`);
                
                // Check if this string belongs to a piano-locked chord and apply those settings
                const isDomEl = element && typeof element === 'object' && (element.closest || element.classList || element.querySelector);
                const safeElement = isDomEl ? element : null;
                const columnElement = safeElement && safeElement.closest ? safeElement.closest('.extension-column') : null;
                let pianoLockedData = null;
                let originalSettings = null;
                
                if (columnElement) {
                    try {
                        const relSteps = this.getChordStepsForColumn(columnElement);
                        const chordData = {
                            name: (columnElement.querySelector('.extension-header .chord-name')?.textContent||'').trim(),
                            quality: this.currentQuality,
                            intervals: Array.isArray(relSteps) ? relSteps : []
                        };
                        pianoLockedData = this.findPianoLockData(chordData);
                    } catch(_) {}
                }
                
                if (pianoLockedData) {
                    console.log('ðŸŽ¹ Applying piano-locked settings for playback:', pianoLockedData.chordName);
                    
                    // Store current settings for immediate restoration
                    originalSettings = {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 },
                        envelope: { ...this.envelope },
                        osc2Envelope: { ...this.osc2Envelope },
                        reverb: { ...this.reverb },
                        panning: { ...this.panning },
                        volume: this.volume,
                        masterVolume: this.masterVolume
                    };
                    
                    // Apply piano-locked settings temporarily (UI DOES NOT CHANGE)
                    this.applyPianoLockedSettings(pianoLockedData);
                }
                
                // Bass is monophonic: stop any existing bass voices before starting a new one
                if (baseType === 'bass' && oscillatorPool && oscillatorPool.size > 0) {
                    try {
                        const keys = Array.from(oscillatorPool.keys());
                        for (const k of keys) { if (k !== frequency) this.stopFrequency(k, null, 'bass'); }
                    } catch(_) {}
                }

                // If oscillator already exists in this pool, stop it first to prevent overlap
                if (oscillatorPool.has(frequency)) {
                    this.stopFrequency(frequency, safeElement, sourceType);
                }
                
                if (!this.audioContext) return;
                
                // Create dual oscillators (or single) with separate envelopes
                let osc1, osc2;
                let peak1 = null;
                let peak2 = null;
                let dcBlockVoice = null;
                const osc1Envelope = this.audioContext.createGain();
                const osc2Envelope = this.audioContext.createGain();
                const osc1Gain = this.audioContext.createGain();
                const osc2Gain = this.audioContext.createGain();
                const finalMixer = this.audioContext.createGain();
                
                // Create oscillator 1 (or noise)
                const o1 = inst?.a?.osc || this.oscillators.osc1;
                if (o1.type === 'noise') {
                    osc1 = this.createNoiseSource();
                } else {
                    osc1 = this.audioContext.createOscillator();
                    const t1 = o1.type;
                    if (['sine','sawtooth','square','pulse','fullrect','halfrect','parabolic','stair'].includes(t1)) {
                        osc1.setPeriodicWave(this.getCustomPeriodicWave(t1, o1.pulseWidth, o1.shapeWidth));
                    } else { osc1.type = t1; }
                    const totalDetune1 = (o1.detune||0) + ((o1.coarse||0) * (1200 / tuning));
                    let freq1 = adjustedFrequency * Math.pow(2, (o1.octave||0) + (totalDetune1 / 1200));
                    freq1 = Math.max(safeMin, Math.min(safeMax, freq1));
                    osc1.frequency.setValueAtTime(freq1, this.audioContext.currentTime);
                }
                
                // Create oscillator 2 (or noise)
                const useSecond = (baseType === 'strum' || baseType === 'default');
                const o2 = inst?.b?.osc || this.oscillators.osc2;
                if (useSecond && o2 && o2.type === 'noise') {
                    osc2 = this.createNoiseSource();
                } else if (useSecond && o2) {
                    osc2 = this.audioContext.createOscillator();
                    const t2 = o2.type;
                    if (['sine','sawtooth','square','pulse','fullrect','halfrect','parabolic','stair'].includes(t2)) {
                        osc2.setPeriodicWave(this.getCustomPeriodicWave(t2, o2.pulseWidth, o2.shapeWidth));
                    } else { osc2.type = t2; }
                    const totalDetune2 = (o2.detune||0) + ((o2.coarse||0) * (1200 / tuning));
                    let freq2 = adjustedFrequency * Math.pow(2, (o2.octave||0) + (totalDetune2 / 1200));
                    freq2 = Math.max(safeMin, Math.min(safeMax, freq2));
                    osc2.frequency.setValueAtTime(freq2, this.audioContext.currentTime);
                } else {
                    // No second osc for chord/arp/bass
                    osc2 = this.audioContext.createOscillator();
                    osc2.type = 'sine';
                    osc2.frequency.setValueAtTime(0.0001, this.audioContext.currentTime);
                    osc2Gain.gain.value = 0; // muted
                }
                
                // Set oscillator levels with volume + velocity multipliers applied
                osc1Gain.gain.value = (inst?.a?.osc?.level ?? this.oscillators.osc1.level) * volumeMultiplier * velocityMultiplier;
                osc2Gain.gain.value = (inst?.b?.osc?.level ?? this.oscillators.osc2.level) * volumeMultiplier * velocityMultiplier;
                
                // Connect oscillators through their individual envelopes
                if (o1.type === 'noise') {
                    // Add a resonant peak at the played frequency using a peaking EQ
                    const totalDetune1 = (o1.detune||0) + ((o1.coarse||0) * (1200 / tuning));
                    let center1 = adjustedFrequency * Math.pow(2, (o1.octave||0) + (totalDetune1 / 1200));
                    peak1 = this.audioContext.createBiquadFilter();
                    peak1.type = 'peaking';
                    const c1 = Math.max(safeMin, Math.min(safeMax, center1));
                    peak1.frequency.setValueAtTime(c1, this.audioContext.currentTime);
                    // Shape Width controls Q of the resonant peak too
                    {
                        const sw = Math.max(0, Math.min(1, o1.shapeWidth ?? 0.5));
                        const minQ = 0.5, maxQ = 60;
                        const q = minQ * Math.pow(maxQ / minQ, sw);
                        peak1.Q.setValueAtTime(q, this.audioContext.currentTime);
                    }
                    // Level -> 0..+48 dB; 0 dB means plain brown noise
                    const lvlNorm1 = Math.max(0, Math.min(1, ((inst?.a?.osc?.level ?? this.oscillators.osc1.level) || 0) / 0.125));
                    peak1.gain.setValueAtTime(lvlNorm1 * 48, this.audioContext.currentTime);
                    osc1.connect(peak1);
                    peak1.connect(osc1Gain);
                } else {
                    // Direct connect; shaping is embedded in the PeriodicWave
                    osc1.connect(osc1Gain);
                }
                osc1Gain.connect(osc1Envelope);
                
                if (useSecond && o2 && o2.type === 'noise') {
                    const totalDetune2 = (o2.detune||0) + ((o2.coarse||0) * (1200 / tuning));
                    let center2 = adjustedFrequency * Math.pow(2, (o2.octave||0) + (totalDetune2 / 1200));
                    peak2 = this.audioContext.createBiquadFilter();
                    peak2.type = 'peaking';
                    const c2 = Math.max(safeMin, Math.min(safeMax, center2));
                    peak2.frequency.setValueAtTime(c2, this.audioContext.currentTime);
                    {
                        const sw = Math.max(0, Math.min(1, o2.shapeWidth ?? 0.5));
                        const minQ = 0.5, maxQ = 60;
                        const q = minQ * Math.pow(maxQ / minQ, sw);
                        peak2.Q.setValueAtTime(q, this.audioContext.currentTime);
                    }
                    const lvlNorm2 = Math.max(0, Math.min(1, ((inst?.b?.osc?.level ?? this.oscillators.osc2.level) || 0) / 0.125));
                    peak2.gain.setValueAtTime(lvlNorm2 * 48, this.audioContext.currentTime);
                    osc2.connect(peak2);
                    peak2.connect(osc2Gain);
                } else {
                    osc2.connect(osc2Gain);
                }
                osc2Gain.connect(osc2Envelope);
                // Mix envelopes into final mixer
                osc1Envelope.connect(finalMixer);
                osc2Envelope.connect(finalMixer);
                if (window.DEBUG_AUDIO) console.log('Both oscillators mixed (with per-oscillator bandpass shaping)');
                
                const currentTime = this.audioContext.currentTime;
                
                // No DC sources used for shape width anymore

                // Create panner and apply panning based on mode (BEFORE reverb)
                const panner = this.audioContext.createStereoPanner();
                let panValue = 0; // Default center
                
                switch (this.panning.mode) {
                    case 'frequency':
                        // Pan based on frequency (low = left, high = right)
                        const logFreq = Math.log2(frequency / 220); // A3 as reference
                        panValue = Math.max(-1, Math.min(1, logFreq * 0.3)) * this.panning.width;
                        break;
                    case 'random':
                        // Random panning
                        panValue = (Math.random() * 2 - 1) * this.panning.width;
                        break;
                    case 'rotating':
                        // Rotating panning
                        this.panning.rotationAngle += 0.1;
                        panValue = Math.sin(this.panning.rotationAngle) * this.panning.width;
                        break;
                    case 'alternating':
                        // Alternating left/right; when ARP is running, step-driven toggle occurs in scheduler
                        if (!this._suppressPanningAutoToggle) {
                            this.panning.alternateState = !this.panning.alternateState;
                        }
                        panValue = (this.panning.alternateState ? 1 : -1) * this.panning.width;
                        break;
                    default:
                        // Center
                        panValue = 0;
                        break;
                }
                // Ensure BASS is always mono/center
                if (baseType === 'bass') panValue = 0;
                panner.pan.setValueAtTime(panValue, currentTime);
                
                // FX Send routing based on instrument setting
                const instrumentType = baseType === 'strum' ? 'strum1' : instrumentKey; // Handle strum mapping / variants
                const sendToFX = (baseType === 'bells' && safeElement && safeElement.__bellsInst)
                    ? (safeElement.__bellsInst.fxSend ?? true)
                    : (this.instruments[instrumentType]?.fxSend ?? true);
                
                // Connect: finalMixer â†’ DC-block highpass â†’ panner â†’ routing destination
                // Insert a gentle per-voice DC-blocking highpass to avoid clicks/pops at loop boundaries
                dcBlockVoice = this.audioContext.createBiquadFilter();
                dcBlockVoice.type = 'highpass';
                dcBlockVoice.frequency.value = 14; // ~14 Hz to remove DC/very low drift without thinning lows
                dcBlockVoice.Q.value = 0.707;
                finalMixer.connect(dcBlockVoice);
                dcBlockVoice.connect(panner);
                
                if (sendToFX) {
                    // Send to effects chain (reverb, delay, etc.) via master gainNode
                    const useBellsFuzz = (baseType === 'bells') && !!(safeElement?.__bellsState?.glide) && (this._bellsFuzz?.amount > 0);
                    if (useBellsFuzz && this._bellsFuzz?.input) {
                        panner.connect(this._bellsFuzz.input);
                        if (window.DEBUG_AUDIO) console.log(`[${sourceType.toUpperCase()}] Sent to BELLS fuzz`);
                    } else {
                        panner.connect(this.gainNode);
                        if (window.DEBUG_AUDIO) console.log(`[${sourceType.toUpperCase()}] Sent to FX chain`);
                    }
                } else {
                    // Bypass effects - connect directly to master output via a dry path
                    // We need to create a bypass path that avoids the FX processing
                    if (!this.dryGainNode) {
                        this.dryGainNode = this.audioContext.createGain();
                        this.dryGainNode.connect(this.audioContext.destination);
                        this.dryGainNode.gain.value = this.masterVolume;
                    }
                    panner.connect(this.dryGainNode);
                    if (window.DEBUG_AUDIO) console.log(`[${sourceType.toUpperCase()}] Bypassed FX chain`);
                }
                
                // ADSR envelopes per instrument
                let env1Attack, env1Decay, env1Sustain, env1Release;
                let env2Attack, env2Decay, env2Sustain, env2Release;
                const e1 = inst?.a?.env || this.envelope;
                const e2 = inst?.b?.env || this.osc2Envelope;
                if (sourceType === 'chord') {
                    // For chords, use bar-length sustain so chord stays audible until next chord
                    // Calculate decay based on BPM and hold setting
                    let chordDecayTime = 2.0; // fallback 2 seconds
                    try {
                        const bpmEl = document.getElementById('universalBpm');
                        const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                        const beatMs = 60000 / Math.max(20, bpm);
                        const timeSignatureEl = document.getElementById('universalTimeSignature');
                        const timeSignature = timeSignatureEl ? timeSignatureEl.value : '4/4';
                        const [beatsPerBar] = timeSignature.split('/').map(Number);
                        const barMs = beatMs * (beatsPerBar || 4);
                        // Use HOLD setting if available
                        const holdSelect = document.getElementById('universalHold') || document.getElementById('chordHold');
                        const holdValue = holdSelect ? holdSelect.value : 'bar:1';
                        const [kind, valStr] = String(holdValue).split(':');
                        const n = Math.max(1, parseInt(valStr || '1', 10));
                        const holdMs = (kind === 'beat') ? n * beatMs : n * barMs;
                        chordDecayTime = Math.max(0.1, (holdMs / 1000) * 1.5); // Convert to seconds, add 50% buffer
                    } catch(_) {}
                    env1Attack = e1.attack; env1Decay = chordDecayTime; env1Sustain = 1.0; env1Release = e1.release;
                    env2Attack = (e2?.attack ?? e1.attack); env2Decay = chordDecayTime; env2Sustain = 1.0; env2Release = (e2?.release ?? e1.release);
                } else {
                    const glideHold = ((baseType === 'strum' || baseType === 'bells') && safeElement && safeElement.__glideHold);
                    if (glideHold) {
                        env1Attack = Math.max(0.003, e1.attack || 0.005); env1Decay = 0.0; env1Sustain = 1.0; env1Release = e1.release;
                        env2Attack = Math.max(0.003, (e2?.attack ?? e1.attack) || 0.005); env2Decay = 0.0; env2Sustain = 1.0; env2Release = (e2?.release ?? e1.release);
                    } else {
                        env1Attack = e1.attack; env1Decay = e1.decay; env1Sustain = e1.sustain; env1Release = e1.release;
                        env2Attack = (e2?.attack ?? e1.attack); env2Decay = (e2?.decay ?? e1.decay); env2Sustain = (e2?.sustain ?? e1.sustain); env2Release = (e2?.release ?? e1.release);
                    }
                }
                // Prevent zero-attack degenerate ramps (some browsers ignore ramp-to at same time)
                const minAttack = 0.003; // 3ms
                env1Attack = Math.max(minAttack, Number(env1Attack) || 0);
                env2Attack = Math.max(minAttack, Number(env2Attack) || 0);
                
                const osc1AttackTime = currentTime + env1Attack;
                const osc1DecayTime = osc1AttackTime + env1Decay;
                
                osc1Envelope.gain.setValueAtTime(0, currentTime);
                osc1Envelope.gain.linearRampToValueAtTime(1, osc1AttackTime); // Attack
                osc1Envelope.gain.linearRampToValueAtTime(env1Sustain, osc1DecayTime); // Decay to sustain
                
                // OSC 2 ADSR envelope (separate OSC 2 ADSR)
                const osc2AttackTime = currentTime + env2Attack;
                const osc2DecayTime = osc2AttackTime + env2Decay;
                
                osc2Envelope.gain.setValueAtTime(0, currentTime);
                osc2Envelope.gain.linearRampToValueAtTime(1, osc2AttackTime); // Attack
                osc2Envelope.gain.linearRampToValueAtTime(env2Sustain, osc2DecayTime); // Decay to sustain
                
                osc1.start();
                osc2.start();
                
                // If we applied piano-locked settings, restore the original synthesizer state immediately
                if (originalSettings) {
                    console.log('ðŸŽ¹ Restoring original settings (no UI change)');
                    
                    // Restore from the stored original settings
                    Object.assign(this.oscillators.osc1, originalSettings.osc1);
                    Object.assign(this.oscillators.osc2, originalSettings.osc2);
                    Object.assign(this.envelope, originalSettings.envelope);
                    Object.assign(this.osc2Envelope, originalSettings.osc2Envelope);
                    Object.assign(this.reverb, originalSettings.reverb);
                    Object.assign(this.panning, originalSettings.panning);
                    this.volume = originalSettings.volume;
                    this.masterVolume = originalSettings.masterVolume;
                    
                    // Update audio context nodes if available
                    if (this.wetGainNode && this.dryGainNode) {
                        this.wetGainNode.gain.value = this.reverb.wet;
                        this.dryGainNode.gain.value = this.masterVolume;
                    }
                    if (this.reverbFilterNode) {
                        this.reverbFilterNode.frequency.value = this.reverb.filterCutoff;
                    }
                    if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                    if (this.gainNode) {
                        this.gainNode.gain.value = this.volume * this.masterVolume;
                    }
                }
                
                // Auto-release logic based on source type and sustain state
                let releaseTimeout = null;
                
                const choirSlideHold = (baseType === 'chord' && this.chordsEnabled && this._arpTransport && this._arpTransport.running);
                if (baseType === 'chord' && choirSlideHold) {
                    // Choir-slide: keep voices alive across chord changes and loop wrap.
                    // STOP / stopAllActiveNotes is responsible for release.
                    releaseTimeout = null;
                } else if (baseType === 'chord' || baseType === 'bass') {
                    // Chord and Bass modes: always use HOLD duration, even if sustain is active
                    const holdSelect = document.getElementById('universalHold') || document.getElementById('chordHold');
                    const holdValue = holdSelect ? holdSelect.value : 'bar:1';
                    const [kind, valStr] = String(holdValue).split(':');
                    const n = Math.max(1, parseInt(valStr || '1', 10));
                    
                    // Calculate hold duration in milliseconds
                    const bpmEl = document.getElementById('universalBpm');
                    const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                    const beatMs = 60000 / Math.max(20, bpm);
                    
                    // Get time signature
                    const timeSignatureEl = document.getElementById('universalTimeSignature');
                    const timeSignature = timeSignatureEl ? timeSignatureEl.value : '4/4';
                    const [beatsPerBar] = timeSignature.split('/').map(Number);
                    const barMs = beatMs * (beatsPerBar || 4);
                    // Enforce minimum hold = 1/8 note regardless of time signature
                    const quantMinMs = beatMs * 0.5;
                    const baseHoldMs = (kind === 'beat') ? n * beatMs : n * barMs;
                    const holdMs = Math.max(quantMinMs, baseHoldMs);
                    
                    // Do NOT clamp to bar boundary; allow releases to carry over cleanly across loops
                    releaseTimeout = setTimeout(() => {
                        this.stopFrequency(frequency, safeElement, sourceType);
                    }, holdMs);
                    
                    console.log(`[${sourceType.toUpperCase()}] Auto-release scheduled in ${holdMs}ms (${holdValue})`);
                    
                } else if (baseType === 'strum' || baseType === 'bells') {
                    // STRUM should always decay/release normally, even if a CHORD gesture is sustaining.
                    // Prefer an explicit musical gate if provided, otherwise release at end-of-decay.
                    if (safeElement && safeElement.__glideHold) {
                        releaseTimeout = null;
                    } else {
                    const epsilonMs = 6;
                    const elGateMs = (element && Number.isFinite(element.__gateMs)) ? element.__gateMs : null;
                    let gateMs = null;
                    if (elGateMs && elGateMs > 0) {
                        gateMs = Math.max(10, Math.floor(elGateMs - epsilonMs));
                    } else {
                        const endOfDecayTime = Math.max(osc1DecayTime, osc2DecayTime);
                        gateMs = Math.max(10, Math.floor(Math.max(0, (endOfDecayTime - currentTime) * 1000) - epsilonMs));
                    }
                    releaseTimeout = setTimeout(() => {
                        this.stopFrequency(frequency, safeElement, sourceType);
                    }, gateMs);
                    }
                } else if (!this._sustainActive && baseType !== 'arp') {
                    // Other modes: release at end of decay if sustain not active
                    const endOfDecayTime = Math.max(osc1DecayTime, osc2DecayTime);
                    const releaseDelayMs = Math.max(0, (endOfDecayTime - currentTime) * 1000);
                    releaseTimeout = setTimeout(() => {
                        this.stopFrequency(frequency, safeElement, sourceType);
                    }, releaseDelayMs);
                }

                // Store oscillator data along with the exact ADSR values used at note start
                oscillatorPool.set(frequency, { 
                    osc1, 
                    osc2, 
                    osc1Envelope,
                    osc2Envelope,
                    finalMixer,
                    panner,
                    osc1Gain,
                    osc2Gain,
                    dcBlockVoice,
                    peak1,
                    peak2,
                    releaseTimeout,
                    isGlobalBass: (baseType === 'bass'),
                    element: safeElement,
                    startTime: currentTime,
                    env1: {
                        attack: env1Attack,
                        decay: env1Decay,
                        sustain: env1Sustain,
                        release: env1Release
                    },
                    env2: {
                        attack: env2Attack,
                        decay: env2Decay,
                        sustain: env2Sustain,
                        release: env2Release
                    }
                });
                if (safeElement) {
                    safeElement.classList.add('active');
                    const core = safeElement.querySelector('.string-core');
                    if (core) {
                        const stepIndex = parseInt(safeElement.dataset.noteIndex||'0',10);
                        const period = this.computeVibrationPeriod(adjustedFrequency, stepIndex);
                        core.style.setProperty('--vib-period', period + 'ms');
                        core.classList.add('vibrating');
                    }
                }
            }

            stopFrequency(frequency, element, sourceType = 'default') {
                // Select appropriate oscillator pool based on source type
                const rawType = String(sourceType || 'default');
                const baseType = rawType.startsWith('arp') ? 'arp' : rawType;
                let oscillatorPool;
                switch (baseType) {
                    case 'strum':
                        oscillatorPool = this.activeStrumOscillators;
                        break;
                    case 'bells':
                        oscillatorPool = this.activeBellsOscillators;
                        break;
                    case 'chord':
                        oscillatorPool = this.activeChordOscillators;
                        break;
                    case 'arp':
                        oscillatorPool = this.activeArpOscillators;
                        break;
                    case 'bass':
                        oscillatorPool = this.activeBassOscillators;
                        break;
                    default:
                        oscillatorPool = this.activeOscillators;
                }
                
                // Direct lookup first
                let osc = oscillatorPool.get(frequency);
                // Fallback: in case of tiny drift, try nearest key within 1 cent for bass/arp
                if (!osc && oscillatorPool.size > 0 && (baseType === 'bass' || baseType === 'arp' || baseType === 'chord')) {
                    try {
                        const keys = Array.from(oscillatorPool.keys());
                        const cand = keys.reduce((best,k)=>{
                            const d = Math.abs(Math.log2(k) - Math.log2(Math.max(1e-6, frequency)));
                            return (!best || d < best.d) ? {k, d} : best;
                        }, null);
                        if (cand && cand.d < (1/1200)) { // within 1 cent
                            osc = oscillatorPool.get(cand.k);
                            if (osc) frequency = cand.k;
                        }
                    } catch(_) {}
                }
                if (!osc) return;

                try {
                    if (window.DEBUG_CHOIR_SLIDE && sourceType === 'chord' && this.chordsEnabled && this._arpTransport && this._arpTransport.running) {
                        console.warn('[CHOIR] stopFrequency(chord) while transport running', frequency);
                    }
                } catch(_) {}
                
                const { osc1, osc2, osc1Envelope, osc2Envelope, releaseTimeout, env1, env2, finalMixer, panner, osc1Gain, osc2Gain, dcBlockVoice, peak1, peak2 } = osc;
                
                // Clear auto-release timeout
                if (releaseTimeout) {
                    clearTimeout(releaseTimeout);
                }
                
                // Remove from active oscillators immediately to prevent overlap
                oscillatorPool.delete(frequency);
                
                try {
                    const currentTime = this.audioContext.currentTime;
                    
                    // Apply OSC 1 release envelope
                    osc1Envelope.gain.cancelScheduledValues(currentTime);
                    osc1Envelope.gain.setValueAtTime(osc1Envelope.gain.value, currentTime);
                    osc1Envelope.gain.linearRampToValueAtTime(0, currentTime + Math.max(0, env1?.release ?? this.envelope.release));
                    
                    // Apply OSC 2 release envelope
                    osc2Envelope.gain.cancelScheduledValues(currentTime);
                    osc2Envelope.gain.setValueAtTime(osc2Envelope.gain.value, currentTime);
                    osc2Envelope.gain.linearRampToValueAtTime(0, currentTime + Math.max(0, env2?.release ?? this.osc2Envelope.release));
                    
                    // Stop oscillators after the longer of the two release times (based on the values used at note start)
                    const maxReleaseTime = Math.max(Math.max(0, env1?.release ?? this.envelope.release), Math.max(0, env2?.release ?? this.osc2Envelope.release));
                    osc1.stop(currentTime + maxReleaseTime);
                    osc2.stop(currentTime + maxReleaseTime);
                    
                    
                    if (window.DEBUG_AUDIO) console.log('Note stopped with', maxReleaseTime, 'second release time');
                    
                    // Disconnect nodes after release to avoid WebAudio node buildup on Safari
                    const cleanupDelay = Math.max(60, Math.floor(maxReleaseTime * 1000 + 80));
                    setTimeout(() => {
                        try { osc1 && osc1.disconnect && osc1.disconnect(); } catch(_){ }
                        try { osc2 && osc2.disconnect && osc2.disconnect(); } catch(_){ }
                        try { osc1Gain && osc1Gain.disconnect && osc1Gain.disconnect(); } catch(_){ }
                        try { osc2Gain && osc2Gain.disconnect && osc2Gain.disconnect(); } catch(_){ }
                        try { osc1Envelope && osc1Envelope.disconnect && osc1Envelope.disconnect(); } catch(_){ }
                        try { osc2Envelope && osc2Envelope.disconnect && osc2Envelope.disconnect(); } catch(_){ }
                        try { finalMixer && finalMixer.disconnect && finalMixer.disconnect(); } catch(_){ }
                        try { panner && panner.disconnect && panner.disconnect(); } catch(_){ }
                        try { dcBlockVoice && dcBlockVoice.disconnect && dcBlockVoice.disconnect(); } catch(_){ }
                        try { peak1 && peak1.disconnect && peak1.disconnect(); } catch(_){ }
                        try { peak2 && peak2.disconnect && peak2.disconnect(); } catch(_){ }
                    }, cleanupDelay);

                    // Clean up visual indicator
                    setTimeout(() => {
                        if (element) {
                            element.classList.remove('active');
                            const core = element.querySelector('.string-core');
                            if (core) core.classList.remove('vibrating');
                        }
                    }, maxReleaseTime * 1000 + 50);
                } catch (error) {
                    console.warn('Error stopping oscillator:', error);
                    if (element) {
                        element.classList.remove('active');
                        const core = element.querySelector('.string-core');
                        if (core) core.classList.remove('vibrating');
                    }
                }
            }

            _markUserActivity(){
                try {
                    const now = (performance && performance.now) ? performance.now() : Date.now();
                    this._lastInteractionAt = now;
                    if (this._idleCleanupTimer) { clearTimeout(this._idleCleanupTimer); this._idleCleanupTimer = null; }
                    this._idleCleanupTimer = setTimeout(()=>{ try { this._runIdleCleanup(); } catch(_){} }, 2000);
                } catch(_){ }
            }

            _runIdleCleanup(){
                try {
                    if (!this.audioContext) return;
                    // Only clean up when user is idle and not actively sequencing.
                    if (this._isSequencing) return;
                    this._cleanupStaleVoices();
                } catch(_){ }
            }

            _cleanupStaleVoices(){
                try {
                    const now = this.audioContext ? this.audioContext.currentTime : 0;
                    const prune = (pool, sourceType, maxAgeSec)=>{
                        if (!pool || !pool.size) return;
                        const keys = Array.from(pool.keys());
                        keys.forEach(k=>{
                            const voice = pool.get(k);
                            const age = (voice && Number.isFinite(voice.startTime)) ? (now - voice.startTime) : 0;
                            if (age > maxAgeSec) {
                                try {
                                    if (voice && voice.env1) voice.env1.release = Math.min(voice.env1.release ?? 0.25, 0.25);
                                    if (voice && voice.env2) voice.env2.release = Math.min(voice.env2.release ?? 0.25, 0.25);
                                } catch(_) {}
                                try { this.stopFrequency(k, voice?.element || null, sourceType); } catch(_){ }
                            }
                        });
                    };
                    prune(this.activeStrumOscillators, 'strum', 6);
                    prune(this.activeBellsOscillators, 'bells', 6);
                    prune(this.activeChordOscillators, 'chord', 10);
                    prune(this.activeArpOscillators, 'arp', 6);
                    prune(this.activeBassOscillators, 'bass', 8);
                    prune(this.activeOscillators, 'default', 6);
                } catch(_){ }
            }

            _isFreqNear(a, b, tolCents = 3){
                try {
                    if (!(a>0) || !(b>0)) return false;
                    const cents = Math.abs(Math.log2(a / b)) * 1200;
                    return cents <= tolCents;
                } catch(_){ return false; }
            }

            _hasActiveFreq(pool, freq, tolCents = 3){
                try {
                    if (!pool || !pool.size) return false;
                    for (const k of pool.keys()) {
                        if (this._isFreqNear(k, freq, tolCents)) return true;
                    }
                } catch(_){ }
                return false;
            }

            _fadeVoicesNotInSet(pool, sourceType, keepFreqs, tolCents = 3, releaseMax = 0.25){
                try {
                    if (!pool || !pool.size) return;
                    const keep = Array.isArray(keepFreqs) ? keepFreqs.filter(f=> Number.isFinite(f) && f>0) : [];
                    for (const k of Array.from(pool.keys())) {
                        const keepIt = keep.some(f=> this._isFreqNear(k, f, tolCents));
                        if (keepIt) continue;
                        const voice = pool.get(k);
                        try {
                            if (voice && voice.env1) voice.env1.release = Math.min(voice.env1.release ?? releaseMax, releaseMax);
                            if (voice && voice.env2) voice.env2.release = Math.min(voice.env2.release ?? releaseMax, releaseMax);
                        } catch(_){ }
                        try { this.stopFrequency(k, voice?.element || null, sourceType); } catch(_){ }
                    }
                } catch(_){ }
            }

            // Apply CHORD LEVEL changes to currently-playing chord voices (safe, click-free).
            _applyLiveChordOutputLevel(){
                try {
                    if (!this.audioContext) return;
                    const lvl = (this.instruments?.chord?.osc?.level ?? null);
                    if (lvl == null || !Number.isFinite(lvl)) return;
                    if (!this.activeChordOscillators || this.activeChordOscillators.size === 0) return;
                    const now = this.audioContext.currentTime;
                    const timeConst = 0.015;
                    // Keep the existing chord mix reduction used at note start.
                    const volumeMultiplier = 0.75;
                    const target = Math.max(0, lvl * volumeMultiplier);
                    for (const voice of this.activeChordOscillators.values()) {
                        if (!voice) continue;
                        const g1 = voice.osc1Gain?.gain;
                        const g2 = voice.osc2Gain?.gain;
                        try {
                            if (g1 && typeof g1.setTargetAtTime === 'function') g1.setTargetAtTime(target, now, timeConst);
                            else if (g1) g1.value = target;
                        } catch(_){ }
                        try {
                            if (g2 && typeof g2.setTargetAtTime === 'function') g2.setTargetAtTime(target, now, timeConst);
                            else if (g2) g2.value = target;
                        } catch(_){ }
                    }
                } catch(_){ }
            }

            _hardKillVoiceNow(voice){
                try {
                    if (!voice || !this.audioContext) return;
                    const now = this.audioContext.currentTime;

                    try { if (voice.releaseTimeout) clearTimeout(voice.releaseTimeout); } catch(_){ }

                    try {
                        if (voice.finalMixer && voice.finalMixer.gain) {
                            voice.finalMixer.gain.cancelScheduledValues(now);
                            voice.finalMixer.gain.setValueAtTime(0, now);
                        }
                    } catch(_){ }

                    const zeroParamNow = (param)=>{
                        try {
                            if (!param) return;
                            if (typeof param.cancelScheduledValues === 'function') param.cancelScheduledValues(now);
                            if (typeof param.setValueAtTime === 'function') param.setValueAtTime(0, now);
                            else param.value = 0;
                        } catch(_){ }
                    };

                    zeroParamNow(voice.osc1Envelope?.gain);
                    zeroParamNow(voice.osc2Envelope?.gain);
                    zeroParamNow(voice.osc1Gain?.gain);
                    zeroParamNow(voice.osc2Gain?.gain);
                    try { if (voice.panner && voice.panner.pan) voice.panner.pan.cancelScheduledValues(now); } catch(_){ }

                    try { voice.osc1 && voice.osc1.stop && voice.osc1.stop(now); } catch(_){ }
                    try { voice.osc2 && voice.osc2.stop && voice.osc2.stop(now); } catch(_){ }

                    // Disconnect aggressively to guarantee silence ASAP.
                    try { voice.osc1 && voice.osc1.disconnect && voice.osc1.disconnect(); } catch(_){ }
                    try { voice.osc2 && voice.osc2.disconnect && voice.osc2.disconnect(); } catch(_){ }
                    try { voice.osc1Gain && voice.osc1Gain.disconnect && voice.osc1Gain.disconnect(); } catch(_){ }
                    try { voice.osc2Gain && voice.osc2Gain.disconnect && voice.osc2Gain.disconnect(); } catch(_){ }
                    try { voice.osc1Envelope && voice.osc1Envelope.disconnect && voice.osc1Envelope.disconnect(); } catch(_){ }
                    try { voice.osc2Envelope && voice.osc2Envelope.disconnect && voice.osc2Envelope.disconnect(); } catch(_){ }
                    try { voice.finalMixer && voice.finalMixer.disconnect && voice.finalMixer.disconnect(); } catch(_){ }
                    try { voice.panner && voice.panner.disconnect && voice.panner.disconnect(); } catch(_){ }

                    try {
                        const el = voice.element;
                        if (el && el.classList) {
                            el.classList.remove('active');
                            const core = el.querySelector && el.querySelector('.string-core');
                            if (core && core.classList) core.classList.remove('vibrating');
                        }
                    } catch(_){ }
                } catch(_){ }
            }

            _hardKillChordVoicesNow(){
                try {
                    if (!this.activeChordOscillators || this.activeChordOscillators.size === 0) return;
                    const entries = Array.from(this.activeChordOscillators.entries());
                    this.activeChordOscillators.clear();
                    for (const [, voice] of entries) {
                        try { this._hardKillVoiceNow(voice); } catch(_){ }
                    }
                } catch(_){ }
                try { if (this._chordSlideVoices) this._chordSlideVoices.clear(); } catch(_){ }
            }

            _hardKillMidiChordNotesNow(){
                try {
                    if (!window.midi || !window.midi.enabled || typeof window.midi.sendNoteOff !== 'function') return;
                    if (!this._midiChordNoteKeys || !this._midiChordNoteKeys.size) return;
                    for (const key of Array.from(this._midiChordNoteKeys)) {
                        try {
                            const parts = String(key).split('@');
                            const n = parseInt(parts[0]||'0',10);
                            const ch = parseInt(parts[1]||'0',10);
                            const port = parts[2] || null;
                            if (Number.isFinite(n) && Number.isFinite(ch)) {
                                window.midi.sendNoteOff(n, ch, port && port !== '*' ? port : null);
                            }
                        } catch(_){ }
                    }
                    this._midiChordNoteKeys.clear();
                } catch(_){ }
            }

            _cancelPendingChordEventsNow(){
                try { if (this._chordHoldTimer) { clearTimeout(this._chordHoldTimer); this._chordHoldTimer = null; } } catch(_){ }

                try { if (this._pendingQuantizedArpStart) { try { clearTimeout(this._pendingQuantizedArpStart.timer); } catch(_){ } this._pendingQuantizedArpStart = null; } } catch(_){ }
                try { if (this._pendingQuantizedBassChange) { try { clearTimeout(this._pendingQuantizedBassChange.timer); } catch(_){ } this._pendingQuantizedBassChange = null; } } catch(_){ }
                try { if (this._pendingQuantizedChordChange) { try { clearTimeout(this._pendingQuantizedChordChange.timer); } catch(_){ } this._pendingQuantizedChordChange = null; } } catch(_){ }
                try { if (this._pendingArpChordChange) { try { clearTimeout(this._pendingArpChordChange.timer); } catch(_){ } this._pendingArpChordChange = null; } } catch(_){ }

                try { if (this._chordSlideHoverCommitTimer) { clearTimeout(this._chordSlideHoverCommitTimer); this._chordSlideHoverCommitTimer = null; } } catch(_){ }
                try { if (this._chordSlideIdleTimer) { clearTimeout(this._chordSlideIdleTimer); this._chordSlideIdleTimer = null; } } catch(_){ }

                // Prevent any pending transport chord switch from re-seeding chord voices.
                try {
                    if (this._arp && this._arp.pendingSwitch && this._arp.pendingSwitch.enableChord) {
                        this._arp.pendingSwitch.enableChord = false;
                        this._arp.pendingSwitch.chordRows = [];
                        if (this._arp.pendingSwitch.mode === 'chord') this._arp.pendingSwitch.mode = 'arp';
                    }
                } catch(_){ }
            }

            hardStopChordsNow(){
                // User requirement: CHORDS OFF must silence immediately (no release tail).
                try { this._cancelPendingChordEventsNow(); } catch(_){ }
                try { this._hardKillMidiChordNotesNow(); } catch(_){ }
                try { this._hardKillChordVoicesNow(); } catch(_){ }
            }

            stopAllStrings() {
                // Stop across all oscillator pools with the correct source type
                try {
                    const pools = [
                        { pool: this.activeOscillators, type: 'default' },
                        { pool: this.activeStrumOscillators, type: 'strum' },
                        { pool: this.activeBellsOscillators, type: 'bells' },
                        { pool: this.activeChordOscillators, type: 'chord' },
                        { pool: this.activeArpOscillators, type: 'arp' },
                        { pool: this.activeBassOscillators, type: 'bass' }
                    ];
                    for (const { pool, type } of pools) {
                        if (!pool || pool.size === 0) continue;
                        // Snapshot keys to avoid mutation during iteration
                        const keys = Array.from(pool.keys());
                        for (const k of keys) {
                            try {
                                const info = pool.get(k);
                                // Preserve global bass if flagged
                                if (info && info.isGlobalBass) continue;
                                this.stopFrequency(k, info?.element || null, type);
                            } catch (e) {
                                console.warn('stopAllStrings: error stopping', type, k, e);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('stopAllStrings: pooled stop failed, falling back', e);
                    try { this.stopAllActiveNotes(); } catch(_) {}
                }
                // Clear per-gesture tracking
                this.triggeredStrings.clear();
                // Clear held-bass references as well
                try { this._heldBassVoice = null; this._heldBassLiveFreq = null; this._heldBassVoiceKey = null; } catch(_){ }
            }

            // Gently duck any existing bass tails when a new bass note starts, to prevent previous-root bleed
            _duckExistingBassVoices(excludeFrequency = null, fastMs = 25, targetGain = 0.12){
                try {
                    const ac = this.audioContext; if (!ac) return;
                    const t = ac.currentTime;
                    const fast = Math.max(0.005, (fastMs||0)/1000);
                    const tgt = Math.max(0.0, Math.min(1.0, Number(targetGain)||0.12));
                    if (!this.activeBassOscillators || this.activeBassOscillators.size === 0) return;
                    for (const [freq, v] of this.activeBassOscillators.entries()){
                        if (excludeFrequency != null && Math.abs(Math.log2(freq) - Math.log2(Math.max(1e-6, excludeFrequency))) <= (1/1200)) continue;
                        const env1 = v?.osc1Envelope; const env2 = v?.osc2Envelope;
                        try {
                            if (env1 && env1.gain){
                                env1.gain.cancelScheduledValues(t);
                                env1.gain.setValueAtTime(Math.max(0, env1.gain.value||0), t);
                                env1.gain.linearRampToValueAtTime(tgt, t + fast);
                            }
                        } catch(_){}
                        try {
                            if (env2 && env2.gain){
                                env2.gain.cancelScheduledValues(t);
                                env2.gain.setValueAtTime(Math.max(0, env2.gain.value||0), t);
                                env2.gain.linearRampToValueAtTime(tgt, t + fast);
                            }
                        } catch(_){}
                    }
                } catch(_) { /* ignore */ }
            }

            // Tutorial System
            initTutorial() {
                this.tutorialStep = 0;
                this.tutorialSteps = [
                    { title: "Hi! Let's make music", text: "Tap the big + to add a chord. We'll build it together.", highlight: "#createNewChordBtn" },
                    { title: "Pick your tuning (EDO)", text: "EDO = how many steps in an octave. Try 12, 19, or 24.", highlight: "#edoQuickInput" },
                    { title: "Add notes on the top row", text: "Click the white/black circles or colored dots to add sounds. Pick at least two.", highlight: "#rootGrid" },
                    { title: "Strum your chord", text: "Click and drag up/down the new box to hear it. Numbers 1â€“0 also trigger boxes!", highlight: "#extensionColumns" },
                    { title: "Transpose everything", text: "Use the â–² â–¼ on the left of the keyboard or press + / - on your keys.", highlight: ".transpose-controls-left" },
                    { title: "Try ARP mode", text: "Click ARP on the CHORD/ARP toggle, set a BPM and Quant, then hold a chord box to hear a pattern.", highlight: "#modeChordArp" },
                    { title: "Change your sound", text: "Open OSCILLATORS and try Sine/Saw/Square, then tweak ADSR.", highlight: "#oscillatorsSection" },
                    { title: "Add space & motion", text: "Open EFFECTS to add reverb or make the sound move left-right.", highlight: "#effectsSection" },
                    { title: "Type a sequence", text: "Click SEQ and type chords (like I IV V or C F G).", highlight: "#openTextChordParserBtn" },
                    { title: "Save your song", text: "ðŸ’¾ saves the full .XEN session; â¬‡ï¸ also exports .XEN.", highlight: "#bottomExportOMGBtn" },
                    { title: "You're ready!", text: "Keep adding chords, strum, and experiment. Music rewards curiosity.", highlight: null }
                ];

                document.getElementById('tutorialButton').addEventListener('click', () => {
                    this.startTutorial();
                });

                document.getElementById('tutorialNext').addEventListener('click', () => {
                    this.nextTutorialStep();
                });

                document.getElementById('tutorialPrev').addEventListener('click', () => {
                    this.prevTutorialStep();
                });

                document.getElementById('tutorialSkip').addEventListener('click', () => {
                    this.endTutorial();
                });

                // Initialize escape mechanisms
                this.initTutorialEscapes();
            }

            startTutorial() {
                this.tutorialStep = 0;
                document.getElementById('tutorialOverlay').style.display = 'block';
                this.showTutorialStep();
                this.greyOutAll();
                
                // Add escape mechanisms
                document.addEventListener('keydown', this.tutorialEscapeHandler);
            }

            showTutorialStep() {
                const step = this.tutorialSteps[this.tutorialStep];
                document.getElementById('tutorialTitle').textContent = step.title;
                document.getElementById('tutorialText').textContent = step.text;

                // Update button states
                document.getElementById('tutorialPrev').style.display = this.tutorialStep > 0 ? 'inline-block' : 'none';
                document.getElementById('tutorialNext').textContent = this.tutorialStep < this.tutorialSteps.length - 1 ? 'Next' : 'Finish';

                // Position tutorial box
                this.positionTutorialBox(step.highlight);

                // Highlight current element
                this.highlightElement(step.highlight);
            }

            positionTutorialBox(selector) {
                const tutorialBox = document.getElementById('tutorialBox');
                
                if (selector) {
                    const element = document.querySelector(selector);
                    if (element) {
                        const rect = element.getBoundingClientRect();
                        const boxWidth = 400;
                        const boxHeight = 250;
                        
                        // Try to position next to the element
                        let left = rect.right + 20;
                        let top = rect.top;
                        
                        // Keep box on screen
                        if (left + boxWidth > window.innerWidth) {
                            left = rect.left - boxWidth - 20;
                        }
                        if (left < 20) {
                            left = 20;
                        }
                        
                        if (top + boxHeight > window.innerHeight) {
                            top = window.innerHeight - boxHeight - 20;
                        }
                        if (top < 20) {
                            top = 20;
                        }
                        
                        tutorialBox.style.left = `${left}px`;
                        tutorialBox.style.top = `${top}px`;
                        tutorialBox.style.transform = 'none';
                    } else {
                        // Center if element not found
                        tutorialBox.style.left = '50%';
                        tutorialBox.style.top = '50%';
                        tutorialBox.style.transform = 'translate(-50%, -50%)';
                    }
                } else {
                    // Center the box
                    tutorialBox.style.left = '50%';
                    tutorialBox.style.top = '50%';
                    tutorialBox.style.transform = 'translate(-50%, -50%)';
                }
            }

            highlightElement(selector) {
                // Remove previous highlights
                document.querySelectorAll('.tutorial-highlight').forEach(el => {
                    el.classList.remove('tutorial-highlight');
                    el.style.position = '';
                    el.style.zIndex = '';
                    el.style.filter = '';
                });

                if (selector) {
                    const element = document.querySelector(selector);
                    if (element) {
                        element.classList.add('tutorial-highlight');
                        element.style.position = 'relative';
                        element.style.zIndex = '2100';
                        element.style.filter = 'brightness(1.5) contrast(1.2)';
                    }
                }
            }

            greyOutAll() {
                // Create overlay instead of using filter to avoid breaking highlighting
                const overlay = document.createElement('div');
                overlay.id = 'tutorialGreyOverlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 1900;
                    pointer-events: none;
                `;
                document.body.appendChild(overlay);
            }

            ungreyAll() {
                const overlay = document.getElementById('tutorialGreyOverlay');
                if (overlay) {
                    overlay.remove();
                }
                // Also remove any filters that might have been applied
                document.body.style.filter = '';
            }

            nextTutorialStep() {
                if (this.tutorialStep < this.tutorialSteps.length - 1) {
                    this.tutorialStep++;
                    this.showTutorialStep();
                } else {
                    this.endTutorial();
                }
            }

            prevTutorialStep() {
                if (this.tutorialStep > 0) {
                    this.tutorialStep--;
                    this.showTutorialStep();
                }
            }

            endTutorial() {
                document.getElementById('tutorialOverlay').style.display = 'none';
                this.ungreyAll();
                this.highlightElement(null);
                
                // Remove any event listeners that might interfere
                document.removeEventListener('keydown', this.tutorialEscapeHandler);
            }

            // Add escape key handler and click-to-close functionality
            initTutorialEscapes() {
                // ESC key to close tutorial
                this.tutorialEscapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.endTutorial();
                    }
                };

                // Click outside tutorial box to close
                document.getElementById('tutorialOverlay').addEventListener('click', (e) => {
                    if (e.target.id === 'tutorialOverlay') {
                        this.endTutorial();
                    }
                });
            }

            // BELLS window (simple large bars for learning use)
            initBells() {
                const btn = document.getElementById('bellsButton');
                if (btn && !btn._wired) {
                    btn._wired = true;
                    btn.addEventListener('click', () => this.openBellsWindow());
                }
                const btnSide = document.getElementById('bellsBtnSidebar');
                if (btnSide && !btnSide._wired) {
                    btnSide._wired = true;
                    btnSide.addEventListener('click', () => this.openBellsWindow());
                }
                this._initInlineJam();
            }

            _getInlineBellsWin(){
                try {
                    const jamArea = document.getElementById('jamArea');
                    if (!jamArea) return null;
                    const win = window;
                    win.__bellsInline = true;
                    win.__bellsInlineRoot = jamArea;
                    return win;
                } catch(_){ return null; }
            }

            _ensureInlineBellsState(win){
                if (!win) return null;
                const st = this._getBellsState(win);
                st.mode = 'single';
                st.count = 1;
                st.baseOct = 4;
                const edo = this.currentTuning || 12;
                const limits = this._getInlineJamSpanLimits(edo);
                const defaultSpan = Math.max(limits.minSpan, Math.min(limits.maxSpan, edo + 1));
                if (!Number.isFinite(st.spanSteps) || st.spanSteps < limits.minSpan) {
                    st.spanSteps = defaultSpan;
                }
                if (!Number.isFinite(st.baseAbsStep)) {
                    st.baseAbsStep = (st.baseOct || 4) * edo;
                }
                return st;
            }

            _initInlineJam(){
                const win = this._getInlineBellsWin();
                if (!win) return;
                this._ensureInlineBellsState(win);
                try { this._renderBellsUI(win); } catch(_){ }
                try { this._renderBellsBars(win); } catch(_){ }
                this._startBellsAutoUpdate();
            }

            _getInlineJamSpanLimits(edo){
                const minSpan = 1;
                const maxSpan = Math.max(1, (edo * 4));
                return { minSpan, maxSpan };
            }

            _computeInlineJamNotes(baseAbsStep, spanSteps, edo){
                const notes = [];
                const baseAbs = Math.round(Number.isFinite(baseAbsStep) ? baseAbsStep : 0);
                const span = Math.max(1, spanSteps | 0);
                for (let i = 0; i < span; i++) {
                    const abs = baseAbs + i;
                    const step = ((abs % edo) + edo) % edo;
                    const octave = Math.floor(abs / edo);
                    const label = `${this.getRootNameForStep(step, edo)}${octave}`;
                    const color = this.getUniversalPitchColorForStep(step, edo).color || '#888';
                    const freq = this.getFrequency(step, octave, edo);
                    notes.push({ freq, step, octave, label, color, tuning: edo });
                }
                return notes;
            }

            openBellsWindow() {
                const winName = `XENON_BELLS_${Date.now()}_${Math.floor(Math.random()*1e6)}`;
                const win = window.open('', winName, 'popup=yes,resizable=yes,scrollbars=no');
                if (!win) {
                    alert('Popup blocked. Allow popups to open BELLS.');
                    return;
                }
                this._bellsWin = win;
                this._bellsWins = Array.isArray(this._bellsWins) ? this._bellsWins : [];
                this._bellsWins.push(win);
                this._getBellsState(win);
                this._buildBellsWindowShell(win);
                try {
                    win.addEventListener('beforeunload', () => {
                        this._bellsWins = (this._bellsWins || []).filter(w => w && !w.closed && w !== win);
                        if (this._bellsWin === win) this._bellsWin = null;
                    });
                } catch(_) {}
                this._startBellsAutoUpdate();
                this._renderBellsUI(win);
                return win;
            }

            _getBellsState(win){
                const ensure = (st)=>{
                    if (!st || typeof st !== 'object') st = {};
                    if (!Number.isFinite(st.count)) st.count = 2;
                    if (!Number.isFinite(st.activeIndex)) st.activeIndex = 0;
                    if (!Number.isFinite(st.baseOct)) st.baseOct = 4;
                    if (!st.mode) st.mode = 'single';
                    if (st.glide == null) st.glide = false;
                    return st;
                };
                if (!win) {
                    this._bellsState = ensure(this._bellsState || { count: 2, activeIndex: 0, baseOct: 4, mode: 'single', glide: false });
                    return this._bellsState;
                }
                if (!win.__bellsState) win.__bellsState = ensure({});
                return win.__bellsState;
            }

            _getOpenBellsWindows(){
                const out = [];
                const list = Array.isArray(this._bellsWins) ? this._bellsWins : [];
                list.forEach(w => { if (w && !w.closed) out.push(w); });
                if (this._bellsWin && !this._bellsWin.closed && !out.includes(this._bellsWin)) out.push(this._bellsWin);
                this._bellsWins = out.slice();
                return out;
            }

            _renderAllBellsUIs(){
                this._getOpenBellsWindows().forEach(w => { try { this._renderBellsUI(w); } catch(_){} });
                const inlineWin = this._getInlineBellsWin();
                if (inlineWin) {
                    try { this._ensureInlineBellsState(inlineWin); } catch(_){ }
                    try { this._renderBellsUI(inlineWin); } catch(_){ }
                }
            }

            _renderAllBellsBars(){
                this._getOpenBellsWindows().forEach(w => { try { this._renderBellsBars(w); } catch(_){} });
                const inlineWin = this._getInlineBellsWin();
                if (inlineWin) {
                    try { this._ensureInlineBellsState(inlineWin); } catch(_){ }
                    try { this._renderBellsBars(inlineWin); } catch(_){ }
                }
            }

            _updateAllBellsScrollPositions(){
                this._getOpenBellsWindows().forEach(w => { try { this._updateBellsScrollPosition(w); } catch(_){} });
            }

            _buildBellsWindowShell(win) {
                const doc = win.document;
                                const html = `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>XENON BELLS</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    html, body { width: 100%; height: 100%; margin: 0; background: #000; color: #e8f5ff; font-family: 'Oswald', Arial, sans-serif; }
    #bellsHeader {
      display: flex; flex-direction: column; gap: 8px; padding: 10px 12px; border-bottom: 1px solid #1f2f3a;
      background: #060c10; position: sticky; top: 0; z-index: 2;
    }
        #bellsTransportRow { display:flex; align-items:center; gap:8px; }
        .bells-transport-btn {
            padding: 6px 12px; background: #214051; color: #e8f5ff; border: 1px solid #2b5567;
            border-radius: 8px; font-size: 13px; cursor: pointer; min-width: 80px; text-align: center;
        }
        .bells-transport-btn.active { background: #2ecc71; border-color: #27ae60; color: #0a1014; }
        #bellsChords { display: flex; flex-wrap: wrap; gap: 6px; }
        #bellsModeToggle { display: flex; gap: 6px; margin-top: 6px; }
    .bells-chord-btn {
      padding: 6px 10px; background: #1a2f3c; color: #e8f5ff; border: 1px solid #2b5567;
      border-radius: 8px; font-size: 14px; cursor: pointer; min-width: 48px; text-align: center;
    }
    .bells-chord-btn.active { background: #f39c12; border-color: #e67e22; color: #111; }
        .bells-mode-btn {
            padding: 6px 12px; background: #0d2938; color: #e8f5ff; border: 1px solid #2b5567;
            border-radius: 8px; font-size: 13px; cursor: pointer; min-width: 110px; text-align: center;
        }
        .bells-mode-btn.active { background: #3498db; border-color: #2980b9; color: #0a1014; }
    #bellsControls { display: grid; grid-template-columns: auto 1fr auto auto 1fr auto auto; gap: 10px; align-items: center; }
    #bellsCount, #bellsOctave { width: 100%; }
    #bellsCountValue, #bellsOctaveValue { min-width: 28px; text-align: right; font-size: 16px; color: #9db6c8; }
    #bellsGlideWrap { display:flex; align-items:center; gap:6px; font-size:14px; color:#9db6c8; }
        #bellsDrawerRow { display:flex; align-items:center; gap:8px; margin-top:6px; }
        .bells-gear {
            width:28px; height:26px; display:inline-flex; align-items:center; justify-content:center;
            background:#214051; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px;
            cursor:pointer; font-size:14px; line-height:1; padding:0; flex:0 0 auto;
        }
        .bells-gear[aria-expanded="true"] { outline:2px solid #ffd046; outline-offset:1px; }
        .bells-drawer { display:none; flex-wrap:wrap; gap:8px; align-items:center; padding:8px 10px; border:1px solid rgba(74,106,112,0.55); border-radius:8px; background:rgba(13,41,56,0.7); }
        .bells-drawer.open { display:flex; }
        .bells-osc-row { display:flex; gap:6px; flex-wrap:wrap; }
        .bells-osc-btn {
            padding:4px 8px; background:#1a2f3c; color:#e8f5ff; border:1px solid #2b5567;
            border-radius:6px; font-size:12px; cursor:pointer; min-width:44px; text-align:center;
        }
        .bells-osc-btn.active { background:#f39c12; border-color:#e67e22; color:#111; }
        .bells-osc-slider { display:flex; align-items:center; gap:6px; font-size:12px; color:#9db6c8; }
        .bells-osc-slider input[type="range"] { width:120px; }
        #bellsBars { position: relative; width: 100%; height: calc(100vh - 170px); overflow: hidden; }
        #bellsBars .bells-scroll-track { position:absolute; left:0; top:0; width:100%; height:200%; will-change: transform; transition: none; }
        #bellsBars .bells-scroll-panel { position: relative; width:100%; height:50%; }
        .bells-key {
            position: absolute; display: flex; align-items: center; justify-content: center;
            font-size: 22px; font-weight: 600; color: #000; text-shadow: 0 1px 0 rgba(255,255,255,0.2);
            user-select: none; cursor: pointer; border: 2px solid rgba(255,255,255,0.55);
            border-radius: 6px 6px 0 0;
            box-shadow: inset 0 0 0 2px rgba(0,0,0,0.25), inset 0 0 14px rgba(0,0,0,0.35), 0 4px 14px rgba(0,0,0,0.35);
            outline: 2px solid rgba(0,0,0,0.35);
            outline-offset: -2px;
            overflow: hidden;
        }
        .bells-key::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, rgba(255,255,255,0.45), rgba(255,255,255,0.05) 45%, rgba(0,0,0,0) 65%);
            opacity: 0.25;
            pointer-events: none;
            transform: translateX(-30%);
        }
        .bells-key.ringing::after {
            opacity: 0.75;
            animation: bellsShimmer 0.9s linear infinite;
        }
        .bells-key.bells-dim { filter: brightness(0.9); opacity: 0.9; }
        .bells-key.bells-current { box-shadow: inset 0 0 0 2px rgba(255,255,255,0.65), 0 0 18px rgba(255,255,255,0.25); }
        @keyframes bellsShimmer {
            0% { transform: translateX(-120%); }
            100% { transform: translateX(120%); }
        }
        .bells-natural { height: 100%; z-index: 1; bottom: 0; }
        .bells-accidental { height: 75%; z-index: 2; top: 0; }
        .bells-micro { height: 55%; z-index: 3; top: 0; }
        .bells-micro.small { height: 35%; }
    .bells-empty { padding: 24px; color: #9db6c8; font-size: 18px; }
  </style>
</head>
<body>
  <div id="bellsHeader">
        <div id="bellsTransportRow">
            <button id="bellsPlayBtn" class="bells-transport-btn">PLAY</button>
        </div>
    <div id="bellsChords"></div>
    <div id="bellsModeToggle"><button id="bellsModeToggleBtn" class="bells-mode-btn"></button></div>
        <div id="bellsControls">
            <label id="bellsCountLabel" for="bellsCount" style="font-size:14px;color:#9db6c8;">NOTES</label>
            <input id="bellsCount" type="range" min="1" max="16" value="2" />
            <span id="bellsCountValue">2</span>
            <label for="bellsOctave" style="font-size:14px;color:#9db6c8;">OCT</label>
            <input id="bellsOctave" type="range" min="2" max="6" value="4" />
            <span id="bellsOctaveValue">4</span>
            <label id="bellsGlideWrap"><input id="bellsGlide" type="checkbox" /> GLIDE</label>
        </div>
        <div id="bellsDrawerRow">
            <button id="bellsGearBtn" class="bells-gear" aria-expanded="false" title="BELLS Oscillator">âš™</button>
            <div id="bellsDrawer" class="bells-drawer">
                <div class="bells-osc-row" id="bellsOscWaveRow">
                    <button class="bells-osc-btn" data-wave="sine">Sin</button>
                    <button class="bells-osc-btn" data-wave="sawtooth">Saw</button>
                    <button class="bells-osc-btn" data-wave="square">Sqr</button>
                    <button class="bells-osc-btn" data-wave="triangle">Tri</button>
                    <button class="bells-osc-btn" data-wave="noise">Nse</button>
                    <button class="bells-osc-btn" data-wave="pulse">Pulse</button>
                    <button class="bells-osc-btn" data-wave="fullrect">FRect</button>
                    <button class="bells-osc-btn" data-wave="halfrect">HRect</button>
                    <button class="bells-osc-btn" data-wave="parabolic">Para</button>
                    <button class="bells-osc-btn" data-wave="stair">Stair</button>
                </div>
                <div class="bells-osc-slider">
                    <span>LEVEL</span>
                    <input id="bellsOscLevel" type="range" min="0" max="10" value="5" />
                    <span id="bellsOscLevelValue">50%</span>
                </div>
                <div class="bells-osc-slider">
                    <span>DETUNE</span>
                    <input id="bellsOscDetune" type="range" min="-50" max="50" value="0" />
                    <span id="bellsOscDetuneValue">0Â¢</span>
                </div>
                <div class="bells-osc-slider">
                    <span>OCT</span>
                    <input id="bellsOscOctave" type="range" min="-3" max="3" value="0" />
                    <span id="bellsOscOctaveValue">0</span>
                </div>
                <div class="bells-osc-slider">
                    <span>COARSE</span>
                    <input id="bellsOscCoarse" type="range" min="-24" max="24" value="0" step="1" />
                    <span id="bellsOscCoarseValue">0 steps</span>
                </div>
                <div class="bells-osc-slider">
                    <span>ATTACK</span>
                    <input id="bellsEnvAttack" type="range" min="0" max="1000" value="5" />
                    <span id="bellsEnvAttackValue">5ms</span>
                </div>
                <div class="bells-osc-slider">
                    <span>DECAY</span>
                    <input id="bellsEnvDecay" type="range" min="0" max="1000" value="250" />
                    <span id="bellsEnvDecayValue">250ms</span>
                </div>
                <div class="bells-osc-slider">
                    <span>SUSTAIN</span>
                    <input id="bellsEnvSustain" type="range" min="0" max="100" value="85" />
                    <span id="bellsEnvSustainValue">85%</span>
                </div>
                <div class="bells-osc-slider">
                    <span>RELEASE</span>
                    <input id="bellsEnvRelease" type="range" min="0" max="2000" value="350" />
                    <span id="bellsEnvReleaseValue">350ms</span>
                </div>
                <div class="bells-osc-slider">
                    <span>GLIDE</span>
                    <input id="bellsGlideMs" type="range" min="0" max="800" value="0" />
                    <span id="bellsGlideMsValue">AUTO</span>
                </div>
                <div class="bells-osc-slider">
                    <span>FUZZ</span>
                    <input id="bellsFuzz" type="range" min="0" max="100" value="0" />
                    <span id="bellsFuzzValue">0%</span>
                </div>
                <div class="bells-midi-row" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
                    <label for="midiIn-bells" style="font-size:11px;color:#9db6c8;">MIDI IN</label>
                    <input id="midiIn-bells" type="number" min="0" max="15" value="1" title="Listen on MIDI input channel (0-15; 0=omni)" style="width:64px; background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:2px 4px; font-size:11px;" />
                    <label for="midiOut-bells" style="font-size:11px;color:#9db6c8;">OUT</label>
                    <select id="midiOut-bells" title="Select MIDI output port (by name)" style="min-width:160px; background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:2px 4px; font-size:11px;"></select>
                </div>
            </div>
        </div>
  </div>
  <div id="bellsBars"></div>
</body>
</html>`;
                doc.open();
                doc.write(html);
                doc.close();
            }

            _getBellsChordList() {
                const cols = Array.from(document.querySelectorAll('.extension-column'));
                const list = [];
                cols.forEach((col) => {
                    try {
                        if (col?.dataset?.isSpacer === 'true') return;
                    } catch(_){ }
                    const name = col.querySelector('.extension-header .chord-name')?.textContent?.trim() || '';
                    const normName = name.replace(/\s+/g, ' ').trim().toLowerCase();
                    if (!name || name === '|' || normName === 'empty' || normName === '-' || normName === 'â€”' || normName === 'â€“' || normName === 'new') return;
                    try {
                        const id = col?.dataset?.chordId;
                        let model = null;
                        if (id) model = (this.chordExtensions || []).find(c => String(c?.id) === String(id)) || null;
                        if (!model && col?.dataset?.originalPosition != null) {
                            const op = parseInt(String(col.dataset.originalPosition), 10);
                            if (!isNaN(op) && op >= 0) model = this.chordExtensions?.[op] || null;
                        }
                        if (model && (model.isSpacer || (model.isCustom && (!model.intervals || model.intervals.length === 0) && String(model.name || '').trim().toLowerCase() === 'new'))) {
                            return;
                        }
                    } catch(_){ }
                    list.push({ name, column: col });
                });
                return list;
            }

            _getBellsActiveColumn(stateOrWin=null) {
                const list = this._getBellsChordList();
                if (list.length === 0) return null;
                const st = (stateOrWin && stateOrWin.document) ? this._getBellsState(stateOrWin) : (stateOrWin || this._getBellsState(null));
                const idx = Math.max(0, Math.min(list.length - 1, st?.activeIndex || 0));
                return list[idx]?.column || list[0].column;
            }

            _setBellsActiveIndex(idx, win=null) {
                const list = this._getBellsChordList();
                if (!list.length) return;
                const next = Math.max(0, Math.min(list.length - 1, idx | 0));
                const st = this._getBellsState(win);
                st.activeIndex = next;
                const col = list[next]?.column;
                if (col) {
                    this.currentActiveColumnEl = col;
                    try { this.highlightKeyboardForColumn(col); } catch(_) {}
                }
            }

            _renderBellsUI(winOverride=null) {
                const win = winOverride || this._bellsWin;
                if (!win || win.closed) return;
                if (win.__bellsInline) {
                    try { this._ensureInlineBellsState(win); } catch(_){ }
                }
                const doc = win.document;
                const chordsEl = doc.getElementById('bellsChords');
                const modeEl = doc.getElementById('bellsModeToggle');
                const barsEl = doc.getElementById('bellsBars');
                const zoomWrap = doc.getElementById('bellsZoomWrap');
                const zoomEl = doc.getElementById('bellsZoom');
                const zoomValEl = doc.getElementById('bellsZoomValue');
                const slider = doc.getElementById('bellsCount');
                const sliderVal = doc.getElementById('bellsCountValue');
                const sliderLabel = doc.getElementById('bellsCountLabel');
                const octSlider = doc.getElementById('bellsOctave');
                const octVal = doc.getElementById('bellsOctaveValue');
                const glideToggle = doc.getElementById('bellsGlide');
                const gearBtn = doc.getElementById('bellsGearBtn');
                const drawer = doc.getElementById('bellsDrawer');
                const waveRow = doc.getElementById('bellsOscWaveRow');
                const levelEl = doc.getElementById('bellsOscLevel');
                const levelVal = doc.getElementById('bellsOscLevelValue');
                const detuneEl = doc.getElementById('bellsOscDetune');
                const detuneVal = doc.getElementById('bellsOscDetuneValue');
                const octEl = doc.getElementById('bellsOscOctave');
                const octVal2 = doc.getElementById('bellsOscOctaveValue');
                const coarseEl = doc.getElementById('bellsOscCoarse');
                const coarseVal = doc.getElementById('bellsOscCoarseValue');
                const atkEl = doc.getElementById('bellsEnvAttack');
                const atkVal = doc.getElementById('bellsEnvAttackValue');
                const decEl = doc.getElementById('bellsEnvDecay');
                const decVal = doc.getElementById('bellsEnvDecayValue');
                const susEl = doc.getElementById('bellsEnvSustain');
                const susVal = doc.getElementById('bellsEnvSustainValue');
                const relEl = doc.getElementById('bellsEnvRelease');
                const relVal = doc.getElementById('bellsEnvReleaseValue');
                const glideMsEl = doc.getElementById('bellsGlideMs');
                const glideMsVal = doc.getElementById('bellsGlideMsValue');
                const fuzzEl = doc.getElementById('bellsFuzz');
                const fuzzVal = doc.getElementById('bellsFuzzValue');
                const midiInEl = doc.getElementById('midiIn-bells');
                const midiOutEl = doc.getElementById('midiOut-bells');
                if (!chordsEl || !modeEl || !barsEl || !slider || !sliderVal || !sliderLabel || !octSlider || !octVal || !glideToggle) return;

                try {
                    const midi = window.midi;
                    if (midi && midi.enabled && midiOutEl) {
                        midi.populateOutputSelect(midiOutEl);
                        if (win.__bellsMidiOutId == null) {
                            const seed = (midi.outputPortMap?.bells ?? midi.outputPortMap?.default ?? '');
                            win.__bellsMidiOutId = seed || null;
                        }
                        const desired = win.__bellsMidiOutId;
                        if (desired && Array.from(midiOutEl.options).some(op=>op.value===desired)) midiOutEl.value = desired;
                    }
                } catch(_){ }

                const list = this._getBellsChordList();
                const st = this._getBellsState(win);
                if (st.activeIndex >= list.length) st.activeIndex = 0;
                if (!st.mode) st.mode = 'single';

                const isInline = !!win.__bellsInline;
                if (zoomWrap && zoomEl && zoomValEl) {
                    if (isInline) {
                        const edo = this.currentTuning || 12;
                        const limits = this._getInlineJamSpanLimits(edo);
                        zoomWrap.style.display = '';
                        zoomEl.min = String(limits.minSpan);
                        zoomEl.max = String(limits.maxSpan);
                        zoomEl.step = '1';
                        const curSteps = Math.max(limits.minSpan, Math.min(limits.maxSpan, (st.spanSteps || limits.minSpan) | 0));
                        zoomEl.value = String(curSteps);
                        const curOct = curSteps / edo;
                        zoomValEl.textContent = `${curSteps} ${curSteps === 1 ? 'key' : 'keys'} (${curOct.toFixed(2)}x)`;
                        if (!zoomEl._wired) {
                            zoomEl._wired = true;
                            zoomEl.addEventListener('input', () => {
                                const edoNow = this.currentTuning || 12;
                                const lim = this._getInlineJamSpanLimits(edoNow);
                                const steps = Math.max(lim.minSpan, Math.min(lim.maxSpan, parseInt(zoomEl.value, 10) || lim.minSpan));
                                const center = (st.baseAbsStep || 0) + ((st.spanSteps || lim.minSpan) - 1) / 2;
                                const maxAbs = edoNow * 8;
                                const minAbs = 0;
                                const maxBase = Math.max(minAbs, maxAbs - (steps - 1));
                                const nextBase = Math.max(minAbs, Math.min(maxBase, center - ((steps - 1) / 2)));
                                st.spanSteps = steps;
                                st.baseAbsStep = nextBase;
                                const oct = steps / edoNow;
                                zoomValEl.textContent = `${steps} ${steps === 1 ? 'key' : 'keys'} (${oct.toFixed(2)}x)`;
                                this._renderBellsBars(win);
                            });
                        }
                    } else {
                        zoomWrap.style.display = 'none';
                    }
                }

                chordsEl.innerHTML = '';
                if (list.length === 0) {
                    barsEl.innerHTML = '<div class="bells-empty">No chords available.</div>';
                    return;
                }

                list.forEach((item, i) => {
                    const btn = doc.createElement('button');
                    const isActive = (st.mode === 'single' && i === st.activeIndex);
                    btn.className = 'bells-chord-btn' + (isActive ? ' active' : '');
                    btn.textContent = item.name;
                    btn.addEventListener('click', () => {
                        this._setBellsActiveIndex(i, win);
                        st.mode = 'single';
                        this._renderBellsUI(win);
                    });
                    chordsEl.appendChild(btn);
                });

                const modeBtn = doc.getElementById('bellsModeToggleBtn');
                if (modeBtn) {
                    const modes = [
                        { label: 'CURRENT CHORD', value: 'single' },
                        { label: 'ALL CHORDS', value: 'all-chords' },
                        { label: 'ALL NOTES', value: 'all-notes' }
                    ];
                    const curIdx = Math.max(0, modes.findIndex(m => m.value === st.mode));
                    const cur = modes[curIdx] || modes[0];
                    modeBtn.textContent = cur.label;
                    modeBtn.classList.toggle('active', cur.value !== 'single');
                    if (!modeBtn._wired) {
                        modeBtn._wired = true;
                        modeBtn.addEventListener('click', () => {
                            const i = Math.max(0, modes.findIndex(m => m.value === st.mode));
                            const next = modes[(i + 1) % modes.length];
                            st.mode = next.value;
                            this._renderBellsUI(win);
                        });
                    }
                }

                if (!slider._wired) {
                    slider._wired = true;
                    slider.addEventListener('input', () => {
                        const v = Math.max(1, Math.min(16, parseInt(slider.value, 10) || 2));
                        st.count = v;
                        sliderVal.textContent = String(v);
                        this._renderBellsBars(win);
                    });
                }
                if (!octSlider._wired) {
                    octSlider._wired = true;
                    octSlider.addEventListener('input', () => {
                        const v = Math.max(2, Math.min(6, parseInt(octSlider.value, 10) || 4));
                        st.baseOct = v;
                        octVal.textContent = String(v);
                        this._renderBellsBars(win);
                    });
                }
                const midiOnForBells = !!(window.midi && window.midi.enabled);
                if (midiOnForBells) {
                    st.glide = false;
                    if (this._bellsGlideActive) this._bellsGlideStop();
                }
                if (glideMsEl) {
                    glideMsEl.disabled = midiOnForBells;
                    try { glideMsEl.title = midiOnForBells ? 'GLIDE disabled when MIDI is enabled' : 'Glide time'; } catch(_){ }
                }
                if (!glideToggle._wired) {
                    glideToggle._wired = true;
                    glideToggle.addEventListener('change', () => {
                        if (window.midi && window.midi.enabled) {
                            glideToggle.checked = false;
                            st.glide = false;
                            if (this._bellsGlideActive) this._bellsGlideStop();
                            return;
                        }
                        st.glide = !!glideToggle.checked;
                        if (!st.glide && this._bellsGlideActive) this._bellsGlideStop();
                    });
                }
                // BELLS OSC drawer controls
                try {
                    const cloneInst = (obj)=>{ try { if (typeof structuredClone==='function') return structuredClone(obj); } catch(_){} try { return JSON.parse(JSON.stringify(obj)); } catch(_) { return obj; } };
                    const baseInst = this.instruments?.bells || (this.instruments.bells = {
                        osc: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                        env: { attack: 0.005, decay: 0.25, sustain: 0.85, release: 0.35 },
                        fxSend: true
                    });
                    if (!win.__bellsInst) win.__bellsInst = cloneInst(baseInst);
                    const inst = win.__bellsInst;

                    if (gearBtn && drawer && !gearBtn._wired) {
                        gearBtn._wired = true;
                        gearBtn.addEventListener('click', () => {
                            drawer.classList.toggle('open');
                            gearBtn.setAttribute('aria-expanded', drawer.classList.contains('open') ? 'true' : 'false');
                        });
                    }

                    if (waveRow && !waveRow._wired) {
                        waveRow._wired = true;
                        waveRow.querySelectorAll('.bells-osc-btn').forEach(btn => {
                            btn.addEventListener('click', () => {
                                const wave = String(btn.dataset.wave || 'sine');
                                inst.osc.type = wave;
                                waveRow.querySelectorAll('.bells-osc-btn').forEach(b=> b.classList.toggle('active', b === btn));
                            });
                        });
                    }

                    if (levelEl && !levelEl._wired) {
                        levelEl._wired = true;
                        levelEl.addEventListener('input', () => {
                            const v = Math.max(0, Math.min(10, parseInt(levelEl.value, 10) || 0));
                            inst.osc.level = (v * 0.125) / 10;
                            if (levelVal) levelVal.textContent = `${Math.round((v/10)*100)}%`;
                        });
                    }
                    if (detuneEl && !detuneEl._wired) {
                        detuneEl._wired = true;
                        detuneEl.addEventListener('input', () => {
                            const v = Math.max(-50, Math.min(50, parseInt(detuneEl.value, 10) || 0));
                            inst.osc.detune = v;
                            if (detuneVal) detuneVal.textContent = `${v}Â¢`;
                        });
                    }
                    if (octEl && !octEl._wired) {
                        octEl._wired = true;
                        octEl.addEventListener('input', () => {
                            const v = Math.max(-3, Math.min(3, parseInt(octEl.value, 10) || 0));
                            inst.osc.octave = v;
                            if (octVal2) octVal2.textContent = String(v);
                        });
                    }
                    if (coarseEl && !coarseEl._wired) {
                        coarseEl._wired = true;
                        coarseEl.addEventListener('input', () => {
                            const v = Math.max(-24, Math.min(24, parseInt(coarseEl.value, 10) || 0));
                            inst.osc.coarse = v;
                            if (coarseVal) coarseVal.textContent = `${v} steps`;
                        });
                    }
                    if (atkEl && !atkEl._wired) {
                        atkEl._wired = true;
                        atkEl.addEventListener('input', () => {
                            const v = Math.max(0, Math.min(1000, parseInt(atkEl.value, 10) || 0));
                            inst.env.attack = v / 1000;
                            if (atkVal) atkVal.textContent = `${v}ms`;
                        });
                    }
                    if (decEl && !decEl._wired) {
                        decEl._wired = true;
                        decEl.addEventListener('input', () => {
                            const v = Math.max(0, Math.min(1000, parseInt(decEl.value, 10) || 0));
                            inst.env.decay = v / 1000;
                            if (decVal) decVal.textContent = `${v}ms`;
                        });
                    }
                    if (susEl && !susEl._wired) {
                        susEl._wired = true;
                        susEl.addEventListener('input', () => {
                            const v = Math.max(0, Math.min(100, parseInt(susEl.value, 10) || 0));
                            inst.env.sustain = v / 100;
                            if (susVal) susVal.textContent = `${v}%`;
                        });
                    }
                    if (relEl && !relEl._wired) {
                        relEl._wired = true;
                        relEl.addEventListener('input', () => {
                            const v = Math.max(0, Math.min(2000, parseInt(relEl.value, 10) || 0));
                            inst.env.release = v / 1000;
                            if (relVal) relVal.textContent = `${v}ms`;
                        });
                    }
                    if (glideMsEl && !glideMsEl._wired) {
                        glideMsEl._wired = true;
                        glideMsEl.addEventListener('input', () => {
                            const v = Math.max(0, Math.min(800, parseInt(glideMsEl.value, 10) || 0));
                            this._bellsGlideMs = v > 0 ? v : null;
                            if (glideMsVal) glideMsVal.textContent = v > 0 ? `${v}ms` : 'AUTO';
                        });
                    }
                    if (fuzzEl && !fuzzEl._wired) {
                        fuzzEl._wired = true;
                        fuzzEl.addEventListener('input', () => {
                            const v = Math.max(0, Math.min(100, parseInt(fuzzEl.value, 10) || 0));
                            if (this._bellsFuzz) {
                                this._bellsFuzz.amount = v;
                                if (typeof this.updateBellsFuzz === 'function') this.updateBellsFuzz();
                            }
                            if (fuzzVal) fuzzVal.textContent = `${v}%`;
                        });
                    }

                    // BELLS MIDI IN/OUT controls
                    try {
                        const midi = window.midi;
                        if (midi) {
                            midi.inputChannelMap = midi.inputChannelMap || {};
                            midi.outputPortMap = midi.outputPortMap || {};
                            if (midi.inputChannelMap.bells == null) midi.inputChannelMap.bells = (midi.inputChannelMap.arp ?? 1);
                            if (midi.outputPortMap.bells == null) midi.outputPortMap.bells = (midi.outputPortMap.arp ?? midi.outputPortMap.default ?? null);

                            if (midiInEl && !midiInEl._wiredMidiBells) {
                                midiInEl._wiredMidiBells = true;
                                midiInEl.addEventListener('change', ()=>{
                                    midi.inputChannelMap.bells = Math.max(0, Math.min(15, parseInt(midiInEl.value||'0',10)|0));
                                    try { midi.saveMIDISettings && midi.saveMIDISettings(); } catch(_){ }
                                });
                            }
                            if (midiOutEl && !midiOutEl._wiredMidiBells) {
                                midiOutEl._wiredMidiBells = true;
                                try { midi.populateOutputSelect && midi.populateOutputSelect(midiOutEl); } catch(_){ }
                                try {
                                    if (win.__bellsMidiOutId == null) {
                                        const seed = (midi.outputPortMap.bells || midi.outputPortMap.default || '');
                                        win.__bellsMidiOutId = seed || null;
                                    }
                                    const sel = win.__bellsMidiOutId || '';
                                    midiOutEl.value = String(sel || '');
                                } catch(_){ }
                                midiOutEl.addEventListener('change', ()=>{
                                    const id = String(midiOutEl.value||'');
                                    win.__bellsMidiOutId = id || null;
                                    try { this._renderBellsBars(win); } catch(_){ }
                                });
                            }
                        }
                    } catch(_) {}

                    // Sync UI values from instrument state
                    try {
                        if (waveRow) {
                            const wave = String(inst.osc.type || 'sine');
                            waveRow.querySelectorAll('.bells-osc-btn').forEach(btn => btn.classList.toggle('active', String(btn.dataset.wave) === wave));
                        }
                        if (levelEl) {
                            const levelUi = Math.max(0, Math.min(10, Math.round((inst.osc.level || 0) * 10 / 0.125)));
                            levelEl.value = String(levelUi);
                            if (levelVal) levelVal.textContent = `${Math.round((levelUi/10)*100)}%`;
                        }
                        if (detuneEl) {
                            const v = Math.max(-50, Math.min(50, Math.round(inst.osc.detune || 0)));
                            detuneEl.value = String(v);
                            if (detuneVal) detuneVal.textContent = `${v}Â¢`;
                        }
                        if (octEl) {
                            const v = Math.max(-3, Math.min(3, parseInt(inst.osc.octave || 0, 10) || 0));
                            octEl.value = String(v);
                            if (octVal2) octVal2.textContent = String(v);
                        }
                        if (coarseEl) {
                            const v = Math.max(-24, Math.min(24, parseInt(inst.osc.coarse || 0, 10) || 0));
                            coarseEl.value = String(v);
                            if (coarseVal) coarseVal.textContent = `${v} steps`;
                        }
                        if (atkEl) {
                            const v = Math.max(0, Math.min(1000, Math.round((inst.env.attack || 0) * 1000)));
                            atkEl.value = String(v);
                            if (atkVal) atkVal.textContent = `${v}ms`;
                        }
                        if (decEl) {
                            const v = Math.max(0, Math.min(1000, Math.round((inst.env.decay || 0) * 1000)));
                            decEl.value = String(v);
                            if (decVal) decVal.textContent = `${v}ms`;
                        }
                        if (susEl) {
                            const v = Math.max(0, Math.min(100, Math.round((inst.env.sustain ?? 0.85) * 100)));
                            susEl.value = String(v);
                            if (susVal) susVal.textContent = `${v}%`;
                        }
                        if (relEl) {
                            const v = Math.max(0, Math.min(2000, Math.round((inst.env.release || 0) * 1000)));
                            relEl.value = String(v);
                            if (relVal) relVal.textContent = `${v}ms`;
                        }
                        if (glideMsEl) {
                            const v = Number.isFinite(this._bellsGlideMs) ? Math.max(0, Math.min(800, Math.round(this._bellsGlideMs))) : 0;
                            glideMsEl.value = String(v);
                            if (glideMsVal) glideMsVal.textContent = v > 0 ? `${v}ms` : 'AUTO';
                        }
                        if (fuzzEl) {
                            const v = this._bellsFuzz ? Math.max(0, Math.min(100, Math.round(this._bellsFuzz.amount || 0))) : 0;
                            fuzzEl.value = String(v);
                            if (fuzzVal) fuzzVal.textContent = `${v}%`;
                        }
                        try {
                            const midi = window.midi;
                            if (midiInEl && midi) {
                                const v = Math.max(0, Math.min(15, parseInt(midi.inputChannelMap?.bells ?? 1, 10) || 0));
                                midiInEl.value = String(v);
                            }
                            if (midiOutEl && midi) {
                                const sel = win.__bellsMidiOutId || '';
                                if (Array.from(midiOutEl.options || []).some(op=>String(op.value)===String(sel))) {
                                    midiOutEl.value = String(sel || '');
                                }
                            }
                        } catch(_) {}
                    } catch(_) {}
                } catch(_) {}
                if (st.mode === 'all-chords' || st.mode === 'all-notes') {
                    sliderLabel.textContent = 'OCTAVES';
                    slider.min = '1';
                    slider.max = '6';
                } else {
                    sliderLabel.textContent = 'NOTES';
                    slider.min = '1';
                    slider.max = '16';
                }
                slider.value = String(st.count || 2);
                sliderVal.textContent = String(st.count || 2);
                octSlider.value = String(st.baseOct || 4);
                octVal.textContent = String(st.baseOct || 4);
                glideToggle.checked = !!st.glide;
                glideToggle.disabled = !!(window.midi && window.midi.enabled);
                try {
                    glideToggle.title = glideToggle.disabled ? 'GLIDE disabled when MIDI is enabled' : 'Enable glide';
                } catch(_){ }
                try {
                    const playBtn = doc.getElementById('bellsPlayBtn');
                    if (playBtn) {
                        if (win.__bellsInline) {
                            playBtn.style.display = 'none';
                        } else {
                            const isRunning = !!(this._arpTransport && this._arpTransport.running);
                            playBtn.textContent = isRunning ? 'STOP' : 'PLAY';
                            playBtn.title = isRunning ? 'Stop transport' : 'Start transport';
                            playBtn.classList.toggle('active', isRunning);
                            if (!playBtn._wired) {
                                playBtn._wired = true;
                                playBtn.addEventListener('click', () => {
                                    try {
                                        const transportBtn = document.getElementById('playStopToggleBtn');
                                        if (transportBtn) transportBtn.click();
                                    } catch(_){ }
                                });
                            }
                        }
                    }
                } catch(_){ }
                this._renderBellsBars(win);
            }

            _renderBellsBars(winOverride=null) {
                const win = winOverride || this._bellsWin;
                if (!win || win.closed) return;
                const doc = win.document;
                const barsEl = doc.getElementById('bellsBars');
                if (!barsEl) return;

                if (win.__bellsInline) {
                    try { this._ensureInlineBellsState(win); } catch(_){ }
                }
                const st = this._getBellsState(win);
                const edoInline = this.currentTuning || 12;
                let notes = [];
                let count = Math.max(1, Math.min(16, st?.count || 2));
                const nowCol = this._getNowPlayingColumn();
                const currentSteps = nowCol ? this._getCurrentChordAbsSteps(nowCol) : null;
                if (win.__bellsInline) {
                    const limits = this._getInlineJamSpanLimits(edoInline);
                    const span = Math.max(limits.minSpan, Math.min(limits.maxSpan, (st.spanSteps || limits.minSpan)|0));
                    st.spanSteps = span;
                    const maxAbs = (edoInline * 8);
                    const minAbs = 0;
                    const maxBase = Math.max(minAbs, maxAbs - (span - 1));
                    let baseAbs = Number.isFinite(st.baseAbsStep) ? st.baseAbsStep : ((st.baseOct || 4) * edoInline);
                    baseAbs = Math.max(minAbs, Math.min(maxBase, baseAbs));
                    st.baseAbsStep = baseAbs;
                    notes = this._computeInlineJamNotes(baseAbs, span, edoInline);
                    count = notes.length;
                } else
                if (st?.mode === 'all-chords') {
                    const octCount = Math.max(1, Math.min(6, st?.count || 1));
                    notes = this._computeAllChordsNotes(octCount, st);
                    count = notes.length;
                    const slider = doc.getElementById('bellsCount');
                    const sliderVal = doc.getElementById('bellsCountValue');
                    if (slider) slider.value = String(octCount);
                    if (sliderVal) sliderVal.textContent = String(count);
                } else if (st?.mode === 'all-notes') {
                    const octCount = Math.max(1, Math.min(6, st?.count || 1));
                    notes = this._computeAllNotes(octCount, st);
                    count = notes.length;
                    const slider = doc.getElementById('bellsCount');
                    const sliderVal = doc.getElementById('bellsCountValue');
                    if (slider) slider.value = String(octCount);
                    if (sliderVal) sliderVal.textContent = String(count);
                } else {
                    const col = this._getBellsActiveColumn(st);
                    if (!col) {
                        barsEl.innerHTML = '<div class="bells-empty">No chord selected.</div>';
                        return;
                    }
                    notes = this._computeBellsNotes(col, count, st);
                }

                if (!notes || notes.length === 0) {
                    barsEl.innerHTML = '<div class="bells-empty">No notes available.</div>';
                    return;
                }
                barsEl.innerHTML = '';

                // Inline JAM: drag/pinch on negative space
                if (win.__bellsInline && !barsEl._inlineJamWired) {
                    barsEl._inlineJamWired = true;
                    barsEl._jamPointers = new Map();
                    barsEl._jamPinchDist = null;
                    barsEl._jamPinchStart = null;
                    barsEl._jamDrag = null;
                    barsEl._jamRaf = null;
                    const clampBase = (baseAbs, spanSteps)=>{
                        const maxAbs = edoInline * 8;
                        const minAbs = 0;
                        const maxBase = Math.max(minAbs, maxAbs - (spanSteps - 1));
                        return Math.max(minAbs, Math.min(maxBase, baseAbs));
                    };
                    const stepPxForSpan = (span)=>{
                        const w = barsEl.clientWidth || 1;
                        return Math.max(8, w / Math.max(1, (span - 1)));
                    };
                    const scheduleRender = ()=>{
                        if (barsEl._jamRaf) return;
                        barsEl._jamRaf = requestAnimationFrame(()=>{
                            barsEl._jamRaf = null;
                            this._renderBellsBars(win);
                        });
                    };
                    const isNegativeSpace = (target)=>{
                        if (!target) return true;
                        if (target.closest && target.closest('.bells-key')) return false;
                        return true;
                    };
                    barsEl.addEventListener('pointerdown', (e)=>{
                        if (!isNegativeSpace(e.target)) return;
                        try { barsEl.setPointerCapture(e.pointerId); } catch(_){ }
                        barsEl._jamPointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
                        if (barsEl._jamPointers.size === 1) {
                            const limits = this._getInlineJamSpanLimits(edoInline);
                            const span = st.spanSteps || limits.minSpan;
                            barsEl._jamDrag = {
                                startX: e.clientX,
                                baseAbs: st.baseAbsStep || ((st.baseOct || 4) * edoInline),
                                spanSteps: span,
                                stepPx: stepPxForSpan(span)
                            };
                        }
                        if (barsEl._jamPointers.size === 2) {
                            // Pinch zoom disabled; use the zoom slider instead.
                            barsEl._jamPinchDist = null;
                            barsEl._jamPinchStart = null;
                        }
                    });
                    barsEl.addEventListener('pointermove', (e)=>{
                        if (!barsEl._jamPointers.has(e.pointerId)) return;
                        barsEl._jamPointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
                        if (barsEl._jamPointers.size === 2) return;
                        if (barsEl._jamDrag) {
                            const drag = barsEl._jamDrag;
                            const dx = e.clientX - drag.startX;
                            const span = st.spanSteps || drag.spanSteps || this._getInlineJamSpanLimits(edoInline).minSpan;
                            const stepDelta = -dx / drag.stepPx;
                            const nextBase = clampBase(drag.baseAbs + stepDelta, span);
                            if (nextBase !== st.baseAbsStep) {
                                st.baseAbsStep = nextBase;
                                scheduleRender();
                            }
                        }
                    });
                    const endPointer = (e)=>{
                        if (barsEl._jamPointers.has(e.pointerId)) barsEl._jamPointers.delete(e.pointerId);
                        if (barsEl._jamPointers.size < 2) {
                            barsEl._jamPinchDist = null;
                            barsEl._jamPinchStart = null;
                        }
                        if (barsEl._jamPointers.size === 0) barsEl._jamDrag = null;
                    };
                    barsEl.addEventListener('pointerup', endPointer);
                    barsEl.addEventListener('pointercancel', endPointer);
                }

                // Drag-to-strum support across keys
                try {
                    if (!win.__bellsDragWired) {
                        win.__bellsDragWired = true;
                        win.__bellsDragActive = false;
                        win.__bellsLastIndex = -1;
                        win.__bellsPlayedSet = new Set();
                        win.__bellsLastX = null;
                        win.__bellsDir = 0;
                        win.document.addEventListener('pointerup', (e) => {
                            win.__bellsDragActive = false;
                            win.__bellsLastIndex = -1;
                            win.__bellsLastX = null;
                            win.__bellsDir = 0;
                            if (this._bellsGlideActive) this._bellsGlideStop();
                            try { this._handleInlineJamDrop(win, e); } catch(_){ }
                        });
                        win.document.addEventListener('pointercancel', () => { win.__bellsDragActive = false; win.__bellsLastIndex = -1; win.__bellsLastX = null; win.__bellsDir = 0; if (this._bellsGlideActive) this._bellsGlideStop(); });
                        const getKeyAtPoint = (x, y) => {
                            try {
                                const list = (win.document.elementsFromPoint ? win.document.elementsFromPoint(x, y) : [win.document.elementFromPoint(x, y)]).filter(Boolean);
                                const keys = list.map(el => (el && el.closest) ? el.closest('.bells-key') : null).filter(Boolean);
                                let top = keys[0] || null;
                                if (!top) {
                                    try {
                                        const allKeys = Array.from(win.document.querySelectorAll('.bells-key'));
                                        let best = null;
                                        allKeys.forEach(k => {
                                            const r = k.getBoundingClientRect();
                                            if (x < r.left || x > r.right) return;
                                            const dy = (y < r.top) ? (r.top - y) : (y > r.bottom) ? (y - r.bottom) : 0;
                                            if (best == null || dy < best.dy) best = { k, dy };
                                        });
                                        if (best && best.dy <= 14) top = best.k;
                                    } catch(_){ }
                                }
                                if (!top) return null;
                                return top;
                            } catch(_){ return null; }
                        };
                        win.__bellsGetKeyAtPoint = getKeyAtPoint;
                        win.document.addEventListener('pointermove', (e) => {
                            try {
                                if (!win.__bellsDragActive) return;
                                const glideOn = !!st?.glide;
                                win.__bellsLastX = e.clientX;
                                const key = getKeyAtPoint(e.clientX, e.clientY);
                                if (!key) {
                                    if (glideOn && win.__bellsLayout) {
                                        this._bellsGlideUpdateFromX(win, e.clientX, e.clientY);
                                    }
                                    return;
                                }
                                const idx = parseInt(key.dataset.index || '-1', 10);
                                if (idx < 0) return;
                                const note = key.__bellsNote;
                                if (glideOn) {
                                    if (note) this._bellsGlideSnapTo(note, key, win, e.clientX, e.clientY);
                                    return;
                                }
                                if (idx === win.__bellsLastIndex) return;
                                win.__bellsLastIndex = idx;
                                if (note) this._playBellsNote(note, key);
                            } catch(_) {}
                        });
                    }
                } catch(_) {}

                // Piano-style layout: naturals full height, accidentals/microtonals nested above.
                const noteNames = this.getNoteNames();
                const tuning = (notes[0] && notes[0].tuning) ? notes[0].tuning : (this.currentTuning || 12);
                const parseLabel = (label) => {
                    const name = String(label || '').replace(/[0-9]/g,'');
                    const m = name.match(/^([A-G])([#b]?)(.*)$/);
                    if (!m) return { base: name, acc: '', micro: '' };
                    return { base: m[1], acc: m[2] || '', micro: m[3] || '' };
                };
                const isNaturalLabel = (label) => {
                    const p = parseLabel(label);
                    return !!p.base && !p.acc && !p.micro;
                };
                const isAccidentalLabel = (label) => {
                    const p = parseLabel(label);
                    return !!p.base && !!p.acc && !p.micro;
                };
                const isMicroLabel = (label) => {
                    const p = parseLabel(label);
                    return !!p.base && !!p.micro;
                };
                const jiTargets = [
                    { name: 'C', cents: 0 },
                    { name: 'D', cents: 1200 * Math.log2(9/8) },
                    { name: 'E', cents: 1200 * Math.log2(5/4) },
                    { name: 'F', cents: 1200 * Math.log2(4/3) },
                    { name: 'G', cents: 1200 * Math.log2(3/2) },
                    { name: 'A', cents: 1200 * Math.log2(5/3) },
                    { name: 'B', cents: 1200 * Math.log2(15/8) }
                ];
                const buildJINaturalMap = (edo) => {
                    const stepCents = Array.from({ length: edo }, (_, step) => {
                        const cents = ((this.getCentValue(step, edo) % 1200) + 1200) % 1200;
                        return { step, cents };
                    });
                    const bestForDegree = new Map();
                    jiTargets.forEach((d) => {
                        let best = { step: 0, dist: Infinity };
                        stepCents.forEach((s) => {
                            let dist = Math.abs(s.cents - d.cents);
                            if (dist > 600) dist = 1200 - dist;
                            if (dist < best.dist) best = { step: s.step, dist };
                        });
                        bestForDegree.set(d.name, best);
                    });
                    const naturalSteps = new Set(Array.from(bestForDegree.values()).map(v => v.step));
                    const stepToName = new Map();
                    stepCents.forEach((s) => {
                        let best = { name: 'C', dist: Infinity };
                        jiTargets.forEach((d) => {
                            let dist = Math.abs(s.cents - d.cents);
                            if (dist > 600) dist = 1200 - dist;
                            if (dist < best.dist) best = { name: d.name, dist };
                        });
                        stepToName.set(s.step, best.name);
                    });
                    return { naturalSteps, stepToName };
                };
                const jiMap = buildJINaturalMap(tuning);

                const renderNotes = (noteList, targetEl, opts={}) => {
                    const highlightSteps = opts.highlightSteps || null;
                    const forceFull = !!opts.forceFull;
                    const addKey = (note, idx, cls, leftPct, widthPct, heightPct, z, displayLabel) => {
                        const key = doc.createElement('div');
                        key.className = `bells-key ${cls}`;
                        key.dataset.index = String(idx);
                        key.__bellsNote = note;
                        key.style.background = note.color;
                        key.style.left = `${leftPct}%`;
                        key.style.width = `${widthPct}%`;
                        key.style.height = `${heightPct}%`;
                        key.style.zIndex = String(z);
                        if (cls.includes('bells-natural')) {
                            key.style.bottom = '0';
                            key.style.top = 'auto';
                        } else {
                            key.style.top = '0';
                            key.style.bottom = 'auto';
                        }
                        const label = displayLabel || note.label;
                        key.textContent = label;
                        key.title = label;
                        key.__midiOutOverride = win.__bellsMidiOutId || null;
                        key.__bellsInst = win.__bellsInst || null;
                        key.__bellsState = st;
                        if (highlightSteps && !highlightSteps.has(note.step)) key.classList.add('bells-dim');
                        if (highlightSteps && highlightSteps.has(note.step)) key.classList.add('bells-current');
                        const play = () => this._playBellsNote(note, key);
                        key.addEventListener('pointerdown', (ev) => {
                            try {
                                if (win.__bellsInline) {
                                    win.__jamDragNote = note;
                                    win.__jamDragStep = note.step;
                                    win.__jamDragTuning = note.tuning || this.currentTuning || 12;
                                    win.__jamDragKeyEl = key;
                                    win.__jamDragStart = { x: ev.clientX, y: ev.clientY };
                                }
                            } catch(_) {}
                            try {
                                win.__bellsDragActive = true;
                                win.__bellsLastIndex = idx;
                                win.__bellsPlayedSet = new Set([idx]);
                                win.__bellsLastX = ev.clientX;
                                win.__bellsDir = 0;
                                const rect = win.__bellsLayout?.rect;
                                if (rect && rect.width > 0) {
                                    const xNorm = Math.max(0, Math.min(1, (ev.clientX - rect.left) / rect.width));
                                    const absCents = this.getCentValue(note.step, note.tuning||this.currentTuning) + (note.octave*1200);
                                    win.__bellsAnchor = { absCents, xNorm };
                                }
                            } catch(_) {}
                            let useKey = key;
                            let useNote = note;
                            try {
                                if (win.__bellsGetKeyAtPoint) {
                                    const k2 = win.__bellsGetKeyAtPoint(ev.clientX, ev.clientY);
                                    if (k2 && k2.__bellsNote) { useKey = k2; useNote = k2.__bellsNote; }
                                }
                            } catch(_) {}
                            try {
                                const useIdx = parseInt(useKey?.dataset?.index || '-1', 10);
                                if (useIdx >= 0) win.__bellsLastIndex = useIdx;
                            } catch(_){ }
                            if (st?.glide) {
                                this._bellsGlideStart(useNote, useKey, win, ev.clientX, ev.clientY);
                            } else {
                                this._playBellsNote(useNote, useKey);
                            }
                        });
                        key.addEventListener('pointerenter', (ev) => {
                            try {
                                if (!win.__bellsDragActive) return;
                                if (st?.glide) {
                                    this._bellsGlideSnapTo(note, key, win, win.__bellsLastX ?? 0, 0);
                                    return;
                                }
                                if (idx === win.__bellsLastIndex) return;
                                win.__bellsLastIndex = idx;
                                const rect = win.__bellsLayout?.rect;
                                if (rect && rect.width > 0) {
                                    const xNorm = Math.max(0, Math.min(1, ((win.__bellsLastX ?? 0) - rect.left) / rect.width));
                                    const absCents = this.getCentValue(note.step, note.tuning||this.currentTuning) + (note.octave*1200);
                                    win.__bellsAnchor = { absCents, xNorm };
                                }
                                play();
                            } catch(_) {}
                        });
                        key.addEventListener('touchstart', (e) => { e.preventDefault(); play(); }, { passive: false });
                        targetEl.appendChild(key);
                    };

                    // Cent-based spacing across the rendered pitch span (no gaps, any EDO 5â€“53)
                    const absNotes = noteList.map((n, i) => {
                        const stepC = this.getCentValue(n.step, n.tuning || tuning) % 1200;
                        const absC = (n.octave || 0) * 1200 + stepC;
                        return { note: n, idx: i, absCents: absC };
                    });
                    absNotes.sort((a,b)=> a.absCents - b.absCents);
                    const minC = absNotes[0]?.absCents ?? 0;
                    const maxC = absNotes[absNotes.length-1]?.absCents ?? (minC + 1200);
                    const wantsEdgePad = !!(opts.edgePad && absNotes.length > 1);
                    let padC = 0;
                    if (wantsEdgePad) {
                        const firstGap = Math.max(1, absNotes[1].absCents - absNotes[0].absCents);
                        const lastGap = Math.max(1, absNotes[absNotes.length - 1].absCents - absNotes[absNotes.length - 2].absCents);
                        padC = Math.max(1, Math.min(firstGap, lastGap) / 2);
                    }
                    const span = Math.max(1, (maxC - minC) + padC * 2);
                    const pos = absNotes.map(o => ({
                        ...o,
                        rel: (o.absCents - minC + padC) / span
                    }));
                    // Anchor alignment to reduce jumps across chord changes
                    try {
                        if (win.__bellsAnchor && st?.mode === 'single') {
                            const anchor = win.__bellsAnchor;
                            const nearest = pos.reduce((best, cur)=>{
                                const d = Math.abs(cur.absCents - anchor.absCents);
                                return (!best || d < best.d) ? { cur, d } : best;
                            }, null);
                            if (nearest && Number.isFinite(anchor.xNorm)) {
                                const minRel = Math.min(...pos.map(p=>p.rel));
                                const maxRel = Math.max(...pos.map(p=>p.rel));
                                let offset = anchor.xNorm - nearest.cur.rel;
                                const minOffset = -minRel;
                                const maxOffset = 1 - maxRel;
                                offset = Math.max(minOffset, Math.min(maxOffset, offset));
                                pos.forEach(p=>{ p.rel = Math.max(0, Math.min(1, p.rel + offset)); });
                            }
                        }
                    } catch(_) {}
                    const bounds = pos.map((o,i)=>{
                        const left = i === 0 ? 0 : (pos[i-1].rel + o.rel) / 2;
                        const right = i === pos.length-1 ? 1 : (o.rel + pos[i+1].rel) / 2;
                        return { left, right };
                    });
                    try {
                        if (opts.setLayout) {
                            const rect = targetEl.getBoundingClientRect();
                            win.__bellsLayout = {
                                minC, maxC, span,
                                baseC0: this.getFrequency(0, 0, tuning),
                                rect,
                                tuning
                            };
                        }
                    } catch(_) {}

                    pos.forEach((o, i) => {
                        const note = o.note;
                        const isJINatural = !!(jiMap && jiMap.naturalSteps && jiMap.naturalSteps.has(note.step));
                        const jiName = (jiMap && jiMap.stepToName) ? jiMap.stepToName.get(note.step) : null;
                        const displayLabel = (isJINatural && jiName)
                            ? `${jiName}${Number.isFinite(note.octave) ? note.octave : ''}`
                            : (note.label || '');
                        const label = displayLabel || '';
                        const leftPct = bounds[i].left * 100;
                        const widthPct = Math.max(1.5, (bounds[i].right - bounds[i].left) * 100);
                        if (forceFull) {
                            addKey(note, o.idx, 'bells-natural', leftPct, widthPct, 100, 1, displayLabel);
                        } else if (isJINatural) {
                            addKey(note, o.idx, 'bells-natural', leftPct, widthPct, 100, 1, displayLabel);
                        } else if (isAccidentalLabel(label)) {
                            const width = Math.min(widthPct, Math.max(5, widthPct * 0.8));
                            const center = (leftPct + widthPct / 2);
                            addKey(note, o.idx, 'bells-accidental', Math.max(0, Math.min(100-width, center - width/2)), width, 75, 2, displayLabel);
                        } else if (isMicroLabel(label)) {
                            const microLen = (parseLabel(label).micro || '').length;
                            const cls = microLen > 1 ? 'bells-micro small' : 'bells-micro';
                            const height = microLen > 1 ? 35 : 55;
                            const width = Math.min(widthPct, Math.max(4, widthPct * 0.7));
                            const center = (leftPct + widthPct / 2);
                            addKey(note, o.idx, cls, Math.max(0, Math.min(100-width, center - width/2)), width, height, 3, displayLabel);
                        } else {
                            addKey(note, o.idx, 'bells-natural', leftPct, widthPct, 100, 1, displayLabel);
                        }
                    });
                };

                const wantsScroll = (st?.mode === 'single' && this._bellsShouldScroll(win));
                if (wantsScroll) {
                    const currentCol = this._getNowPlayingColumn() || this._getBellsActiveColumn(st);
                    const nextCol = this._getNextBellsScrollColumn(currentCol) || currentCol;
                    const currentNotes = currentCol ? this._computeBellsNotes(currentCol, count, st) : [];
                    const nextNotes = nextCol ? this._computeBellsNotes(nextCol, count, st) : [];
                    if (!currentNotes || currentNotes.length === 0) {
                        barsEl.innerHTML = '<div class="bells-empty">No notes available.</div>';
                        return;
                    }
                    const nextNotesSafe = (nextNotes && nextNotes.length) ? nextNotes : currentNotes;
                    barsEl.innerHTML = '';
                    const track = doc.createElement('div');
                    track.className = 'bells-scroll-track';
                    const panelA = doc.createElement('div');
                    const panelB = doc.createElement('div');
                    panelA.className = 'bells-scroll-panel';
                    panelB.className = 'bells-scroll-panel';
                    track.appendChild(panelA);
                    track.appendChild(panelB);
                    barsEl.appendChild(track);
                    win.__bellsScrollTrack = track;
                    const stepsA = currentCol ? this._getCurrentChordAbsSteps(currentCol) : null;
                    const edgePad = !!win.__bellsInline;
                    renderNotes(currentNotes, panelA, { forceFull: !win.__bellsInline, setLayout: true, highlightSteps: stepsA, edgePad });
                    renderNotes(nextNotesSafe, panelB, { forceFull: !win.__bellsInline, setLayout: false, highlightSteps: null, edgePad });
                    this._updateBellsScrollPosition(win);
                    return;
                }

                try { win.__bellsScrollTrack = null; } catch(_){ }
                renderNotes(notes, barsEl, { forceFull: (!win.__bellsInline && st?.mode === 'single'), setLayout: true, highlightSteps: currentSteps, edgePad: !!win.__bellsInline });
            }

            _handleInlineJamDrop(win, evt) {
                try {
                    if (!win || !win.__bellsInline) return;
                    const note = win.__jamDragNote;
                    win.__jamDragNote = null;
                    win.__jamDragKeyEl = null;
                    if (!note) return;
                    const x = evt?.clientX;
                    const y = evt?.clientY;
                    if (!Number.isFinite(x) || !Number.isFinite(y)) return;
                    const el = document.elementFromPoint(x, y);
                    if (!el) return;
                    if (el.closest && el.closest('#jamArea')) return;
                    const column = (el.closest && el.closest('.extension-column')) ? el.closest('.extension-column') : null;
                    if (column) {
                        this._applyJamNoteToColumn(column, note);
                        return;
                    }
                    // If no chords exist yet, allow dropping into the splash/top area to create the first chord
                    try {
                        const container = document.getElementById('extensionColumns');
                        const cols = container
                            ? Array.from(container.querySelectorAll('.extension-column'))
                                .filter(c => c && !c.classList.contains('repeat-marker-column') && c.dataset.isSpacer !== 'true')
                            : [];
                        const isEmpty = cols.length === 0;
                        if (isEmpty) {
                            const isSplash = !!(el.id === 'emptyChordSplash' || (el.closest && el.closest('#emptyChordSplash')));
                            const inChordZone = !!(el.closest && (el.closest('#extensionColumns') || el.closest('#strumArea')));
                            const inTopHalf = (y <= (window.innerHeight * 0.5));
                            if (isSplash || inChordZone || inTopHalf) {
                                const edo = (note && Number.isFinite(note.tuning)) ? note.tuning : (this.currentTuning || 12);
                                const step = (note && Number.isFinite(note.step)) ? note.step : null;
                                const oct = (note && Number.isFinite(note.octave)) ? note.octave : 4;
                                if (step != null) {
                                    const absStep = (oct * edo) + step;
                                    this._createChordFromRootAbsStep(absStep, edo);
                                    return;
                                }
                            }
                        }
                    } catch(_){ }
                    const strumArea = document.getElementById('strumArea');
                    if (strumArea && (el === strumArea || (strumArea.contains && strumArea.contains(el)))) {
                        const cols = Array.from(document.querySelectorAll('#extensionColumns .extension-column'))
                            .filter(c => c && !c.classList.contains('repeat-marker-column') && c.dataset.isSpacer !== 'true');
                        cols.forEach(col => this._applyJamNoteToColumn(col, note));
                    }
                } catch(_){ }
            }

            _applyJamNoteToColumn(column, note) {
                try {
                    if (!column || column.dataset.isSpacer === 'true' || column.classList.contains('repeat-marker-column')) return;
                    if (this.lockedChords && this.lockedChords.has(column)) return;
                    const chordId = column.dataset && column.dataset.chordId ? String(column.dataset.chordId) : null;
                    let model = null;
                    if (chordId) model = (this.chordExtensions || []).find(c => c && String(c.id) === chordId) || null;
                    if (!model && column.dataset.originalPosition != null) {
                        const op = parseInt(column.dataset.originalPosition, 10);
                        if (!isNaN(op) && op >= 0) model = this.chordExtensions?.[op] || null;
                    }
                    if (!model) return;

                    const tuning = model.fixedRootTuning || this.currentTuning || 12;
                    const srcEdo = (note && Number.isFinite(note.tuning)) ? note.tuning : (this.currentTuning || 12);
                    const mapStep = (step, src, dst) => {
                        if (!src || src === dst) return ((step % dst) + dst) % dst;
                        const cents = ((step % src + src) % src) * (1200 / src);
                        const mapped = Math.round(cents / (1200 / dst));
                        return ((mapped % dst) + dst) % dst;
                    };
                    const noteStep = (note && Number.isFinite(note.step)) ? note.step : null;
                    if (noteStep == null) return;
                    const absStep = (tuning === srcEdo) ? ((noteStep % tuning) + tuning) % tuning : mapStep(noteStep, srcEdo, tuning);

                    const info = this._getBaseRootForColumn(column);
                    const baseRoot = info.baseRoot;
                    const g = ((this.transposeDelta || 0) % tuning + tuning) % tuning;
                    const l = ((+column.dataset.localTranspose || 0) % tuning + tuning) % tuning;
                    const modelRoot = ((baseRoot - g - l) % tuning + tuning) % tuning;

                    const isBlank = !!(model && model.isCustom && (!Array.isArray(model.intervals) || model.intervals.length === 0)
                        && !(typeof model.fixedRootStepAbs === 'number'));
                    if (isBlank) {
                        // First dragged note defines the root for this blank chord
                        const newRootModel = ((absStep - g - l) % tuning + tuning) % tuning;
                        model.isCustom = true;
                        model.intervals = [0];
                        model.fixedRootStepAbs = newRootModel;
                        model.fixedRootTuning = tuning;
                        model.lastTuning = tuning;
                        if (!Array.isArray(model.originalIntervals) || !model.originalIntervals.length) {
                            model.originalIntervals = [0];
                        }
                        const rootLabel = this.getRootNameForStep(absStep, tuning);
                        model.name = rootLabel;
                        const nameEl = column.querySelector('.extension-header .chord-name');
                        if (nameEl) {
                            nameEl.textContent = rootLabel;
                            nameEl.dataset.lockedName = rootLabel;
                        }
                        try { column.dataset.lastIntervals = JSON.stringify(model.intervals || []); } catch(_){ }
                        const oldContainer = column.querySelector('.strings-column');
                        if (oldContainer) oldContainer.remove();
                        this.generateStringsForColumn(column, model.intervals, true);
                        try { this.highlightKeyboardForColumn(column); } catch(_) {}
                        try {
                            if (this.pendingBlankChordId && String(chordId) === String(this.pendingBlankChordId)) {
                                this.pendingBlankChordId = null;
                                this.pendingBlankChordStrumEligible = false;
                            }
                        } catch(_) {}
                        try { this.saveChordConfiguration?.(); } catch(_) {}
                        try { this.updateChordDisplay?.(); } catch(_) {}
                        return;
                    }

                    let relSteps = this._getBellsChordSteps(column) || [];
                    let absSteps = relSteps.map(s => ((baseRoot + s) % tuning + tuning) % tuning);
                    const exists = absSteps.includes(absStep);
                    if (exists) {
                        absSteps = absSteps.filter(s => s !== absStep);
                    } else {
                        absSteps.push(absStep);
                    }
                    absSteps = Array.from(new Set(absSteps));
                    const newRel = absSteps.map(s => ((s - baseRoot) % tuning + tuning) % tuning)
                        .sort((a,b)=> this.stepToSemitone(a, tuning) - this.stepToSemitone(b, tuning));

                    model.isCustom = true;
                    model.intervals = newRel;
                    model.fixedRootStepAbs = modelRoot;
                    model.fixedRootTuning = tuning;
                    model.lastTuning = tuning;
                    if (!Array.isArray(model.originalIntervals) || !model.originalIntervals.length) {
                        model.originalIntervals = newRel.slice();
                    }

                    if (absSteps.length) {
                        const label = this.computeFullChordNameFromAbsoluteSteps(absSteps, tuning);
                        if (label) {
                            model.name = label;
                            const nameEl = column.querySelector('.extension-header .chord-name');
                            if (nameEl) {
                                nameEl.textContent = label;
                                nameEl.dataset.lockedName = label;
                            }
                        }
                    } else {
                        model.name = 'New';
                        const nameEl = column.querySelector('.extension-header .chord-name');
                        if (nameEl) {
                            nameEl.textContent = 'New';
                            nameEl.dataset.lockedName = '';
                        }
                    }

                    try { column.dataset.lastIntervals = JSON.stringify(model.intervals || []); } catch(_){ }
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                    this.generateStringsForColumn(column, model.intervals, true);
                    try { this.highlightKeyboardForColumn(column); } catch(_) {}
                    try { this.saveChordConfiguration?.(); } catch(_) {}
                    try { this.updateChordDisplay?.(); } catch(_) {}
                } catch(_){ }
            }

            _bellsGlideStart(note, key, win, clientX, clientY){
                try {
                    if (window.midi && window.midi.enabled) return;
                    if (!note) return;
                    if (this._bellsGlideActive) this._bellsGlideStop();
                    key.__gateMs = 120000;
                    key.__glideHold = true;
                    try { key.classList.add('ringing'); } catch(_) {}
                    this._bellsGlideActive = true;
                    this._bellsGlideKeyEl = key;
                    this._bellsGlideVoiceKey = note.freq;
                    this._bellsGlideBaseFreq = note.freq;
                    this._bellsGlideLastTime = performance.now();
                    this._bellsGlideLastX = clientX;
                    this._bellsGlideSnapTo(note, key, win, clientX, clientY, true);
                } catch(_) {}
            }

            _bellsGlideSnapTo(note, key, win, clientX, clientY, isStart=false){
                if (!note) return;
                try {
                    const rect = win.__bellsLayout?.rect;
                    if (rect && rect.width > 0) {
                        const xNorm = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                        win.__bellsAnchor = { absCents: this.getCentValue(note.step, note.tuning||this.currentTuning) + (note.octave*1200), xNorm };
                    }
                } catch(_) {}
                if (isStart) {
                    this.playFrequency(note.freq, key, 'bells');
                    this._bellsGlideSendMidiBase(note);
                } else {
                    if (this._bellsGlideMidiBase) this._bellsGlideMidiBase.freq = note.freq;
                    this._bellsGlideResetMidiBend();
                }
                this._bellsGlideUpdate(note.freq, note);
            }

            _bellsGlideUpdateFromX(win, clientX, clientY){
                try {
                    if (!this._bellsGlideActive || !win.__bellsLayout) return;
                    const rect = win.__bellsLayout.rect;
                    if (!rect || rect.width <= 0) return;
                    const xNorm = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                    const targetC = win.__bellsLayout.minC + (xNorm * win.__bellsLayout.span);
                    const baseC0 = win.__bellsLayout.baseC0 || this.getFrequency(0,0, win.__bellsLayout.tuning || this.currentTuning || 12);
                    const targetF = baseC0 * Math.pow(2, targetC / 1200);
                    win.__bellsAnchor = { absCents: targetC, xNorm };
                    this._bellsGlideUpdate(targetF, null, clientX);
                } catch(_) {}
            }

            _bellsGlideUpdate(targetFreq, note=null, clientX=null){
                try {
                    if (!this._bellsGlideActive) return;
                    const voice = this.activeBellsOscillators.get(this._bellsGlideVoiceKey);
                    if (!voice) return;
                    const now = this.audioContext?.currentTime || 0;
                    let timeConst = 0.02;
                    try {
                        if (Number.isFinite(this._bellsGlideMs) && this._bellsGlideMs > 0) {
                            timeConst = Math.max(0.003, Math.min(0.25, (this._bellsGlideMs / 1000)));
                        } else {
                            const t = performance.now();
                            if (this._bellsGlideLastTime && Number.isFinite(this._bellsGlideLastX) && Number.isFinite(clientX)) {
                                const dt = Math.max(1, t - this._bellsGlideLastTime);
                                const dx = Math.abs(clientX - this._bellsGlideLastX);
                                const speed = dx / dt; // px/ms
                                timeConst = Math.max(0.005, Math.min(0.08, 0.08 / Math.max(0.05, speed)));
                            }
                            this._bellsGlideLastTime = t;
                            if (Number.isFinite(clientX)) this._bellsGlideLastX = clientX;
                        }
                    } catch(_) {}
                    voice.osc1.frequency.cancelScheduledValues(now);
                    voice.osc1.frequency.setTargetAtTime(targetFreq, now, timeConst);
                    if (voice.osc2 && voice.osc2.frequency) {
                        voice.osc2.frequency.cancelScheduledValues(now);
                        voice.osc2.frequency.setTargetAtTime(targetFreq, now, timeConst);
                    }
                    this._bellsGlideSendMidiBend(targetFreq);
                } catch(_) {}
            }

            _bellsGlideStop(){
                try {
                    if (!this._bellsGlideActive) return;
                    if (this._bellsGlideKeyEl) {
                        this._bellsGlideKeyEl.__glideHold = false;
                        this._bellsGlideKeyEl.__gateMs = null;
                    }
                    try {
                        const voice = this.activeBellsOscillators?.get(this._bellsGlideVoiceKey);
                        if (voice && voice.env1 && voice.env2) {
                            const releaseSec = 0.25;
                            voice.env1.release = releaseSec;
                            voice.env2.release = releaseSec;
                        }
                    } catch(_) {}
                    if (this._bellsGlideVoiceKey) this.stopFrequency(this._bellsGlideVoiceKey, this._bellsGlideKeyEl || null, 'bells');
                    this._bellsGlideResetMidiBend();
                } catch(_) {}
                try {
                    if (this._bellsGlideKeyEl) {
                        this._bellsGlideKeyEl.classList.remove('ringing');
                    }
                } catch(_) {}
                this._bellsGlideActive = false;
                this._bellsGlideVoiceKey = null;
                this._bellsGlideKeyEl = null;
                this._bellsGlideBaseFreq = null;
            }

            _bellsGlideSendMidiBase(note){
                try {
                    if (!window.midi || !window.midi.enabled) return;
                    const baseNote = Math.round(69 + 12 * Math.log2(note.freq / 440));
                    this._bellsGlideMidiBase = { note: baseNote, freq: note.freq };
                    const targets = ['bells'];
                    for (const tgt of targets) {
                        const chBase = window.midi.channelMap?.[tgt] || 1;
                        const outSel = window.midi.outputForSource ? window.midi.outputForSource(tgt) : null;
                        if (typeof window.midi.setPitchBendRange === 'function') window.midi.setPitchBendRange(12, chBase);
                        if (typeof window.midi.sendPitchBend === 'function') window.midi.sendPitchBend(0, chBase, outSel);
                    }
                } catch(_) {}
            }

            _bellsGlideSendMidiBend(targetFreq){
                try {
                    if (!window.midi || !window.midi.enabled || !this._bellsGlideMidiBase) return;
                    const base = this._bellsGlideMidiBase.freq || targetFreq;
                    const cents = 1200 * Math.log2(targetFreq / base);
                    const range = 12; // semitones
                    const bend = Math.max(-1, Math.min(1, (cents/100) / range));
                    const targets = ['bells'];
                    for (const tgt of targets) {
                        const chBase = window.midi.channelMap?.[tgt] || 1;
                        const outSel = window.midi.outputForSource ? window.midi.outputForSource(tgt) : null;
                        if (typeof window.midi.sendPitchBend === 'function') window.midi.sendPitchBend(bend, chBase, outSel);
                    }
                } catch(_) {}
            }

            _bellsGlideResetMidiBend(){
                try {
                    if (!window.midi || !window.midi.enabled) return;
                    const targets = ['bells'];
                    for (const tgt of targets) {
                        const chBase = window.midi.channelMap?.[tgt] || 1;
                        const outSel = window.midi.outputForSource ? window.midi.outputForSource(tgt) : null;
                        if (typeof window.midi.sendPitchBend === 'function') window.midi.sendPitchBend(0, chBase, outSel);
                    }
                } catch(_) {}
            }

            _getBellsChordSteps(column){
                const lockedChord = this.lockedChords?.get(column);
                // Prefer model intervals for correct mapping in non-12 EDO
                let model = null;
                try {
                    const id = column.dataset.chordId;
                    if (id) model = (this.chordExtensions || []).find(c => String(c.id) === String(id)) || null;
                    if (!model && column.dataset.originalPosition != null) {
                        const op = parseInt(column.dataset.originalPosition,10);
                        if (!isNaN(op) && op >= 0) model = this.chordExtensions?.[op] || null;
                    }
                    if (!model) {
                        const label = (column.querySelector('.extension-header .chord-name')?.textContent || '').trim();
                        model = (this.chordExtensions || []).find(c => !c?.isRepeatMarker && String(c?.name||'').trim() === label) || null;
                    }
                } catch(_) {}

                if (model && Array.isArray(model.intervals) && model.intervals.length) {
                    const tuning = model.fixedRootTuning || this.currentTuning || 12;
                    if (model.isCustom) {
                        return model.intervals.map(iv => ((iv % tuning) + tuning) % tuning);
                    }
                    return model.intervals.map(iv => this.mapIntervalToEDO(iv, tuning));
                }

                if (lockedChord && Array.isArray(lockedChord.intervals) && lockedChord.intervals.length) {
                    const tuning = lockedChord.lockedTuning || this.currentTuning || 12;
                    return lockedChord.intervals.map(iv => this.mapIntervalToEDO(iv, tuning));
                }

                return this.getChordStepsForColumn(column);
            }

            _computeBellsNotes(column, count, state=null) {
                const noteNames = this.getNoteNames();
                const relStepsRaw = this._getBellsChordSteps(column);
                const baseInfo = this._getBaseRootForColumn(column);
                const tuning = baseInfo.tuning;
                const baseRoot = baseInfo.baseRoot;
                const steps = (relStepsRaw && relStepsRaw.length ? relStepsRaw : [0]).slice();
                steps.sort((a,b) => this.stepToSemitone(a, tuning) - this.stepToSemitone(b, tuning));

                const st = state || this._getBellsState(null);
                const baseOct = Math.max(2, Math.min(6, st?.baseOct || 4));
                const maxOct = 8;
                const notes = [];
                const norm = (v,m)=> ((v % m) + m) % m;
                for (let i=0; i<count; i++) {
                    const idx = i % steps.length;
                    const octOffset = Math.floor(i / steps.length);
                    const rel = steps[idx];
                    const total = baseRoot + rel;
                    const step = norm(total, tuning);
                    let octave = baseOct + octOffset + Math.floor(total / tuning);
                    if (octave > maxOct) octave = maxOct;
                    const freq = this.getFrequency(step, octave, tuning);
                    const label = `${noteNames[step] || ('Note ' + step)}${octave}`;
                    const color = this.getUniversalPitchColorForStep(step, tuning).color || '#888';
                    notes.push({ freq, step, octave, label, color, tuning });
                }
                return notes;
            }

            _getCurrentChordAbsSteps(col){
                if (!col) return null;
                const baseInfo = this._getBaseRootForColumn(col);
                const tuning = baseInfo.tuning;
                const baseRoot = baseInfo.baseRoot;
                const relSteps = this._getBellsChordSteps(col) || [];
                const set = new Set();
                relSteps.forEach(s => set.add(((baseRoot + s) % tuning + tuning) % tuning));
                return set;
            }

            _computeAllChordsNotes(octaves=1, state=null){
                const noteNames = this.getNoteNames();
                const list = this._getBellsChordList();
                if (!list.length) return [];
                let tuning = this.currentTuning || 12;
                const norm = (v,m)=> ((v % m) + m) % m;
                const set = new Set();
                list.forEach(({ column }) => {
                    const baseInfo = this._getBaseRootForColumn(column);
                    tuning = baseInfo.tuning || tuning;
                    const baseRoot = baseInfo.baseRoot;
                    const relSteps = this._getBellsChordSteps(column);
                    relSteps.forEach(s => set.add(norm(baseRoot + s, tuning)));
                });
                const steps = Array.from(set.values());
                steps.sort((a,b) => this.stepToSemitone(a, tuning) - this.stepToSemitone(b, tuning));
                const st = state || this._getBellsState(null);
                const baseOct = Math.max(2, Math.min(6, st?.baseOct || 4));
                const out = [];
                const octCount = Math.max(1, Math.min(6, octaves|0));
                for (let o=0; o<octCount; o++) {
                    const oct = baseOct + o;
                    steps.forEach(step => {
                        const label = `${noteNames[step] || ('Note ' + step)}${oct}`;
                        const color = this.getUniversalPitchColorForStep(step, tuning).color || '#888';
                        const freq = this.getFrequency(step, oct, tuning);
                        out.push({ freq, step, octave: oct, label, color, tuning });
                    });
                }
                // Add final octave root to complete the span
                try {
                    const labelTop = `${noteNames[0] || 'Note 0'}${baseOct + octCount}`;
                    const colorTop = this.getUniversalPitchColorForStep(0, tuning).color || '#888';
                    const freqTop = this.getFrequency(0, baseOct + octCount, tuning);
                    out.push({ freq: freqTop, step: 0, octave: baseOct + octCount, label: labelTop, color: colorTop, tuning });
                } catch(_) {}
                return out;
            }

            _computeAllNotes(octaves=1, state=null){
                const noteNames = this.getNoteNames();
                const tuning = this.currentTuning || 12;
                const st = state || this._getBellsState(null);
                const baseOct = Math.max(2, Math.min(6, st?.baseOct || 4));
                const notes = [];
                const octCount = Math.max(1, Math.min(6, octaves|0));
                for (let o=0; o<octCount; o++) {
                    const oct = baseOct + o;
                    for (let step=0; step<tuning; step++) {
                        const label = `${noteNames[step] || ('Note ' + step)}${oct}`;
                        const color = this.getUniversalPitchColorForStep(step, tuning).color || '#888';
                        const freq = this.getFrequency(step, oct, tuning);
                        notes.push({ freq, step, octave: oct, label, color, tuning });
                    }
                }
                // Add final octave root to complete the span
                try {
                    const labelTop = `${noteNames[0] || 'Note 0'}${baseOct + octCount}`;
                    const colorTop = this.getUniversalPitchColorForStep(0, tuning).color || '#888';
                    const freqTop = this.getFrequency(0, baseOct + octCount, tuning);
                    notes.push({ freq: freqTop, step: 0, octave: baseOct + octCount, label: labelTop, color: colorTop, tuning });
                } catch(_) {}
                return notes;
            }

            _getNowPlayingColumn(){
                try {
                    const transportCol = this._arp?.column || this._arpTransport?.column || null;
                    if (transportCol) return transportCol;
                    const nowHeader = document.querySelector('.extension-header.now-playing, .extension-column-header.now-playing');
                    if (nowHeader) return nowHeader.closest('.extension-column');
                } catch(_) {}
                return null;
            }

            _bellsShouldScroll(win=null){
                try {
                    const st = this._getBellsState(win);
                    if (!st || st.mode !== 'single') return false;
                    const tr = this._arpTransport;
                    if (!tr || !tr.running) return false;
                    const loopChk = document.getElementById('loopToggle') || document.getElementById('playLoop');
                    if (loopChk && !loopChk.checked) return false;
                    return true;
                } catch(_){ return false; }
            }

            _getNextBellsScrollColumn(nowCol){
                try {
                    const tr = this._arpTransport;
                    const plan = tr?._seqOneLoopPlan;
                    const allCols = tr?._seqAllCols;
                    let planPos = tr?._seqPlanPos;
                    if (Array.isArray(plan) && plan.length && Array.isArray(allCols) && allCols.length) {
                        const len = plan.length;
                        let idx = plan[Math.max(0, Math.min(len - 1, planPos|0))];
                        if (!Number.isFinite(idx)) idx = plan[0];
                        let col = allCols[idx];
                        if (col && col.classList && col.classList.contains('extension-column')) return col;
                        for (let k = 0; k < len; k++) {
                            const p = plan[(planPos + k) % len];
                            const c = allCols[p];
                            if (c && c.classList && c.classList.contains('extension-column')) return c;
                        }
                    }
                } catch(_){ }
                try {
                    const list = this._getBellsChordList();
                    if (!list.length) return null;
                    const idx = list.findIndex(x => x.column === nowCol);
                    const next = list[(idx + 1 + list.length) % list.length];
                    return next ? next.column : null;
                } catch(_){ return null; }
            }

            _getBellsScrollProgress(){
                try {
                    const tr = this._arpTransport;
                    if (!tr || !tr.running) return 0;
                    const tickMsRaw = Number(tr.tickMs) || 0;
                    const tickMs = (tickMsRaw > 0) ? tickMsRaw : ((tr.beatMs || (60000 / Math.max(20, tr.bpm || 120))) / Math.max(1, tr.ticksPerBeat || 4));
                    const nowMs = (performance && performance.now) ? performance.now() : Date.now();
                    const nextAt = Number.isFinite(tr.nextAt) ? tr.nextAt : nowMs;
                    const lastTickAt = nextAt - Math.max(1, tickMs);
                    let frac = (nowMs - lastTickAt) / Math.max(1, tickMs);
                    if (!Number.isFinite(frac)) frac = 0;
                    frac = Math.max(0, Math.min(1, frac));
                    const nowAbs = (tr.absTickCounter|0) + frac;
                    const last = Number.isFinite(tr._seqLastSwitchAbsTick) ? (tr._seqLastSwitchAbsTick|0) : null;
                    const hold = Number.isFinite(tr._seqLastHoldTicks) ? (tr._seqLastHoldTicks|0) : null;
                    let dur = hold;
                    if (!dur && Number.isFinite(tr._seqNextSwitchAbsTick) && last != null) {
                        dur = Math.max(1, (tr._seqNextSwitchAbsTick|0) - last);
                    }
                    if (!dur || last == null) return 0;
                    const prog = (nowAbs - last) / Math.max(1, dur);
                    return Math.max(0, Math.min(1, prog));
                } catch(_){ return 0; }
            }

            _updateBellsScrollPosition(winOverride=null){
                try {
                    const win = winOverride || this._bellsWin;
                    if (!win || win.closed) return;
                    const track = win.__bellsScrollTrack;
                    if (!track) return;
                    const prog = this._getBellsScrollProgress();
                    track.style.transform = `translateY(${(-50 * prog)}%)`;
                } catch(_){ }
            }

            _startBellsScrollRAF(){
                if (this._bellsScrollRafActive) return;
                this._bellsScrollRafActive = true;
                const tick = ()=>{
                    if (!this._bellsScrollRafActive) return;
                    const wins = this._getOpenBellsWindows();
                    if (!wins.length) {
                        this._bellsScrollRafActive = false;
                        this._bellsScrollRaf = null;
                        return;
                    }
                    wins.forEach(win=>{
                        const st = this._getBellsState(win);
                        if ((st?.mode || 'single') !== 'single') return;
                        try {
                            const list = this._getBellsChordList();
                            const nowCol = this._getNowPlayingColumn() || this.currentActiveColumnEl;
                            const idx = list.findIndex(x => x.column === nowCol);
                            const nowId = (idx >= 0) ? String(idx) : (nowCol?.dataset?.chordId || nowCol || null);
                            if (nowId && nowId !== st._lastNowChordId) {
                                st._lastNowChordId = String(nowId);
                                try { this._renderBellsBars(win); } catch(_){ }
                                return;
                            }
                            if (this._bellsShouldScroll(win)) {
                                const nextCol = this._getNextBellsScrollColumn(nowCol);
                                const nextId = nextCol ? (nextCol?.dataset?.chordId || nextCol) : null;
                                if (nextId && String(nextId) !== String(st._lastNextChordId || '')) {
                                    st._lastNextChordId = String(nextId);
                                    try { this._renderBellsBars(win); } catch(_){ }
                                    return;
                                }
                                try { this._updateBellsScrollPosition(win); } catch(_){ }
                            }
                        } catch(_){ }
                    });
                    this._bellsScrollRaf = (window.requestAnimationFrame ? window.requestAnimationFrame(tick) : setTimeout(tick, 16));
                };
                this._bellsScrollRaf = (window.requestAnimationFrame ? window.requestAnimationFrame(tick) : setTimeout(tick, 16));
            }

            _stopBellsScrollRAF(){
                this._bellsScrollRafActive = false;
                try {
                    if (this._bellsScrollRaf != null) {
                        if (window.cancelAnimationFrame) cancelAnimationFrame(this._bellsScrollRaf);
                        else clearTimeout(this._bellsScrollRaf);
                    }
                } catch(_){ }
                this._bellsScrollRaf = null;
            }

            _startBellsAutoUpdate(){
                this._stopBellsAutoUpdate();
                this._startBellsScrollRAF();
                this._bellsAutoTimer = setInterval(() => {
                    const wins = this._getOpenBellsWindows();
                    const inlineWin = this._getInlineBellsWin();
                    const hasInline = !!inlineWin;
                    if (!wins.length && !hasInline) { this._stopBellsAutoUpdate(); return; }
                    const nowCol = this._getNowPlayingColumn() || this.currentActiveColumnEl;
                    if (!nowCol) return;
                    const list = this._getBellsChordList();
                    const idx = list.findIndex(x => x.column === nowCol);
                    const targets = hasInline ? wins.concat([inlineWin]) : wins;
                    targets.forEach(win => {
                        if (win && win.__bellsInline) {
                            try { this._ensureInlineBellsState(win); } catch(_){ }
                        }
                        const st = this._getBellsState(win);
                        const mode = st.mode || 'single';
                        const lastId = st._lastNowChordId;
                        const nowId = (idx >= 0) ? String(idx) : (nowCol?.dataset?.chordId || nowCol);

                        if (idx >= 0 && idx !== st.activeIndex && mode === 'single') {
                            st.activeIndex = idx;
                            st._lastNowChordId = nowId;
                            try { this._renderBellsUI(win); } catch(_){}
                            return;
                        }

                        if (nowId !== lastId) {
                            st._lastNowChordId = nowId;
                            try { this._renderBellsBars(win); } catch(_){}
                        }

                        if (this._bellsShouldScroll(win) && mode === 'single') {
                            const nextCol = this._getNextBellsScrollColumn(nowCol);
                            const nextId = nextCol ? (nextCol?.dataset?.chordId || nextCol) : 'none';
                            if (nextId !== st._lastNextChordId) {
                                st._lastNextChordId = String(nextId);
                                try { this._renderBellsBars(win); } catch(_){}
                                return;
                            }
                            try { this._updateBellsScrollPosition(win); } catch(_){}
                        }
                    });
                }, 120);
            }

            _stopBellsAutoUpdate(){
                if (this._bellsAutoTimer) {
                    clearInterval(this._bellsAutoTimer);
                    this._bellsAutoTimer = null;
                }
                this._stopBellsScrollRAF();
            }

            _getBaseRootForColumn(column) {
                const lockedChord = this.lockedChords?.get(column);
                let tuning = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                const norm = (v,m)=> ((v % m) + m) % m;
                const g = norm((this.transposeDelta || 0), tuning);
                const l = norm((+column.dataset.localTranspose || 0), tuning);
                let baseRoot = 0;

                if (lockedChord && typeof lockedChord.lockedRoot === 'number') {
                    baseRoot = norm((lockedChord.lockedRoot || 0) + l, tuning);
                } else {
                    let model = null;
                    try {
                        const id = column.dataset.chordId;
                        if (id) model = (this.chordExtensions || []).find(c => String(c.id) === String(id)) || null;
                        if (!model && column.dataset.originalPosition != null) {
                            const op = parseInt(column.dataset.originalPosition,10);
                            if (!isNaN(op) && op >= 0) model = this.chordExtensions?.[op] || null;
                        }
                        if (!model) {
                            const label = (column.querySelector('.extension-header .chord-name')?.textContent || '').trim();
                            model = (this.chordExtensions || []).find(c => !c?.isRepeatMarker && String(c?.name||'').trim() === label) || null;
                        }
                    } catch(_) {}
                    if (model && typeof model.fixedRootStepAbs === 'number' && model.fixedRootTuning) {
                        tuning = model.fixedRootTuning;
                        baseRoot = norm((model.fixedRootStepAbs % tuning) + g + l, tuning);
                    } else {
                        baseRoot = norm((this.currentRoot || 0) + g + l, tuning);
                    }
                }
                return { baseRoot, tuning };
            }

            _playBellsNote(note, el=null) {
                if (!note || !Number.isFinite(note.freq)) return;
                try {
                    this.ensureAudioContext && this.ensureAudioContext();
                } catch(_) {}
                try {
                    if (el) {
                        try {
                            el.classList.add('ringing');
                            el.__ringingTimeout && clearTimeout(el.__ringingTimeout);
                            el.__ringingTimeout = setTimeout(()=>{ try { el.classList.remove('ringing'); } catch(_){} }, 240);
                        } catch(_) {}
                    }
                    this.playFrequency(note.freq, el || null, 'bells');
                } catch(_) {}
            }

            // Random Dice System (disabled per requirement)
            initRandomDice() {
                return;
            }

            randomizeEverything() {
                // ðŸŽ¹ PROTECTION: Store all piano-locked settings AND preloaded presets before randomization
                const protectedPianoLocks = new Map();
                const protectedPresets = new Map();
                
                if (this.pianoLockedChords && this.pianoLockedChords.size > 0) {
                    
                    // Create deep copies of all piano lock data
                    this.pianoLockedChords.forEach((lockData, key) => {
                        protectedPianoLocks.set(key, {
                            ...lockData,
                            presetId: lockData.presetId, // Preserve preset ID
                            osc1: { ...lockData.osc1 },
                            osc2: { ...lockData.osc2 },
                            envelope: { ...lockData.envelope },
                            osc2Envelope: { ...lockData.osc2Envelope },
                            reverb: { ...lockData.reverb },
                            panning: { ...lockData.panning },
                            volume: { ...lockData.volume }
                        });
                    });
                    
                    // Also protect preloaded presets
                    this.preloadedPresets.forEach((presetData, presetId) => {
                        protectedPresets.set(presetId, {
                            ...presetData,
                            osc1: { ...presetData.osc1 },
                            osc2: { ...presetData.osc2 },
                            envelope: { ...presetData.envelope },
                            osc2Envelope: { ...presetData.osc2Envelope },
                            reverb: { ...presetData.reverb },
                            panning: { ...presetData.panning },
                            volume: { ...presetData.volume }
                        });
                    });
                } else {
                    
                }
                
                // Animate the dice button
                const diceBtn = document.getElementById('randomDiceButton');
                if (diceBtn) {
                    diceBtn.style.transform = 'rotate(720deg)';
                    setTimeout(() => {
                        diceBtn.style.transform = '';
                    }, 600);
                }

                // Focus purely on oscillator sound design - no tuning/chord changes
                this.randomizeOscillator(1); // STRUM 1
                this.randomizeOscillator(2); // STRUM 2
                this.randomizeInstrument('chord'); // CHORD/ARP OSC 3
                this.randomizeInstrument('arp'); // ARP OSC 3 (separate instance)
                // BASS (OSC 4) is NOT randomized by DICE per user requirements

                // Effects are NEVER randomized by dice (per requirements)
                // this.randomizeEffects(); // disabled

                // ðŸŽ¹ RESTORE: Put back all piano-locked settings and presets after randomization
                if (protectedPianoLocks.size > 0) {
                    this.pianoLockedChords = protectedPianoLocks;
                    
                    // Restore preloaded presets
                    this.preloadedPresets = protectedPresets;
                    
                    // Also restore the UI button states for piano locks
                    setTimeout(() => {
                        this.restorePianoLockStates();
                        // Warm all currently piano-locked columns (use markers or backend flags)
                        try {
                            document.querySelectorAll('.extension-column.piano-locked-col').forEach(col => { try { this.preloadPianoLockedChord(col); } catch(_){} });
                            document.querySelectorAll('.extension-column').forEach(col => {
                                try {
                                    const hdr = col.querySelector('.extension-header');
                                    const cd = (typeof this.getChordDataFromColumn === 'function') ? this.getChordDataFromColumn(col, hdr) : null;
                                    if (cd && cd.isPianoLocked) { try { this.preloadPianoLockedChord(col); } catch(_){} }
                                } catch(_){}
                            });
                        } catch(_) {}
                    }, 100);
                }
            }

            // Create a tiny, near-silent tick through the full chain to wake up the audio graph/IR
            async warmUpAudioGraph(durationMs = 18) {
                try {
                    const ok = await this.ensureAudioContext();
                    if (!ok || !this.audioContext || !this.gainNode) return;
                    // Short sine pip at -60dB to exercise convolver/panner/gain path without being audible
                    const osc = this.audioContext.createOscillator();
                    const g = this.audioContext.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, this.audioContext.currentTime);
                    g.gain.setValueAtTime(0.001, this.audioContext.currentTime); // ~-60 dB
                    osc.connect(g);
                    g.connect(this.gainNode);
                    const t0 = this.audioContext.currentTime;
                    osc.start(t0);
                    osc.stop(t0 + Math.max(0.001, durationMs/1000));
                } catch(_) { /* ignore */ }
            }

            // Preload/warm a piano-locked chord's preset and current notes for instant playback
            async preloadPianoLockedChord(columnElement) {
                if (!columnElement) return;
                try {
                    const relSteps = this.getChordStepsForColumn(columnElement);
                    const chordData = { intervals: Array.isArray(relSteps) ? relSteps : [] };
                    const pianoLockedData = this.findPianoLockData(chordData);
                    if (!pianoLockedData) return;
                    // Build a warmup key that changes with preset and transpositions
                    const lt = String(+columnElement.dataset.localTranspose || 0);
                    const gt = String(this.transposeDelta || 0);
                    const warmKey = `${pianoLockedData.lockKey || pianoLockedData.presetId}:${lt}:${gt}`;
                    if (this.preloadedChordWarmups.has(warmKey)) return; // already warm
                    this.preloadedChordWarmups.add(warmKey);

                    // Snapshot current synth state, apply preset briefly, warm audio, then restore
                    const originalSettings = {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 },
                        envelope: { ...this.envelope },
                        osc2Envelope: { ...this.osc2Envelope },
                        volume: this.volume,
                        masterVolume: this.masterVolume
                    };
                    this.applyPianoLockedSettings(pianoLockedData);
                    await this.warmUpAudioGraph(18);
                    // Touch current string frequencies to ensure datasets are present (no audio triggered)
                    try {
                        const strings = columnElement.querySelectorAll('.string');
                        strings.forEach(el => { void el.dataset.frequency; });
                    } catch(_) { }
                    // Restore original state (no UI change)
                    Object.assign(this.oscillators.osc1, originalSettings.osc1);
                    Object.assign(this.oscillators.osc2, originalSettings.osc2);
                    Object.assign(this.envelope, originalSettings.envelope);
                    Object.assign(this.osc2Envelope, originalSettings.osc2Envelope);
                    this.volume = originalSettings.volume;
                    this.masterVolume = originalSettings.masterVolume;
                    // Reverb/panning untouched
                    if (this.gainNode) this.gainNode.gain.value = this.volume * this.masterVolume;
                } catch(_) { /* no-op */ }
            }

            randomizeOscillator(oscNum) {
                const waveforms = ['sine', 'sawtooth', 'square', 'triangle', 'pulse', 'fullrect', 'halfrect', 'trapezoid', 'parabolic', 'stair'];
                const randomWave = waveforms[Math.floor(Math.random() * waveforms.length)];
                
                // Set waveform by updating the buttons
                const waveButtons = document.querySelectorAll(`[data-wave][data-osc="${oscNum}"]`);
                waveButtons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.wave === randomWave) {
                        btn.classList.add('active');
                    }
                });
                this.oscillators[`osc${oscNum}`].type = randomWave;
                const pwContainer = document.querySelector(`.pulse-width-container[data-osc="${oscNum}"]`);
                if (randomWave === 'pulse') {
                    const pw = 5 + Math.floor(Math.random() * 90);
                    const pwSlider = document.getElementById(`osc${oscNum}PulseWidth`);
                    const pwValue = document.getElementById(`osc${oscNum}PulseWidthValue`);
                    this.oscillators[`osc${oscNum}`].pulseWidth = pw / 100;
                    if (pwSlider) pwSlider.value = String(pw);
                    if (pwValue) pwValue.textContent = `${pw}%`;
                    if (pwContainer) pwContainer.style.display = 'block';
                } else if (pwContainer) {
                    pwContainer.style.display = 'none';
                }

                // Skip volume, coarse, fine, octave randomization to maintain tuning
                // Only randomize ADSR controls within their actual slider ranges
                
                // Use correct slider IDs - OSC1 has no prefix, OSC2 has "osc2" prefix
                const attackSliderID = oscNum === 1 ? 'attackSlider' : 'osc2AttackSlider';
                const decaySliderID = oscNum === 1 ? 'decaySlider' : 'osc2DecaySlider';
                const sustainSliderID = oscNum === 1 ? 'sustainSlider' : 'osc2SustainSlider';
                const releaseSliderID = oscNum === 1 ? 'releaseSlider' : 'osc2ReleaseSlider';
                
                const attackValueID = oscNum === 1 ? 'attackValue' : 'osc2AttackValue';
                const decayValueID = oscNum === 1 ? 'decayValue' : 'osc2DecayValue';
                const sustainValueID = oscNum === 1 ? 'sustainValue' : 'osc2SustainValue';
                const releaseValueID = oscNum === 1 ? 'releaseValue' : 'osc2ReleaseValue';

                const attackSlider = document.getElementById(attackSliderID);
                const decaySlider = document.getElementById(decaySliderID);
                const sustainSlider = document.getElementById(sustainSliderID);
                const releaseSlider = document.getElementById(releaseSliderID);
                
                // Get the actual slider min/max values for proper randomization
                let attackMin = 1; // default minimum
                let attackMax = 1000; // default for OSC1
                if (attackSlider) {
                    attackMin = Math.max(1, parseInt(attackSlider.min)); // Ensure minimum 1ms
                    attackMax = parseInt(attackSlider.max);
                }
                
                // Randomize ADSR parameters
                // Requirement: limit ATTACK randomization to 0â€“200ms (keep slider max at 1000ms)
                const attackRandomMinMs = 0;
                const attackRandomMaxMs = Math.min(200, attackMax);
                const attack = attackRandomMinMs + Math.random() * (attackRandomMaxMs - attackRandomMinMs);
                const decay = Math.random() * 300; // 0-300ms
                const sustain = Math.random() * 0.5; // 0-50%
                const release = Math.random() * 1000; // 0-1000ms (cap)

                if (attackSlider) {
                    attackSlider.value = attack;
                    const attackValue = document.getElementById(attackValueID);
                    if (attackValue) attackValue.textContent = `${Math.round(attack)}ms`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.attack = attack / 1000;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.attack = attack / 1000;
                    }
                    console.log(`?? OSC${oscNum} Attack set to ${Math.round(attack)}ms`);
                }
                if (decaySlider) {
                    decaySlider.value = decay;
                    const decayValue = document.getElementById(decayValueID);
                    if (decayValue) decayValue.textContent = `${Math.round(decay)}ms`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.decay = decay / 1000;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.decay = decay / 1000;
                    }
                    console.log(`?? OSC${oscNum} Decay set to ${Math.round(decay)}ms`);
                }
                if (sustainSlider) {
                    sustainSlider.value = sustain * 100;
                    const sustainValue = document.getElementById(sustainValueID);
                    if (sustainValue) sustainValue.textContent = `${Math.round(sustain * 100)}%`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.sustain = sustain;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.sustain = sustain;
                    }
                    console.log(`?? OSC${oscNum} Sustain set to ${Math.round(sustain * 100)}%`);
                }
                if (releaseSlider) {
                    releaseSlider.value = release;
                    const releaseValue = document.getElementById(releaseValueID);
                    if (releaseValue) releaseValue.textContent = `${Math.round(release)}ms`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.release = Math.min(1, release / 1000);
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.release = Math.min(1, release / 1000);
                    }
                    console.log(`?? OSC${oscNum} Release set to ${Math.round(release)}ms`);
                }

                // Update ADSR values in the internal structure (backup)
                if (this.adsrSettings && this.adsrSettings[`osc${oscNum}`]) {
                    this.adsrSettings[`osc${oscNum}`].attack = attack / 1000;
                    this.adsrSettings[`osc${oscNum}`].decay = decay / 1000;
                    this.adsrSettings[`osc${oscNum}`].sustain = sustain;
                    this.adsrSettings[`osc${oscNum}`].release = release / 1000;
                }
                
                console.log(`ðŸŽ² Randomized OSC${oscNum}: ${randomWave} wave, A:${Math.round(attack)} D:${Math.round(decay)} S:${Math.round(sustain*100)}% R:${Math.round(release)}`);
            }

            randomizeInstrument(instName) {
                if (!this.instruments[instName]) {
                    console.warn(`No instrument configuration found for: ${instName}`);
                    return;
                }

                const waveforms = ['sine', 'sawtooth', 'square', 'triangle', 'pulse', 'fullrect', 'halfrect', 'trapezoid', 'parabolic', 'stair'];
                const randomWave = waveforms[Math.floor(Math.random() * waveforms.length)];
                
                // Set waveform by updating the buttons and internal state
                const waveButtons = document.querySelectorAll(`[data-wave][data-inst="${instName}"]`);
                waveButtons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.wave === randomWave) {
                        btn.classList.add('active');
                    }
                });
                this.instruments[instName].osc.type = randomWave;

                // Handle pulse width for pulse waves
                const pwContainerId = `${instName}PulseWidthContainer`;
                const pwContainer = document.getElementById(pwContainerId);
                if (randomWave === 'pulse') {
                    const pw = 5 + Math.floor(Math.random() * 90);
                    const pwSlider = document.getElementById(`${instName}PulseWidth`);
                    const pwValue = document.getElementById(`${instName}PulseWidthValue`);
                    this.instruments[instName].osc.pulseWidth = pw / 100;
                    if (pwSlider) pwSlider.value = String(pw);
                    if (pwValue) pwValue.textContent = `${pw}%`;
                    if (pwContainer) pwContainer.style.display = 'block';
                } else if (pwContainer) {
                    pwContainer.style.display = 'none';
                }

                // Randomize ADSR parameters
                const attack = Math.random() * 200; // 0-200ms
                const decay = Math.random() * 300; // 0-300ms
                const sustain = Math.random() * 0.5; // 0-50%
                const release = Math.random() * 1000; // 0-1000ms

                // Update UI sliders and internal state
                const attackSlider = document.getElementById(`${instName}AttackSlider`);
                const decaySlider = document.getElementById(`${instName}DecaySlider`);
                const sustainSlider = document.getElementById(`${instName}SustainSlider`);
                const releaseSlider = document.getElementById(`${instName}ReleaseSlider`);
                
                if (attackSlider) {
                    attackSlider.value = attack;
                    const attackValue = document.getElementById(`${instName}AttackValue`);
                    if (attackValue) attackValue.textContent = `${Math.round(attack)}ms`;
                    this.instruments[instName].env.attack = attack / 1000;
                }
                if (decaySlider) {
                    decaySlider.value = decay;
                    const decayValue = document.getElementById(`${instName}DecayValue`);
                    if (decayValue) decayValue.textContent = `${Math.round(decay)}ms`;
                    this.instruments[instName].env.decay = decay / 1000;
                }
                if (sustainSlider) {
                    sustainSlider.value = sustain * 100;
                    const sustainValue = document.getElementById(`${instName}SustainValue`);
                    if (sustainValue) sustainValue.textContent = `${Math.round(sustain * 100)}%`;
                    this.instruments[instName].env.sustain = sustain;
                }
                if (releaseSlider) {
                    releaseSlider.value = release;
                    const releaseValue = document.getElementById(`${instName}ReleaseValue`);
                    if (releaseValue) releaseValue.textContent = `${Math.round(release)}ms`;
                    this.instruments[instName].env.release = release / 1000;
                }

                console.log(`ðŸŽ² Randomized ${instName.toUpperCase()}: ${randomWave} wave, A:${Math.round(attack)} D:${Math.round(decay)} S:${Math.round(sustain*100)}% R:${Math.round(release)}`);
            }

            randomizeEffects() {
                // Random reverb settings with wider ranges
                const reverbWet = Math.random() * 0.9; // 0-90% wet
                const reverbDecay = 0.3 + Math.random() * 5.7; // 0.3-6 seconds
                const reverbCut = 800 + Math.random() * 19200; // 800Hz-20kHz

                const reverbWetSlider = document.getElementById('reverbWet');
                const reverbDecaySlider = document.getElementById('reverbDecay');
                const reverbCutSlider = document.getElementById('reverbFilterCutoff');

                if (reverbWetSlider) {
                    reverbWetSlider.value = reverbWet * 10; // slider is 0-10 scale
                    if (this.reverb) this.reverb.wet = reverbWet;
                    if (this.wetGainNode && this.dryGainNode) {
                        this.wetGainNode.gain.value = reverbWet;
                        this.dryGainNode.gain.value = this.masterVolume;
                    }
                    if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                    const reverbWetValue = document.getElementById('reverbWetValue');
                    if (reverbWetValue) reverbWetValue.textContent = `${Math.round(reverbWet * 100)}%`;
                }
                if (reverbDecaySlider) {
                    reverbDecaySlider.value = reverbDecay;
                    if (this.reverb) this.reverb.decay = reverbDecay;
                    const reverbDecayValue = document.getElementById('reverbDecayValue');
                    if (reverbDecayValue) reverbDecayValue.textContent = `${reverbDecay.toFixed(1)}s`;
                }
                if (reverbCutSlider) {
                    reverbCutSlider.value = reverbCut;
                    if (this.reverbFilterNode) this.reverbFilterNode.frequency.value = reverbCut;
                    const reverbCutValue = document.getElementById('reverbFilterCutoffValue');
                    if (reverbCutValue) reverbCutValue.textContent = `${Math.round(reverbCut)}Hz`;
                }

                // Random panning mode and width
                const panModes = ['center', 'random', 'frequency', 'rotating', 'alternating', 'wide'];
                const panMode = panModes[Math.floor(Math.random() * panModes.length)];
                const panWidth = 0.2 + Math.random() * 0.8; // 20-100% width
                
                const panSelector = document.getElementById('panningMode');
                const panWidthSlider = document.getElementById('panningWidth');
                
                if (panSelector) {
                    panSelector.value = panMode;
                    this.panning.mode = panMode;
                }
                if (panWidthSlider) {
                    panWidthSlider.value = panWidth * 100;
                    this.panning.width = panWidth;
                    const panWidthValue = document.getElementById('panningWidthValue');
                    if (panWidthValue) panWidthValue.textContent = `${Math.round(panWidth * 100)}%`;
                }
                
                console.log(`??? Randomized effects: ${panMode} panning (${Math.round(panWidth * 100)}%), ${reverbDecay.toFixed(1)}s reverb`);
            }
        }

        // Initialize the instrument when the page loads
        let omnichord;
    window.addEventListener('load', () => {
            // === BPM-quantized time controls & editable ms labels ===
            window.TimeGrid = {
                // Musical divisions including triplets and quintuple subdivision (1/5 bar)
                divisions: [
                    '1/32','1/16','1/8','1/8T','1/4','1/4T','1/5bar','1/2','1','2bar','4bar','8bar'
                ],
                // Convert a division key to milliseconds for the current bpm
                toMs(div, bpm){
                    const beatMs = 60000 / Math.max(1, bpm||120);
                    let barMs;
                    try {
                        const tsEl = document.getElementById('universalTimeSignature');
                        const raw = tsEl ? String(tsEl.value||'4/4') : '4/4';
                        const [n,d] = raw.split('/').map(v=>parseInt(v,10));
                        const tsNum = (Number.isFinite(n) && n>0) ? n : 4;
                        const tsDen = (Number.isFinite(d) && d>0) ? d : 4;
                        const beatsPerBar = (tsNum * 4) / tsDen;
                        barMs = beatMs * beatsPerBar;
                    } catch(_) { barMs = beatMs * 4; }
                    switch(div){
                        case '1/32': return beatMs/8;
                        case '1/16': return beatMs/4;
                        case '1/8T': return (beatMs/3); // triplet 1/8 over beat
                        case '1/8': return beatMs/2;
                        case '1/4T': return (2*beatMs/3);
                        case '1/4': return beatMs;
                        case '1/5bar': return barMs/5;
                        case '1/2': return 2*beatMs;
                        case '1': return 4*beatMs;
                        case '2bar': return 2*barMs;
                        case '4bar': return 4*barMs;
                        case '8bar': return 8*barMs;
                        default: return Math.max(1, Number(div)||300);
                    }
                },
                nearestDivision(ms, bpm){
                    let best = '1/16';
                    let bestErr = Infinity;
                    for (const d of this.divisions){
                        const t = this.toMs(d, bpm);
                        const err = Math.abs(t - ms);
                        if (err < bestErr){ bestErr = err; best = d; }
                    }
                    return best;
                }
            };
            function getBpm(){
                const main=document.getElementById('universalBpm');
                if (main) return Number(main.value)||120;
                const mini=document.getElementById('drumBpmMini');
                return mini? (Number(mini.value)||120) : 120;
            }
            function formatMs(ms){
                if (ms >= 1000) return `${(ms/1000).toFixed(ms%1000?2:1)}s`;
                return `${Math.round(ms)}ms`;
            }
            function parseMsText(text){
                if (!text) return null;
                const t = String(text).trim().toLowerCase();
                if (t.endsWith('ms')) return Number(t.replace('ms','').trim());
                if (t.endsWith('s')) return Number(t.replace('s','').trim())*1000;
                const n = Number(t);
                return Number.isFinite(n)? n : null;
            }
            // Track Shift globally so users can press it anytime to get ms-precision dragging
            if (!window.__timeGridShiftHooked){
                window.__timeGridShiftHooked = true;
                window.__timeGridShiftPressed = false;
                window.addEventListener('keydown', (e)=>{ if (e.key === 'Shift') window.__timeGridShiftPressed = true; });
                window.addEventListener('keyup',   (e)=>{ if (e.key === 'Shift') window.__timeGridShiftPressed = false; });
                window.addEventListener('blur', ()=>{ window.__timeGridShiftPressed = false; });
            }
            // Map glide slider position (0..1000) to ms: 0=1/32, 500=1 bar, 1000=8 bars
            function glidePosToMs(pos, bpm){
                pos = Math.max(0, Math.min(1000, Number(pos)||0));
                const bar = window.TimeGrid.toMs('1', bpm);
                const leftMs = window.TimeGrid.toMs('1/32', bpm);
                const rightMs = window.TimeGrid.toMs('8bar', bpm);
                if (pos === 500) return bar;
                if (pos < 500){
                    const t = pos/500; // 0..1
                    // geometric-ish taper towards shorter values for better resolution
                    const k = Math.pow(t, 1.6);
                    return leftMs + (bar - leftMs) * k;
                } else {
                    const t = (pos-500)/500; // 0..1
                    const k = Math.pow(t, 1.2);
                    return bar + (rightMs - bar) * k;
                }
            }
            function msToGlidePos(ms, bpm){
                const bar = window.TimeGrid.toMs('1', bpm);
                const leftMs = window.TimeGrid.toMs('1/32', bpm);
                const rightMs = window.TimeGrid.toMs('8bar', bpm);
                ms = Math.max(leftMs, Math.min(rightMs, Number(ms)||bar));
                if (ms === bar) return 500;
                if (ms < bar){
                    const t = (ms - leftMs) / (bar - leftMs);
                    const k = Math.pow(Math.max(0, Math.min(1, t)), 1/1.6);
                    return Math.round(k * 500);
                } else {
                    const t = (ms - bar) / (rightMs - bar);
                    const k = Math.pow(Math.max(0, Math.min(1, t)), 1/1.2);
                    return Math.round(500 + k * 500);
                }
            }
            function wireQuantizedTimeSlider(sliderId, labelId, opts){
                const slider = document.getElementById(sliderId);
                const label = document.getElementById(labelId);
                if (!slider || !label) return;
                const isGlide = /glide/i.test(sliderId);
                const minMs = isGlide ? window.TimeGrid.toMs('1/32', getBpm()) : (Number(slider.min)||10);
                const maxMs = isGlide ? window.TimeGrid.toMs('8bar', getBpm())  : (Number(slider.max)||120000);
                let shifting = false; // deprecated local flag; kept for pointer events
                let recursing = false;
                // optional sticky division memory (per control)
                const stickyKey = `div@${labelId}`;
                let stickyDiv = null;
                // if user typed an explicit ms value, keep it until they type a division or drag without Shift
                let manualMs = false;
                const snap = (bypassQuantize)=>{
                    const bpm = getBpm();
                    let v;
                    if (isGlide){
                        // Interpret slider.value as position 0..1000 and map to ms
                        v = glidePosToMs(Number(slider.value)||500, bpm);
                    } else {
                        v = Number(slider.value)||minMs;
                    }
                    const wantBypass = !!(bypassQuantize || shifting || window.__timeGridShiftPressed || manualMs);
                    if (!wantBypass){
                        // Choose the division nearest to the current slider position
                        const div = window.TimeGrid.nearestDivision(v, bpm);
                        v = Math.min(maxMs, Math.max(minMs, window.TimeGrid.toMs(div, bpm)));
                        if (isGlide){ slider.value = String(msToGlidePos(v, bpm)); } else { slider.value = String(Math.round(v)); }
                        // Persist sticky for glides and other musical time controls
                        stickyDiv = div; try { sessionStorage.setItem(stickyKey, div); } catch(_) {}
                    } else {
                        // Keep raw ms while bypassing quantization
                        v = Math.min(maxMs, Math.max(minMs, v));
                        if (isGlide){ slider.value = String(msToGlidePos(v, bpm)); } else { slider.value = String(Math.round(v)); }
                    }
                    if (label){
                        // For glides, show musical division when quantized; show ms when bypassing
                        if (isGlide && !wantBypass){
                            label.textContent = stickyDiv || window.TimeGrid.nearestDivision(v,bpm);
                        } else {
                            label.textContent = formatMs(v);
                        }
                    }
                    return v;
                };
                // initial render
                try { stickyDiv = sessionStorage.getItem(stickyKey) || null; } catch(_) {}
                // For glides, initialize slider position to reflect current ms value
                if (isGlide){
                    const bpm = getBpm();
                    const initMs = stickyDiv ? window.TimeGrid.toMs(stickyDiv, bpm) : glidePosToMs(Number(slider.value)||500, bpm);
                    slider.value = String(msToGlidePos(initMs, bpm));
                }
                snap(false);
                // respond to slider moves
                slider.addEventListener('input', ()=>{ 
                    if (recursing) return; 
                    const before = Number(slider.value);
                    const bypassNow = (window.__timeGridShiftPressed || shifting || manualMs);
                    // If user is not bypassing now and previously typed ms, return to quantized mode
                    if (!bypassNow && manualMs) manualMs = false;
                    // If Shift currently held, bypass quantization to allow fine ms control
                    const v = snap(bypassNow); 
                    if (Math.round(before) !== Math.round(v)){
                        // propagate quantized value to other listeners
                        recursing = true;
                        setTimeout(()=>{ try{ slider.dispatchEvent(new Event('input', {bubbles:false})); } finally { recursing=false; } }, 0);
                    }
                });
                // shift precision
                slider.addEventListener('pointerdown', (e)=>{ shifting = !!(e.shiftKey || window.__timeGridShiftPressed); });
                slider.addEventListener('pointerup', ()=>{ shifting=false; });
                slider.addEventListener('pointercancel', ()=>{ shifting=false; });
                // respond to BPM changes to resnap value to the grid
                const bpmEl = document.getElementById('universalBpm');
                if (bpmEl){ bpmEl.addEventListener('input', ()=>{ 
                    // When BPM changes, keep ms if user is in manualMs or holding Shift; otherwise re-quantize
                    const v = snap(window.__timeGridShiftPressed || manualMs); 
                    recursing = true; 
                    setTimeout(()=>{ try{ slider.dispatchEvent(new Event('input', {bubbles:false})); } finally { recursing=false; } }, 0);
                }); }
                // label typing (accepts ms or s; for glides, also accept division tokens like 1/2, 2bar)
                label.addEventListener('keydown', (e)=>{
                    if (e.key === 'Enter'){
                        e.preventDefault();
                        const txt = String(label.textContent||'').trim().toLowerCase();
                        // try division tokens first (e.g., 1/2, 2bar)
                        let nextMs = null;
                        if (/(^\d+\/\d+$)|bar$|t$/.test(txt)){
                            stickyDiv = txt.replace(/\s+/g,'');
                            // normalize common aliases
                            const aliases = { '1/1':'1', '1':'1', '1bar':'1', '2bars':'2bar', '4bars':'4bar', '8bars':'8bar' };
                            stickyDiv = aliases[stickyDiv] || stickyDiv;
                            nextMs = window.TimeGrid.toMs(stickyDiv, getBpm());
                            manualMs = false; // return to quantized mode
                        } else {
                            const ms = parseMsText(txt);
                            if (Number.isFinite(ms)) nextMs = ms;
                        }
                        if (Number.isFinite(nextMs)){
                            const clamped = Math.min(maxMs, Math.max(minMs, nextMs));
                            slider.value = String(Math.round(clamped));
                            if (/(^\d+\/\d+$)|bar$|t$/.test(txt)){
                                // Division: quantize and show division (for glides) or ms (others)
                                const v = snap(false);
                                recursing = true; 
                                setTimeout(()=>{ try{ slider.dispatchEvent(new Event('input', {bubbles:false})); } finally { recursing=false; } }, 0);
                            } else {
                                // Explicit ms/s typed: keep raw ms and show ms; notify listeners
                                manualMs = true;
                                if (label) label.textContent = formatMs(clamped);
                                recursing = true;
                                setTimeout(()=>{ try{ slider.dispatchEvent(new Event('input', {bubbles:false})); } finally { recursing=false; } }, 0);
                            }
                        } else { snap(); }
                        label.blur();
                    }
                });
                label.addEventListener('blur', ()=>{ snap(); });
            }
            // Wire key time controls
            try {
                wireQuantizedTimeSlider('chordGlideMs', 'chordGlideMsValue');
                wireQuantizedTimeSlider('delayTime', 'delayTimeValue');
                // panning speed uses seconds in UI, still accept ms typing
                (function(){
                    const s=document.getElementById('panningSpeed');
                    const l=document.getElementById('panningSpeedValue');
                    if (!s||!l) return;
                    const render=()=>{ l.textContent = formatMs(Number(s.value)||0).replace('ms','ms').replace(/^(\d+(?:\.\d+)?)s$/, '$1s'); };
                    render();
                    s.addEventListener('input', render);
                    // quantize to BPM grid as well
                    wireQuantizedTimeSlider('panningSpeed','panningSpeedValue');
                })();
                // ADSR sliders (attack/decay/release for both OSCs) â€” attacks are free ms-only
                wireQuantizedTimeSlider('decaySlider','decayValue');
                wireQuantizedTimeSlider('releaseSlider','releaseValue');
                // attacks are wired directly above in input listeners; keep them unquantized
                wireQuantizedTimeSlider('osc2DecaySlider','osc2DecayValue');
                wireQuantizedTimeSlider('osc2ReleaseSlider','osc2ReleaseValue');
            } catch(_) {}
            omnichord = new MicrotonalOmnichord();
            window.omnichord = omnichord; // Make it globally accessible
            try { omnichord.setDebug?.(true); console.log('[DEBUG] window.load: omnichord ready; debug=', !!omnichord._debug); } catch(_){ }
            try {
                const chordsBtn = document.getElementById('chordsBtn');
                if (chordsBtn) chordsBtn.classList.toggle('active', !!omnichord.chordsEnabled);
            } catch(_){ }

            // Basic JAM tests (run manually in console: window.runJamTests())
            window.runJamTests = function(){
                const results = [];
                const add = (name, ok, info='') => results.push({ name, ok: !!ok, info });
                try { add('JAM open function', typeof omnichord.openBellsWindow === 'function'); } catch(_) { add('JAM open function', false, 'omnichord missing'); }
                let w1 = null; let w2 = null;
                try {
                    w1 = omnichord.openBellsWindow();
                    w2 = omnichord.openBellsWindow();
                } catch(e){ add('JAM multi-window', false, 'Popup blocked or error'); }
                if (w1 && w2) {
                    add('JAM multi-window', w1 !== w2);
                    try {
                        const sel = w1.document && w1.document.getElementById('midiOut-bells');
                        add('JAM MIDI OUT select exists', !!sel);
                        const playBtn = w1.document && w1.document.getElementById('bellsPlayBtn');
                        add('JAM transport button exists', !!playBtn);
                    } catch(_){ add('JAM window DOM access', false, 'Cross-window access failed'); }
                }
                try { console.table(results); } catch(_) { console.log(results); }
                return results;
            };

            // --- Startup UX: prompt every load; NEW PROJECT starts blank with keyboard closed ---
            try {
                const ensureKeyboardClosed = ()=>{
                    try { if (typeof window.closeKeyboardModal === 'function') window.closeKeyboardModal(); } catch(_){ }
                    try { const km = document.getElementById('keyboardModal'); if (km) km.style.display = 'none'; } catch(_){ }
                    try { const kb = document.getElementById('keyboardBtn'); if (kb) kb.classList.remove('active'); } catch(_){ }
                };

                const clearPatternInstances = ()=>{
                    try {
                        const insts = window._patternInstances || [];
                        insts.forEach(info=>{
                            try {
                                const modal = info && info.modal;
                                if (modal && modal._stripBtn) modal._stripBtn.remove();
                                if (modal) modal.remove();
                            } catch(_){ }
                        });
                        window._patternInstances = [];
                        window._patternInstanceCounter = 0;
                        const host = document.getElementById('patternButtons');
                        if (host) host.innerHTML = '';
                    } catch(_){ }
                };

                const clearDrumInstances = ()=>{
                    try {
                        const insts = window._drumInstances || [];
                        insts.forEach(inst=>{ try { if (inst && inst._stripBtn) inst._stripBtn.remove(); } catch(_){ } });
                        window._drumInstances = [];
                        window._drumInstanceCounter = 0;
                        window._activeDrumInstanceId = null;
                        const host = document.getElementById('drumButtons');
                        if (host) host.innerHTML = '';
                    } catch(_){ }
                };

                const stopPlayIfRunning = ()=>{
                    try {
                        const omni = window.omnichord;
                        if (omni && omni._arpTransport && omni._arpTransport.running) {
                            const btn = document.getElementById('playStopToggleBtn');
                            if (btn) btn.click();
                        }
                    } catch(_){ }
                };

                window.__xenStartNewProjectBlank = function(){
                    try { stopPlayIfRunning(); } catch(_){ }
                    try { ensureKeyboardClosed(); } catch(_){ }
                    try { clearPatternInstances(); } catch(_){ }
                    try { clearDrumInstances(); } catch(_){ }
                    try {
                        const oc = window.omnichord;
                        if (oc) {
                            oc.chordExtensions = [];
                            oc.hiddenColumns = [];
                            oc.pendingBlankChordId = null;
                            try { oc.saveChordConfiguration?.(); } catch(_){ }
                            try { oc.generateExtensionColumns?.(); } catch(_){ }
                        }
                    } catch(_){ }
                    try { if (window.omnichord?._refreshArpTransportTiming) window.omnichord._refreshArpTransportTiming(); } catch(_){ }
                };

                window.__xenOpenLoadXenPicker = function(){
                    try { ensureKeyboardClosed(); } catch(_){ }
                    try {
                        const input = document.getElementById('loadSessionInput');
                        if (input) input.click();
                        else {
                            const btn = document.getElementById('loadXenBtn');
                            if (btn) btn.click();
                        }
                    } catch(_){ }
                };

                const overlay = document.getElementById('startupPromptOverlay');
                if (overlay && !overlay._wired) {
                    overlay._wired = true;
                    const hide = ()=>{ try { overlay.style.display = 'none'; } catch(_){ } };
                    const newBtn = document.getElementById('startupNewProjectBtn');
                    const loadBtn = document.getElementById('startupLoadXenBtn');
                    if (newBtn) newBtn.addEventListener('click', ()=>{ hide(); try { window.__xenStartNewProjectBlank(); } catch(_){ } });
                    if (loadBtn) loadBtn.addEventListener('click', ()=>{ hide(); try { window.__xenOpenLoadXenPicker(); } catch(_){ } });
                }
                // Always show startup prompt on load
                if (overlay) {
                    ensureKeyboardClosed();
                    overlay.style.display = 'flex';
                }
            } catch(_){ }

            // Provide pattern note playback hook if not already defined
            if (typeof window.omnichord._playPatternNote !== 'function') {
                window.omnichord._playPatternNote = function(rowIdx, lenSteps, stepIndex, velocity = 100, opts){
                    try {
                        const o = (opts && typeof opts === 'object') ? opts : null;
                        const gridEl = (o && o.gridEl) ? o.gridEl : document.getElementById('patternGrid');
                        const instrumentKey = (o && o.instrumentKey) ? String(o.instrumentKey) : 'arp';
                        const transportObj = (o && o.transport) ? o.transport : (window._patternTransport || { stepMs: 120 });

                        // Strict preview/mute gating: if PATTERN is off (not green), never emit audio.
                        // Also honor per-instance mute in pattern clone modals.
                        try {
                            const btn = document.getElementById('patternBtn');
                            if (btn && !btn.classList.contains('active')) return null;
                        } catch(_){ }
                        try {
                            const modalRoot = gridEl && gridEl.closest ? gridEl.closest('.floating-modal') : null;
                            if (modalRoot && typeof modalRoot._patternEnabled === 'boolean' && !modalRoot._patternEnabled) return null;
                        } catch(_){ }

                        // PATTERN pitch semantics (no voice-leading): NOTE 1 (rowIdx=0) is always the chord ROOT (lowest chord tone).
                        // We derive chord degrees from the current effective chord (column/root), not from mapAsc/voicing.
                        const tuning = this.currentTuning || 12;
                        const norm = (x)=> ((x % tuning) + tuning) % tuning;
                        const col = (this._arp && this._arp.column) || this.currentActiveColumnEl || document.querySelector('#extensionColumns .extension-column');
                        let rootAbs = Number.isFinite(this.currentRoot) ? (this.currentRoot|0) : 0;
                        try {
                            if (col && typeof this._getNamedColumnRootStep === 'function') {
                                const r = this._getNamedColumnRootStep(col);
                                if (Number.isFinite(r)) rootAbs = r;
                            } else if (col && typeof this._getEffectiveColumnRootStep === 'function') {
                                const r = this._getEffectiveColumnRootStep(col);
                                if (Number.isFinite(r)) rootAbs = r;
                            }
                        } catch(_){ }

                        let degs = [];
                        try {
                            if (col && typeof this._getChordDegreesForColumn === 'function') {
                                const d = this._getChordDegreesForColumn(col);
                                if (Array.isArray(d) && d.length) degs = d.map(norm);
                            }
                            if ((!degs || !degs.length) && col) {
                                // Fallback: derive from rendered strings
                                const rows = Array.from(col.querySelectorAll('.strings-column .string'));
                                const stepsAbs = rows.map(r=> parseInt(r.dataset.noteIndex,10)).filter(Number.isFinite);
                                const rel = stepsAbs.map(st=> norm(st - rootAbs));
                                degs = Array.from(new Set(rel));
                            }
                        } catch(_){ degs = []; }

                        // Ensure root is always present and always first.
                        degs = Array.from(new Set([0, ...(Array.isArray(degs) ? degs : [])])).map(norm);
                        const others = degs.filter(d=> d !== 0);
                        try {
                            if (typeof this.stepToSemitone === 'function') {
                                others.sort((a,b)=> this.stepToSemitone(a, tuning) - this.stepToSemitone(b, tuning));
                            } else {
                                others.sort((a,b)=> a-b);
                            }
                        } catch(_){ others.sort((a,b)=>a-b); }
                        degs = [0, ...others];

                        // Determine how many NOTE rows are available (exclude BASS rows)
                        let npcCount = 0;
                        try {
                            const rows = gridEl ? Array.from(gridEl.querySelectorAll('.pattern-row')) : [];
                            npcCount = rows.filter(r=>!r.classList.contains('bass-row')).length;
                        } catch(_){ npcCount = 0; }

                        // UI semantics: NOTE 1 is the BOTTOM row (lowest pitch).
                        // Flip row index so the bottom row maps to ROOT (degree 0).
                        const rawRow = Math.max(0, (rowIdx|0));
                        const row = (npcCount > 0) ? Math.max(0, (npcCount - 1) - rawRow) : rawRow;
                        const degCount = Math.max(1, degs.length);
                        // Row 0 => ROOT, Row 1 => next degree, etc. After degrees, wrap to next octave.
                        const degIdx = row % degCount;
                        const octCycle = Math.floor(row / degCount);
                        const baseOct = 3 + octCycle;
                        // Compute step in current EDO. Avoid bitwise truncation so microtonal/converted roots stay accurate.
                        const absStepRaw = (Number(rootAbs) + Number(degs[degIdx] || 0));
                        const absStep = norm(Math.round(absStepRaw));
                        let f = null;
                        // Prefer the column's rendered string frequency (already tuned for current EDO).
                        try {
                            if (col) {
                                const match = col.querySelector(`.strings-column .string[data-note-index="${absStep}"][data-octave="${baseOct}"]`)
                                    || col.querySelector(`.strings-column .string[data-noteIndex="${absStep}"][data-octave="${baseOct}"]`);
                                const f0 = match ? parseFloat(match.dataset.frequency) : NaN;
                                if (Number.isFinite(f0) && f0 > 0) f = f0;
                            }
                        } catch(_){ }
                        if (!Number.isFinite(f) || !(f > 0)) {
                            try { f = this.getFrequency(absStep, baseOct, tuning); } catch(_){ f = null; }
                        }

                        // Ultimate fallback: old voicing-based mapping if something went wrong
                        if (!Number.isFinite(f) || !(f > 0)) {
                            const asc = Array.isArray(this._arp?.mapAsc) ? this._arp.mapAsc : [];
                            const useCount2 = asc.length;
                            const idxInAsc = Math.max(0, Math.min(useCount2 - 1, (rowIdx|0)));
                            const node = asc[idxInAsc];
                            if (!node) return null;
                            let f2 = parseFloat(node?.dataset?.frequency);
                            if (Number.isFinite(f2) && f2 > 0) f = f2;
                        }
                        if (!isFinite(f) || !(f>0)) return null;
                        const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                        const stepsPerBar = Math.max(1, Math.min(maxLen, parseInt(gridEl?.dataset?.length||'16',10)||16));
                        const maxStepsOverride = (o && Number.isFinite(o.maxSteps)) ? (o.maxSteps|0) : (o && typeof o.maxSteps === 'string' ? (parseInt(o.maxSteps,10)||0) : 0);
                        const maxStepsForCap = Math.max(1, Math.min(256, (maxStepsOverride > 0 ? maxStepsOverride : stepsPerBar)));
                        const si = Math.max(0, Math.min(maxStepsForCap - 1, stepIndex|0));
                        const effLenSteps = Math.max(1, Math.min((lenSteps|0)||1, maxStepsForCap - si));
                        const pt = transportObj || { stepMs: 120 };
                        const epsilonMs = 8;
                        let gateMs = NaN;
                        try {
                            const gm = (o && o.gateMs != null) ? Number(o.gateMs) : NaN;
                            if (Number.isFinite(gm) && gm > 0) gateMs = gm;
                        } catch(_){ }
                        if (!Number.isFinite(gateMs) || !(gateMs > 0)) {
                            gateMs = Math.max(10, Math.floor((pt.stepMs||120) * effLenSteps - epsilonMs));
                        }
                        
                        // Ensure MIDI note-off uses this gate duration
                        try { this._lastArpGateMs = gateMs; } catch(_) {}
                        // Play with per-note velocity override
                        this.playFrequency(f, { __gateMs: gateMs }, instrumentKey, velocity);
                        const stop = ()=>{ try { this.stopFrequency(f, null, instrumentKey); } catch(_){} };
                        setTimeout(stop, gateMs + 2);
                        return stop;
                    } catch(_){ return null; }
                };
            }

            // Ensure an independent pattern transport exists when needed
            if (!window.ensurePatternTransport) {
                window.ensurePatternTransport = function(){
                    try {
                        if (window._patternTransport) return;
                        const pg = document.getElementById('patternGrid');
                        if (!pg) return;
                        const pt = window._patternTransport = {
                            running: false,
                            tickCounter: 0,
                            absTickCounter: 0,
                            nextAt: (performance && performance.now ? performance.now() : Date.now()),
                            stepMs: 120,
                            activeVoices: new Set(),
                            swingPct: 0,
                            _rafActive: false,
                            waitingForDeferred: false,
                            resumeAfterDeferred: false,
                            preRollUntil: null,
                            // Beat-locked: driven from omnichord._arpTransport
                            _useMasterClock: true,
                            _gridEl: pg,
                            _scheduleStep: null,
                            _masterLastAbsStep: null,
                            _startAtBarIndex: null,
                        };
                        function refreshTiming(){
                            try {
                                const bpmEl = document.getElementById('universalBpm');
                                const transportBpmEl = document.getElementById('transportBpm');
                                const quantEl = document.getElementById('universalQuant');
                                const patternQuantEl = document.getElementById('patternQuant');
                                const swingEl = document.getElementById('universalSwing');
                                // Priority: __MASTER_BPM > transportBpm > universalBpm > default 120
                                const bpm = Math.max(20, window.__MASTER_BPM || parseFloat(transportBpmEl?.value||'0') || parseFloat(bpmEl?.value||'120')||120);
                                const quant = (patternQuantEl?.value || quantEl?.value || '1/16').trim();
                                let baseDiv = 16; let isTrip = false; let tupletRatio = 1;
                                if (/tuplet:\s*(\d+)\/(\d+)/i.test(quant)) { const m=quant.match(/tuplet:\s*(\d+)\/(\d+)/i); const n=+m[1], d=+m[2]; if(n>0&&d>0){ tupletRatio=n/d; baseDiv=4; } }
                                else if (/^1\/(\d+)(t)?$/i.test(quant)) { const m=quant.match(/^1\/(\d+)(t)?$/i); baseDiv=parseInt(m[1],10)||16; if(m[2]) isTrip=true; }
                                const beatMs = 60000 / bpm;
                                let stepMs = beatMs * 4 / baseDiv; if (isTrip) stepMs *= (2/3); if (tupletRatio !== 1) stepMs *= (1/tupletRatio);
                                pt.stepMs = stepMs; pt.swingPct = Math.max(0, Math.min(75, parseFloat(swingEl?.value||'0')||0));
                            } catch(_) {}
                        }
                        refreshTiming();
                        window.refreshPatternTransportTiming = window.refreshPatternTransportTiming || refreshTiming;
                        ['universalBpm','universalQuant','universalSwing','transportBpm','patternQuant'].forEach(id=>{ const el=document.getElementById(id); if(el){ el.addEventListener('input', refreshTiming); el.addEventListener('change', refreshTiming); }});
                        const gcd = (a,b)=>{ a=Math.abs(a|0); b=Math.abs(b|0); while(b){ const t=a%b; a=b; b=t; } return a||1; };
                        const getLaneD = (lane, fallback)=>{
                            let D = fallback|0;
                            try {
                                const qs = String(lane?.dataset?.quant||'').trim();
                                const mf = qs.match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
                                if (mf) {
                                    // Pattern semantics: numerator = Q subdivisions (accept legacy "7/16" as 7)
                                    const n = parseInt(mf[1],10);
                                    if (Number.isFinite(n) && n>0) D = n;
                                } else {
                                    const mn = qs.match(/^\s*(\d+)\s*$/);
                                    if (mn) {
                                        const n = parseInt(mn[1],10);
                                        if (Number.isFinite(n) && n>0) D = n;
                                    }
                                }
                            } catch(_){ }
                            D = Math.max(1, Math.min(256, D|0));
                            return D;
                        };
                        function noteId(row, stepIdx){ return `r${row}s${stepIdx}`; }
                        function scheduleStep(absTickNow, barTick, ticksPerBar){
                            // Gate pattern playback: only play if PATTERN button is ON
                            try {
                                const patternBtn = document.getElementById('patternBtn');
                                const patternEnabled = !!(patternBtn && patternBtn.classList.contains('active'));
                                if (!patternEnabled) {
                                    // Stop any active voices when pattern is disabled
                                    if (pt.activeVoices.size){
                                        for (const vid of Array.from(pt.activeVoices)){
                                            const meta = pt[vid]; if (meta && meta.stop) { try { meta.stop(); } catch(_){} }
                                            pt.activeVoices.delete(vid); delete pt[vid];
                                        }
                                    }
                                    return; // Don't play any notes
                                }
                            } catch(_) {}

                            const tpb = Math.max(1, ticksPerBar|0);
                            const bt = Math.max(0, barTick|0);
                            const tickMs = (window.omnichord && window.omnichord._arpTransport && window.omnichord._arpTransport.tickMs) ? Number(window.omnichord._arpTransport.tickMs) : NaN;

                            // Stop expired voices
                            if (pt.activeVoices.size){
                                for (const vid of Array.from(pt.activeVoices)){
                                    const meta = pt[vid];
                                    if (meta && meta.offAbsTick != null && (meta.offAbsTick|0) <= (absTickNow|0)){
                                        try { if (meta.stop) meta.stop(); } catch(_){}
                                        pt.activeVoices.delete(vid);
                                        delete pt[vid];
                                    }
                                }
                            }

                            const rows = pg.querySelectorAll('.pattern-row');
                            const baseFallback = Math.max(1, parseInt(pg.dataset.length||'16',10)||16);
                            rows.forEach((rowEl, rowIdx)=>{
                                const lane = rowEl.querySelector('.pattern-lane');
                                if (!lane) return;
                                const D = Math.max(1, (lane.querySelectorAll('.pattern-step').length|0) || getLaneD(lane, baseFallback));
                                // Fraction-based scheduling: works even when ticksPerBar is clamped and not divisible by D.
                                const frac = bt / tpb;
                                const stepIdx = Math.max(0, Math.min(D-1, Math.floor(frac * D + 1e-9)));
                                // Fire at most once per lane-step.
                                if (lane._lastPatternStepIdx === stepIdx) return;
                                lane._lastPatternStepIdx = stepIdx;
                                try { lane.style.setProperty('--steps-per-bar', String(D)); } catch(_){ }
                                const cell = lane.querySelector(`.pattern-step[data-step="${stepIdx}"]`);
                                if (!cell) return;
                                if (!cell.classList.contains('active')) return;
                                if (cell.dataset.tie === '1') return;

                                // Visual feedback: pulse the dot when it fires.
                                try { window._pulseStepEl && window._pulseStepEl(cell); } catch(_){ }

                                const lenSteps = Math.max(1, Math.min(D - stepIdx, parseInt(cell.dataset.len||'1',10)||1));
                                const vel = (window.getStepVelocity ? (window.getStepVelocity(cell) ?? 100) : (parseInt(cell.dataset.vel||'100',10)||100));

                                const vid = noteId(rowIdx, stepIdx);
                                const durTicks = Math.max(1, Math.round((lenSteps * tpb) / D));
                                const offAbsTick = (absTickNow|0) + durTicks;
                                const epsilonMs = 8;
                                const gateMs = (Number.isFinite(tickMs) && tickMs > 0)
                                    ? Math.max(10, Math.floor((tickMs * durTicks) - epsilonMs))
                                    : NaN;
                                let stopFn = null;
                                try {
                                    if (window.omnichord && typeof window.omnichord._playPatternNote === 'function') {
                                        stopFn = window.omnichord._playPatternNote(rowIdx, lenSteps, stepIdx, vel, {
                                            gridEl: pg,
                                            instrumentKey: 'arp',
                                            transport: pt,
                                            gateMs,
                                            maxSteps: D,
                                        });
                                    }
                                } catch(_){ }

                                // Replace any existing voice for this id
                                try {
                                    if (pt.activeVoices.has(vid)) {
                                        const prev = pt[vid];
                                        if (prev && prev.stop) { try { prev.stop(); } catch(_){ } }
                                        pt.activeVoices.delete(vid);
                                        delete pt[vid];
                                    }
                                } catch(_){ }

                                pt.activeVoices.add(vid);
                                pt[vid] = { offAbsTick, stop: stopFn };
                            });
                        }
                        function loop(){
                            pt._rafActive = true;
                            if (!pt.running) { pt._rafActive = false; return; }
                            // Master transport drives steps; never run an independent rAF clock.
                            if (pt._useMasterClock) { pt._rafActive = false; return; }
                            const now=(performance && performance.now ? performance.now() : Date.now());
                            if (pt.preRollUntil != null) {
                                if (now + 0.5 < pt.preRollUntil) {
                                    requestAnimationFrame(loop);
                                    return;
                                }
                                pt.preRollUntil = null;
                                // Ensure the first step lines up immediately after pre-roll
                                if (!Number.isFinite(pt.nextAt) || pt.nextAt < now) {
                                    pt.nextAt = now + pt.stepMs;
                                }
                            }
                            if (now + 1 >= pt.nextAt){
                                const base = pt.stepMs; const isEven = (pt.tickCounter % 2)===0; let stepDur = base;
                                if (pt.swingPct>0){ const s=pt.swingPct/100; stepDur = isEven ? base*(1+s*0.5) : base*(1-s*0.5); }
                                const tpb = (window.omnichord && window.omnichord._arpTransport && window.omnichord._arpTransport.ticksPerBar)
                                    ? (window.omnichord._arpTransport.ticksPerBar | 0)
                                    : (parseInt(pg.dataset.length||'16',10) || 16);
                                const bt = (tpb > 0) ? ((pt.tickCounter | 0) % tpb) : (pt.tickCounter | 0);
                                scheduleStep(pt.absTickCounter | 0, bt, tpb | 0);
                                pt.tickCounter = (pt.tickCounter + 1) >>> 0; pt.absTickCounter = (pt.absTickCounter + 1) >>> 0;
                                if (pt.tickCounter >= 100000000) pt.tickCounter = tpb > 0 ? (pt.tickCounter % tpb) : pt.tickCounter;
                                pt.nextAt += stepDur;
                            }
                            if (pt.preRollUntil == null && pt.nextAt - now > 5000) pt.nextAt = now + pt.stepMs;
                            requestAnimationFrame(loop);
                        }
                        pt.nextAt = (performance && performance.now ? performance.now() : Date.now()) + pt.stepMs;
                        // Allow external restart of rAF after STOP (legacy only)
                        pt.kick = function(){
                            if (pt._useMasterClock) return;
                            if (!pt._rafActive) { try { requestAnimationFrame(loop); } catch(_){} }
                        };
                        pt.stopVoices = function(){
                            try {
                                if (pt.activeVoices.size){
                                    for (const vid of Array.from(pt.activeVoices)){
                                        const meta = pt[vid];
                                        if (meta && meta.stop) {
                                            try { meta.stop(); } catch(_){ }
                                        }
                                        if (vid in pt) delete pt[vid];
                                    }
                                    pt.activeVoices.clear();
                                }
                            } catch(_){}
                        };
                        pt.stop = function(resetPhase = true){
                            pt.running = false;
                            pt.stopVoices();
                            pt.waitingForDeferred = false;
                            pt.resumeAfterDeferred = false;
                            pt.preRollUntil = null;
                            if (resetPhase) {
                                pt.tickCounter = 0;
                                pt.absTickCounter = 0;
                                const now = (performance && performance.now ? performance.now() : Date.now());
                                // Fire step 0 immediately (no delay)
                                pt.nextAt = now;
                            }
                        };
                        pt.start = function(resetPhase = true, opts){
                            if (typeof resetPhase === 'object' && opts === undefined) {
                                opts = resetPhase;
                                resetPhase = true;
                            }
                            const options = opts || {};
                            if (pt._useMasterClock) {
                                // Beat 1 is king: always start on Beat 1 of the NEXT bar.
                                const omni = window.omnichord;
                                const transport = omni && omni._arpTransport;
                                const tpBar = Math.max(1, (transport && transport.ticksPerBar) || 16);
                                const absTick = (transport && (transport.absTickCounter|0)) || 0;
                                const curBar = Math.floor(absTick / tpBar);
                                pt._startAtBarIndex = curBar + 1;
                                pt._masterLastAbsStep = null;
                                pt.preRollUntil = null;
                                pt.waitingForDeferred = false;
                                pt.resumeAfterDeferred = false;
                                pt.running = true;
                                try { pt.stopVoices && pt.stopVoices(); } catch(_){ }
                                return;
                            }
                            const base = Math.max(1, pt.stepMs || 120);
                            void base;
                            const now = (performance && performance.now ? performance.now() : Date.now());
                            if (resetPhase) {
                                pt.tickCounter = 0;
                                pt.absTickCounter = 0;
                            }
                            let delayMs = 0;
                            const alignToTransport = options.alignToTransport !== false;
                            const preBufferMs = Math.max(0, Number.isFinite(options.preBufferMs) ? Number(options.preBufferMs) : 0);
                            const omni = window.omnichord;
                            const transport = omni && omni._arpTransport;
                            if (alignToTransport && transport) {
                                const tickMs = transport.tickMs || ((transport.beatMs || (60000 / Math.max(20, transport.bpm || 120))) / Math.max(1, transport.ticksPerBeat || 4));
                                const tpBar = Math.max(1, transport.ticksPerBar || ((transport.beatsPerBar || 4) * Math.max(1, transport.ticksPerBeat || 4)));
                                const curTick = transport.tickCounter|0;
                                const remTicks = (tpBar - (curTick % tpBar)) % tpBar;
                                const waitTicks = remTicks === 0 ? tpBar : remTicks;
                                delayMs += waitTicks * tickMs;
                            }
                            delayMs += preBufferMs;
                            if (delayMs > 1) {
                                pt.preRollUntil = now + delayMs;
                                // Fire step 0 immediately after pre-roll (no extra delay)
                                pt.nextAt = pt.preRollUntil;
                            } else {
                                pt.preRollUntil = null;
                                // Fire step 0 immediately (no delay)
                                pt.nextAt = now;
                            }
                            pt.waitingForDeferred = false;
                            pt.resumeAfterDeferred = false;
                            pt.running = true;
                            pt.kick();
                        };

                        // Expose scheduler so the master transport can drive this pattern in sync.
                        try { pt._scheduleStep = scheduleStep; } catch(_){ }
                    } catch(_) {}
                };
            }
            // Provide a lightweight pattern-note playback helper used by the independent pattern transport
            if (!window.omnichord._playPatternNote) {
                window.omnichord._playPatternNote = function(rowIdx, lenSteps, stepIdx, velocity = 100){
                    try {
                        // Mirror the primary implementation: NOTE 1 is always chord root, no voice-leading.
                        const tuning = this.currentTuning || 12;
                        const norm = (x)=> ((x % tuning) + tuning) % tuning;
                        const col = (this._arp && this._arp.column) || this.currentActiveColumnEl || document.querySelector('#extensionColumns .extension-column');
                        let rootAbs = Number.isFinite(this.currentRoot) ? (this.currentRoot|0) : 0;
                        try {
                            if (col && typeof this._getNamedColumnRootStep === 'function') {
                                const r = this._getNamedColumnRootStep(col);
                                if (Number.isFinite(r)) rootAbs = r;
                            } else if (col && typeof this._getEffectiveColumnRootStep === 'function') {
                                const r = this._getEffectiveColumnRootStep(col);
                                if (Number.isFinite(r)) rootAbs = r;
                            }
                        } catch(_){ }

                        let degs = [];
                        try {
                            if (col && typeof this._getChordDegreesForColumn === 'function') {
                                const d = this._getChordDegreesForColumn(col);
                                if (Array.isArray(d) && d.length) degs = d.map(norm);
                            }
                            if ((!degs || !degs.length) && col) {
                                const rows = Array.from(col.querySelectorAll('.strings-column .string'));
                                const stepsAbs = rows.map(r=> parseInt(r.dataset.noteIndex,10)).filter(Number.isFinite);
                                const rel = stepsAbs.map(st=> norm(st - rootAbs));
                                degs = Array.from(new Set(rel));
                            }
                        } catch(_){ degs = []; }
                        degs = Array.from(new Set([0, ...(Array.isArray(degs) ? degs : [])])).map(norm);
                        const others = degs.filter(d=> d !== 0);
                        try {
                            if (typeof this.stepToSemitone === 'function') {
                                others.sort((a,b)=> this.stepToSemitone(a, tuning) - this.stepToSemitone(b, tuning));
                            } else {
                                others.sort((a,b)=> a-b);
                            }
                        } catch(_){ others.sort((a,b)=>a-b); }
                        degs = [0, ...others];

                        // UI semantics: NOTE 1 is the BOTTOM row (lowest pitch). Flip row index.
                        let npcCount = 0;
                        try {
                            const pg = document.getElementById('patternGrid');
                            const rows = pg ? Array.from(pg.querySelectorAll('.pattern-row')) : [];
                            npcCount = rows.filter(r=>!r.classList.contains('bass-row')).length;
                        } catch(_){ npcCount = 0; }
                        const rawRow = Math.max(0, (rowIdx|0));
                        const row = (npcCount > 0) ? Math.max(0, (npcCount - 1) - rawRow) : rawRow;
                        const degCount = Math.max(1, degs.length);
                        const degIdx = row % degCount;
                        const octCycle = Math.floor(row / degCount);
                        const baseOct = 3 + octCycle;
                        const absStepRaw = (Number(rootAbs) + Number(degs[degIdx] || 0));
                        const absStep = norm(Math.round(absStepRaw));
                        let f = null;
                        try {
                            if (col) {
                                const match = col.querySelector(`.strings-column .string[data-note-index="${absStep}"][data-octave="${baseOct}"]`)
                                    || col.querySelector(`.strings-column .string[data-noteIndex="${absStep}"][data-octave="${baseOct}"]`);
                                const f0 = match ? parseFloat(match.dataset.frequency) : NaN;
                                if (Number.isFinite(f0) && f0 > 0) f = f0;
                            }
                        } catch(_){ }
                        if (!Number.isFinite(f) || !(f > 0)) {
                            try { f = this.getFrequency(absStep, baseOct, tuning); } catch(_){ f = null; }
                        }

                        // Fallback to old mapping if chord context unavailable
                        if (!Number.isFinite(f) || !(f > 0)) {
                            const asc = Array.isArray(this._arp?.mapAsc) ? this._arp.mapAsc : [];
                            if (!asc.length) return null;
                            const idxInAsc = Math.max(0, Math.min(asc.length - 1, (rowIdx|0)));
                            const node = asc[idxInAsc];
                            if (!node) return null;
                            const f2 = parseFloat(node?.dataset?.frequency);
                            if (Number.isFinite(f2) && f2 > 0) f = f2;
                        }
                        if (!Number.isFinite(f) || !(f>0)) return null;
                        const pg = document.getElementById('patternGrid');
                        const maxLen = (window.omnichord && typeof window.omnichord._getMaxCycleSteps === 'function') ? window.omnichord._getMaxCycleSteps() : 64;
                        const stepsPerBar = Math.max(1, Math.min(maxLen, parseInt(pg?.dataset?.length||'16',10)||16));
                        const si = Math.max(0, Math.min(stepsPerBar - 1, stepIdx|0));
                        const effLenSteps = Math.max(1, Math.min((lenSteps|0)||1, stepsPerBar - si)); // release by beat 1 of next cycle
                        const stepMs = Math.max(1, (window._patternTransport?.stepMs || 120));
                        const epsilonMs = 8;
                        const gateMs = Math.max(10, Math.floor(stepMs * effLenSteps - epsilonMs));
                        
                        // Ensure MIDI note-off uses this gate duration
                        try { this._lastArpGateMs = gateMs; } catch(_) {}

                        let stopped = false; let timer = null;
                        const self = this;
                        try { this.playFrequency(f, { __gateMs: gateMs }, 'arp', velocity); } catch(_){ }
                        const stopNow = ()=>{
                            if (!stopped){
                                stopped = true;
                                try { self.stopFrequency(f, null, 'arp'); } catch(_){ }
                            }
                        };
                        try { timer = setTimeout(stopNow, gateMs + 2); } catch(_){ }
                        return ()=>{ if (timer) clearTimeout(timer); stopNow(); };
                    } catch(_){ return null; }
                };
            }

            // Initialize CALC modal on startup (make it draggable)
            // Use setTimeout to ensure all other initialization is complete
            setTimeout(() => {
                try {
                    const calcModal = document.getElementById('keyboardModal');
                    if (calcModal) {
                        if (!calcModal._draggableSet) {
                            makeDraggable(calcModal);
                            calcModal._draggableSet = true;
                            console.log('âœ… CALC modal made draggable on startup');
                        }
                    }
                    // Sync CALC EDO with transport EDO
                    const calcEDO = document.getElementById('edoQuickInputKeyboard');
                    const transportEDO = document.getElementById('edoQuickInputTransport');
                    if (calcEDO && transportEDO) {
                        calcEDO.value = transportEDO.value;
                    }
                } catch(e) {
                    console.error('âŒ Error initializing CALC modal on startup:', e);
                }
            }, 100); // Small delay to ensure DOM is ready

            // Minimal Web MIDI manager providing init/send/receive APIs and integration
            (function(){
                class WebMIDIManager {
                    constructor() {
                        this.enabled = false;
                        this.midiAccess = null;
                        this.inputs = new Map();
                        this.outputs = new Map();
                        this.inputHandler = null;
                        this.channelMap = { strum:1, strum1:1, strum2:2, chord:3, arp:4, bass:5, drum:6, osc1:7, osc2:8, bells:9, default:6 };
                        this.noteState = new Map(); // key: `${note}@${ch}` -> {ts}
                        this.sustain = false; // CC64 >= 64
                        this.deferredOff = new Set(); // keys to send off when sustain released
                        this._idleTimer = null;
                        this._idleMs = 10000; // 10s PANIC after no interaction
                        this.octaveOffset = 0; // UI-controlled MIDI octave transpose
                        this.defaultVelocity = 100; // UI-controlled default velocity
                        // Per-source octave transpose (octaves, always 12 semitones per octave for MIDI)
                        this.perSourceOctave = { strum1:0, strum2:0, chord:0, arp:0, bass:0, osc1:0, osc2:0, bells:0, default:0 };
                        // Per-source default velocity (overrides global if set)
                        this.perSourceVelocity = { strum1:100, strum2:100, chord:100, arp:100, bass:100, osc1:100, osc2:100, bells:100, default:100 };
                        // Per-section MIDI IN channel filter (1=channel 1, not 0=omni)
                        this.inputChannelMap = { strum1:1, strum2:1, chord:1, arp:1, bass:1, bells:1, default:1 };
                        // Per-section MIDI OUT port selection (stores output.id). null => send to all outputs
                        this.outputPortMap = { strum1:null, strum2:null, chord:null, arp:null, bass:null, bells:null, drum:null, default:null };
                        this.currentProgram = 0;
                        // Load saved MIDI settings on initialization
                        this.loadMIDISettings();
                    }
                    // Save MIDI settings to localStorage
                    saveMIDISettings() {
                        try {
                            const settings = {
                                inputChannelMap: this.inputChannelMap,
                                outputPortMap: this.outputPortMap,
                                perSourceOctave: this.perSourceOctave,
                                perSourceVelocity: this.perSourceVelocity,
                                octaveOffset: this.octaveOffset,
                                defaultVelocity: this.defaultVelocity
                            };
                            localStorage.setItem('xenmicord_midi_settings', JSON.stringify(settings));
                            console.log('ðŸŽ›ï¸ MIDI settings saved to localStorage');
                        } catch (e) {
                            console.warn('Failed to save MIDI settings:', e);
                        }
                    }
                    // Load MIDI settings from localStorage
                    loadMIDISettings() {
                        try {
                            const saved = localStorage.getItem('xenmicord_midi_settings');
                            if (saved) {
                                const settings = JSON.parse(saved);
                                if (settings.inputChannelMap) this.inputChannelMap = { ...this.inputChannelMap, ...settings.inputChannelMap };
                                if (settings.outputPortMap) this.outputPortMap = { ...this.outputPortMap, ...settings.outputPortMap };
                                if (settings.perSourceOctave) this.perSourceOctave = { ...this.perSourceOctave, ...settings.perSourceOctave };
                                if (settings.perSourceVelocity) this.perSourceVelocity = { ...this.perSourceVelocity, ...settings.perSourceVelocity };
                                if (typeof settings.octaveOffset === 'number') this.octaveOffset = settings.octaveOffset;
                                if (typeof settings.defaultVelocity === 'number') this.defaultVelocity = settings.defaultVelocity;
                                console.log('ðŸŽ›ï¸ MIDI settings loaded from localStorage');
                                // Apply loaded settings to UI elements
                                this.applySettingsToUI();
                            }
                        } catch (e) {
                            console.warn('Failed to load MIDI settings:', e);
                        }
                    }
                    // Apply loaded settings to UI elements
                    applySettingsToUI() {
                        try {
                            const sections = ['strum1','strum2','chord','arp','bass','bells','drum'];
                            for (const sec of sections) {
                                const inEl = document.getElementById(`midiIn-${sec}`);
                                const outEl = document.getElementById(`midiOut-${sec}`);
                                const octEl = document.getElementById(`midiOct-${sec}`);
                                const velEl = document.getElementById(`midiVel-${sec}`);
                                if (inEl && this.inputChannelMap[sec] !== undefined) inEl.value = String(this.inputChannelMap[sec]);
                                else if (inEl) inEl.value = '1'; // Default to channel 1
                                if (outEl && this.outputPortMap[sec] !== undefined) outEl.value = String(this.outputPortMap[sec] || '');
                                if (octEl && this.perSourceOctave[sec] !== undefined) octEl.value = String(this.perSourceOctave[sec]);
                                if (velEl && this.perSourceVelocity[sec] !== undefined) velEl.value = String(this.perSourceVelocity[sec]);
                            }
                            // Apply octave offset if element exists
                            const octOffsetEl = document.getElementById('midiOctaveOffset');
                            if (octOffsetEl) octOffsetEl.value = String(this.octaveOffset);
                            // Populate ALL MIDI OUT selects (including cloned pattern/drum/JAM windows)
                            try { this.populateAllOutputSelects(); } catch(_) {}
                        } catch (e) {
                            console.warn('Failed to apply MIDI settings to UI:', e);
                        }
                    }
                    async init() {
                        if (!('requestMIDIAccess' in navigator)) {
                            console.warn('Web MIDI not supported in this browser');
                            return false;
                        }
                        try {
                            this.midiAccess = await navigator.requestMIDIAccess({ sysex:false });
                        } catch (e) {
                            console.warn('Web MIDI access denied:', e);
                            return false;
                        }
                        this.refreshPorts();
                        this.midiAccess.onstatechange = () => this.refreshPorts();
                        this.enabled = true;
                        return true;
                    }
                    refreshPorts() {
                        this.inputs.clear();
                        this.outputs.clear();
                        if (!this.midiAccess) return;
                        try {
                            for (const input of this.midiAccess.inputs.values()) {
                                this.inputs.set(input.id, input);
                                input.onmidimessage = (ev)=>this._handleMIDIMessage(ev);
                            }
                            for (const output of this.midiAccess.outputs.values()) {
                                this.outputs.set(output.id, output);
                            }
                        } catch(e){ console.warn('Enumerating MIDI ports failed', e); }
                        try {
                            const inNames = Array.from(this.inputs.values()).map(p=>p.name||p.id);
                            const outNames = Array.from(this.outputs.values()).map(p=>p.name||p.id);
                            const loopIn = inNames.filter(n=>/loopmidi/i.test(String(n)));
                            const loopOut = outNames.filter(n=>/loopmidi/i.test(String(n)));
                            console.log(`[MIDI] Inputs(${this.inputs.size}): ${inNames.join(', ')}`);
                            console.log(`[MIDI] Outputs(${this.outputs.size}): ${outNames.join(', ')}`);
                            if (!loopIn.length && !loopOut.length) {
                                console.warn('[MIDI] No loopMIDI ports detected (case-insensitive search).');
                            } else {
                                console.log(`[MIDI] loopMIDI detected -> In:[${loopIn.join(', ')}] Out:[${loopOut.join(', ')}]`);
                                try {
                                    // Auto-map first loopMIDI OUT to all sections if nothing chosen yet
                                    const haveAnyMapping = Object.values(this.outputPortMap||{}).some(v=>!!v);
                                    if (!haveAnyMapping && loopOut.length) {
                                        const loopId = (()=>{
                                            // Find actual output id corresponding to first detected loopMIDI name
                                            const wanted = loopOut[0];
                                            for (const o of this.outputs.values()) {
                                                const nm = o.name || o.id || '';
                                                if (nm === wanted) return o.id; // exact match
                                            }
                                            // Fallback: first output whose name matches /loopmidi/i
                                            for (const o of this.outputs.values()) {
                                                const nm = o.name || o.id || '';
                                                if (/loopmidi/i.test(nm)) return o.id;
                                            }
                                            return null;
                                        })();
                                        if (loopId) {
                                            ['strum1','strum2','chord','arp','bass','bells','drum','default'].forEach(sec=>{ this.outputPortMap[sec] = loopId; });
                                            console.log(`[MIDI] Auto-mapped loopMIDI port '${loopOut[0]}' (id=${loopId}) to all sections.`);
                                        }
                                    }
                                } catch(e){ console.warn('MIDI auto-map error', e); }
                            }
                        } catch(e){ console.warn('MIDI logging error', e); }
                        try {
                            ['strum1','strum2','chord','arp','bass','bells','drum'].forEach(sec=>{
                                const el = document.getElementById(`midiOut-${sec}`);
                                if (el && el.tagName === 'SELECT') {
                                    this.populateOutputSelect(el);
                                    try {
                                        const sel = this.outputPortMap?.[sec] ?? this.outputPortMap?.default ?? '';
                                        if (sel && Array.from(el.options).some(op=>op.value===sel)) el.value = sel;
                                    } catch(_) {}
                                }
                            });
                        } catch(_){}
                        // Also refresh any cloned or popup MIDI OUT selects
                        try { this.populateAllOutputSelects(); } catch(_){ }
                    }
                    onInput(cb){ this.inputHandler = cb; }
                    // If outputTarget provided (string id or WebMIDIOutput), send only to that port; otherwise broadcast to all outputs
                    sendRaw(data, timestamp=0, channel=1, outputTarget=null) {
                        if (!this.enabled || this.outputs.size === 0) return;
                        const status = data[0];
                        const isChanMsg = (status & 0xF0) >= 0x80 && (status & 0xF0) <= 0xE0;
                        const msg = isChanMsg ? [ (status & 0xF0) | ((channel-1) & 0x0F), data[1] ?? 0, data[2] ?? 0 ] : data;
                        const sendTo = (out)=>{ try { out && out.send(msg, timestamp || undefined); } catch(_) {} };
                        if (outputTarget) {
                            const out = (typeof outputTarget === 'string') ? this.outputs.get(outputTarget) : outputTarget;
                            sendTo(out);
                        } else {
                            for (const out of this.outputs.values()) sendTo(out);
                        }
                    }
                    getOutputsArray(){ try { return Array.from(this.outputs.values()); } catch(_) { return []; } }
                    populateOutputSelect(selectEl){
                        try {
                            if (!selectEl) return;
                            const arr = this.getOutputsArray();
                            const prev = selectEl.value || '';
                            while (selectEl.firstChild) selectEl.removeChild(selectEl.firstChild);
                            const optAll = document.createElement('option');
                            optAll.value = '';
                            optAll.textContent = '(All Outputs)';
                            selectEl.appendChild(optAll);
                            arr.forEach(o=>{
                                const opt = document.createElement('option');
                                opt.value = o.id;
                                opt.textContent = o.name || o.id || 'MIDI Out';
                                selectEl.appendChild(opt);
                            });
                            if (prev && Array.from(selectEl.options).some(op=>op.value===prev)) selectEl.value = prev;
                        } catch(_) {}
                    }
                    populateAllOutputSelects(){
                        const self = this;
                        const applySelect = (sel)=>{
                            try {
                                if (!sel || sel.tagName !== 'SELECT') return;
                                self.populateOutputSelect(sel);
                                const id = String(sel.id || '');
                                const m = id.match(/^midiOut-(.+)$/);
                                const key = m ? m[1] : null;
                                const desired = (key && self.outputPortMap && self.outputPortMap[key] != null)
                                    ? self.outputPortMap[key]
                                    : (self.outputPortMap?.default ?? '');
                                if (desired != null && desired !== '') {
                                    const val = String(desired);
                                    if (Array.from(sel.options).some(op=>op.value===val)) sel.value = val;
                                }
                            } catch(_){ }
                        };
                        try {
                            document.querySelectorAll('select[id^="midiOut-"]').forEach(applySelect);
                        } catch(_){ }
                        try {
                            const bellWin = window.omnichord?._bellsWin;
                            if (bellWin && !bellWin.closed && bellWin.document) {
                                bellWin.document.querySelectorAll('select[id^="midiOut-"]').forEach(applySelect);
                            }
                        } catch(_){ }
                    }
                    _portIdFromOutput(output){
                        try {
                            if (!output) return '*';
                            if (typeof output === 'string') return output;
                            return output.id || output.name || '*';
                        } catch(_) { return '*'; }
                    }
                    outputForSource(src){
                        try {
                            const sel = (this.outputPortMap && (this.outputPortMap[src] ?? this.outputPortMap.default)) || null;
                            if (!sel) return null;
                            if (typeof sel === 'string') return this.outputs.get(sel) ? sel : null;
                            // If stored as index (1-based), map to current outputs list
                            const arr = this.getOutputsArray();
                            if (Number.isFinite(sel)) {
                                const idx = Math.max(1, Math.min(arr.length, (sel|0)));
                                return arr[idx-1]?.id || null;
                            }
                            return null;
                        } catch(_) { return null; }
                    }
                    // Normalize note and channel so that final MIDI note stays within 0..127.
                    // If note overflows >127 (or <0), subtract/add EDO steps and move to adjacent channels.
                    // Assumes receiving instrument tunes adjacent channels in octave steps for current EDO.
                    normalizeNoteChannel(note, channel){
                        try {
                            const edo = (window?.omnichord?.currentTuning|0) || 12;
                            // Global MIDI octave offset uses 12 semitones per octave
                            let n = (note|0) + ((this.octaveOffset|0) * 12);
                            let ch = channel|0;
                            if (!Number.isFinite(n) || !Number.isFinite(ch) || edo <= 0) {
                                return { note: Math.max(0, Math.min(127, n|0)), channel: Math.min(16, Math.max(1, ch||1)) };
                            }
                            // Shift up while above 127 by subtracting one EDO octave per extra channel
                            while (n > 127 && edo > 0) { n -= edo; ch += 1; }
                            // Shift down while below 0 by adding one EDO octave per previous channel
                            while (n < 0 && edo > 0) { n += edo; ch -= 1; }
                            // Wrap channel into 1..16 to stay valid
                            if (ch < 1) ch = ((ch % 16) + 16);
                            if (ch > 16) ch = ((ch - 1) % 16) + 1;
                            // Final clamp for safety
                            n = Math.max(0, Math.min(127, n|0));
                            ch = Math.min(16, Math.max(1, ch|0));
                            return { note: n, channel: ch };
                        } catch(_) {
                            return { note: Math.max(0, Math.min(127, note|0)), channel: Math.min(16, Math.max(1, channel||1)) };
                        }
                    }
                    sendNoteOn(note, velocity=100, channel=1, outputTarget=null) {
                        // Panic mute: silence immediately but keep playback/clock running.
                        if (this._panicMuted) return;
                        const norm = this.normalizeNoteChannel(note, channel);
                        const n = norm.note;
                        channel = norm.channel;
                        let vRaw = Number.isFinite(velocity) ? velocity : this.defaultVelocity;
                        
                        // Apply master volume scaling to MIDI velocity if available
                        if (typeof this._masterVolumeScale === 'number') {
                            vRaw = vRaw * this._masterVolumeScale;
                        }
                        
                        const v = Math.max(1, Math.min(127, Math.round(vRaw)));
                        this.sendRaw([0x90, n & 0x7F, v], 0, channel, outputTarget);
                        const pId = this._portIdFromOutput(outputTarget);
                        this.noteState.set(`${n}@${channel}@${pId}`, { ts: performance.now() });
                    }
                    sendNoteOff(note, channel=1, outputTarget=null) {
                        const norm = this.normalizeNoteChannel(note, channel);
                        const n = norm.note;
                        channel = norm.channel;
                        this.sendRaw([0x80, n & 0x7F, 0], 0, channel, outputTarget);
                        const pId = this._portIdFromOutput(outputTarget);
                        this.noteState.delete(`${n}@${channel}@${pId}`);
                    }
                    sendProgramChange(program=0, channel=1) {
                        const p = Math.max(0, Math.min(127, Math.round(program)));
                        this.sendRaw([0xC0, p & 0x7F, 0], 0, channel);
                    }
                    sendCC(cc, value, channel=1) {
                        const v = Math.max(0, Math.min(127, Math.round(value)));
                        this.sendRaw([0xB0, cc & 0x7F, v], 0, channel);
                    }
                    sendPitchBend(value=0, channel=1, outputTarget=null) {
                        // value in range -1..1
                        const v = Math.max(-1, Math.min(1, Number(value) || 0));
                        const val14 = Math.round((v + 1) * 8191.5); // 0..16383
                        const lsb = val14 & 0x7F;
                        const msb = (val14 >> 7) & 0x7F;
                        this.sendRaw([0xE0, lsb, msb], 0, channel, outputTarget);
                    }
                    setPitchBendRange(semitones=2, channel=1){
                        const s = Math.max(0, Math.min(24, Math.round(Number(semitones)||0)));
                        this.selectRPN(0,0,channel); this.dataEntry(s, 0, channel); this.rpnNull(channel);
                    }
                    // RPN helpers for tuning
                    selectRPN(msb, lsb, channel=1){ this.sendCC(101, msb & 0x7F, channel); this.sendCC(100, lsb & 0x7F, channel); }
                    rpnNull(channel=1){ this.sendCC(101, 127, channel); this.sendCC(100, 127, channel); }
                    dataEntry(msb, lsb=null, channel=1){ this.sendCC(6, msb & 0x7F, channel); if (lsb!=null) this.sendCC(38, lsb & 0x7F, channel); }
                    setFineTune(cents=0, channel=1){
                        const v = Math.max(-100, Math.min(100, Number(cents)||0));
                        const val14 = Math.round((v/100) * 8192) + 8192; // 0..16383
                        const msb = (val14 >> 7) & 0x7F; const lsb = val14 & 0x7F;
                        this.selectRPN(0,1,channel); this.dataEntry(msb, lsb, channel); this.rpnNull(channel);
                    }
                    setCoarseTune(semitones=0, channel=1){
                        const s = Math.max(-64, Math.min(63, Math.round(Number(semitones)||0)));
                        const msb = 64 + s; // 0..127, 64=0
                        this.selectRPN(0,2,channel); this.dataEntry(msb, null, channel); this.rpnNull(channel);
                    }
                    allNotesOff() {
                        // Send All Notes Off (CC123) on all 16 channels (do not cut sounds)
                        for (let ch = 1; ch <= 16; ch++) {
                            this.sendCC(123, 0, ch);
                        }
                        // Clear local note state and deferred offs
                        this.noteState.clear();
                        this.deferredOff.clear();
                    }
                    markActivity() {
                        if (this._idleTimer) clearTimeout(this._idleTimer);
                        this._idleTimer = setTimeout(()=>{
                            // Do not panic while sustain held; re-arm timer instead
                            if (this.sustain) { this.markActivity(); return; }
                            try {
                                this.allNotesOff();
                            } catch(_) {}
                        }, this._idleMs);
                    }
                    _handleMIDIMessage(ev){
                        const [status, d1=0, d2=0] = ev.data || [];
                        const type = status & 0xF0; const ch = (status & 0x0F) + 1;
                        const payload = { status, type, channel: ch, data1: d1, data2: d2, timeStamp: ev.timeStamp };
                        // Suppress immediate MIDI echo from our own recently-sent notes (loopMIDI feedback, etc.)
                        try {
                            if (type === 0x90 || type === 0x80) { // Note On/Off
                                const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                                const ECHO_MS = 50;
                                let isEcho = false;
                                for (const [key, info] of this.noteState.entries()) {
                                    if (!info || typeof info.ts !== 'number') continue;
                                    const parts = String(key).split('@');
                                    const n = parseInt(parts[0]||'0', 10);
                                    const chKey = parseInt(parts[1]||'0', 10);
                                    if (n === d1 && chKey === ch) {
                                        const dt = now - info.ts;
                                        if (dt >= 0 && dt <= ECHO_MS) { isEcho = true; break; }
                                    }
                                }
                                if (isEcho) return; // treat as self-feedback; ignore for input routing
                            }
                        } catch(_) {}
                        // Basic per-section input filtering: if any section specifies a non-omni channel
                        // and the message channel doesn't match any, drop it from inputHandler.
                        try {
                            const ins = this.inputChannelMap || {};
                            const filters = Object.values(ins).filter(v => Number.isFinite(v) && v>0 && v<=16);
                            let pass = true;
                            if (filters.length>0){ pass = filters.includes(ch); }
                            if (this.inputHandler && pass) this.inputHandler(payload);
                        } catch(_){ if (this.inputHandler) try { this.inputHandler(payload); } catch(_) {}
                        }
                        this.markActivity();
                    }
                }

                const midi = new WebMIDIManager();
                window.midi = midi;

                // Prevent duplicate initialization during session import or re-entrant UI wiring
                if (!window._xenMidiInitGuard) window._xenMidiInitGuard = { prompted:false };

                // Wire MIDI toggle button
                const midiBtn = document.getElementById('midiToggle');
                if (midiBtn && !midiBtn._wired) {
                    midiBtn._wired = true;
                    midiBtn.addEventListener('click', async ()=>{
                        if (!midi.enabled) {
                            // Skip if already initializing to avoid double errors
                            if (midi._initializing) return;
                            midi._initializing = true;
                            const ok = await midi.init();
                            midi._initializing = false;
                            if (ok) {
                                // Detect loopMIDI outputs with short retry window (async enumeration may lag)
                                let hasLoop = false; let firstLoopId = null; let firstLoopName = null; let attempts = 0;
                                for (; attempts < 8; attempts++) { // up to ~8*75ms = 600ms
                                    try {
                                        const outsArr = Array.from(midi.outputs.values());
                                        for (const o of outsArr) {
                                            const nm = String(o.name||o.id||'');
                                            if (/loopmidi/i.test(nm)) { hasLoop = true; if (!firstLoopId){ firstLoopId = o.id; firstLoopName = nm; } }
                                        }
                                        if (hasLoop || outsArr.length > 0) break;
                                    } catch(_) {}
                                    await new Promise(r=>setTimeout(r,75));
                                }
                                // Extra deferred pass (after a microdelay) in case drivers enumerate slower
                                if (!hasLoop && midi.outputs.size === 0) {
                                    await new Promise(r=>setTimeout(r,300));
                                    try {
                                        for (const o of midi.outputs.values()) {
                                            const nm = String(o.name||o.id||'');
                                            if (/loopmidi/i.test(nm)) { hasLoop = true; if (!firstLoopId){ firstLoopId = o.id; firstLoopName = nm; } }
                                        }
                                    } catch(_) {}
                                }
                                if (!hasLoop) {
                                    // If there are zero outputs after retries, check UI for visible outputs; suppress prompt if any outputs appear in UI
                                    const outsCount = midi.outputs.size;
                                    if (outsCount === 0) {
                                        // Double-check UI selects: if any select already populated, treat as outputs visible
                                        let uiVisible = false;
                                        try {
                                            const selIds = ['midiOutputSelect','midiStrumOutput','midiChordOutput','midiArpOutput','midiBassOutput','midiDrumOutput'];
                                            for (const id of selIds) {
                                                const el = document.getElementById(id);
                                                if (el && el.options && el.options.length > 0) { uiVisible = true; break; }
                                            }
                                        } catch(_) {}
                                        if (!uiVisible) {
                                            if (!window._xenMidiInitGuard.prompted) {
                                                window._xenMidiInitGuard.prompted = true;
                                                const msg = 'No MIDI outputs detected yet. If you intend to route to other software, you can install loopMIDI:\nhttps://www.tobias-erichsen.de/software/loopmidi.html';
                                                // Use non-blocking alert style (no redirect) to avoid annoyance; user can still continue once devices appear
                                                try { window.alert(msg); } catch(_) {}
                                            }
                                            // Keep enabled; devices might appear slightly later (hotâ€‘plug)
                                        }
                                    } else {
                                        // Proceed silently; any output counts (hardware or loopback)
                                        try {
                                            if (!firstLoopId) {
                                                const first = Array.from(midi.outputs.values())[0];
                                                if (first) { firstLoopId = first.id; firstLoopName = first.name || first.id; }
                                            }
                                        } catch(_) {}
                                    }
                                    // At this point we do NOT disable MIDI merely for missing loopMIDI; user has some outputs or may have them appear soon.
                                }
                                midiBtn.classList.add('active');
                                try {
                                    // Auto-map first loopMIDI port to all sections if none chosen yet
                                    const haveAnyMapping = Object.values(midi.outputPortMap||{}).some(v=>!!v);
                                    if (!haveAnyMapping && firstLoopId) {
                                        ['strum1','strum2','chord','arp','bass','bells','drum','default'].forEach(sec=>{ midi.outputPortMap[sec] = firstLoopId; });
                                        console.log(`[MIDI] Auto-mapped loopMIDI port '${firstLoopName}' (id=${firstLoopId}) to all sections (toggle).`);
                                    }
                                } catch(_){ }
                                // Mute internal oscillators & drums by reducing masterVolume but remember prior
                                try {
                                    const oc = window.omnichord;
                                    if (oc) {
                                        if (oc._preMidiMasterVolume === undefined) oc._preMidiMasterVolume = oc.masterVolume;
                                        // Set a very low master volume (not zero to keep envelopes functional visually)
                                        oc.masterVolume = 0.0001;
                                        if (oc.gainNode) oc.gainNode.gain.value = oc.volume * oc.masterVolume;
                                        if (oc.dryGainNode) oc.dryGainNode.gain.value = oc.masterVolume;
                                        if (oc.reverbOutGain) oc.reverbOutGain.gain.value = oc.masterVolume;
                                    }
                                } catch(_){ }
                                try { midi.applySettingsToUI(); } catch(_){ }
                                // Light indicator if present
                                try {
                                    const led = document.getElementById('midiStatusLed');
                                    if (led) { led.classList.add('on'); led.title = 'MIDI Enabled'; }
                                } catch(_) {}
                            }
                        } else {
                            midi.enabled = false; midiBtn.classList.remove('active');
                            
                            // Disconnect all MIDI input handlers
                            try {
                                if (midi.inputs) {
                                    for (const input of midi.inputs.values()) {
                                        input.onmidimessage = null;
                                    }
                                }
                            } catch(_) {}
                            
                            // Clear MIDI input handler
                            try {
                                if (midi.inputHandler) {
                                    midi.inputHandler = null;
                                }
                            } catch(_) {}
                            
                            try {
                                // When MIDI is off, restore MASTER so all oscillators are heard
                                const oc = window.omnichord;
                                if (oc) {
                                    // Disable MIDI bypass to return to oscillator mode
                                    oc.midiBypassOscillators = false;
                                    
                                    const restore = (typeof oc._preMidiMasterVolume === 'number') ? oc._preMidiMasterVolume : oc.masterVolume;
                                    oc.masterVolume = restore;
                                    if (oc.gainNode) oc.gainNode.gain.value = oc.volume * oc.masterVolume;
                                    if (oc.dryGainNode) oc.dryGainNode.gain.value = oc.masterVolume;
                                    if (oc.reverbOutGain) oc.reverbOutGain.gain.value = oc.masterVolume;
                                    // Clear the pre-MIDI backup so volume controls work normally
                                    delete oc._preMidiMasterVolume;
                                }
                                // Clear MIDI volume scaling
                                if (midi) {
                                    delete midi._masterVolumeScale;
                                }
                            } catch(_) {}
                                try {
                                    const led = document.getElementById('midiStatusLed');
                                    if (led) { led.classList.remove('on'); led.title = 'MIDI Disabled'; }
                                } catch(_) {}
                        }
                        midi.markActivity();
                    });
                }
                // Program change UI removed per request

                // Helper: map internal frequency to MIDI note based on current EDO steps
                // Anchor: C4 = MIDI 60. Each EDO step => +1 MIDI note.
                function freqToMidiNote(freq){
                    try {
                        const oc = window.omnichord;
                        const tuning = oc?.currentTuning || 12;
                        // C in current tuning (semitone 0 -> step in EDO), octave 4
                        const cStep = typeof oc?.semitoneToStep === 'function' ? oc.semitoneToStep(0, tuning) : 0;
                        const c4 = typeof oc?.getFrequency === 'function' ? oc.getFrequency(cStep, 4, tuning) : 261.6256; // fallback C4
                        const stepDiff = Math.round(tuning * Math.log2(freq / c4));
                        const midi = 60 + stepDiff; // C4 anchor, 1 step per EDO unit
                        return midi; // do not clamp here; allow overflow handling later
                    } catch(_) {
                        // Fallback to A440 mapping if anything goes wrong
                        const n = 69 + 12 * Math.log2(freq / 440);
                        return Math.round(n);
                    }
                }
                function channelForSource(src){ return midi.channelMap[src] || midi.channelMap.default; }

                // Hook play/stop to mirror MIDI out with minimal intrusion
                const _playFrequency = omnichord.playFrequency.bind(omnichord);
                omnichord.playFrequency = async function(frequency, element, sourceType='default', velocityOverride=null){
                    // Send MIDI Note On first to avoid race with quick releases
                    try {
                        if (midi.enabled) {
                            const note = freqToMidiNote(frequency);
                            let targets = (sourceType === 'strum') ? ['strum1','strum2'] : [sourceType];
                            if (sourceType === 'default') {
                                // Mirror to all five primary sections so oscillators still fire independently
                                targets = ['strum1','strum2','chord','arp','bass'];
                            }
                            const velInput = document.getElementById('midiDefaultVelocity');
                            const vGlobal = velInput ? Math.max(1, Math.min(127, parseInt(velInput.value||'100',10))) : 100;
                            midi.defaultVelocity = vGlobal;
                            const octSel = document.getElementById('midiOctaveOffset');
                            midi.octaveOffset = octSel ? (parseInt(octSel.value||'0',10) || 0) : 0;
                            // Helper to derive decay ms per target instrument
                            const decayMsFor = (t) => {
                                try {
                                    const ins = omnichord.instruments || {};
                                    if (t === 'strum1') return Math.max(0, Math.round(((ins.strum1?.env?.decay) ?? omnichord.envelope?.decay ?? 0.2) * 1000));
                                    if (t === 'strum2') return Math.max(0, Math.round(((ins.strum2?.env?.decay) ?? omnichord.osc2Envelope?.decay ?? 0.05) * 1000));
                                    if (t === 'chord')  return Math.max(0, Math.round(((ins.chord?.env?.decay)  ?? 0.2) * 1000));
                                    if (t === 'arp')    return Math.max(0, Math.round(((ins.arp?.env?.decay)    ?? 0.2) * 1000));
                                    if (t === 'bass')   return Math.max(0, Math.round(((ins.bass?.env?.decay)   ?? 0.08) * 1000));
                                    if (t === 'bells')  return Math.max(0, Math.round(((ins.bells?.env?.decay)  ?? 0.25) * 1000));
                                    return 200;
                                } catch(_) { return 200; }
                            };
                            for (const tgt of targets) {
                                const chBase = channelForSource(tgt);
                                const perOct = (midi.perSourceOctave && Number.isFinite(midi.perSourceOctave[tgt])) ? (midi.perSourceOctave[tgt]|0) : 0;
                                const stepsPerOct = (window?.omnichord?.currentTuning|0) || 12;
                                const effNote = note + (perOct * stepsPerOct);
                                const norm = midi.normalizeNoteChannel(effNote, chBase);
                                const nNote = norm.note; const nCh = norm.channel;
                                let outSel = midi.outputForSource(tgt);
                                if (tgt === 'bells' && element && element.__midiOutOverride) outSel = element.__midiOutOverride;
                                const key = `${nNote}@${nCh}@${(outSel||'*')}`;
                                if ((tgt === 'strum1' || tgt === 'strum2') && midi.noteState.has(key) && !midi.sustain) {
                                    midi.sendNoteOff(nNote, nCh, outSel);
                                }
                                if (tgt === 'chord' && midi.noteState.has(key) && !midi.sustain) {
                                    midi.sendNoteOff(nNote, nCh, outSel);
                                }
                                const perV = (midi.perSourceVelocity && Number.isFinite(midi.perSourceVelocity[tgt])) ? (midi.perSourceVelocity[tgt]|0) : vGlobal;
                                // Per-note velocity override (pattern/arp steps) wins
                                let noteVel = null;
                                try {
                                    if (velocityOverride != null && Number.isFinite(parseInt(velocityOverride,10))) noteVel = parseInt(velocityOverride,10);
                                    if (noteVel == null && window.getStepVelocity) noteVel = window.getStepVelocity(element);
                                } catch(_) { noteVel = null; }
                                const useV = Math.max(1, Math.min(127, (noteVel == null ? perV : noteVel)));
                                midi.sendNoteOn(nNote, useV, nCh, outSel);
                                // Schedule Note Off based on musical intent per section
                                const epsilonMs = 8;
                                let offDelay = Math.max(10, decayMsFor(tgt)|0);
                                let gateFromElement = null;
                                try {
                                    gateFromElement = (element && Number.isFinite(element.__gateMs)) ? Number(element.__gateMs) : null;
                                    if (gateFromElement && !['chord','bass'].includes(tgt)) {
                                        offDelay = Math.max(10, Math.floor(gateFromElement - epsilonMs));
                                    }
                                } catch(_) { gateFromElement = null; }
                                try {
                                    if ((tgt === 'strum1' || tgt === 'strum2' || tgt === 'bells') && element && Number.isFinite(element.__gateMs)) {
                                        offDelay = Math.max(10, Math.floor(element.__gateMs));
                                    }
                                } catch(_) {}
                                try {
                                    if (tgt === 'chord') {
                                        // Align CHORD MIDI note-off to the next DRUM bar boundary for tight chord changes
                                        let useOff = null;
                                        const tp = omnichord._arpTransport;
                                        if (tp && tp.running && Number.isFinite(tp.tickMs) && Number.isFinite(tp.ticksPerBar)) {
                                            const cur = (tp.tickCounter|0) % (tp.ticksPerBar||1);
                                            const remTicks = ((tp.ticksPerBar||1) - cur) % (tp.ticksPerBar||1);
                                            const untilMs = Math.max(1, Math.floor((remTicks || (tp.ticksPerBar||1)) * tp.tickMs - epsilonMs));
                                            useOff = untilMs;
                                        }
                                        if (useOff == null) {
                                            // Fallback to HOLD-based duration if transport info unavailable
                                            const bpmEl = document.getElementById('universalBpm');
                                            const bpm = bpmEl ? (parseFloat(bpmEl.value)||120) : (omnichord._arpTransport?.bpm || 120);
                                            const beatMs = 60000 / Math.max(1, bpm);
                                            // Respect LEN override if present (len16 -> barMs = len16 * (beatMs/4))
                                            const len16 = (omnichord._arpTransport?._len16PerBar|0) || 0;
                                            const barMs = (len16>0) ? Math.floor(len16 * (beatMs/4)) : (()=>{
                                                const tsEl = document.getElementById('timeSignatureSelect');
                                                const timeSignature = tsEl ? tsEl.value : (omnichord._arpTransport?.timeSignature || '4/4');
                                                const [beatsPerBar] = String(timeSignature).split('/').map(Number);
                                                return Math.floor(beatMs * (beatsPerBar || 4));
                                            })();
                                            const holdSel = document.getElementById('universalHold') || document.getElementById('chordHold');
                                            const holdVal = holdSel ? String(holdSel.value||'bar:1') : 'bar:1';
                                            const [kind, valStr] = holdVal.split(':');
                                            const n = Math.max(1, parseInt(valStr||'1',10));
                                            const holdMs = (kind === 'beat') ? n*beatMs : n*barMs;
                                            useOff = Math.max(10, Math.floor(holdMs - epsilonMs));
                                        }
                                        offDelay = Math.max(10, useOff|0);
                                    } else if (tgt === 'arp') {
                                        // QUANT-based duration for ARP (e.g., 1/8 note)
                                        // BUT if omnichord has a stored gate duration for this note (from pill metadata), use that instead
                                        const elGateMs = gateFromElement != null ? gateFromElement : ((element && Number.isFinite(element.__gateMs)) ? element.__gateMs : null);
                                        if (elGateMs && elGateMs > 0) {
                                            offDelay = Math.max(10, Math.floor(elGateMs - epsilonMs));
                                        } else if (omnichord._lastArpGateMs && Number.isFinite(omnichord._lastArpGateMs) && omnichord._lastArpGateMs > 0) {
                                            offDelay = Math.max(10, Math.floor(omnichord._lastArpGateMs - epsilonMs));
                                        } else {
                                            try { if (typeof omnichord._ensureArpTransport === 'function') omnichord._ensureArpTransport(); } catch(_) {}
                                            let quantMs = omnichord._arpTransport?.tickMs;
                                            if (!quantMs || !Number.isFinite(quantMs)) {
                                                const quantEl = document.getElementById('universalQuant');
                                                const bpmEl = document.getElementById('universalBpm');
                                                const bpm = bpmEl ? (parseFloat(bpmEl.value)||120) : (omnichord._arpTransport?.bpm || 120);
                                                const q = quantEl?.value || omnichord._arpTransport?.quant || '1/16';
                                                if (typeof omnichord._parseQuantToMs === 'function') {
                                                    quantMs = omnichord._parseQuantToMs(q, bpm);
                                                } else {
                                                    const beatMs = 60000 / Math.max(1, bpm);
                                                    const base = String(q).replace('T','');
                                                    const map = { '1/1':1, '1/2':2, '1/4':4, '1/8':8, '1/16':16, '1/32':32 };
                                                    const div = map[base] || 8;
                                                    quantMs = beatMs * (4/div);
                                                    if (String(q).endsWith('T')) quantMs *= 2/3;
                                                }
                                            }
                                            offDelay = Math.max(10, Math.floor(quantMs - epsilonMs));
                                        }
                                    } else if (tgt === 'bass') {
                                        // Match CHORD behavior: HOLD-based duration for BASS
                                        const bpmEl = document.getElementById('universalBpm');
                                        const bpm = bpmEl ? (parseFloat(bpmEl.value)||120) : (omnichord._arpTransport?.bpm || 120);
                                        const beatMs = 60000 / Math.max(1, bpm);
                                        const tsEl = document.getElementById('timeSignatureSelect');
                                        const timeSignature = tsEl ? tsEl.value : (omnichord._arpTransport?.timeSignature || '4/4');
                                        const [beatsPerBar] = String(timeSignature).split('/').map(Number);
                                        const barMs = beatMs * (beatsPerBar || 4);
                                        const holdSel = document.getElementById('universalHold') || document.getElementById('chordHold');
                                        const holdVal = holdSel ? String(holdSel.value||'bar:1') : 'bar:1';
                                        const [kind, valStr] = holdVal.split(':');
                                        const n = Math.max(1, parseInt(valStr||'1',10));
                                        const holdMs = (kind === 'beat') ? n*beatMs : n*barMs;
                                        offDelay = Math.max(10, Math.floor(holdMs - epsilonMs));
                                    }
                                } catch(_) {}
                                setTimeout(()=>{
                                    try {
                                        if (!midi.enabled) return;
                                        midi.sendNoteOff(nNote, nCh, outSel);
                                    } catch(_) {}
                                }, offDelay);
                            }
                        }
                    } catch(_) {}
                    // Clear the stored gate duration so it doesn't affect subsequent notes
                    try { omnichord._lastArpGateMs = null; } catch(_) {}
                    await _playFrequency(frequency, element, sourceType, velocityOverride);
                    try { midi.markActivity(); } catch(_) {}
                };

                const _stopFrequency = omnichord.stopFrequency.bind(omnichord);
                omnichord.stopFrequency = function(frequency, element, sourceType='default'){
                    try {
                        if (midi.enabled) {
                            const note = freqToMidiNote(frequency);
                            let targets = (sourceType === 'strum') ? ['strum1','strum2'] : [sourceType];
                            if (sourceType === 'default') {
                                targets = ['strum1','strum2','chord','arp','bass'];
                            }
                            for (const tgt of targets) {
                                // Do not send immediate Note Off for CHORD/ARP/BASS; allow HOLD/QUANT timers to release
                                if (tgt === 'chord' || tgt === 'arp' || tgt === 'bass') continue;
                                const chBase = channelForSource(tgt);
                                const perOct = (midi.perSourceOctave && Number.isFinite(midi.perSourceOctave[tgt])) ? (midi.perSourceOctave[tgt]|0) : 0;
                                const stepsPerOct = (window?.omnichord?.currentTuning|0) || 12;
                                const effNote = note + (perOct * stepsPerOct);
                                const norm = midi.normalizeNoteChannel(effNote, chBase);
                                const nNote = norm.note; const nCh = norm.channel;
                                const outSel = midi.outputForSource(tgt);
                                midi.sendNoteOff(nNote, nCh, outSel);
                            }
                        }
                    } catch(_) {}
                    try { midi.markActivity(); } catch(_) {}
                    return _stopFrequency(frequency, element, sourceType);
                };

                // Map keyboard modifiers to MIDI pedals during playback
                (function(){
                    try {
                        if (window.__midiPedalsHooked) return;
                        window.__midiPedalsHooked = true;
                        const usedChannels = ()=>{
                            const s = new Set(Object.values(midi.channelMap||{}));
                            // Always include default channel
                            s.add(midi.channelMap?.default||5);
                            // Also include any channels currently holding notes (for overflow splitting)
                            try {
                                for (const key of midi.noteState.keys()){
                                    const parts = String(key).split('@');
                                    const ch = parseInt(parts[1]||'0',10);
                                    if (ch>=1 && ch<=16) s.add(ch);
                                }
                            } catch(_){}
                            return Array.from(s);
                        };
                        const sendSustain = (on)=>{ try { for (const ch of usedChannels()) midi.sendCC(64, on?127:0, ch); } catch(_){} };
                        const sendSoft = (on)=>{ try { for (const ch of usedChannels()) midi.sendCC(67, on?127:0, ch); } catch(_){} };
                        const flushDeferred = ()=>{}; // No-op: avoid abrupt kills on pedal release
                        window.addEventListener('keydown', (e)=>{
                            if (!midi.enabled) return;
                            // SHIFT: sustain pedal on (edge only, ignore repeats)
                            if (e.key === 'Shift' && !e.repeat){
                                if (!window.__sustainKeyDown){
                                    window.__sustainKeyDown = true;
                                    midi.sustain = true;
                                    sendSustain(true);
                                }
                            }
                            if (e.key === 'Control' && !window.__softPedalDown){
                                window.__softPedalDown = true; sendSoft(true);
                            }
                            // ALT+C: toggle CHORD/ARP mode
                            if (e.altKey && (e.key === 'c' || e.key === 'C')){
                                try { if (window.omnichord && typeof window.omnichord.toggleChordArpMode === 'function') window.omnichord.toggleChordArpMode(); } catch(_) {}
                                e.preventDefault();
                            }
                            // ALT+B: toggle Bass
                            if (e.altKey && (e.key === 'b' || e.key === 'B')){
                                try { if (window.omnichord && typeof window.omnichord.toggleBassMode === 'function') window.omnichord.toggleBassMode(); } catch(_) {}
                                e.preventDefault();
                            }
                            // ALT +/âˆ’: octave up/down for ARP and CHORD MIDI
                            if (e.altKey && !e.repeat) {
                                const plus  = (e.key === '+' || e.key === '=' || e.code === 'NumpadAdd');
                                const minus = (e.key === '-' || e.key === '_' || e.code === 'NumpadSubtract');
                                if (plus || minus) {
                                    const delta = plus ? 1 : -1;
                                    try {
                                        midi.perSourceOctave = midi.perSourceOctave || {};
                                        midi.perSourceOctave.chord = (midi.perSourceOctave.chord || 0) + delta;
                                        midi.perSourceOctave.arp   = (midi.perSourceOctave.arp   || 0) + delta;
                                        const chordSel = document.getElementById('midiOct-chord');
                                        if (chordSel) {
                                            const newVal = String(Math.max(-3, Math.min(3, parseInt(chordSel.value || '0', 10) + delta)));
                                            chordSel.value = newVal;
                                        }
                                        const arpSel = document.getElementById('midiOct-arp');
                                        if (arpSel) {
                                            const newVal = String(Math.max(-3, Math.min(3, parseInt(arpSel.value || '0', 10) + delta)));
                                            arpSel.value = newVal;
                                        }
                                    } catch(_) {}
                                    e.preventDefault();
                                }
                            }
                            // ArrowUp: ramp mod wheel up while held, LATCH on release (do not auto-reset)
                            if (e.key === 'ArrowUp' && !window.__modWheelRampActive){
                                window.__modWheelRampActive = true;
                                try { if (!window.__modWheelVal) window.__modWheelVal = 0; } catch(_) {}
                                try { if (window.__modWheelTimer) { clearInterval(window.__modWheelTimer); window.__modWheelTimer = null; } } catch(_){ }
                                window.__modWheelTimer = setInterval(()=>{
                                    try {
                                        window.__modWheelVal = Math.min(127, (window.__modWheelVal||0) + 5);
                                        for (const ch of usedChannels()) midi.sendCC(1, window.__modWheelVal, ch);
                                        if (window.__modWheelVal >= 127){
                                            clearInterval(window.__modWheelTimer); window.__modWheelTimer = null;
                                        }
                                    } catch(_) {}
                                }, 40);
                                e.preventDefault();
                            }
                            // ArrowDown: ramp mod wheel back down while held
                            if (e.key === 'ArrowDown' && !window.__modWheelDownActive){
                                window.__modWheelDownActive = true;
                                try { if (window.__modWheelTimer) { clearInterval(window.__modWheelTimer); window.__modWheelTimer = null; } } catch(_){ }
                                window.__modWheelTimer = setInterval(()=>{
                                    try {
                                        window.__modWheelVal = Math.max(0, (window.__modWheelVal||0) - 5);
                                        for (const ch of usedChannels()) midi.sendCC(1, window.__modWheelVal, ch);
                                        if (window.__modWheelVal <= 0){
                                            clearInterval(window.__modWheelTimer); window.__modWheelTimer = null;
                                        }
                                    } catch(_) {}
                                }, 40);
                                e.preventDefault();
                            }
                        }, {passive:true});
                        window.addEventListener('keyup', (e)=>{
                            if (!midi.enabled) return;
                            // SHIFT: sustain pedal off on keyup
                            if (e.key === 'Shift'){
                                if (window.__sustainKeyDown){ window.__sustainKeyDown = false; }
                                if (midi.sustain){ midi.sustain=false; sendSustain(false); }
                            }
                            if (e.key === 'Control' && window.__softPedalDown){
                                window.__softPedalDown = false; sendSoft(false);
                            }
                            // Stop current mod wheel ramp on ArrowUp release, but DO NOT reset value (latch)
                            if (e.key === 'ArrowUp'){
                                try { if (window.__modWheelTimer){ clearInterval(window.__modWheelTimer); window.__modWheelTimer = null; } } catch(_) {}
                                try { window.__modWheelRampActive = false; } catch(_) {}
                                e.preventDefault();
                            }
                            // Stop ramping down on ArrowDown release (value stays wherever it is)
                            if (e.key === 'ArrowDown'){
                                try { if (window.__modWheelTimer){ clearInterval(window.__modWheelTimer); window.__modWheelTimer = null; } } catch(_) {}
                                try { window.__modWheelDownActive = false; } catch(_) {}
                                e.preventDefault();
                            }
                        }, {passive:true});
                        window.addEventListener('blur', ()=>{
                            if (!midi.enabled) return;
                            if (midi.sustain){ midi.sustain=false; sendSustain(false); }
                            if (window.__softPedalDown){ window.__softPedalDown=false; sendSoft(false); }
                        });
                    } catch(_){}
                })();
                // Incoming MIDI â†’ chord selection + mod wheel strum
                const baseNote = 0; // C-2 (MIDI 0)
                const maxSlots = 32; // 32 slots starting at C-2
                let heldChordSlot = null;
                midi.onInput((msg)=>{
                    if (!midi.enabled) return;
                    const { type, data1, data2 } = msg;
                    if (type === 0x90 && data2 > 0) { // Note On
                        const idx = data1 - baseNote; // 0..31
                        if (idx >= 0 && idx < maxSlots) {
                            heldChordSlot = idx;
                            try { omnichord.playChordByIndex(idx); } catch(_) {}
                        }
                    } else if (type === 0x80 || (type === 0x90 && data2 === 0)) { // Note Off
                        const idx = data1 - baseNote;
                        if (idx >= 0 && idx < maxSlots) {
                            heldChordSlot = null;
                            try { omnichord.stopAllActiveNotes(); } catch(_) {}
                        }
                    } else if (type === 0xB0) { // CC
                        if (data1 === 64) { // Sustain pedal
                            midi.sustain = data2 >= 64;
                        } else if (data1 === 1) { // Mod wheel â†’ strum
                            if (heldChordSlot != null) {
                                // Map CC value to a brief strum gesture across current column
                                const columns = document.querySelectorAll('.extension-column');
                                const col = columns[heldChordSlot] || null;
                                if (col) {
                                    const rect = col.getBoundingClientRect();
                                    const y = rect.top + (1 - (data2/127)) * rect.height;
                                    try { omnichord.playChordStrum(col, {name:'MIDI'}, y-8, y+8); } catch(_) {}
                                }
                            }
                        }
                    }
                });
                // Wire per-section MIDI controls (IN/OUT-PORT/OCTAVE/VELOCITY)
                ;(function(){
                    try {
                        const sections = ['strum1','strum2','chord','arp','bass','bells','drum'];
                        for (const sec of sections){
                            const inEl = document.getElementById(`midiIn-${sec}`);
                            const outEl = document.getElementById(`midiOut-${sec}`);
                            const octEl = document.getElementById(`midiOct-${sec}`);
                            const velEl = document.getElementById(`midiVel-${sec}`);
                            if (inEl){ inEl.addEventListener('change', ()=>{ midi.inputChannelMap[sec] = Math.max(0, Math.min(15, parseInt(inEl.value||'0',10)|0)); try { omnichord._ensureArpTransport(); omnichord._arpTransport.deferFlags = Object.assign(omnichord._arpTransport.deferFlags||{}, { midi:true }); const tpBeat=Math.max(1,omnichord._arpTransport.ticksPerBeat||1); const nowAbs=omnichord._arpTransport.absTickCounter|0; omnichord._arpTransport.deferApplyAtAbsTick=(nowAbs+2*tpBeat)>>>0; } catch(_){} midi.saveMIDISettings(); }); }
                            if (outEl){ outEl.addEventListener('change', ()=>{
                                const id = String(outEl.value||'');
                                midi.outputPortMap[sec] = id || null; // empty = all outputs
                                try { omnichord._ensureArpTransport(); omnichord._arpTransport.deferFlags = Object.assign(omnichord._arpTransport.deferFlags||{}, { midi:true }); const tpBeat=Math.max(1,omnichord._arpTransport.ticksPerBeat||1); const nowAbs=omnichord._arpTransport.absTickCounter|0; omnichord._arpTransport.deferApplyAtAbsTick=(nowAbs+2*tpBeat)>>>0; } catch(_){} midi.saveMIDISettings();
                            }); }
                            if (octEl){ octEl.addEventListener('change', ()=>{ midi.perSourceOctave[sec] = Math.max(-3, Math.min(3, parseInt(octEl.value||'0',10)|0)); midi.saveMIDISettings(); }); }
                            if (velEl){ velEl.addEventListener('change', ()=>{ midi.perSourceVelocity[sec] = Math.max(1, Math.min(127, parseInt(velEl.value||'100',10)|0)); midi.saveMIDISettings(); }); }
                            // Initialize from defaults
                            if (inEl) inEl.value = String(midi.inputChannelMap[sec] ?? 1);
                            if (outEl && outEl.tagName === 'SELECT') {
                                // Populate once now
                                try { midi.populateOutputSelect(outEl); } catch(_){}
                                const sel = midi.outputPortMap[sec] || midi.outputPortMap.default || '';
                                outEl.value = sel || '';
                            }
                            if (octEl) octEl.value = String(midi.perSourceOctave[sec] ?? 0);
                            if (velEl) velEl.value = String(midi.perSourceVelocity[sec] ?? midi.defaultVelocity ?? 100);
                        }
                    } catch(_) {}
                })();

                // Keyboard hotkeys for MIDI velocity: [,] down 5, [.] up 5 (apply to ALL sections)
                (function(){
                    try {
                        if (window.__midiVelHotkeys) return; window.__midiVelHotkeys = true;
                        const clamp127 = (n)=> Math.max(1, Math.min(127, n|0));
                        const adjust = (delta)=>{
                            const inp = document.getElementById('midiDefaultVelocity');
                            let base = Number.isFinite(parseInt(inp?.value||'0',10)) ? (parseInt(inp.value,10)) : (midi.defaultVelocity||100);
                            const newDefault = clamp127(base + delta);
                            if (inp) inp.value = String(newDefault);
                            midi.defaultVelocity = newDefault;
                            try {
                                const sections = ['strum1','strum2','chord','arp','bass','bells','drum'];
                                midi.perSourceVelocity = midi.perSourceVelocity || {};
                                for (const sec of sections){
                                    const el = document.getElementById(`midiVel-${sec}`);
                                    // Derive current value: prefer object, else input, else default
                                    let curVal = midi.perSourceVelocity[sec];
                                    if (!Number.isFinite(curVal)) curVal = Number.parseInt(el?.value||'') || newDefault;
                                    const nextVal = clamp127(curVal + delta);
                                    if (el) el.value = String(nextVal);
                                    midi.perSourceVelocity[sec] = nextVal;
                                }
                            } catch(_) {}
                        };
                        window.addEventListener('keydown', (e)=>{
                            if (!midi.enabled) return;
                            if (e.key === ',') { e.preventDefault(); adjust(-5); }
                            else if (e.key === '.') { e.preventDefault(); adjust(+5); }
                        }, {passive:false});
                    } catch(_){}
                })();
            })();

            // Force 24-EDO at startup before any parsing/sequencing occurs
            try {
                if (omnichord && typeof omnichord.updateTuningSystem === 'function') {
                    omnichord.updateTuningSystem(24);
                }
                const edoPanel = document.getElementById('edoDivisions');
                if (edoPanel) edoPanel.value = '24';
                const edoQuick = document.getElementById('edoQuickInput');
                if (edoQuick) edoQuick.value = '24';
            } catch {}

            // Briefly flash the + and SEQUENCE buttons with helper bubbles
            try {
                const plusBtn = document.getElementById('createNewChordBtn');
                const seqBtn = document.getElementById('openTextChordParserBtn');
                if (plusBtn) {
                    plusBtn.classList.add('flash-cta');
                    const bubble = document.createElement('div');
                    bubble.className = 'hint-bubble';
                    bubble.textContent = 'Add Chord';
                    document.body.appendChild(bubble);
                    const rect = plusBtn.getBoundingClientRect();
                    bubble.style.left = `${rect.left + window.scrollX}px`;
                    bubble.style.top = `${rect.top + window.scrollY - 36}px`;
                    setTimeout(()=>{ bubble.remove(); plusBtn.classList.remove('flash-cta'); }, 3500);
                }
                if (seqBtn) {
                    seqBtn.classList.add('flash-cta-alt');
                    const bubble2 = document.createElement('div');
                    bubble2.className = 'hint-bubble';
                    bubble2.textContent = 'Or click here to type a chord sequence';
                    document.body.appendChild(bubble2);
                    const r2 = seqBtn.getBoundingClientRect();
                    bubble2.style.left = `${r2.left + window.scrollX}px`;
                    bubble2.style.top = `${r2.top + window.scrollY - 36}px`;
                    setTimeout(()=>{ bubble2.remove(); seqBtn.classList.remove('flash-cta-alt'); }, 4000);
                }
            } catch {}

            // Wire transport-related UI (metronome, chord-change quant)
            try { if (omnichord && typeof omnichord._wireTransportUI === 'function') omnichord._wireTransportUI(); } catch {}
            // Ensure ARP UI controls are wired
            try {
                if (omnichord && typeof omnichord._wireTransportUI === 'function') {
                    // _wireTransportUI now also wires ARP controls
                }
            } catch {}

            // Add test function for transpose behavior
            omnichord.testTransposeSequence = function() {
                console.log('ðŸŽµ TESTING TRANSPOSE SEQUENCE');
                console.log('Expected: C major â†’ transpose up â†’ Câ†‘Eâ†‘Gâ†‘ â†’ edit notes correctly');
                
                // Helper functions
                const getKeyboardState = () => {
                    const kb = document.querySelector('#rootGrid .piano-keyboard');
                    const litKeys = [];
                    if (kb) {
                        kb.querySelectorAll('[data-step].chord-tone').forEach(el => {
                            litKeys.push({
                                step: parseInt(el.dataset.step),
                                originalStep: parseInt(el.dataset.originalStep || el.dataset.step),
                                label: el.textContent.trim()
                            });
                        });
                    }
                    return litKeys.sort((a, b) => a.step - b.step);
                };
                
                const getChordName = () => {
                    const col = document.querySelector('.extension-column');
                    const nameEl = col?.querySelector('.extension-header .chord-name');
                    return nameEl?.textContent?.trim()?.replace(/^ðŸ”’\s*/, '') || 'Unknown';
                };
                
                const clickKeyByLabel = (label) => {
                    const kb = document.querySelector('#rootGrid .piano-keyboard');
                    const keys = kb.querySelectorAll('[data-step]');
                    for (let key of keys) {
                        if (key.textContent.trim() === label) {
                            console.log(`  Clicking: ${label}`);
                            key.click();
                            return true;
                        }
                    }
                    console.log(`  âŒ Key not found: ${label}`);
                    return false;
                };
                
                const logState = (stepName) => {
                    const state = getKeyboardState();
                    const chordName = getChordName();
                    console.log(`${stepName}:`);
                    console.log(`  Chord: ${chordName}`);
                    console.log(`  Transpose: ${this.transposeDelta}`);
                    console.log(`  Lit keys: ${state.map(k => `${k.label}(${k.step})`).join(', ')}`);
                };
                
                // Set up test environment
                this.currentTuning = 24;
                this.transposeDelta = 0;
                this.generateRootButtons();
                
                setTimeout(() => {
                    logState('1. Initial state');
                    
                    setTimeout(() => {
                        console.log('\n2. Transpose up...');
                        document.querySelector('#transposeUp')?.click();
                        
                        setTimeout(() => {
                            logState('2. After transpose up');
                            console.log('   Expected: Keys should show microtonal notation');
                            
                            setTimeout(() => {
                                console.log('\nâœ… Test setup complete. Now manually test:');
                                console.log('   - Click any key and verify correct chord tones light up');
                                console.log('   - The issue was: clicking F would incorrectly light C#, F#, G#');
                                console.log('   - Now it should light the correct chord tones');
                                
                            }, 100);
                        }, 100);
                    }, 100);
                }, 100);
            };

            // Keyboard logo adjustment no longer needed after rebrand; keep namespace for compatibility
            window.PianoApp = window.PianoApp || {};
            window.PianoApp.adjustKeyboardForLogo = undefined;
            
            // Initialize new features
            omnichord.initTutorial();
            omnichord.initBells();
            try { omnichord.wireEffectsPresetsUI(); } catch {}
            // Wire bottom bar SAVE XEN / LOAD XEN
            (function(){
                const bottomExport = document.getElementById('bottomExportOMGBtn');
                if (bottomExport) bottomExport.addEventListener('click', () => { try { omnichord.exportXenState(); } catch(e){ console.error('Export failed', e);} });
                const bottomImport = document.getElementById('bottomImportOMGBtn');
                if (bottomImport) bottomImport.addEventListener('click', () => {
                    const input = document.getElementById('loadSessionInput');
                    if (input) input.click();
                });
                const fileInput = document.getElementById('loadSessionInput');
                if (fileInput) fileInput.onchange = (e)=> { try { omnichord.importXenState(e); } catch(err){ console.error('Import failed', err); }};
            })();

            // Synchronize HOLD controls (universalHold with chordHold)
            try {
                const universalHold = document.getElementById('universalHold');
                const chordHold = document.getElementById('chordHold');
                if (universalHold && chordHold) {
                    universalHold.addEventListener('change', () => {
                        chordHold.value = universalHold.value;
                    });
                }
            } catch (e) {
                console.error('Error setting up HOLD synchronization:', e);
            }

            // Wire PLAY/STOP toggle button (FORCE bracket-aware logic)
            try {
                console.log('ðŸŽµ DEBUG: Attempting to wire bracket-aware button');
                const playStopToggle = document.getElementById('playStopToggleBtn');
                const loopCheckbox = document.getElementById('loopToggle') || document.getElementById('playLoop');
                console.log('ðŸŽµ DEBUG: Found button:', playStopToggle);
                if (playStopToggle) {
                    // Force re-wire to ensure bracket-aware logic takes precedence
                    playStopToggle._wired = true; // Mark as wired to prevent other handlers
                    
                    // Remove any existing click listeners and add our bracket-aware one
                    playStopToggle.replaceWith(playStopToggle.cloneNode(true));
                    const freshButton = document.getElementById('playStopToggleBtn');
                    // LOOP checkbox behavior while PLAY is running:
                    // - LOOP ON: bracket sequencing will run (only if started with LOOP on)
                    // - LOOP OFF: do NOT stop transport; just stop auto chord scheduling (manual header-tap changes still work)
                    if (loopCheckbox && !loopCheckbox._wiredForLoopMode) {
                        loopCheckbox._wiredForLoopMode = true;
                        loopCheckbox.addEventListener('change', () => {
                            try {
                                if (!omnichord || !omnichord._isSequencing) return;
                                if (!loopCheckbox.checked) {
                                    if (omnichord._arpTransport) {
                                        omnichord._arpTransport._seqNextSwitchAbsTick = null;
                                        omnichord._arpTransport._seqScheduleNext = null;
                                    }
                                }
                            } catch(_){ }
                        });
                    }

                    const stopAllPatterns = (resetPhase = true)=>{
                        try {
                            const pt0 = window._patternTransport;
                            if (pt0 && typeof pt0.stop === 'function') pt0.stop(!!resetPhase);
                            else if (pt0) { pt0.running = false; pt0.tickCounter = 0; pt0.absTickCounter = 0; pt0.stopVoices && pt0.stopVoices(); }
                        } catch(_){ }
                        try {
                            const instances = window._patternInstances || [];
                            instances.forEach(info=>{
                                const m = info && info.modal;
                                const pt = m && m._patternTransport;
                                if (!pt) return;
                                try {
                                    if (typeof pt.stop === 'function') pt.stop(!!resetPhase);
                                    else { pt.running = false; pt.tickCounter = 0; pt.absTickCounter = 0; }
                                } catch(_){ }
                                try { pt.running = false; pt.stopVoices && pt.stopVoices(); } catch(_){ }
                            });
                        } catch(_){ }
                    };

                    const startAllEnabledPatternsFromZero = ()=>{
                        // Sequencer mode: patterns are driven by Omnichord's master transport tick
                        // via _patternsOnTransportTick(). We only need to arm enabled patterns and
                        // ensure any legacy per-pattern timers are stopped.

                        const arm = (pt)=>{
                            if (!pt) return;
                            try { if (typeof pt.stop === 'function') pt.stop(true); } catch(_){ }
                            try { pt.stopVoices && pt.stopVoices(); } catch(_){ }
                            try {
                                pt.running = true;
                                pt.waitingForDeferred = false;
                                pt.resumeAfterDeferred = false;
                                pt._startAtBarIndex = 0;
                                pt._masterLastAbsStep = null;
                                pt._masterBarIndex = null;
                            } catch(_){ }
                        };

                        // Arm legacy/global pattern transport to start at bar 0 beat 1
                        try {
                            window.ensurePatternTransport && window.ensurePatternTransport();
                            if (typeof window.refreshPatternTransportTiming === 'function') window.refreshPatternTransportTiming();
                            arm(window._patternTransport);
                        } catch(_){ }

                        // Arm all enabled pattern instances to start at bar 0 beat 1
                        try {
                            const instances = window._patternInstances || [];
                            instances.forEach(info=>{
                                const m = info && info.modal;
                                if (!m || !m._patternEnabled) return;
                                arm(m._patternTransport);
                            });
                        } catch(_){ }
                    };
                    
                    freshButton.addEventListener('click', (ev) => {
                        try { ev.preventDefault(); ev.stopPropagation(); } catch(_){ }
                        console.log('ðŸŽµ BRACKET-AWARE CLICK HANDLER CALLED');
                        console.log('ðŸŽµ DEBUG: omnichord._isSequencing =', omnichord._isSequencing);
                        
                        if (omnichord._isSequencing) {
                            // Currently playing - stop it
                            try {
                                if (typeof omnichord._panicStopSequencer === 'function') {
                                    omnichord._panicStopSequencer('click-stop');
                                } else {
                                    // Fallback
                                    omnichord.stopAllActiveNotes();
                                    try { omnichord._stopArpTransport && omnichord._stopArpTransport(); } catch(_){ }
                                    omnichord._isSequencing = false;
                                }
                            } catch (e) {
                                console.error('Error stopping sequence:', e);
                            }
                        } else {
                            console.log('ðŸŽµ DEBUG: Starting new sequence...');
                            // Currently stopped - start playing from bar 1
                            try {
                                // Stop any existing sequence first
                                omnichord.stopAllActiveNotes();
                                omnichord._sustainActive = false;
                                omnichord._chordsGestureActive = false;
                                omnichord._chordSlideActive = false;
                                omnichord._stopArp();
                                if (omnichord._arp) {
                                    omnichord._arp.pendingSwitch = null;
                                    omnichord._arp.active = false;
                                }
                                if (omnichord._seqTimer) {
                                    clearTimeout(omnichord._seqTimer);
                                    omnichord._seqTimer = null;
                                }
                                omnichord._isSequencing = false;
                                
                                // Enhanced synchronization: Ensure all transport systems start on beat 1 together
                                console.log('ðŸŽµ SYNCHRONIZED STARTUP: Preparing all transport systems');
                                
                                // 1. PRELOAD AND SYNC ALL TRANSPORT SYSTEMS
                                omnichord._ensureArpDefaults();
                                omnichord._ensureArpTransport();
                                omnichord._refreshArpTransportTiming();

                                try {
                                    window.ensurePatternTransport && window.ensurePatternTransport();
                                    if (typeof window.refreshPatternTransportTiming === 'function') window.refreshPatternTransportTiming();
                                    const pt = window._patternTransport;
                                    if (pt) {
                                        const wasWaiting = !!pt.waitingForDeferred;
                                        if (typeof pt.stop === 'function') pt.stop(true); else { pt.running = false; pt.tickCounter = 0; pt.absTickCounter = 0; }
                                        if (wasWaiting) {
                                            pt.waitingForDeferred = true;
                                            pt.resumeAfterDeferred = true;
                                        }
                                    }
                                } catch(_){ }
                                
                                // 2. PRELOAD DRUM PATTERNS (ensure at least 1 bar ready)
                                try {
                                    if (window._patternTransport) {
                                        // Sync drum transport BPM with arp transport
                                        window._patternTransport.bpm = omnichord._arpTransport.bpm;
                                        // Preload current drum pattern for immediate playback
                                        const drumSteps = document.querySelectorAll('.drum-step.active');
                                        if (drumSteps.length > 0) {
                                            console.log('ðŸŽµ PRELOAD: Drum pattern ready with', drumSteps.length, 'active steps');
                                        }
                                    }
                                } catch(e) { console.log('ðŸŽµ Drum preload error:', e); }
                                
                                // 3. PRELOAD BASS PATTERNS
                                try {
                                    if (omnichord.bassEnabled && omnichord._arp) {
                                        // Ensure bass frequency is calculated and ready
                                        const activeCol = document.querySelector('.chord-column.active') || document.querySelector('.chord-column');
                                        if (activeCol) {
                                            const step = omnichord._getEffectiveColumnRootStep(activeCol);
                                            const bassFreq = omnichord._computeBassFreqInRange(step, null, omnichord.currentTuning || 12);
                                            if (bassFreq) {
                                                omnichord._arp.bassFreq = bassFreq;
                                                console.log('ðŸŽµ PRELOAD: Bass frequency ready at', bassFreq.toFixed(2), 'Hz');
                                            }
                                        }
                                    }
                                } catch(e) { console.log('ðŸŽµ Bass preload error:', e); }
                                
                                // 4. RESET ALL COUNTERS TO ENSURE SYNCHRONIZED START ON BEAT 1
                                if (omnichord._arpTransport) {
                                    omnichord._arpTransport.tickCounter = 0;
                                    omnichord._arpTransport.absTickCounter = 0;
                                    omnichord._arpTransport.beatCounter = 0;
                                    omnichord._arpTransport.barCounter = 0;
                                    console.log('ðŸŽµ SYNC: All transport counters reset to 0');
                                }
                                
                                if (window._patternTransport) {
                                    window._patternTransport.tickCounter = 0;
                                    window._patternTransport.absTickCounter = 0;
                                    console.log('ðŸŽµ SYNC: Pattern transport counters reset to 0');
                                }

                                // Ensure pattern instances also restart from beat 1 with the main transport
                                try { stopAllPatterns(true); } catch(_){ }
                                
                                // 5. BUILD ONE-LOOP LOOKAHEAD PLAN AND START ALL SYSTEMS SIMULTANEOUSLY
                                console.log('ðŸŽµ SYNC: Starting all transport systems together...');
                                
                                // Start sequencing mode
                                omnichord._isSequencing = true;

                                // Arm patterns for master-transport sequencing (start on unified downbeat)
                                try { startAllEnabledPatternsFromZero(); } catch(_){ }
                                
                                // Start play button flashing in time with BPM
                                omnichord._startPlayButtonFlashing();
                                
                                // Read other UI values that might affect the sequence
                                const npcEl = document.getElementById('universalNpc');
                                const patternEl = document.getElementById('universalPattern');
                                const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                                
                                if (omnichord._arp) {
                                    if (npcEl) omnichord._arp.npc = Math.max(1, Number(npcEl.value) || 3);
                                    if (patternEl) omnichord._arp.pattern = patternEl.value || 'up';
                                    if (holdEl) omnichord._arp.chordsHold = holdEl.value || 'bar:1';
                                }
                                
                                // Don't start if no module is enabled (include drums)
                                const hasDrums = !!document.querySelector('.drum-step.active');
                                if (!omnichord.chordsEnabled && !omnichord.arpEnabled && !omnichord.bassEnabled && !hasDrums){
                                    omnichord._stopPlayButtonFlashing();
                                    return;
                                }
                                
                                // Build a row-major ordered list of columns (left-to-right, then next row)
                                console.log('ðŸŽµ DEBUG: About to query for columns...');
                                let cols = Array.from(document.querySelectorAll('#extensionColumns .extension-column'));
                                console.log('ðŸŽµ DEBUG: Found', cols.length, 'basic extension columns');
                                if (!cols.length) {
                                    console.log('ðŸŽµ DEBUG: No columns found - stopping');
                                    omnichord._stopPlayButtonFlashing();
                                    return;
                                }
                                
                                // Get ALL columns including repeat markers for bracket-aware sequencing
                                let allCols = Array.from(document.querySelectorAll('#extensionColumns .extension-column, #extensionColumns .repeat-marker-column'));
                                
                                console.log('ðŸŽµ DEBUG: Found', allCols.length, 'total columns for sequencing');
                                console.log('ðŸŽµ DEBUG: Column details:', allCols.map((col, i) => ({
                                    index: i,
                                    class: col.className,
                                    text: col.textContent?.trim(),
                                    isExtColumn: col.classList.contains('extension-column'),
                                    isRepeatColumn: col.classList.contains('repeat-marker-column')
                                })));
                                
                                // Sort all columns in visual order first
                                const sortRowMajor = (list)=> list.sort((a,b)=>{
                                    const ra = a.getBoundingClientRect();
                                    const rb = b.getBoundingClientRect();
                                    // Consider elements on the same visual row if their tops are close
                                    const dy = Math.round(ra.top - rb.top);
                                    if (Math.abs(dy) > 4) return dy; // different rows: top first
                                    return ra.left - rb.left; // same row: left to right
                                });
                                allCols = sortRowMajor(allCols);
                                
                                console.log('ðŸŽµ All columns for bracket-aware sequencing:', allCols.map(col => ({
                                    class: col.className,
                                    text: col.textContent?.trim(),
                                    nestLevel: col.dataset?.nestLevel
                                })));
                                console.log('ðŸŽµ First 6 columns details:');
                                for (let i = 0; i < Math.min(6, allCols.length); i++) {
                                    console.log(`ðŸŽµ Index ${i}:`, {
                                        class: allCols[i].className,
                                        text: allCols[i].textContent.trim(),
                                        isChord: allCols[i].classList.contains('extension-column'),
                                        isBracketMarker: allCols[i].classList.contains('repeat-marker-column')
                                    });
                                }
                                
                                // Decide a robust starting point: prefer outer '[' then first chord
                                const firstOuterStartIdx = allCols.findIndex(col => col.classList.contains('repeat-marker-column') && (col.textContent?.trim() === '['));
                                const firstChordIdx = allCols.findIndex(col => col.classList.contains('extension-column'));
                                let startIdx = (firstOuterStartIdx >= 0 ? firstOuterStartIdx : firstChordIdx);
                                if (startIdx === -1) {
                                    console.warn('ðŸŽµ No valid start item (no [ marker or chord) â€” aborting');
                                    omnichord._stopPlayButtonFlashing();
                                    return;
                                }
                                // Use bracket-aware sequencing instead of pre-expansion
                                let sequenceIndex = startIdx;
                                let bracketStack = []; // Stack to track bracket positions and repeat counts
                                
                                // One-loop lookahead planner: pre-walk current DOM to a concrete plan of columns for one full cycle
                                const buildOneLoopPlan = () => {
                                    try {
                                        let plan = [];
                                        let idx = startIdx;
                                        let stack = [];
                                        const maxIter = Math.max(1, allCols.length * 32); // safety
                                        let iter = 0;
                                        const pushChord = (i) => { if (i>=0 && i<allCols.length && allCols[i].classList.contains('extension-column')) plan.push(i); };
                                        while (iter++ < maxIter) {
                                            if (idx < 0 || idx >= allCols.length) break;
                                            const node = allCols[idx];
                                            const text = (node.textContent||'').trim();
                                            if (node.classList.contains('extension-column')) {
                                                pushChord(idx);
                                                idx++;
                                            } else if (node.classList.contains('repeat-marker-column')) {
                                                if (text === '[') {
                                                    // find matching end at same level
                                                    const startLevel = Number(node.dataset.nestLevel||0);
                                                    let depth = 0; let endIndex = -1; let repeatCount = null;
                                                    for (let j = idx+1; j < allCols.length; j++) {
                                                        const sc = allCols[j];
                                                        if (!sc.classList.contains('repeat-marker-column')) continue;
                                                        const st = (sc.textContent||'').trim();
                                                        const lvl = Number(sc.dataset.nestLevel||0);
                                                        if (st === '[' && lvl > startLevel) depth++;
                                                        else if ((st === ']' || /^\]x(\d+)$/.test(st))) {
                                                            if (lvl > startLevel) { if (depth>0) depth--; }
                                                            else if (lvl === startLevel && depth === 0) { endIndex = j; if (/^\]x(\d+)$/.test(st)) repeatCount = parseInt(st.match(/^\]x(\d+)$/)[1],10); break; }
                                                        }
                                                    }
                                                    const contentStart = idx+1;
                                                    const contentEnd = (endIndex>=0? endIndex: idx);
                                                    const rep = (repeatCount==null?1: Math.max(1, repeatCount||1));
                                                    // collect chords within once, then repeat
                                                    let inner = [];
                                                    for (let k = contentStart; k < contentEnd; k++) { if (allCols[k].classList.contains('extension-column')) inner.push(k); }
                                                    for (let r=0; r<rep; r++) { plan.push(...inner); }
                                                    idx = (endIndex>=0? endIndex+1: idx+1);
                                                } else if (text === ']') {
                                                    idx++;
                                                } else if (/^\]x(\d+)$/.test(text)) {
                                                    idx++;
                                                } else if (/^[xX](\d+)$/.test(text)) {
                                                    // repeat last chord N-1 more times
                                                    const n = parseInt(text.slice(1),10);
                                                    if (Number.isFinite(n) && n>1 && plan.length>0) {
                                                        const last = plan[plan.length-1];
                                                        for (let r=1; r<n; r++) plan.push(last);
                                                    }
                                                    idx++;
                                                } else {
                                                    idx++;
                                                }
                                            } else {
                                                idx++;
                                            }
                                            // End condition for a single visual cycle: if we walked past the last element and plan has something, stop
                                            if (idx >= allCols.length) break;
                                        }
                                        // Fallback: if plan empty but we have a chord, seed at least first chord to avoid dead start
                                        if (!plan.length) {
                                            const fc = allCols.findIndex(el=> el.classList.contains('extension-column'));
                                            if (fc>=0) plan.push(fc);
                                        }
                                        return plan;
                                    } catch(e){ console.warn('One-loop plan build error', e); return []; }
                                };
                                
                                let oneLoopPlan = buildOneLoopPlan();
                                let planPos = 0;
                                
                                const findNextChordIndex = (startIndex) => {
                                    console.log('ðŸŽµ Looking for bracket markers starting from index:', startIndex);
                                    console.log('ðŸŽµ DEBUG: allCols length:', allCols.length);
                                    console.log('ðŸŽµ DEBUG: allCols[0-5] content:', allCols.slice(0, 6).map(col => ({
                                        class: col.className,
                                        text: col.textContent.trim()
                                    })));
                                    
                                    // If we're inside a bracket, use a scanning cursor so nested markers are handled
                                    if (bracketStack.length > 0) {
                                        const b = bracketStack[bracketStack.length - 1];
                                        let i = Math.max(b.cursor || (b.startIndex + 1), startIndex);
                                        console.log('ðŸŽµ Inside bracket, scanning from cursor:', i, 'to endIndex:', b.endIndex);
                                        for (; i <= b.endIndex && i < allCols.length; i++) {
                                            const c = allCols[i];
                                            const t = c.textContent.trim();
                                            if (c.classList.contains('extension-column')) {
                                                // Schedule this chord and advance cursor
                                                b.cursor = i + 1;
                                                console.log('ðŸŽµ Bracket scan found chord at', i);
                                                return i;
                                            }
                                            if (c.classList.contains('repeat-marker-column')) {
                                                // Let scheduler route markers (nested [ or matching ]/ ]x)
                                                b.cursor = i;
                                                console.log('ðŸŽµ Bracket scan hit marker at', i, t);
                                                return i;
                                            }
                                        }
                                        console.warn('ðŸŽµ Bracket cursor reached end without finding next item; falling back');
                                    }
                                    
                                    // Normal case: look for next chord or bracket marker
                                    for (let i = startIndex; i < allCols.length; i++) {
                                        const col = allCols[i];
                                        const text = col.textContent.trim();
                                        
                                        console.log('ðŸŽµ Scanning index', i, ':', {
                                            class: col.className,
                                            text: text
                                        });
                                        
                                        if (col.classList.contains('repeat-marker-column')) {
                                            console.log('ðŸŽµ Found bracket/repeat marker at index', i, '- calling handleBracketLogic');
                                            return i;
                                        } else if (col.classList.contains('extension-column')) {
                                            console.log('ðŸŽµ Found next chord at index', i, '- normal progression');
                                            return i;
                                        }
                                    }
                                    return -1;
                                };
                                
                                const handleBracketLogic = (currentIndex) => {
                                    const col = allCols[currentIndex];
                                    const text = col.textContent.trim();
                                    
                                    console.log('ðŸŽµ Handling bracket logic at index', currentIndex, 'text:', text);
                                    
                                    if (text === '[') {
                                        // If this is an auto outer and LOOP is OFF, ignore the bracket
                                        try {
                                            const loopChk0 = document.getElementById('loopToggle') || document.getElementById('playLoop');
                                            if (col.dataset && col.dataset.autoOuter === 'true' && (!loopChk0 || !loopChk0.checked)) {
                                                console.log('ðŸŽµ Ignoring auto-outer [ because LOOP is OFF');
                                                return currentIndex + 1;
                                            }
                                        } catch(_){ /* no-op */ }
                                        // Level-aware find of matching end (same nest level)
                                        const startLevel = Number(col.dataset.nestLevel || 0);
                                        let depth = 0;
                                        let endIndex = -1;
                                        let repeatCount = null; // null => no explicit number
                                        for (let i = currentIndex + 1; i < allCols.length; i++) {
                                            const sc = allCols[i];
                                            if (!sc.classList.contains('repeat-marker-column')) continue;
                                            const st = sc.textContent.trim();
                                            const lvl = Number(sc.dataset.nestLevel || 0);
                                            if (st === '[' && lvl > startLevel) {
                                                depth++;
                                            } else if ((st === ']' || /^\]x(\d+)$/.test(st))) {
                                                if (lvl > startLevel) {
                                                    if (depth > 0) depth--;
                                                } else if (lvl === startLevel && depth === 0) {
                                                    endIndex = i;
                                                    if (/^\]x(\d+)$/.test(st)) repeatCount = parseInt(st.match(/^\]x(\d+)$/)[1], 10);
                                                    break;
                                                }
                                            }
                                        }
                                        if (endIndex >= 0) {
                                            const contentStart = currentIndex + 1;
                                            const count = (repeatCount == null ? 0 : repeatCount); // 0 => infinite
                                            console.log('ðŸŽµ Found bracket section (level', startLevel, '):', { startIndex: currentIndex, endIndex, repeatCount: count });
                                            bracketStack.push({
                                                startIndex: currentIndex,
                                                endIndex,
                                                contentStart,
                                                cursor: contentStart,
                                                repeatCount: (count === 0 ? Infinity : Math.max(1, count || 1)),
                                                currentRepeat: 1
                                            });
                                            const resolved = findNextChordIndex(contentStart);
                                            return (resolved !== -1 ? resolved : endIndex);
                                        } else {
                                            console.warn('ðŸŽµ Malformed bracket - no matching ] or ]x found at same level');
                                            return currentIndex + 1;
                                        }
                                    }
                                    else if (text.match(/^\]x(\d+)$/) || text === ']') {
                                        // If this is an auto outer end and LOOP is OFF, treat as end-of-sequence
                                        try {
                                            const loopChk1 = document.getElementById('loopToggle') || document.getElementById('playLoop');
                                            if (col.dataset && col.dataset.autoOuter === 'true' && (!loopChk1 || !loopChk1.checked)) {
                                                console.log('ðŸŽµ Auto-outer ] encountered with LOOP OFF -> end of sequence');
                                                return allCols.length;
                                            }
                                        } catch(_){ /* no-op */ }
                                        // Handle bracket end + repeat - this should advance the bracket logic
                                        if (bracketStack.length > 0) {
                                            const bracket = bracketStack[bracketStack.length - 1];
                                            // Allow dynamic change by reading marker text/dataset each pass
                                            let explicitCount = null;
                                            if (/^\]x(\d+)$/.test(text)) explicitCount = parseInt(text.match(/^\]x(\d+)$/)[1], 10);
                                            if (col.dataset && col.dataset.repeatCount) explicitCount = parseInt(col.dataset.repeatCount, 10);
                                            if (explicitCount != null) bracket.repeatCount = (explicitCount === 0 ? Infinity : Math.max(1, explicitCount));
                                            console.log('ðŸŽµ At bracket end, current repeat:', bracket.currentRepeat, 'of', bracket.repeatCount);
                                            if (bracket.currentRepeat < bracket.repeatCount) {
                                                // Still have repeats left - go back to first chord in bracket
                                                bracket.currentRepeat++;
                                                bracket.cursor = bracket.contentStart;
                                                const resolved = findNextChordIndex(bracket.contentStart);
                                                console.log('ðŸŽµ Starting repeat', bracket.currentRepeat, 'jumping to index', resolved);
                                                return (resolved !== -1 ? resolved : bracket.contentStart);
                                            } else {
                                                // Finished all repeats - remove from stack and continue
                                                bracketStack.pop();
                                                console.log('ðŸŽµ Finished all bracket repeats, continuing after ]x marker');
                                                return currentIndex + 1;
                                            }
                                        } else {
                                            console.warn('ðŸŽµ Found ]x marker without matching [');
                                            return currentIndex + 1;
                                        }
                                    }
                                    else if (text.match(/^[xX](\d+)$/)) {
                                        // Standalone repeat marker - repeats the last bar/chord only
                                        const match = text.match(/^[xX](\d+)$/);
                                        const totalRepeats = parseInt(match[1], 10);
                                        
                                        console.log('ðŸŽµ Standalone repeat marker x' + totalRepeats + ' - repeating last chord');
                                        
                                        // Find the previous chord index
                                        let previousChordIndex = -1;
                                        for (let i = currentIndex - 1; i >= 0; i--) {
                                            if (allCols[i].classList.contains('extension-column')) {
                                                previousChordIndex = i;
                                                break;
                                            }
                                        }
                                        
                                        if (previousChordIndex >= 0) {
                                            if (!col.dataset.standaloneRepeatsLeft) {
                                                col.dataset.standaloneRepeatsLeft = totalRepeats - 1;
                                                console.log('ðŸŽµ Starting standalone repeats, jumping back to chord at index', previousChordIndex);
                                                return previousChordIndex;
                                            } else {
                                                let repeatsLeft = parseInt(col.dataset.standaloneRepeatsLeft);
                                                repeatsLeft--;
                                                col.dataset.standaloneRepeatsLeft = repeatsLeft;
                                                
                                                if (repeatsLeft > 0) {
                                                    return previousChordIndex;
                                                } else {
                                                    delete col.dataset.standaloneRepeatsLeft;
                                                    console.log('ðŸŽµ Finished all standalone repeats');
                                                    return currentIndex + 1;
                                                }
                                            }
                                        } else {
                                            console.warn('ðŸŽµ Found standalone repeat marker but no previous chord!');
                                            return currentIndex + 1;
                                        }
                                    }
                                    
                                    return currentIndex + 1;
                                };
                                omnichord._ensureArpDefaults();
                                omnichord._ensureArpTransport();
                                // mark sequencing mode so HOLD and other idle stops don't interfere
                                omnichord._isSequencing = true;
                                const tpBar = omnichord._arpTransport.ticksPerBar || 16;

                                // Always do a 4-beat count-in when starting from STOPPED.
                                try { omnichord._arpTransport._countInBeatsRequested = 4; } catch(_){ }
                                
                                // Get loop checkbox (UI uses loopToggle)
                                const loopChk = document.getElementById('loopToggle') || document.getElementById('playLoop');
                                
                                // Add startup buffer to ensure smooth audio playback
                                console.log('ðŸŽµ Adding startup buffer to ensure audio readiness...');
                                setTimeout(() => {
                                    console.log('ðŸŽµ Startup buffer complete, beginning playback');
                                    console.log('ðŸŽµ Initial sequenceIndex is:', sequenceIndex);
                                    // Persist timing across steps (and across wraps) for gapless looping
                                    let nextSwitchAbsTick = null; // absolute tick when the next chord should switch
                                    let holdTicksForStep = null;   // last computed hold ticks
                                    let isFirstStep = true;        // only the very first scheduled step aligns to bar boundary

                                    // Helper: clear standalone xN repeat counters on wrap
                                    const _resetStandaloneRepeatCounters = () => {
                                        try {
                                            for (const c of allCols) {
                                                if (c.classList && c.classList.contains('repeat-marker-column')) {
                                                    if (c.dataset && 'standaloneRepeatsLeft' in c.dataset) {
                                                        delete c.dataset.standaloneRepeatsLeft;
                                                    }
                                                }
                                            }
                                        } catch(_) { /* no-op */ }
                                    };

                                    const scheduleNext = ()=>{
                                        const stopSequenceAndReset = ()=>{
                                            try {
                                                omnichord.stopAllActiveNotes();
                                                try { omnichord.stopAllDrums && omnichord.stopAllDrums(); } catch(_){ }
                                                try { omnichord._resetDrumPlayhead && omnichord._resetDrumPlayhead(); } catch(_){ }
                                                omnichord._sustainActive = false; 
                                                omnichord._chordsGestureActive = false; 
                                                omnichord._chordSlideActive = false;
                                                omnichord._stopArp();
                                                try { omnichord._stopArpTransport(); } catch(_){ }
                                                if (omnichord._arp) {
                                                    omnichord._arp.pendingSwitch = null;
                                                    omnichord._arp.active = false;
                                                }
                                                // Clear tick-driven scheduling state
                                                try {
                                                    if (omnichord._arpTransport) {
                                                        omnichord._arpTransport._seqNextSwitchAbsTick = null;
                                                        omnichord._arpTransport._seqScheduleNext = null;
                                                    }
                                                } catch(_){ }
                                                sequenceIndex = startIdx;
                                                bracketStack = [];
                                                freshButton.textContent = 'PLAY';
                                                freshButton.style.background = '#27ae60';
                                                freshButton.style.borderColor = '#2ecc71';
                                                try { omnichord._clearNowPlaying && omnichord._clearNowPlaying(); } catch(_){ }
                                            } catch(_){ }
                                            omnichord._isSequencing = false; 
                                            omnichord._stopPlayButtonFlashing();
                                        };

                                        console.log('ðŸŽµ scheduleNext called; planPos=', planPos, 'planLen=', Array.isArray(oneLoopPlan)?oneLoopPlan.length:0);

                                        // Apply pending SECTION switch exactly at cycle boundary (before selecting chord 1)
                                        try {
                                            const loopOnEarly = (function(){
                                                try {
                                                    const el = document.getElementById('loopToggle') || document.getElementById('playLoop');
                                                    return el ? !!el.checked : true;
                                                } catch(_){ return true; }
                                            })();
                                            if (loopOnEarly && (planPos|0) === 0 && omnichord && omnichord._pendingSectionSwitchId) {
                                                const applyFn = (typeof omnichord._applySectionSwitchById === 'function')
                                                    ? omnichord._applySectionSwitchById
                                                    : (typeof window._applySectionSwitchById === 'function' ? window._applySectionSwitchById : null);
                                                if (applyFn) {
                                                    applyFn(omnichord._pendingSectionSwitchId);
                                                    try {
                                                        const t = omnichord._arpTransport;
                                                        if (t) {
                                                            t._seqRebuildRequested = true;
                                                            t._seqRebuildWhy = 'section-switch';
                                                        }
                                                    } catch(_){ }
                                                }
                                            }
                                        } catch(_){ }

                                        // If chords/columns changed during PLAY, rebuild the one-loop plan at the NEXT cycle boundary.
                                        // This ensures the current cycle finishes unchanged, and the new chord plays at the end of the next cycle.
                                        try {
                                            const t = omnichord && omnichord._arpTransport;
                                            if (t && t._seqRebuildRequested && ((planPos|0) === 0)) {
                                                t._seqRebuildRequested = false;
                                                // Refresh DOM columns in visual order
                                                try {
                                                    const freshAll = Array.from(document.querySelectorAll('#extensionColumns .extension-column, #extensionColumns .repeat-marker-column'));
                                                    allCols = sortRowMajor(freshAll);
                                                } catch(_){ }
                                                // Recompute start index using the same rule as startup
                                                try {
                                                    const firstOuter = allCols.findIndex(col => col.classList.contains('repeat-marker-column') && (col.textContent?.trim() === '['));
                                                    const firstChord2 = allCols.findIndex(col => col.classList.contains('extension-column'));
                                                    startIdx = (firstOuter >= 0 ? firstOuter : firstChord2);
                                                    if (startIdx == null || startIdx < 0) startIdx = (firstChord2 >= 0 ? firstChord2 : 0);
                                                } catch(_){ startIdx = 0; }
                                                // Rebuild one-loop plan from the fresh DOM
                                                try { oneLoopPlan = buildOneLoopPlan(); } catch(_){ oneLoopPlan = oneLoopPlan || []; }
                                                planPos = 0;
                                                sequenceIndex = startIdx;
                                                bracketStack = [];
                                                try { _resetStandaloneRepeatCounters(); } catch(_){ }
                                                // Update tick-driven state snapshot
                                                try {
                                                    t._seqOneLoopPlan = oneLoopPlan;
                                                    t._seqPlanPos = planPos;
                                                    t._seqAllCols = allCols;
                                                    t._seqStartIdx = startIdx;
                                                } catch(_){ }
                                            }
                                        } catch(_){ }

                                        // Drive sequencing from the current one-loop plan
                                        let planLen = Array.isArray(oneLoopPlan) ? oneLoopPlan.length : 0;
                                        const loopOn = (function(){
                                            try {
                                                const el = document.getElementById('loopToggle') || document.getElementById('playLoop');
                                                return el ? !!el.checked : true;
                                            } catch(_){ return true; }
                                        })();
                                        const endHoldMode = (!loopOn && (planPos|0) >= (planLen|0) && (planLen|0) > 0);

                                        if (!planLen) {
                                            console.warn('ðŸŽµ oneLoopPlan is empty - stopping sequence');
                                            stopSequenceAndReset();
                                            return;
                                        }

                                        // Select CURRENT chord strictly from the plan (or enter end-hold mode when LOOP is off)
                                        if (!endHoldMode) {
                                            try {
                                                const selIdx = oneLoopPlan[Math.min(planPos, planLen - 1)];
                                                if (Number.isFinite(selIdx)) {
                                                    sequenceIndex = selIdx;
                                                } else {
                                                    console.warn('ðŸŽµ Invalid plan index selected:', selIdx, 'at planPos=', planPos);
                                                    sequenceIndex = 0;
                                                }
                                            } catch(_){ sequenceIndex = 0; }
                                        }

                                        if (sequenceIndex < 0 || sequenceIndex >= allCols.length) {
                                            console.warn('ðŸŽµ sequenceIndex out of range after plan selection - clamping to 0');
                                            sequenceIndex = 0;
                                        }

                                        // At this point, sequenceIndex is the CURRENT chord to schedule (unless end-hold mode)
                                        console.log('ðŸŽµ Scheduling CURRENT chord at index (from plan):', sequenceIndex, 'endHoldMode=', endHoldMode);

                                    // Continue with chord switching logic for CURRENT chord
                                    const col = (function(){
                                        if (!endHoldMode) return allCols[sequenceIndex];
                                        let holdCol = null;
                                        try { holdCol = omnichord._lastPlayGestureColumnEl || omnichord.currentActiveColumnEl || omnichord._arp?.column || null; } catch(_){ holdCol = null; }
                                        if (holdCol && holdCol.classList && holdCol.classList.contains('extension-column')) return holdCol;
                                        // Fallback: hold on the last scheduled chord if it's valid
                                        try {
                                            const c = allCols[Math.max(0, Math.min(allCols.length - 1, sequenceIndex|0))];
                                            if (c && c.classList && c.classList.contains('extension-column')) return c;
                                        } catch(_){ }
                                        // Final fallback: first chord column
                                        return allCols.find(x=> x && x.classList && x.classList.contains('extension-column')) || allCols[0];
                                    })();
                                    console.log('ðŸŽµ Playing chord at index', sequenceIndex, ':', col.querySelector('.chord-name')?.textContent);
                                    
                                    try {
                                        
                                        const curTick = omnichord._arpTransport.tickCounter|0;
                                        const absNow = omnichord._arpTransport.absTickCounter|0;

                                        const isSpacer = !!(col && col.dataset && col.dataset.isSpacer === 'true');
                                        
                                        // Get the column header to extract chord name and root AFTER chord is named
                                        const header = col.querySelector('.extension-column-header');
                                        const chordName = header ? header.textContent.trim() : '';
                                        
                                        // Extract root note from chord name for bass (e.g., "C7" -> "C", "F#m" -> "F#")
                                        let chordRoot = null;
                                        if (!isSpacer && chordName){
                                            // Scan for a valid bass note by matching sharp/flat notation
                                            const bassMatch = chordName.match(/^([A-G][#â™¯bâ™­]?)/);
                                            if (bassMatch) chordRoot = bassMatch[1].replace(/[â™¯]/g,'#').replace(/[â™­]/g,'b');
                                        }
                                        if (!isSpacer && chordRoot && omnichord.bassEnabled){
                                            // Check if bass modal has active patterns before setting automatic bass
                                            const bassGrid = document.getElementById('bassGrid');
                                            let hasActiveBassPattern = false;
                                            if (bassGrid && bassGrid._computedPattern) {
                                                hasActiveBassPattern = bassGrid._computedPattern.split(' ').some(token => token !== 'x');
                                            }
                                            
                                            if (!hasActiveBassPattern) {
                                                // Schedule bass note only if no bass modal patterns are active
                                                const baseFreq = omnichord.noteNameToFrequency(chordRoot + '2')||55;
                                                omnichord._arp.bassFreq = baseFreq;
                                            } else {
                                                omnichord._arp.bassFreq = null;
                                            }
                                        } else {
                                            omnichord._arp.bassFreq = null;
                                        }
                                        
                                        // Determine HOLD length per chordbox in 16th-note units (default 16).
                                        // We map 16ths -> transport ticks using ticksPerBar.
                                        let len16 = 16;
                                        try {
                                            len16 = Math.max(1, Math.min(1024, parseInt(col.dataset.len16 || '16', 10) || 16));
                                        } catch(_){ len16 = 16; }
                                        const ticksPerSixteenth = Math.max(1, Math.round(tpBar / 16));
                                        const holdTicks = Math.max(1, (len16 * ticksPerSixteenth) | 0);
                                        holdTicksForStep = holdTicks;
                                        const holdMsForStep = Math.max(1, Math.round(holdTicks * (omnichord._arpTransport.tickMs || 0)));
                                        
                                        let targetAbsTick = absNow;
                                        if (isFirstStep){
                                            // First-ever step after pressing PLAY: align to bar downbeat and gate global start until that tick
                                            const ticksToNextBar = (tpBar - (curTick % tpBar)) % tpBar;
                                            const baseStartAbsTick = (absNow + ticksToNextBar) >>> 0;

                                            // Count-in: delay the *actual* start by N beats (default 4) when starting from STOPPED.
                                            let countInBeats = 0;
                                            try { countInBeats = Math.max(0, parseInt(omnichord._arpTransport._countInBeatsRequested||0, 10) || 0); } catch(_){ countInBeats = 0; }
                                            try { omnichord._arpTransport._countInBeatsRequested = 0; } catch(_){ }

                                            if (countInBeats > 0) {
                                                const tpBeat = Math.max(1, omnichord._arpTransport.ticksPerBeat || 1);
                                                const countInTicks = (countInBeats * tpBeat) >>> 0;
                                                const endAbsTick = (baseStartAbsTick + countInTicks) >>> 0;

                                                // Gate everything until the end of count-in.
                                                try { omnichord._arpTransport.startGateAbsTick = endAbsTick; } catch(_){ }
                                                // Arm count-in clicks/UI (handled in the master runTick).
                                                try {
                                                    omnichord._arpTransport.countInActive = true;
                                                    omnichord._arpTransport.countInStartAbsTick = baseStartAbsTick;
                                                    omnichord._arpTransport.countInEndAbsTick = endAbsTick;
                                                    omnichord._arpTransport.countInLastBeat = 0;
                                                } catch(_){ }

                                                // Actual musical start happens after the count.
                                                targetAbsTick = endAbsTick;
                                            } else {
                                                // No count-in: just start on the aligned downbeat.
                                                targetAbsTick = baseStartAbsTick;
                                                try { omnichord._arpTransport.startGateAbsTick = targetAbsTick; } catch(_){ }
                                            }

                                            nextSwitchAbsTick = (targetAbsTick + holdTicks) >>> 0;
                                            isFirstStep = false;
                                        } else if (Number.isFinite(nextSwitchAbsTick)) {
                                            // Gapless advance (also when wrapping to index 0)
                                            targetAbsTick = nextSwitchAbsTick >>> 0;
                                            nextSwitchAbsTick = (nextSwitchAbsTick + holdTicks) >>> 0;
                                        }
                                        
                                        // Prepare a quick sequence from column strings
                                        const rows = Array.from(col.querySelectorAll('.strings-column .string'));
                                        // During PLAY, treat module toggles as independent lanes; all align to the same grid.
                                        // Spacer chordboxes are silent time blocks.
                                        const chordsOn = !isSpacer && !!omnichord.chordsEnabled;
                                        const arpOn = !isSpacer && !!omnichord.arpEnabled;
                                        // Determine NPC: include all unique chord degrees (tensions) during PLAY
                                        const npcUI = (function(){
                                            const n1 = parseInt(document.getElementById('universalNpc')?.value||'');
                                            const n = Number.isFinite(n1)? n1 : (omnichord._arp?.npc||3);
                                            return Math.max(1, Math.min(64, n|0));
                                        })();
                                        // Build CHORD ladder (for sustain voices) and ARP ladder independently
                                        // Build ARP/CHORD ladders, but keep ARP in higher octaves (>=5)
                                        const ascAll = rows.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0) - (parseFloat(b.dataset.frequency)||0));
                                        const ascHigh = ascAll.filter(r => (parseInt(r.dataset.octave||'0',10) >= 5));
                                        // CHORD ladder: optionally group by octave and anchor to last tapped octave
                                        let chordLadder = ascAll;
                                        // Prefer higher-octave chord tones when available to keep chord+ARP texture consistent
                                        const chordHigh = ascAll.filter(r => (parseInt(r.dataset.octave||'0',10) >= 5));
                                        if (chordHigh.length) chordLadder = chordHigh;
                                        if (typeof omnichord.groupStringsByOctave === 'function'){
                                            try {
                                                const { groups } = omnichord.groupStringsByOctave(ascAll);
                                                const baseOct = Number.isFinite(omnichord._lastTappedOctave) ? omnichord._lastTappedOctave : 4;
                                                const filtered = groups.filter(g => Array.isArray(g) && g.length && parseInt(g[0]?.dataset?.octave||'0',10) >= baseOct);
                                                chordLadder = (filtered.length? filtered : groups).flat();
                                            } catch(_){ /* keep ascAll */ }
                                        }
                                        // Expand to all available unique chord degrees so tensions are included
                                        let npcEffective = npcUI;
                                        try {
                                            const edo = omnichord.currentTuning||12;
                                            const norm = (x)=> ((x%edo)+edo)%edo;
                                            const rootAbs = (typeof omnichord._getEffectiveColumnRootStep === 'function') ? omnichord._getEffectiveColumnRootStep(col) : (omnichord.currentRoot||0);
                                            const steps = rows.map(r=> parseInt(r.dataset.noteIndex,10)).filter(n=>Number.isFinite(n));
                                            const uniqDeg = Array.from(new Set(steps.map(st=> norm(st - rootAbs))));
                                            if (uniqDeg.length > npcEffective) npcEffective = uniqDeg.length;
                                        } catch(_) { /* keep npcEffective */ }
                                        const chordRows = chordLadder.slice(0, npcEffective);
                                        
                                        // ARP ladder: rotate to start octave then take NPC and apply pattern
                                        const startOctRaw = Number.isFinite(omnichord._lastTappedOctave) ? omnichord._lastTappedOctave : 4;
                                        const startOct = Math.max(5, startOctRaw);
                                        let rotIndex = ascHigh.findIndex(r => (parseInt(r.dataset.octave||'0',10) >= startOct));
                                        if (rotIndex < 0) rotIndex = 0;
                                        const rotated = (ascHigh.length ? ascHigh : ascAll);
                                        const rotated2 = rotIndex > 0 ? (rotated.slice(rotIndex).concat(rotated.slice(0, rotIndex))) : rotated;
                                        
                                        // Apply pattern to generate proper ARP sequence
                                        let arpSeq = [];
                                        if (arpOn) {
                                            const pattern = omnichord._arp?.pattern || 'up';
                                            // Use builder only for custom typed patterns; otherwise, build from npcEffective so tensions are included
                                            let usedBuilder = false;
                                            try {
                                                const txtEl = document.getElementById('universalPatternText');
                                                const hasCustom = !!(txtEl && String(txtEl.value||'').trim());
                                                if (hasCustom) {
                                                    const sourceRows = chordRows.length ? chordRows : (ascHigh.length ? ascHigh : ascAll);
                                                    const built = omnichord._buildArpSequence(sourceRows, pattern, null) || [];
                                                    if (built.length) { arpSeq = built; usedBuilder = true; }
                                                }
                                            } catch(_) { /* fall through to pattern fallback */ }
                                            if (!usedBuilder) {
                                                // Fallback to simple patterns over the available degrees, limited to UI NPC
                                                const npcSlice = rotated2.slice(0, npcUI);
                                                switch (pattern) {
                                                    case 'up':
                                                        arpSeq = npcSlice;
                                                        break;
                                                    case 'down':
                                                        arpSeq = npcSlice.slice().reverse();
                                                        break;
                                                    case 'updown':
                                                        arpSeq = npcSlice;
                                                        if (npcSlice.length > 2) {
                                                            const desc = npcSlice.slice(1, -1).reverse();
                                                            arpSeq.push(...desc);
                                                        }
                                                        break;
                                                    case 'downup': {
                                                        const descSeq = npcSlice.slice().reverse();
                                                        arpSeq = descSeq;
                                                        if (descSeq.length > 2) {
                                                            const asc = descSeq.slice(1, -1).reverse();
                                                            arpSeq.push(...asc);
                                                        }
                                                        break;
                                                    }
                                                    case 'random':
                                                        arpSeq = npcSlice.slice().sort(() => Math.random() - 0.5);
                                                        break;
                                                    default:
                                                        arpSeq = npcSlice;
                                                }
                                            }
                                        }
                                        const mapAscRef = rotated2;
                                        omnichord._arp.pendingSwitch = {
                                            atAbsTick: targetAbsTick >>> 0,
                                            alignPhaseToTickCounter: true, // align seq phase to transport tick
                                            // Run ARP ticks while optionally sustaining a full chord
                                            seq: arpSeq,
                                            bassFreq: omnichord._arp.bassFreq,
                                            holdTicks: holdTicks,
                                            column: col,
                                            mapAsc: mapAscRef,
                                            // Provide cycle context so other transports can hard-sync at cycle edges
                                            cycleLen: (Array.isArray(oneLoopPlan) ? oneLoopPlan.length|0 : 0),
                                            cycleIdx: (planPos|0),
                                            isCycleStart: ((planPos|0) === 0),
                                            mode: 'arp',
                                            npc: npcUI,
                                            enableChord: chordsOn,
                                            chordRows
                                        };
                                        // Ensure HOLD doesn't cut transport during sequencing
                                        omnichord._arpTransport.holdStopAtAbsTick = null;
                                        omnichord._startArpTransport();

                                        // Advance lookahead plan position now that we've scheduled this step.
                                        // LOOP ON: wrap forever. LOOP OFF: run once, then stop advancing chords.
                                        try {
                                            const planLen2 = Array.isArray(oneLoopPlan) ? oneLoopPlan.length : 0;
                                            if (planLen2 > 0) {
                                                if (!endHoldMode) {
                                                    planPos = loopOn ? ((planPos + 1) % planLen2) : (planPos + 1);
                                                }
                                            } else {
                                                planPos = 0;
                                            }
                                        } catch(_){ }
                                        
                                        // TICK-DRIVEN SCHEDULING: Store next switch tick in transport
                                        // so runTick can call scheduleNext at the exact tick boundary.
                                        // This prevents setTimeout drift and keeps chords locked to drums.
                                        try {
                                            if (endHoldMode) {
                                                // End of sequence (LOOP off): stop advancing chords, keep transport running.
                                                omnichord._arpTransport._seqNextSwitchAbsTick = null;
                                                omnichord._arpTransport._seqScheduleNext = null;
                                            } else {
                                                omnichord._arpTransport._seqNextSwitchAbsTick = nextSwitchAbsTick;
                                                omnichord._arpTransport._seqScheduleNext = scheduleNext;
                                            }
                                            omnichord._arpTransport._seqOneLoopPlan = oneLoopPlan;
                                            omnichord._arpTransport._seqPlanPos = planPos;
                                            omnichord._arpTransport._seqAllCols = allCols;
                                            omnichord._arpTransport._seqStartIdx = startIdx;
                                        } catch(_){ }
                                        
                                        // DO NOT use setTimeout - the transport tick handler will call scheduleNext
                                        // at the exact tick when nextSwitchAbsTick is reached.
                                    } catch (err) {
                                        console.error('Error in sequence step:', err);
                                        // On error, schedule next chord via tick-driven mechanism after 1 bar
                                        try {
                                            const tpBar = omnichord._arpTransport.ticksPerBar || 16;
                                            const absNow = omnichord._arpTransport.absTickCounter|0;
                                            omnichord._arpTransport._seqNextSwitchAbsTick = absNow + tpBar;
                                            omnichord._arpTransport._seqScheduleNext = scheduleNext;
                                        } catch(_){ }

                                        // Wire Drum FX panel on open (safe if audio not initialized yet)
                                        try {
                                            const omni = window.omnichord;
                                            if (omni && typeof omni._wireDrumFxPanel === 'function') omni._wireDrumFxPanel();
                                            if (omni && typeof omni._applyDrumFxPanel === 'function') omni._applyDrumFxPanel();
                                        } catch(_){ }
                                    }
                                };
                                
                                // Start the sequence
                                scheduleNext();
                                }, 100); // 100ms buffer for audio readiness
                                
                                // Update button to show STOP state
                                freshButton.textContent = 'STOP';
                                freshButton.style.background = '#e74c3c';
                                freshButton.style.borderColor = '#c0392b';
                            } catch (e) {
                                console.error('Error starting sequence:', e);
                            }
                        }
                    });
                }
            } catch (e) {
                console.error('Error setting up play/stop toggle:', e);
            }

            // Wire PLAY (one bar per chord) + Loop + STOP
            try {
                const playBtn = document.getElementById('playSeqBtn');
                const loopChk = document.getElementById('playLoop');
                const stopBtn = document.getElementById('stopSeqBtn');
                
                // DISABLED: playSeqBtn doesn't exist in HTML - this conflicts with bracket-aware playStopToggle
                // The playStopToggleBtn handles all playback with proper bracket support
                
                // Removed playBtn logic to prevent conflicts with bracket-aware sequencing
                
                if (false && playBtn && !playBtn._wired){  // DISABLED
                    playBtn._wired = true;
                    playBtn.addEventListener('click', ()=>{
                        try {
                            // Start PLAY button flashing in time with BPM
                            omnichord._startPlayButtonFlashing();
                            
                            // Sync all transport and ARP settings from UI before starting
                            omnichord._ensureArpDefaults();
                            omnichord._ensureArpTransport();
                            omnichord._refreshArpTransportTiming();
                            
                            // Read other UI values that might affect the sequence
                            const npcEl = document.getElementById('universalNpc');
                            const patternEl = document.getElementById('universalPattern');
                            const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                            
                            if (omnichord._arp) {
                                if (npcEl) omnichord._arp.npc = Math.max(1, Number(npcEl.value) || 3);
                                if (patternEl) omnichord._arp.pattern = patternEl.value || 'up';
                                if (holdEl) omnichord._arp.chordsHold = holdEl.value || 'bar:1';
                            }
                            
                            // Ensure audio is unlocked on user gesture
                                    try { omnichord._sustainActive = false; omnichord._chordsGestureActive = false; omnichord._chordSlideActive = false; } catch(_){ }
                            // If a previous sequencing run is active, stop it cleanly first
                            try { if (omnichord._seqTimer) { clearTimeout(omnichord._seqTimer); omnichord._seqTimer = null; } } catch(_){}
                            try { omnichord._isSequencing = false; } catch(_){}
                            // Don't start if no module is enabled
                            if (!omnichord.chordsEnabled && !omnichord.arpEnabled && !omnichord.bassEnabled){
                                omnichord._stopPlayButtonFlashing();
                                return;
                            }
                            // Build a row-major ordered list of columns (left-to-right, then next row)
                            let cols = Array.from(document.querySelectorAll('#extensionColumns .extension-column'));
                            if (!cols.length) return;
                            const sortRowMajor = (list)=> list.sort((a,b)=>{
                                const ra = a.getBoundingClientRect();
                                const rb = b.getBoundingClientRect();
                                // Consider elements on the same visual row if their tops are close
                                const dy = Math.round(ra.top - rb.top);
                                if (Math.abs(dy) > 4) return dy; // different rows: top first
                                return ra.left - rb.left; // same row: left to right
                            });
                            cols = sortRowMajor(cols);
                            omnichord._ensureArpDefaults();
                            omnichord._ensureArpTransport();
                            // mark sequencing mode so HOLD and other idle stops don't interfere
                            omnichord._isSequencing = true;
                            const tpBar = omnichord._arpTransport.ticksPerBar || 16;
                let i = 0;
                            let nextSwitchAbsTick = null; // absolute tick when the next chord should switch
                let holdTicksForStep = null;   // persist across the scheduleNext closure
                            const scheduleNext = ()=>{
                                if (i >= cols.length){
                                    if (loopChk && loopChk.checked){
                                        // recompute visual order on each loop to respect any layout changes
                                        cols = sortRowMajor(Array.from(document.querySelectorAll('#extensionColumns .extension-column')));
                                        i = 0;
                    } else {
                                        // LOOP OFF: Stop everything and reset to ready state
                                        try {
                                            // Stop all active notes and reset states
                                            omnichord.stopAllActiveNotes();
                                            omnichord._sustainActive = false; 
                                            omnichord._chordsGestureActive = false; 
                                            omnichord._chordSlideActive = false;
                                            
                                            // Stop ARP transport and clear pending switches
                                            omnichord._stopArp();
                                            if (omnichord._arp) {
                                                omnichord._arp.pendingSwitch = null;
                                                omnichord._arp.active = false;
                                            }
                                            
                                            // Reset sequence to beginning for next play
                                            i = 0;
                                        } catch(_){ }
                                        omnichord._isSequencing = false; 
                                        omnichord._stopPlayButtonFlashing();
                                        return;
                                    }
                                }
                                const col = cols[i++];
                                // Trigger ARP start on this column; align the first start to next bar, then advance by HOLD length
                                try {
                                    const curTick = omnichord._arpTransport.tickCounter|0;
                                    const absNow = omnichord._arpTransport.absTickCounter|0;

                                    const isSpacer = !!(col && col.dataset && col.dataset.isSpacer === 'true');
                                    
                                    // Get the column header to extract chord name and root AFTER chord is named
                                    const header = col.querySelector('.extension-column-header');
                                    const chordName = header ? header.textContent.trim() : '';
                                    
                                    // Extract root note from chord name for bass (e.g., "C7" -> "C", "F#m" -> "F#")
                                    let chordRoot = null;
                                    if (chordName) {
                                        const normName = omnichord._normalizeChordSymbolsForParse ? omnichord._normalizeChordSymbolsForParse(chordName) : chordName;
                                        const rootMatch = normName.match(/^([A-Ga-g][#b\-d]*)/);
                                        if (rootMatch) {
                                            chordRoot = rootMatch[1].toUpperCase();
                                        }
                                    }
                                    
                                    // Determine HOLD length per chordbox in 16th-note units (default 16).
                                    let len16 = 16;
                                    try {
                                        len16 = Math.max(1, Math.min(1024, parseInt(col.dataset.len16 || '16', 10) || 16));
                                    } catch(_){ len16 = 16; }
                                    const ticksPerSixteenth = Math.max(1, Math.round(tpBar / 16));
                                    const holdTicks = Math.max(1, (len16 * ticksPerSixteenth) | 0);
                    holdTicksForStep = holdTicks;
                                    let targetAbsTick = absNow;
                                    if (i === 1){
                                        const ticksToNextBar = (tpBar - (curTick % tpBar)) % tpBar;
                                        // If we're already on the bar boundary, start immediately (do not wait a full bar)
                                        targetAbsTick = absNow + (ticksToNextBar > 0 ? ticksToNextBar : 0);
                                        nextSwitchAbsTick = (targetAbsTick + holdTicks) >>> 0;
                                    } else if (Number.isFinite(nextSwitchAbsTick)) {
                                        // Lock subsequent switches to the absolute grid
                                        targetAbsTick = nextSwitchAbsTick >>> 0;
                                        nextSwitchAbsTick = (nextSwitchAbsTick + holdTicks) >>> 0;
                                    }
                                    // Prepare a quick sequence from column strings
                                    const rows = Array.from(col.querySelectorAll('.strings-column .string'));
                                    // During PLAY, treat module toggles as independent lanes; all align to the same grid.
                                    // Spacer chordboxes are silent time blocks.
                                    const chordsOn = !isSpacer && !!omnichord.chordsEnabled;
                                    const arpOn = !isSpacer && !!omnichord.arpEnabled;
                                    if (isSpacer && omnichord._arp) {
                                        omnichord._arp.bassFreq = null;
                                    }
                                    // Treat NPC as global during PLAY
                                    const npcGlobal = (function(){
                                        const n1 = parseInt(document.getElementById('universalNpc')?.value||'');
                                        const n = Number.isFinite(n1)? n1 : (omnichord._arp?.npc||3);
                                        return Math.max(1, Math.min(64, n|0));
                                    })();
                                    // Build CHORD ladder (for sustain voices) and ARP ladder independently
                                    const ascAll = rows.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0) - (parseFloat(b.dataset.frequency)||0));
                                    const ascHigh = ascAll.filter(r => (parseInt(r.dataset.octave||'0',10) >= 5));
                                    // CHORD ladder: optionally group by octave and anchor to last tapped octave
                                    let chordLadder = ascAll;
                                    if (typeof omnichord.groupStringsByOctave === 'function'){
                                        try {
                                            const { groups } = omnichord.groupStringsByOctave(ascAll);
                                            const baseOct = Number.isFinite(omnichord._lastTappedOctave) ? omnichord._lastTappedOctave : 4;
                                            const filtered = groups.filter(g => Array.isArray(g) && g.length && parseInt(g[0]?.dataset?.octave||'0',10) >= baseOct);
                                            chordLadder = (filtered.length? filtered : groups).flat();
                                        } catch(_){ /* keep ascAll */ }
                                    }
                                    const chordRows = chordLadder.slice(0, npcGlobal);
                                    
                                    // ARP ladder: use higher octaves (>=5); rotate to start octave then take NPC and apply pattern
                                    const startOctRaw = Number.isFinite(omnichord._lastTappedOctave) ? omnichord._lastTappedOctave : 4;
                                    const startOct = Math.max(5, startOctRaw);
                                    let rotIndex = ascHigh.findIndex(r => (parseInt(r.dataset.octave||'0',10) >= startOct));
                                    if (rotIndex < 0) rotIndex = 0;
                                    const rotatedBase = (ascHigh.length ? ascHigh : ascAll);
                                    const rotated = rotIndex > 0 ? (rotatedBase.slice(rotIndex).concat(rotatedBase.slice(0, rotIndex))) : rotatedBase;
                                    
                                    // Apply pattern to generate proper ARP sequence
                                    let arpSeq = [];
                                    if (arpOn) {
                                        const pattern = omnichord._arp?.pattern || 'up';
                                        // Prefer central builder only when a custom pattern text is provided
                                        let usedBuilder = false;
                                        try {
                                            const txtEl = document.getElementById('universalPatternText');
                                            const hasCustom = !!(txtEl && String(txtEl.value||'').trim());
                                            if (hasCustom) {
                                                const sourceRows = ascHigh.length ? ascHigh : ascAll;
                                                const built = omnichord._buildArpSequence(sourceRows, pattern, null) || [];
                                                if (built.length) { arpSeq = built; usedBuilder = true; }
                                            }
                                        } catch(_) { /* fallback to simple patterns */ }
                                        if (!usedBuilder) {
                                            const npcSlice = rotated.slice(0, npcGlobal);
                                            switch (pattern) {
                                                case 'up':
                                                    arpSeq = npcSlice;
                                                    break;
                                                case 'down':
                                                    arpSeq = npcSlice.slice().reverse();
                                                    break;
                                                case 'updown':
                                                    if (npcSlice.length <= 1) {
                                                        arpSeq = npcSlice;
                                                    } else {
                                                        arpSeq = [...npcSlice];
                                                        if (npcSlice.length > 2) {
                                                            const desc = npcSlice.slice(1, -1).reverse();
                                                            arpSeq.push(...desc);
                                                        }
                                                    }
                                                    break;
                                                case 'downup':
                                                    if (npcSlice.length <= 1) {
                                                        arpSeq = npcSlice;
                                                    } else {
                                                        const descSeq = npcSlice.slice().reverse();
                                                        arpSeq = [...descSeq];
                                                        if (descSeq.length > 2) {
                                                            const asc = descSeq.slice(1, -1).reverse();
                                                            arpSeq.push(...asc);
                                                        }
                                                    }
                                                    break;
                                                case 'walk-up': {
                                                    const L = npcSlice.length;
                                                    if (L <= 2) { arpSeq = npcSlice; break; }
                                                    const motif = [1, 1, -1];
                                                    let idx = 0; arpSeq = [npcSlice[idx]]; let m = 0;
                                                    while (arpSeq.length < npcGlobal) {
                                                        let step = motif[m % motif.length];
                                                        let next = idx + step;
                                                        if (next >= L) { next = L - 2; step = -1; m = (m + 1) % motif.length; }
                                                        else if (next < 0) { next = 1; step = 1; m = (m + 1) % motif.length; }
                                                        else { m = (m + 1) % motif.length; }
                                                        idx = next; arpSeq.push(npcSlice[idx]);
                                                    }
                                                    break;
                                                }
                                                case 'walk-down': {
                                                    const L = npcSlice.length;
                                                    if (L <= 2) { arpSeq = npcSlice.slice().reverse(); break; }
                                                    const motif = [-1, -1, 1];
                                                    let idx = 0; arpSeq = [npcSlice[idx]]; let m = 0;
                                                    while (arpSeq.length < npcGlobal) {
                                                        let step = motif[m % motif.length];
                                                        let next = idx + step;
                                                        if (next >= L) { next = L - 2; step = -1; m = (m + 1) % motif.length; }
                                                        else if (next < 0) { next = 1; step = 1; m = (m + 1) % motif.length; }
                                                        else { m = (m + 1) % motif.length; }
                                                        idx = next; arpSeq.push(npcSlice[idx]);
                                                    }
                                                    break;
                                                }
                                                case 'random':
                                                    arpSeq = npcSlice.slice().sort(() => Math.random() - 0.5);
                                                    break;
                                                case 'alt-ends': {
                                                    const a = npcSlice.slice();
                                                    const out = []; let i = 0, j = a.length - 1;
                                                    while (i <= j) { if (i <= j) out.push(a[i++]); if (i <= j) out.push(a[j--]); }
                                                    arpSeq = out; break;
                                                }
                                                case 'alt-center': {
                                                    const a = npcSlice.slice(); const out = [];
                                                    if (a.length === 0) { arpSeq = out; break; }
                                                    const mid = Math.floor((a.length - 1) / 2); let l = mid, r = mid + 1;
                                                    if (a.length % 2 === 1) { out.push(a[mid]); l = mid - 1; r = mid + 1; }
                                                    while (l >= 0 || r < a.length) { if (r < a.length) out.push(a[r++]); if (l >= 0) out.push(a[l--]); }
                                                    arpSeq = out; break;
                                                }
                                                default:
                                                    arpSeq = npcSlice;
                                            }
                                        }
                                    }
                                    const mapAscRef = rotated;
                                    omnichord._arp.pendingSwitch = {
                                        atAbsTick: targetAbsTick >>> 0,
                                        alignPhaseToTickCounter: true, // align seq phase to transport tick
                                        // Run ARP ticks while optionally sustaining a full chord
                                        seq: arpSeq,
                                        bassFreq: omnichord._arp.bassFreq,
                                        holdTicks: holdTicks,
                                        column: col,
                                        mapAsc: mapAscRef,
                                        mode: 'arp',
                                        npc: npcGlobal,
                                        enableChord: chordsOn,
                                        chordRows
                                    };
                                    // Ensure HOLD doesn't cut transport during sequencing
                                    omnichord._arpTransport.holdStopAtAbsTick = null;
                                    omnichord._startArpTransport();
                                } catch(_) {}
                                // Schedule next chord after the configured HOLD length
                                // Use the same holdTicks computed above to keep cadence consistent
                                try { if (omnichord._seqTimer) { clearTimeout(omnichord._seqTimer); } } catch(_){}
                                
                                // Schedule strictly by computed holdTicks (per chordbox len16)
                                const tickMs = omnichord._arpTransport.tickMs || 250;
                                const totalHoldMs = Math.max(20, Math.round(holdTicksForStep * tickMs));
                                
                                // Schedule next chord strictly by HOLD duration
                                omnichord._seqTimer = setTimeout(scheduleNext, totalHoldMs);
                            };
                            scheduleNext();
                        } catch(_) {}
                    });
                } // END DISABLED playBtn section
                
                if (stopBtn && !stopBtn._wired){
                    stopBtn._wired = true;
                    stopBtn.addEventListener('click', ()=>{
                        try {
                            // Stop sequencing timer and clear state
                            try { if (omnichord._seqTimer) { clearTimeout(omnichord._seqTimer); omnichord._seqTimer = null; } } catch(_){}
                            omnichord._isSequencing = false;
                            // Clear any sustain/slide flags that could alter next run timing
                            try { omnichord._sustainActive = false; omnichord._chordsGestureActive = false; omnichord._chordSlideActive = false; } catch(_){ }
                            if (omnichord._arp) {
                                omnichord._arp.pendingSwitch = null;
                                omnichord._arp.active = false;
                                omnichord._arp.seq = [];
                            }
                            // Stop transport immediately
                            try { omnichord._stopArpTransport(); } catch(_){ }
                            // Silence all voices (lead and bass)
                            try { omnichord.stopAllActiveNotes(); } catch(_){ }
                        } catch(_) {}
                    });
                }
            } catch(_) {}

        // Auto-hide brand footer only when GLIDE menus are open
            try {
                const brandHost = document.getElementById('brandFooter') || document.getElementById('brandHost');
                const adjustBrand = ()=>{
                    try {
                        if (!brandHost) return;
                        const chordMenuOpen = !!document.getElementById('chordGlideMenu')?.classList.contains('open');
                        const arpMenuOpen = !!document.getElementById('arpGlideMenu')?.classList.contains('open');
                        const hide = chordMenuOpen || arpMenuOpen;
                        brandHost.style.display = hide ? 'none' : 'flex';
                    } catch(_) {}
                };
                window.addEventListener('resize', adjustBrand);
                setInterval(adjustBrand, 1000);
                adjustBrand();
            } catch(_) {}
            
            // Add event handler for chord name saving (ensure no root names are saved)
            const saveChordNameBtn = document.getElementById('saveChordName');
            if (saveChordNameBtn) {
                saveChordNameBtn.addEventListener('click', () => {
                    if (omnichord) {
                        omnichord.saveNewChord();
                    }
                });
            }

            // Startup is now in 24-EDO; do not auto-seed chords to avoid interfering with user-entered sequences
        });
        
        // Add exit prompt for saving to OMG file
        window.addEventListener('beforeunload', (e) => {
            if (omnichord && (omnichord.chordExtensions.length > 0 || omnichord.lockedChords?.size > 0)) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Would you like to save your session to an OMG file?';
                return e.returnValue;
            }
        });
             // Bottom bar panel toggling (uses existing migrated panel-content elements)
             (function(){
                 const bar=document.getElementById('bottomBar');
                 const topMenu=document.getElementById('universalMenu'); // Add top menu for panel buttons
                 const host=document.getElementById('panelHost');
                 if(!host) return;
                 const panels=[...host.querySelectorAll('.panel-content')];
                 let open=null;
                 function show(id){
                     panels.forEach(p=>{p.style.display = (p.dataset.panel===id)?'grid':'none';});
                    host.style.display='block';
                    // Ensure panel is visible at top of viewport
                    try { host.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch(_) {}
                 }
                 function close(){ 
                     host.style.display='none'; 
                     panels.forEach(p=>p.style.display='none'); 
                     open=null; 
                     // Remove active class from both bar and top menu buttons
                     if(bar) bar.querySelectorAll('.panel-btn').forEach(b=>b.classList.remove('active'));
                     if(topMenu) topMenu.querySelectorAll('.panel-btn').forEach(b=>b.classList.remove('active'));
                 }
                 // Expose programmatic closer on the main controller if available
                 if (window.omnichord) {
                     window.omnichord.closeBottomPanel = close;
                 } else {
                     // If not yet initialized, defer until DOMContentLoaded listeners create it
                     document.addEventListener('omnichord-ready', ()=>{ if (window.omnichord) window.omnichord.closeBottomPanel = close; }, { once:true });
                 }
                 
                 // Panel click handler function
                 function handlePanelClick(e) {
                     const btn = e.target.closest('.panel-btn[data-panel]');
                     if(!btn) return; // Ignore non-panel buttons like "+" and "SEQUENCE"
                     const id = btn.dataset.panel;
                     if(!id) return;
                     
                     // Route OSC and FX buttons to floating modals instead of panels
                     if (id === 'osc') {
                         const oscModal = document.getElementById('oscModal');
                         if (oscModal) {
                             oscModal.style.display = 'block';
                             bringModalToFront('oscModal');
                             if (!oscModal._draggableSet) {
                                 makeDraggable(oscModal);
                                 oscModal._draggableSet = true;
                             }
                         }
                         return;
                     }
                     
                     if (id === 'fx') {
                         const fxModal = document.getElementById('fxModal');
                         if (fxModal) {
                             fxModal.style.display = 'block';
                             bringModalToFront('fxModal');
                             if (!fxModal._draggableSet) {
                                 makeDraggable(fxModal);
                                 fxModal._draggableSet = true;
                             }
                         }
                         return;
                     }
                     
                     // Original panel logic for other panels
                     if(open===id){ close(); return; }
                     open = id;
                     show(id);
                     // Set active state on the clicked button only
                     if(bar) bar.querySelectorAll('.panel-btn').forEach(b=>b.classList.toggle('active',b===btn));
                     if(topMenu) topMenu.querySelectorAll('.panel-btn').forEach(b=>b.classList.toggle('active',b===btn));
                 }
                 
                 // Listen for panel buttons in both bottom bar and top menu
                 if(bar) bar.addEventListener('click', handlePanelClick);
                 if(topMenu) topMenu.addEventListener('click', handlePanelClick);
                 
                 window.addEventListener('keydown',e=>{ if(e.key==='Escape') close(); });
                 window.addEventListener('click',e=>{ 
                     if(open && !host.contains(e.target) && 
                        (!bar || !bar.contains(e.target)) && 
                        (!topMenu || !topMenu.contains(e.target))) close(); 
                 });
             })();
             
             // Initialize universal controls
             (function() {
                 // Sync initial values - defer if omnichord not ready yet
                 if (typeof window.omnichord !== 'undefined' && window.omnichord.syncUniversalControls) {
                     window.omnichord.syncUniversalControls();
                 }
                    // Helper to schedule 2-beat deferred apply
                    function scheduleDeferred(flags){
                        if (typeof window.omnichord === 'undefined') return;
                        try {
                            omnichord._ensureArpTransport();
                            const t = omnichord._arpTransport;
                            const tpBeat = Math.max(1, t.ticksPerBeat||1);
                            const tpBar = Math.max(tpBeat, t.ticksPerBar||((t.beatsPerBar||4) * tpBeat));
                            const curTick = t.tickCounter|0;
                            const nowAbs = t.absTickCounter|0;
                            const ticksToNextBar = (tpBar - (curTick % tpBar)) % tpBar;
                            // Always apply on the NEXT bar boundary (never immediately)
                            const offset = (ticksToNextBar === 0 ? tpBar : ticksToNextBar);
                            t.deferApplyAtAbsTick = (nowAbs + offset) >>> 0;
                            const cur = t.deferFlags || {};
                            const nextFlags = { ...cur };
                            const incoming = flags || {};
                            Object.keys(incoming).forEach(key => {
                                if (key === 'pattern' && typeof incoming[key] === 'object') {
                                    nextFlags.pattern = {
                                        ...(cur.pattern || {}),
                                        ...incoming.pattern
                                    };
                                } else if (key === 'drums' && typeof incoming[key] === 'object') {
                                    nextFlags.drums = {
                                        ...(cur.drums || {}),
                                        ...incoming.drums
                                    };
                                } else {
                                    nextFlags[key] = incoming[key];
                                }
                            });
                            t.deferFlags = nextFlags;
                        } catch(_) { /* ignore */ }
                    }
                 
                 // Make scheduleDeferred globally accessible for drum controls\n                 window.scheduleDeferred = scheduleDeferred;\n                 // Universal control event handlers
                 const universalBpm = document.getElementById('universalBpm');
                 const universalQuant = document.getElementById('universalQuant');
                 const universalNpc = document.getElementById('universalNpc');
                 const universalHold = document.getElementById('universalHold');
                 const universalPattern = document.getElementById('universalPattern');
                 const universalGlide = document.getElementById('universalGlide');
                 const universalBass = document.getElementById('universalBass');
                 const universalTimeSignature = document.getElementById('universalTimeSignature');
                // Mini Drum header controls (mirror values + events)
                const drumBpmMini = document.getElementById('drumBpmMini');
                const drumTSMini = document.getElementById('drumTSMini');
                const drumQuantMini = document.getElementById('drumQuantMini');
                const drumNpcMini = null; // removed
                const drumSwingMini = null; // removed
                 
                 if (universalBpm) {
                     universalBpm.addEventListener('input', () => {
                         if (window.omnichord && window.omnichord.applyUniversalSettings) {
                             omnichord.applyUniversalSettings();
                         }
                         // Defer transport timing change by 2 beats
                         scheduleDeferred({ transport:true });
                         if (drumBpmMini) drumBpmMini.value = String(universalBpm.value||'');
                     });
                 }
                if (drumBpmMini && !drumBpmMini._wired) {
                    drumBpmMini._wired = true;
                    // Initial sync from universal
                    try { drumBpmMini.value = String(document.getElementById('universalBpm')?.value || ''); } catch(_) {}
                    drumBpmMini.addEventListener('input', ()=>{
                        const main = document.getElementById('universalBpm');
                        if (main) { main.value = String(drumBpmMini.value||''); main.dispatchEvent(new Event('input')); }
                    });
                }
                 // Wire MIDI settings controls if present
                 try {
                     const midiOctSel = document.getElementById('midiOctaveOffset');
                     const midiVelInput = document.getElementById('midiDefaultVelocity');
                     if (midiOctSel && !midiOctSel._wired) {
                         midiOctSel._wired = true;
                         midiOctSel.addEventListener('change', ()=>{
                             try { midi.octaveOffset = parseInt(midiOctSel.value||'0',10) || 0; midi.saveMIDISettings(); } catch(_) {}
                             scheduleDeferred({ midi:true });
                         });
                     }
                     if (midiVelInput && !midiVelInput._wired) {
                         midiVelInput._wired = true;
                         midiVelInput.addEventListener('input', ()=>{
                             try {
                                 const v = Math.max(1, Math.min(127, parseInt(midiVelInput.value||'100',10)));
                                 midi.defaultVelocity = v;
                                 midi.saveMIDISettings();
                             } catch(_) {}
                             scheduleDeferred({ midi:true });
                         });
                     }
                 } catch(_) {}
                 
                 if (universalTimeSignature) {
                     universalTimeSignature.addEventListener('change', () => {
                         if (window.omnichord && window.omnichord.applyUniversalSettings) {
                             omnichord.applyUniversalSettings();
                         }
                         // Defer grid/transport updates to bar-safe boundary
                         scheduleDeferred({ transport:true, grid:true });
                         if (drumTSMini) drumTSMini.value = String(universalTimeSignature.value||'');
                     });
                 }
                if (drumTSMini && !drumTSMini._wired) {
                    drumTSMini._wired = true;
                    try { drumTSMini.value = String(document.getElementById('universalTimeSignature')?.value || ''); } catch(_) {}
                    drumTSMini.addEventListener('change', ()=>{
                        const main = document.getElementById('universalTimeSignature');
                        if (main) { main.value = String(drumTSMini.value||''); main.dispatchEvent(new Event('change')); }
                    });
                }
                 
                 if (universalQuant) {
                     universalQuant.addEventListener('change', () => {
                         if (window.omnichord && window.omnichord.applyUniversalSettings) {
                             omnichord.applyUniversalSettings();
                         }
                         scheduleDeferred({ transport:true });
                         if (drumQuantMini) drumQuantMini.value = String(universalQuant.value||'');
                     });
                 }
                if (drumQuantMini && !drumQuantMini._wired) {
                    drumQuantMini._wired = true;
                    try { drumQuantMini.value = String(document.getElementById('universalQuant')?.value || ''); } catch(_) {}
                    drumQuantMini.addEventListener('change', ()=>{
                        const main = document.getElementById('universalQuant');
                        if (main) { main.value = String(drumQuantMini.value||''); main.dispatchEvent(new Event('change')); }
                    });
                    // Arrow up/down to increment/decrement denominator when single-number or N/D is present
                    drumQuantMini.addEventListener('keydown', (e)=>{
                        if (e.key !== 'ArrowUp' && e.key !== 'ArrowDown') return;
                        try {
                            const s = String(drumQuantMini.value||'').trim();
                            let N = null, D = null, isFrac = false;
                            const mf = s.match(/^(\d+)\s*\/\s*(\d+)$/);
                            if (mf) { isFrac = true; N = parseInt(mf[1],10)||0; D = parseInt(mf[2],10)||0; }
                            else { const mn = s.match(/^(\d+)$/); if (mn) { D = parseInt(mn[1],10)||0; N = D; } }
                            if (!D) { D = 16; N = 16; }
                            const delta = (e.key === 'ArrowUp') ? 1 : -1;
                            const newD = Math.max(1, Math.min(64, D + delta));
                            const out = isFrac ? `${N}/${newD}` : String(newD);
                            drumQuantMini.value = out;
                            // Immediately propagate to universal quant
                            const main = document.getElementById('universalQuant');
                            if (main) { main.value = out; main.dispatchEvent(new Event('change')); }
                            e.preventDefault();
                        } catch(_){ }
                    });
                }
                 
                 if (universalNpc) {
                     universalNpc.addEventListener('input', () => {
                         if (window.omnichord && window.omnichord.applyUniversalSettings) {
                             omnichord.applyUniversalSettings();
                         }
                     });
                 }
                 
                 if (universalHold) {
                     universalHold.addEventListener('change', () => {
                         if (window.omnichord && window.omnichord.applyUniversalSettings) {
                             omnichord.applyUniversalSettings();
                         }
                     });
                 }
                 // Swing control (ARP)
                 const universalSwing = document.getElementById('universalSwing');
                 if (universalSwing && !universalSwing._wired) {
                     universalSwing._wired = true;
                     try {
                         const saved = localStorage.getItem('xen_swing_pct');
                         if (saved != null) universalSwing.value = String(Math.max(0, Math.min(75, parseFloat(saved)||0)));
                     } catch(_) {}
                     universalSwing.addEventListener('input', ()=>{
                         if (typeof window.omnichord === 'undefined') return;
                         try {
                             const v = Math.max(0, Math.min(75, parseFloat(universalSwing.value||'0')));
                             if (!omnichord._arpTransport) omnichord._ensureArpTransport();
                             if (omnichord._arpTransport) {
                                 if (omnichord._arpTransport.running) {
                                     omnichord._arpTransport.pendingSwingPct = v;
                                 } else {
                                     omnichord._arpTransport.swingPct = v;
                                 }
                             }
                             try { localStorage.setItem('xen_swing_pct', String(v)); } catch(_) {}
                         } catch(_) {}
                         scheduleDeferred({ swing:true });
                     });
                 }
                 
                 if (universalPattern) {
                     // Store previous NPC for CUSTOM mode switching
                     if (!window._previousNpcForCustom) {
                         window._previousNpcForCustom = 3; // default
                     }
                     
                     universalPattern.addEventListener('change', () => {
                         const universalNpc = document.getElementById('universalNpc');
                         const selectedPattern = universalPattern.value;
                         const patternTextEl = document.getElementById('universalPatternText');
                             // Flag whether CUSTOM mode is active so schedulers can gate behavior
                             try { if (window.omnichord) window.omnichord._patternModeCustom = (selectedPattern === 'custom'); } catch(_) {}
                         
                         if (selectedPattern === 'custom') {
                             // CUSTOM mode: NPC is now user-controllable (no lock)
                             if (universalNpc) {
                                 universalNpc.readOnly = false; // Allow NPC changes in CUSTOM mode
                             }
                             // Clear pattern text initially for CUSTOM mode
                             if (patternTextEl) patternTextEl.value = '';
                         } else {
                             // Switching FROM CUSTOM to regular pattern
                             if (universalNpc) {
                                 universalNpc.readOnly = false; // Ensure NPC field is editable
                             }
                             // Clear pattern text AND grid for non-CUSTOM modes
                             if (patternTextEl) patternTextEl.value = '';
                             
                             // Clear pattern grid visual state
                             const patternGrid = document.getElementById('patternGrid');
                             if (patternGrid) {
                                 const activeSteps = patternGrid.querySelectorAll('.pattern-step.active');
                                 activeSteps.forEach(step => step.classList.remove('active'));
                             }
                         }
                         
                         if (window.omnichord && window.omnichord.applyUniversalSettings) {
                             omnichord.applyUniversalSettings();
                             omnichord.updateModeUI(); // Update strum button text when pattern changes
                         }
                     });
                 }
                 const universalPatternText = document.getElementById('universalPatternText');
                 // Initialize pattern text as empty on startup (only populate when CUSTOM mode is selected)
                 if (universalPatternText) {
                     universalPatternText.value = '';
                 }
                 if (universalPatternText && !universalPatternText._wired) {
                     universalPatternText._wired = true;
                     const handler = ()=>{
                         if (typeof window.omnichord === 'undefined') return;
                         try {
                             omnichord.applyUniversalSettings();
                             // Rebuild ARP sequence on next edge if active (only when PLAY is running)
                             if (omnichord._isSequencing && omnichord._arp && omnichord._arp.column) {
                                 const col = omnichord._arp.column;
                                 const rowsAll = Array.from(col.querySelectorAll('.strings-column .string'));
                                 const within = rowsAll.filter(r => { const o=parseInt(r.dataset.octave||'0',10); return o>=5 && o<=9; });
                                 const npc = Math.max(1, (omnichord._getGlobalNpc ? omnichord._getGlobalNpc() : (omnichord._arp?.npc|0) || 3));
                                 const seq = omnichord._buildArpSequence(within, omnichord._arp.pattern||'up', null).slice(0, npc);
                                 if (!omnichord._arpTransport) omnichord._ensureArpTransport();
                                 const absTick = omnichord._arpTransport.absTickCounter|0;
                                 omnichord._arp.pendingSwitch = { atAbsTick: (absTick+1)>>>0, alignPhaseToTickCounter:false, seq, bassFreq:omnichord._arp.bassFreq, column:col };
                                 omnichord._startArpTransport();
                             }

                            /* ================= INDEPENDENT PATTERN TRANSPORT =================
                               Provides its own tick counter decoupled from drum/ARP bar length.
                               Guarantees loop at patternLen (data-length on #patternGrid) rather than bar ticks.
                               Uses same BPM & quant base but computes patternTicksPerStep so every step == one grid cell.
                               Protects against note dropping when OSC release tails overlap by tracking active pattern voices.
                            */
                            (function initPatternTransport(){
                                const pg = document.getElementById('patternGrid');
                                if (!pg) return;
                                if (window._patternTransport) return; // singleton
                                const pt = window._patternTransport = {
                                    running: false,
                                    tickCounter: 0,         // counts pattern steps (0..len-1)
                                    absTickCounter: 0,
                                    nextAt: performance.now(),
                                    stepMs: 120,            // dynamic (updated from BPM + quant base)
                                    lastLen: parseInt(pg.dataset.length||'16',10)||16,
                                    activeVoices: new Set(), // track currently sounding pattern notes (id strings)
                                    swingPct: 0,
                                    lastSwingPhase: 0,
                                    guardSkips: 0,
                                    _rafActive: false
                                };
                                // Derive stepMs from universalQuant base (each pattern cell == quant subdivision baseline)
                                function refreshTiming(){
                                    try {
                                        const bpmEl = document.getElementById('universalBpm');
                                        const transportBpmEl = document.getElementById('transportBpm');
                                        const quantEl = document.getElementById('universalQuant');
                                        const patternQuantEl = document.getElementById('patternQuant');
                                        const swingEl = document.getElementById('universalSwing');
                                        // Priority: __MASTER_BPM > transportBpm > universalBpm > default 120
                                        const bpm = Math.max(20, window.__MASTER_BPM || parseFloat(transportBpmEl?.value||'0') || parseFloat(bpmEl?.value||'120')||120);
                                        const quant = (patternQuantEl?.value || quantEl?.value||'1/16').trim();
                                        // Parse quant like 1/16, 1/8T, tuplet:5/4
                                        let baseDiv = 16; let isTrip = false; let tupletRatio = 1;
                                        if (/tuplet:\s*(\d+)\/(\d+)/i.test(quant)) {
                                            const m = quant.match(/tuplet:\s*(\d+)\/(\d+)/i); const n=+m[1], d=+m[2]; if(n>0&&d>0) tupletRatio = n/d; baseDiv = 4; // treat quarter as base then scale
                                        } else if (/^1\/(\d+)(t)?$/i.test(quant)) {
                                            const m = quant.match(/^1\/(\d+)(t)?$/i); baseDiv = parseInt(m[1],10)||16; if(m[2]) isTrip=true; }
                                        const beatMs = 60000 / bpm; // quarter note
                                        let stepMs = beatMs * 4 / baseDiv; // if baseDiv=16 -> 1/16
                                        if (isTrip) stepMs *= (2/3); // triplet shorten
                                        if (tupletRatio !== 1) stepMs *= (1/tupletRatio);
                                        const swingPct = Math.max(0, Math.min(75, parseFloat(swingEl?.value||'0')||0));
                                        pt.stepMs = stepMs;
                                        pt.swingPct = swingPct;
                                    } catch(_){}
                                }
                                refreshTiming();
                                // Recalculate timing when universal controls change
                                ['universalBpm','universalQuant','universalSwing','patternQuant'].forEach(id=>{
                                    const el = document.getElementById(id); if(!el) return; el.addEventListener('input', refreshTiming); el.addEventListener('change', refreshTiming);
                                });
                                function patternTokensForColumn(col){
                                    // Extract active notes at a step col reading patternGrid DOM
                                    const lanes = pg.querySelectorAll('.pattern-row');
                                    const notes = [];
                                    lanes.forEach((row,idx)=>{
                                        const lane = row.querySelector('.pattern-lane');
                                        if(!lane) return;
                                        const cell = lane.querySelector(`.pattern-step[data-step="${col}"]`);
                                        if(!cell) return;
                                        if (cell.classList.contains('disabled')) return; // respect N/D gating
                                        if(cell.classList.contains('active')){
                                            // Determine sustain length
                                            let len = parseInt(cell.dataset.len||'1',10)||1;
                                            // Only fire note-on on the origin (not tied continuation)
                                            const tie = cell.dataset.tie === '1';
                                            const vel = (window.getStepVelocity ? (window.getStepVelocity(cell) ?? 100) : (parseInt(cell.dataset.vel||'100',10)||100));
                                            if(!tie){ notes.push({row:idx, len, vel}); }
                                        }
                                    });
                                    return notes;
                                }
                                function noteId(row,col){ return `r${row}c${col}`; }
                                function scheduleStep(stepIndex){
                                    // Strict gating: if PATTERN not active, do not schedule notes
                                    try {
                                        const patternBtn = document.getElementById('patternBtn');
                                        const patActive = !!(patternBtn && patternBtn.classList.contains('active'));
                                        if (!patActive) {
                                            if (pt.activeVoices.size){
                                                try { console.log('[PATTERN] Gated (button off). Stopping', pt.activeVoices.size, 'voices'); } catch(_){}
                                                for (const vid of Array.from(pt.activeVoices)){
                                                    const meta = pt[vid];
                                                    try { if (meta && meta.stop) meta.stop(); } catch(_){}
                                                    pt.activeVoices.delete(vid); delete pt[vid];
                                                }
                                            }
                                            return;
                                        }
                                    } catch(_){}
                                    const len = parseInt(pg.dataset.length||'16',10)||16;
                                    const fireIdx = stepIndex % len;
                                        // No pattern playhead UI updates (performance + aesthetics)
                                    // Collect notes
                                    const notes = patternTokensForColumn(fireIdx);
                                    // Clear any voices whose sustain expired
                                    if (pt.activeVoices.size){
                                        for (const vid of Array.from(pt.activeVoices)){
                                            const meta = pt[vid];
                                            if (meta && meta.offStep <= stepIndex){
                                                // Send note-off if needed
                                                try { if (meta.stop) meta.stop(); } catch(_){ }
                                                pt.activeVoices.delete(vid); delete pt[vid];
                                            }
                                        }
                                    }
                                    // Trigger new note-ons
                                    notes.forEach(n=>{
                                        const vid = noteId(n.row, fireIdx);
                                        const offStep = stepIndex + n.len; // absolute in pattern stepCounter units
                                        // Fire note (placeholder: call existing MIDI / synth path) â€” reuse omnichord functions if present
                                        let stopFn = null;
                                        try {
                                            if (window.omnichord && typeof window.omnichord._playPatternNote === 'function') {
                                                stopFn = window.omnichord._playPatternNote(n.row, n.len, fireIdx, n.vel);
                                            }
                                        } catch(_){ }
                                        pt.activeVoices.add(vid);
                                        pt[vid] = { offStep, stop: stopFn };
                                        try { console.log('[PATTERN] row', n.row, 'col', fireIdx, 'len', n.len, 'vel', n.vel); } catch(_){}
                                    });
                                }
                                function loop(){
                                    // Track rAF activity to allow external restarts when stopped
                                    pt._rafActive = true;
                                    if(!pt.running){ pt._rafActive = false; return; }
                                    const now = performance.now();
                                    if (now + 1 >= pt.nextAt){ // allow small lookahead tolerance
                                        // Calculate dynamic step duration with swing: even steps extended, odd shortened
                                        const base = pt.stepMs;
                                        const isEven = (pt.tickCounter % 2)===0;
                                        let stepDur = base;
                                        if (pt.swingPct>0){
                                            const swingFactor = pt.swingPct/100;
                                            if (isEven) stepDur = base * (1 + swingFactor*0.5); else stepDur = base * (1 - swingFactor*0.5);
                                        }
                                        scheduleStep(pt.tickCounter);
                                        pt.tickCounter = (pt.tickCounter + 1) >>> 0;
                                        pt.absTickCounter = (pt.absTickCounter + 1) >>> 0;
                                        const len = parseInt(pg.dataset.length||'16',10)||16;
                                        // Hard wrap visual relative index, but absolute continues (for offStep tracking)
                                        if (pt.tickCounter >= 100000000) pt.tickCounter = pt.tickCounter % len; // prevent overflow long-run
                                        pt.nextAt += stepDur;
                                    }
                                    // Guard against drift: if loop falls far behind, resync to now
                                    if (pt.nextAt - now > 5000) pt.nextAt = now + pt.stepMs;
                                    requestAnimationFrame(loop);
                                }
                                pt.nextAt = performance.now() + pt.stepMs;
                                // Do not start rAF loop until PLAY; call pt.kick() on PLAY to begin
                                // requestAnimationFrame(loop);
                                // Public helper to restart the rAF loop after a STOP
                                pt.kick = function(){ if (!pt._rafActive) { try { requestAnimationFrame(loop); } catch(_){ } } };
                                // Public helper to force timing refresh (e.g., after LEN change for UI)
                                window.refreshPatternTransportTiming = refreshTiming;
                            })();
                         } catch(_) {}
                     };
                     universalPatternText.addEventListener('change', handler);
                     universalPatternText.addEventListener('input', (e)=>{ if (e.inputType==='insertReplacementText') handler(); });
                 }
                 
                 // Bass button is wired earlier via omnichord.toggleBassMode
                 
                // TIME modal wiring
                (function(){
                    const timeBtn = document.getElementById('openTimeModalBtn');
                    const modal = document.getElementById('timeModal');
                    const closeBtn = document.getElementById('closeTimeModalBtn');
                    if (timeBtn && modal) {
                        timeBtn.addEventListener('click', () => { modal.style.display = 'flex'; });
                        if (closeBtn) closeBtn.addEventListener('click', () => { modal.style.display = 'none'; });
                        if (modal) modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });
                    }
                })();
                 
                 // Do not auto-start background clock; only PLAY should start transports
                 // Initial mode UI update
                 if (window.omnichord && window.omnichord.updateModeUI) {
                    try { window.omnichord._patternModeCustom = (document.getElementById('universalPattern')?.value === 'custom'); } catch(_) {}
                     omnichord.updateModeUI();
                 }

                // Auto-initialize MIDI (silent) if not already enabled and API available
                try {
                    if (window.omnichord && !window.omnichord._midiAutoInitTried) {
                        window.omnichord._midiAutoInitTried = true;
                        const midiToggleBtn = document.getElementById('midiToggle');
                        // If the internal MIDI manager exists and not enabled, attempt init
                        if (window.omnichord.midi && !window.omnichord.midi.enabled && navigator.requestMIDIAccess) {
                            window.omnichord.midi.init().then(ok=>{
                                if (ok) console.log('[MIDI] Auto-init success'); else console.warn('[MIDI] Auto-init failed');
                            }).catch(e=>console.warn('[MIDI] Auto-init error', e));
                        } else if (midiToggleBtn && navigator.requestMIDIAccess) {
                            // Fallback: simulate a click to run existing wiring
                            try { midiToggleBtn.click(); } catch(_){ }
                        }
                    }
                } catch(e) { console.warn('MIDI auto-init exception', e); }
                 
                // Simple sidebar button handler function (define only if not already defined earlier)
                if (!window.sidebarBtnClick) window.sidebarBtnClick = function(buttonType) {
                    console.log(`${buttonType.toUpperCase()} button clicked`);
                    const btn = document.getElementById(buttonType + 'Btn');
                    if (!btn) return;
                    
                    btn.classList.toggle('active');
                    
                    switch(buttonType) {
                        case 'keyboard':
                            const section = document.getElementById('keyboardSection');
                            if (section) {
                                section.style.display = btn.classList.contains('active') ? 'block' : 'none';
                            }
                            break;
                            
                        case 'strum':
                            if (window.omnichord && typeof omnichord.toggleStrumMode === 'function') {
                                omnichord.toggleStrumMode();
                            }
                            break;
                            
                        case 'arp':
                            if (window.omnichord && typeof omnichord.toggleChordArpMode === 'function') {
                                omnichord.toggleChordArpMode();
                            }
                            break;
                            
                        case 'pattern':
                            if (btn.classList.contains('active')) {
                                if (typeof showPatternModal === 'function') showPatternModal();
                            } else {
                                if (typeof closePatternModal === 'function') closePatternModal();
                            }
                            break;
                            
                        case 'chords':
                            // Chords are always enabled by default
                            break;
                            
                        case 'drums':
                            if (btn.classList.contains('active')) {
                                if (typeof showDrumModal === 'function') showDrumModal();
                            } else {
                                if (typeof closeDrumModal === 'function') closeDrumModal();
                            }
                            break;
                            
                        case 'bass':
                            if (window.omnichord && typeof omnichord.toggleBassMode === 'function') {
                                omnichord.toggleBassMode();
                            }
                            break;
                            
                        case 'midi':
                            const midiActive = btn.classList.contains('active');
                            if (window.omnichord) {
                                omnichord.midiBypassOscillators = midiActive;
                            }
                            const midiToggle = document.getElementById('midiToggle');
                            if (midiToggle && typeof midiToggle.click === 'function') {
                                midiToggle.click();
                            }
                            break;
                    }
                };
                else { console.log('Sidebar button handler already defined earlier, skipping rebind'); }
                
                console.log('Sidebar button handler ready');
                
                /* ================= SIDEBAR MODULE BUTTONS & MODALS =================
                   Wire up the new left sidebar buttons to control module states and floating modals.
                */
                
                // Modal control functions (define only if not already defined earlier)
                if (!window.showDrumModal) window.showDrumModal = function() {
                    console.log('Opening drum modal');
                    const modal = document.getElementById('drumModal');
                    if (modal) {
                        modal.style.display = 'block';
                        makeDraggable(modal);
                    }
                };
                
                if (!window.closeDrumModal) window.closeDrumModal = function() {
                    const modal = document.getElementById('drumModal');
                    if (modal) modal.style.display = 'none';
                    const btn = document.getElementById('drumsBtn');
                    if (btn) btn.classList.remove('active');
                };
                
                if (!window.showPatternModal) window.showPatternModal = function() {
                    console.log('Opening pattern modal');
                    const modal = document.getElementById('patternModal');
                    if (modal) {
                        modal.style.display = 'block';
                        makeDraggable(modal);
                    }
                };
                
                if (!window.closePatternModal) window.closePatternModal = function() {
                    const modal = document.getElementById('patternModal');
                    if (modal) modal.style.display = 'none';
                    const btn = document.getElementById('patternBtn');
                    if (btn) btn.classList.remove('active');
                };
                
                // Make modals draggable by header
                function makeDraggable(element) {
                    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
                    const header = element.querySelector('.modal-header');
                    if (!header) return;
                    
                    header.style.touchAction = 'none'; // Prevent default touch behaviors
                    header.onmousedown = dragMouseDown;
                    header.ontouchstart = dragTouchStart;
                    
                    function dragMouseDown(e) {
                        e = e || window.event;
                        // Ignore drag if the touch/click is on the close button
                        try { if (e.target && e.target.closest && e.target.closest('.modal-close')) return; } catch(_){ }
                        e.preventDefault();
                        pos3 = e.clientX;
                        pos4 = e.clientY;
                        document.onmouseup = closeDragElement;
                        document.onmousemove = elementDrag;
                    }
                    
                    function dragTouchStart(e) {
                        // Ignore drag if the touch is on the close button
                        try { const t = (e.touches && e.touches[0]) ? e.touches[0].target : e.target; if (t && t.closest && t.closest('.modal-close')) return; } catch(_){ }
                        e.preventDefault();
                        const touch = e.touches[0];
                        pos3 = touch.clientX;
                        pos4 = touch.clientY;
                        document.ontouchend = closeDragElement;
                        document.ontouchmove = elementDragTouch;
                    }
                    
                    function elementDrag(e) {
                        e = e || window.event;
                        e.preventDefault();
                        pos1 = pos3 - e.clientX;
                        pos2 = pos4 - e.clientY;
                        pos3 = e.clientX;
                        pos4 = e.clientY;
                        element.style.top = (element.offsetTop - pos2) + "px";
                        element.style.left = (element.offsetLeft - pos1) + "px";
                    }
                    
                    function elementDragTouch(e) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        pos1 = pos3 - touch.clientX;
                        pos2 = pos4 - touch.clientY;
                        pos3 = touch.clientX;
                        pos4 = touch.clientY;
                        element.style.top = (element.offsetTop - pos2) + "px";
                        element.style.left = (element.offsetLeft - pos1) + "px";
                    }
                    
                    function closeDragElement() {
                        document.onmouseup = null;
                        document.onmousemove = null;
                        document.ontouchend = null;
                        document.ontouchmove = null;
                    }
                }
                
                // Global touch/pointer support for modal close buttons (red X)
                if (!window._modalCloseTouchWired) {
                    window._modalCloseTouchWired = true;
                    const invokeClose = (btn) => {
                        try {
                            // Prefer inline onclick via .click()
                            if (btn && typeof btn.click === 'function') { btn.click(); return; }
                        } catch(_) {}
                        // Fallback: hide the nearest modal container
                        try {
                            const modal = btn.closest('.floating-modal') || btn.closest('[id$="Modal"]');
                            if (modal) modal.style.display = 'none';
                        } catch(_) {}
                    };
                    const handler = (e) => {
                        try {
                            const target = e.target;
                            if (!target) return;
                            const btn = target.closest && target.closest('.modal-close');
                            if (!btn) return;
                            e.preventDefault();
                            e.stopPropagation();
                            invokeClose(btn);
                        } catch(_) {}
                    };
                    // Use capture to beat draggable header handlers; passive must be false to allow preventDefault
                    document.addEventListener('touchend', handler, { capture: true, passive: false });
                    document.addEventListener('pointerup', handler, { capture: true, passive: false });
                }
                
                // Simple sidebar button handler function (define only if not already defined earlier)
                if (!window.sidebarBtnClick) window.sidebarBtnClick = function(buttonType) {
                    console.log(`${buttonType.toUpperCase()} button clicked`);
                    const btn = document.getElementById(buttonType + 'Btn');
                    if (!btn) return;
                    
                    btn.classList.toggle('active');
                    
                    switch(buttonType) {
                        case 'keyboard':
                            const section = document.getElementById('keyboardSection');
                            if (section) {
                                section.style.display = btn.classList.contains('active') ? 'block' : 'none';
                            }
                            break;
                            
                        case 'strum':
                            if (window.omnichord && typeof omnichord.toggleStrumMode === 'function') {
                                omnichord.toggleStrumMode();
                            }
                            break;
                            
                        case 'arp':
                            if (window.omnichord && typeof omnichord.toggleChordArpMode === 'function') {
                                omnichord.toggleChordArpMode();
                            }
                            break;
                            
                        case 'pattern':
                            if (btn.classList.contains('active')) {
                                showPatternModal();
                            } else {
                                closePatternModal();
                            }
                            break;
                            
                        case 'chords':
                            // Chords are always enabled by default
                            break;
                            
                        case 'drums':
                            if (btn.classList.contains('active')) {
                                showDrumModal();
                            } else {
                                closeDrumModal();
                            }
                            break;
                            
                        case 'bass':
                            if (window.omnichord && typeof omnichord.toggleBassMode === 'function') {
                                omnichord.toggleBassMode();
                            }
                            break;
                            
                        case 'midi':
                            const midiActive = btn.classList.contains('active');
                            if (window.omnichord) {
                                omnichord.midiBypassOscillators = midiActive;
                            }
                            const midiToggle = document.getElementById('midiToggle');
                            if (midiToggle && typeof midiToggle.click === 'function') {
                                midiToggle.click();
                            }
                            break;
                    }
                };
                else { console.log('Sidebar button handler already defined earlier, skipping rebind'); }
                
                console.log('Sidebar button handler ready');
                
                // Initialize default states
                try {
                    const chordsBtn = document.getElementById('chordsBtn');
                    const bassBtn = document.getElementById('bassBtn');
                    
                    if (chordsBtn && window.omnichord) chordsBtn.classList.toggle('active', !!omnichord.chordsEnabled);
                    if (bassBtn && window.omnichord) bassBtn.classList.toggle('active', !!omnichord.bassEnabled);
                    
                    // Open keyboard modal by default (for half-screen layout)
                    const keyboardBtn = document.getElementById('keyboardBtn');
                    if (keyboardBtn) {
                        keyboardBtn.classList.add('active');
                        // Show keyboard modal on startup
                        setTimeout(() => {
                            if (typeof showKeyboardModal === 'function') {
                                showKeyboardModal();
                            }
                        }, 100);
                    }
                    
                    // Ensure rootGrid exists for keyboard functionality
                    const rootGrid = document.getElementById('rootGrid');
                    if (rootGrid) {
                        console.log('Root grid found, keyboard modal will work');
                    } else {
                        console.error('Root grid not found - keyboard modal will not work!');
                    }
                    
                    console.log('Sidebar buttons initialized');
                } catch(e) {
                    console.error('Error initializing sidebar:', e);
                }
                
             })();
    </script>
    <script>
    // Ensure TIME button opens the modal even if earlier setup didn't wire it
    (function(){
        const bind = () => {
            const btn = document.getElementById('openTimeModalBtn');
            const modal = document.getElementById('timeModal');
            const closeBtn = document.getElementById('closeTimeModalBtn');
            if (!btn || !modal) return false;
            if (!btn._wiredTime) {
                btn._wiredTime = true;
                btn.addEventListener('click', () => { modal.style.display = 'flex'; });
            }
            if (closeBtn && !closeBtn._wiredTime) {
                closeBtn._wiredTime = true;
                closeBtn.addEventListener('click', () => { modal.style.display = 'none'; });
            }
            if (!modal._wiredBackdrop) {
                modal._wiredBackdrop = true;
                modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });
            }
            return true;
        };
        if (!bind()) {
            document.addEventListener('DOMContentLoaded', bind, { once: true });
        }
    })();
    </script>
    
    <script>
    // New Transport Controls functionality (unified with SPACE key logic & master BPM)
    (function(){
        const bind = () => {
            // Transport button handlers
            const playBtn = document.getElementById('playStopTransportBtn');
            const loopToggle = document.getElementById('loopToggle');
            const bpmInput = document.getElementById('transportBpm');
            const legacyPlayToggle = document.getElementById('playStopToggleBtn'); // existing main sequencer button used by SPACE handler

            // Master BPM setter - single source of truth
            function setMasterBpm(raw){
                const bpm = Math.max(20, Math.min(300, parseInt(raw,10) || 120));
                if (window.omnichord && window.omnichord._arpTransport) {
                    window.omnichord._arpTransport.bpm = bpm;
                }
                if (window._patternTransport) {
                    window._patternTransport.bpm = bpm;
                }
                if (bpmInput && bpmInput.value != bpm) bpmInput.value = bpm;
                const drumBpm = document.getElementById('drumBpmMini');
                if (drumBpm && drumBpm.value != bpm) drumBpm.value = bpm;
                const patternBpm = document.getElementById('patternBpm');
                if (patternBpm && patternBpm.value != bpm) patternBpm.value = bpm;
                window.__MASTER_BPM = bpm;
                return bpm;
            }

            // Master volume setter for both oscillators and MIDI
            function setMasterVolume(raw){
                const vol = Math.max(0, Math.min(10, parseFloat(raw) || 10));
                const linear = vol * 0.1; // 0-1 range
                if (window.omnichord) {
                    // Don't override if MIDI has muted (preserve _preMidiMasterVolume logic)
                    if (window.omnichord._preMidiMasterVolume === undefined) {
                        window.omnichord.masterVolume = linear;
                        if (window.omnichord.gainNode) window.omnichord.gainNode.gain.value = window.omnichord.volume * linear;
                        if (window.omnichord.dryGainNode) window.omnichord.dryGainNode.gain.value = linear;
                        if (window.omnichord.reverbOutGain) window.omnichord.reverbOutGain.gain.value = linear;
                    }
                }
                const volInput = document.getElementById('transportMasterVolume');
                if (volInput && volInput.value != vol) volInput.value = vol;
                const legacyVol = document.getElementById('masterVolume');
                if (legacyVol && legacyVol.value != vol) legacyVol.value = vol;
                const volValue = document.getElementById('masterVolumeValue');
                if (volValue) volValue.textContent = Math.round(vol * 10) + '%';
                return vol;
            }

            // Initialize master BPM
            if (typeof window.__MASTER_BPM === 'undefined') {
                const seed = (bpmInput && bpmInput.value) || (document.getElementById('drumBpmMini')?.value) || (document.getElementById('patternBpm')?.value) || 120;
                setMasterBpm(seed);
            } else {
                setMasterBpm(window.__MASTER_BPM);
            }

            if (playBtn && !playBtn._xenPlayWired) {
                playBtn._xenPlayWired = true;
                playBtn._wired = true;
                playBtn.addEventListener('click', () => {
                    // Always re-query: the bracket-aware wiring replaces the legacy button node.
                    const livePlayToggle = document.getElementById('playStopToggleBtn');
                    if (livePlayToggle) {
                        livePlayToggle.click();
                        setTimeout(()=>{ try { window.omnichord && window.omnichord._reflectPlayUI && window.omnichord._reflectPlayUI(); } catch(_){ } }, 10);
                        return;
                    }
                    // Fallback: if legacy button is missing, toggle transport directly.
                    if (window.omnichord) {
                        const isPlaying = !!(window.omnichord._arpTransport && (window.omnichord._arpTransport.isRunning || window.omnichord._arpTransport.running));
                        if (isPlaying) window.omnichord._stopArpTransport && window.omnichord._stopArpTransport();
                        else window.omnichord._startArpTransport && window.omnichord._startArpTransport();
                        setTimeout(()=>{ try { window.omnichord && window.omnichord._reflectPlayUI && window.omnichord._reflectPlayUI(); } catch(_){ } }, 10);
                    }
                });
            }

            // Mirror legacy button state changes into compact playBtn
            if (legacyPlayToggle && playBtn && !legacyPlayToggle._mirrorToTransport) {
                legacyPlayToggle._mirrorToTransport = true;
                const observer = new MutationObserver(()=>{
                    const isSequencing = (window.omnichord && window.omnichord._isSequencing);
                    playBtn.innerHTML = isSequencing ? 'â¹' : 'â–¶'; // Unicode symbols
                    playBtn.style.background = isSequencing ? '#e74c3c' : '#27ae60';
                    playBtn.style.borderColor = isSequencing ? '#c0392b' : '#2ecc71';
                });
                observer.observe(legacyPlayToggle, { attributes:true, attributeFilter:['data-state','class','style']});
            }

            // Enhanced loop toggle with proper stop behavior
            const legacyLoop = document.getElementById('playLoop');
            if (loopToggle && legacyLoop && !loopToggle._wired) {
                loopToggle._wired = true;
                
                // Keep them in sync - transport toggle controls legacy checkbox
                loopToggle.addEventListener('change', () => {
                    legacyLoop.checked = loopToggle.checked;
                    if (window.omnichord && window.omnichord._arpTransport) {
                        window.omnichord._arpTransport.loopEnabled = loopToggle.checked;
                        // If unchecking loop and currently playing, prepare to stop after current cycle
                        if (!loopToggle.checked && window.omnichord._isSequencing) {
                            console.log('ðŸŽµ LOOP disabled - will stop after current cycle');
                            window.omnichord._arpTransport.stopAfterCurrentCycle = true;
                        }
                    }
                });
                
                // Also sync the other direction if legacy checkbox changes
                if (!legacyLoop._syncedToTransport) {
                    legacyLoop._syncedToTransport = true;
                    legacyLoop.addEventListener('change', () => {
                        loopToggle.checked = legacyLoop.checked;
                        if (window.omnichord && window.omnichord._arpTransport) {
                            window.omnichord._arpTransport.loopEnabled = legacyLoop.checked;
                            // If unchecking loop and currently playing, prepare to stop after current cycle
                            if (!legacyLoop.checked && window.omnichord._isSequencing) {
                                console.log('ðŸŽµ LOOP disabled - will stop after current cycle');
                                window.omnichord._arpTransport.stopAfterCurrentCycle = true;
                            }
                        }
                    });
                }
                
                // Initialize sync
                loopToggle.checked = legacyLoop.checked;
            }

            // BPM input handlers
            if (bpmInput && !bpmInput._wired) {
                bpmInput._wired = true;
                bpmInput.addEventListener('input', () => { setMasterBpm(bpmInput.value); });
            }
            const drumBpmMini = document.getElementById('drumBpmMini');
            if (drumBpmMini && !drumBpmMini._wired) {
                drumBpmMini._wired = true;
                drumBpmMini.addEventListener('input', ()=>{ setMasterBpm(drumBpmMini.value); });
            }
            const patternBpm = document.getElementById('patternBpm');
            // Wire transport master volume
            const transportVolInput = document.getElementById('transportMasterVolume');
            if (transportVolInput && !transportVolInput._wired) {
                transportVolInput._wired = true;
                transportVolInput.addEventListener('input', () => { setMasterVolume(transportVolInput.value); });
            }
            // Wire legacy master volume to sync with transport
            const legacyVolInput = document.getElementById('masterVolume');
            if (legacyVolInput && !legacyVolInput._wired) {
                legacyVolInput._wired = true;
                legacyVolInput.addEventListener('input', () => { setMasterVolume(legacyVolInput.value); });
            }
            if (patternBpm && !patternBpm._wired) {
                patternBpm._wired = true;
                patternBpm.addEventListener('input', ()=>{ setMasterBpm(patternBpm.value); });
            }

            // Wire up sidebar button handlers for moved menu items
            const createNewChordBtnSidebar = document.getElementById('createNewChordBtnSidebar');
            if (createNewChordBtnSidebar) {
                createNewChordBtnSidebar.addEventListener('click', () => {
                    const originalBtn = document.getElementById('createNewChordBtn');
                    if (originalBtn) originalBtn.click();
                });
            }
            
            const edoInput = document.getElementById('edoQuickInputSidebar');
            if (edoInput) {
                edoInput.addEventListener('input', () => {
                    const originalInput = document.getElementById('edoQuickInput');
                    if (originalInput) {
                        originalInput.value = edoInput.value;
                        originalInput.dispatchEvent(new Event('input'));
                    }
                });
                if (!edoInput._focusModal) {
                    edoInput._focusModal = true;
                    edoInput.addEventListener('focus', ()=>{ 
                        const m=document.getElementById('tuningModal'); 
                        if(m) {
                            m.style.display='block';
                            if (!m._draggableSet) {
                                makeDraggable(m);
                                m._draggableSet = true;
                            }
                        }
                    });
                }
            }
            
            const oscPanelBtn = document.getElementById('oscPanelBtn');
            if (oscPanelBtn) {
                oscPanelBtn.addEventListener('click', () => {
                    // Open OSC floating modal
                    const oscModal = document.getElementById('oscModal');
                    if (oscModal) {
                        oscModal.style.display = 'block';
                        bringModalToFront('oscModal');
                        if (!oscModal._draggableSet) {
                            makeDraggable(oscModal);
                            oscModal._draggableSet = true;
                        }
                    }
                });
            }
            
            const fxPanelBtn = document.getElementById('fxPanelBtn');
            if (fxPanelBtn) {
                fxPanelBtn.addEventListener('click', () => {
                    // Open FX floating modal
                    const fxModal = document.getElementById('fxModal');
                    if (fxModal) {
                        fxModal.style.display = 'block';
                        bringModalToFront('fxModal');
                        if (!fxModal._draggableSet) {
                            makeDraggable(fxModal);
                            fxModal._draggableSet = true;
                        }
                    }
                });
            }
            
            const seqPanelBtn = document.getElementById('seqPanelBtn');
            if (seqPanelBtn) {
                seqPanelBtn.addEventListener('click', () => {
                    const originalBtn = document.getElementById('openTextChordParserBtn');
                    if (originalBtn) originalBtn.click();
                });
            }
            
            const loadXenBtn = document.getElementById('loadXenBtn');
            if (loadXenBtn) {
                loadXenBtn.addEventListener('click', () => {
                    const originalBtn = document.getElementById('bottomImportOMGBtn');
                    if (originalBtn) originalBtn.click();
                });
            }
            
            const saveXenBtn = document.getElementById('saveXenBtn');
            if (saveXenBtn) {
                saveXenBtn.addEventListener('click', () => {
                    const originalBtn = document.getElementById('bottomExportOMGBtn');
                    if (originalBtn) originalBtn.click();
                });
            }

            // Close buttons for OSC/FX modals
            const closeOsc = document.getElementById('closeOscModal');
            if (closeOsc && !closeOsc._wired) { closeOsc._wired = true; closeOsc.addEventListener('click', ()=>{ const m=document.getElementById('oscModal'); if(m) m.style.display='none'; }); }
            const closeFx = document.getElementById('closeFxModal');
            if (closeFx && !closeFx._wired) { closeFx._wired = true; closeFx.addEventListener('click', ()=>{ const m=document.getElementById('fxModal'); if(m) m.style.display='none'; }); }
            const closeTuning = document.getElementById('closeTuningModal');
            if (closeTuning && !closeTuning._wired) { closeTuning._wired = true; closeTuning.addEventListener('click', ()=>{ const m=document.getElementById('tuningModal'); if(m) m.style.display='none'; }); }
            
            const tutorialBtnSidebar = document.getElementById('tutorialBtnSidebar');
            if (tutorialBtnSidebar) {
                tutorialBtnSidebar.addEventListener('click', () => {
                    const originalBtn = document.getElementById('tutorialButton');
                    if (originalBtn) originalBtn.click();
                });
            }
            
            return true;
        };
        
        if (!bind()) {
            document.addEventListener('DOMContentLoaded', bind, { once: true });
        }
    })();
    </script>
</body>
</html>




