<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>XENON</title>
    <!-- Retro font (Oswald) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --retro-font: 'Oswald','Arial Narrow','Helvetica Neue',Arial,sans-serif;
            /* Top bar height; tweaked by media query for touch later */
            --bar-h: 56px;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        /* Base layout and background (black background layer for modals) */
        body {
            font-family: var(--retro-font) !important;
            background: transparent; /* Transparent to show black background layer */
            color: #fff;
            overflow: hidden;
            /* Use dynamic viewport height to avoid mobile URL bar issues (with small-viewport fallback) */
            height: 100svh;
            height: 100dvh;
            padding-top: 0; /* No padding needed since transport is now floating */
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            padding-bottom: 0; /* No bottom padding - eliminate blue space */
        }

        /* Black background layer for clean modal presentation */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000; /* Pure black background */
            z-index: -1; /* Behind all content */
            pointer-events: none; /* Don't interfere with interactions */
        }

        .instrument {
            display: flex;
            flex-direction: column;
            height: calc(100dvh - 20px); /* Match minimal top padding for transport row */
            width: 100vw;
            padding-bottom: 0; /* Remove bottom padding to eliminate blue space */
        }

        .root-notes-area {
            height: 320px; /* more space for 10 drum lanes incl. BASS */
            background: #000000; /* Black background for clean modal layer */
            border-bottom: none;
            padding: 10px;
            display: flex;
            align-items: flex-start;
        }

        .strum-area {
            flex: 1 1 auto; /* fill remaining vertical space */
            position: relative;
            background: #000000; /* Black background for clean modal layer */
            overflow: hidden;
            display: flex;
            padding: 0;
            border: none;
            gap: 0;
            min-height: 200px;
            /* Position to the right of sidebar */
            margin-left: 80px;
            /* Anchor to XENON bar at bottom */
            position: absolute;
            top: 0;
            bottom: 28px; /* Height of XENON bar */
            left: 80px; /* Right of sidebar */
            right: 0;
            /* Remove vertical line by ensuring no borders on child elements */
        }

        .strum-area:hover {
            border-color: #8fb3d3;
        }

        /* Chord Resize Container */
        .chord-resize-container {
            position: relative;
            height: 100%;
            background: #000000; /* Explicit black background to prevent color blending */
            display: flex;
            flex-direction: column;
        }

        .chord-resize-handle {
            position: absolute;
            top: calc(50vh - 12px); /* Position just above the strum-area */
            left: 0;
            right: 0;
            height: 12px;
            background: linear-gradient(180deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border-bottom: 1px solid #333333; /* Dark gray border instead of blue */
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .chord-resize-handle:hover {
            background: linear-gradient(180deg, rgba(255,255,255,0.15), rgba(255,255,255,0.08));
        }

        .resize-grip {
            width: 30px;
            height: 3px;
            background: #8fb3d3;
            border-radius: 2px;
            opacity: 0.6;
        }

        .chord-resize-handle:hover .resize-grip {
            opacity: 1;
        }

        .clear-triads-container {
            display: flex;
            align-items: center;
        }

        .clear-triads-btn {
            background: linear-gradient(135deg, #e94560, #c73650);
            border: 1px solid #c73650;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .clear-triads-btn:hover {
            background: linear-gradient(135deg, #c73650, #a52a42);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .clear-triads-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .notes-area {
            height: 18vh;
            background: rgba(0, 20, 40, 0.8);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px;
        }

        .control-panel {
            /* Switch to dynamic viewport height so the math stays correct on mobile */
            height: calc(100dvh - 70px - 28vh - 28vh);
            min-height: 35vh;
            padding: 10px;
            margin-top: 0; /* Remove margin - sit directly below universal menu */
            overflow: visible;
            display: grid;
            grid-template-columns: 300px 200px 280px 1fr;
            gap: 15px;
            align-content: start;
            min-width: 0;
            width: 100%;
            position: relative; /* Ensure proper stacking context */
            z-index: 1; /* Above background elements */
        }


        .tuning-btn {
            padding: 6px 8px;
            background: #2a4858;
            border: 1px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 10px;
            white-space: nowrap;
            font-weight: bold;
        }

        .tuning-btn.active {
            background: #4a8fa0;
            border-color: #6aa0b0;
            box-shadow: 0 0 10px rgba(74, 143, 160, 0.5);
        }

        .chord-section {
            margin-bottom: 20px;
        }
        .section-title {
            font-size: 20px;
            margin-bottom: 15px;
            color: #8fb3d3;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 8px;
            margin-bottom: 15px;
        }

        .chord-btn {
            aspect-ratio: 1;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .chord-btn:hover {
            background: #3a5868;
            transform: scale(1.05);
        }

        .chord-btn:active {
            background: #4a7888;
            transform: scale(0.98);
        }

        .chord-btn.active {
            background: #e74c3c;
            border-color: #c0392b;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }

        /* Touch-specific feedback states */
        .chord-btn.touch-pressed {
            background: #4a7888;
            transform: scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .chord-btn.touch-long-press {
            background: #5a8898;
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(90, 136, 152, 0.6);
            border-color: #6a98a8;
        }

        .quality-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .quality-btn {
            flex: 1;
            padding: 10px;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
        }

        .quality-btn.active {
            background: #f39c12;
            border-color: #e67e22;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        .extension-columns {
            flex: 1;
            display: flex;
            height: 100%; /* Fill parent height (resizable strum-area) */
            max-height: 100%;
            min-height: 120px; /* Minimum to show chord headers + compressed strings */
            gap: 0;
            padding: 0;
            justify-content: stretch;
            overflow: hidden; /* Prevent overflow past bounds */
        }

        .quality-section {
            display: flex;
            flex-direction: row;
            flex: 1;
            gap: 2px;
            padding: 0;
            border-radius: 0;
            min-width: 0; /* Allow shrinking */
            max-width: 33.33%; /* Ensure 3 equal sections */
        }

        .extension-column {
            position: relative;
            border-right: none; /* Remove vertical line completely */
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 120px; /* Ensure minimum height for header + compressed strings */
            max-height: 100%; /* Respect parent height constraint */
            min-width: 0;
            width: 100%;
            cursor: grab;
            transition: all 0.2s ease;
            height: 100%;
            overflow: hidden; /* Prevent strings from overflowing */
        }

        /* Ensure header stays at fixed height */
        .extension-header {
            flex-shrink: 0; /* Don't allow header to compress */
            min-height: 40px;
            max-height: 40px;
        }

        .extension-column:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        /* Enhanced touch feedback for improved responsiveness */
        .touch-active {
            background: rgba(255, 255, 255, 0.1) !important;
            transform: scale(1.02) !important;
            transition: all 0.05s ease !important;
        }

        .extension-column:active {
            cursor: grabbing;
        }


        .extension-column:last-child {
            border-right: none; /* Ensure no borders anywhere */
        }

        .extension-header {
            height: auto; /* allow header to grow when buttons wrap */
            min-height: 56px;
            max-height: none;
            background: rgba(0, 0, 0, 0.5);
            /* Subtle root tint overlay, if provided */
            background-image: var(--root-tint-gradient, none);
            background-repeat: no-repeat;
            background-size: cover;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 13px;
            font-weight: bold;
            text-align: center;
            padding: 10px 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            position: relative;
            transition: background 0.2s, transform 0.1s;
            z-index: 100;
            user-select: none;
            border-radius: 4px 4px 0 0;
            margin: 2px 2px 0 2px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            flex-wrap: wrap;
            align-content: flex-start; /* stack rows from the top when wrapping */
        }

        .chord-name {
            /* Only as wide as its text */
            flex: 0 0 auto;
            display: inline-block;
            white-space: nowrap;
            text-align: center;
            margin: 0 auto; /* center within flex container without stretching */
        }

        .lock-button {
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s;
            margin-left: 6px;
            flex-shrink: 0;
            z-index: 100;
            position: relative;
            pointer-events: auto;
            touch-action: manipulation;
        }

        .lock-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .lock-button.locked {
            background: #4CAF50;
            border-color: #45a049;
            color: #fff;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }


        .chord-action-button {
            width: 34px;
            height: 34px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s;
            margin-left: 6px;
            flex-shrink: 0;
            pointer-events: auto;
            touch-action: manipulation;
        }

        .chord-action-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        /* High-contrast styling for per-chord transpose arrows */
        .chord-action-button.transpose-up,
        .chord-action-button.transpose-down {
            background: rgba(17, 24, 39, 0.85); /* slate-900 */
            border-color: rgba(255, 255, 255, 0.35);
            color: #ffffff;
        }
        .chord-action-button.transpose-up:hover,
        .chord-action-button.transpose-down:hover {
            background: rgba(31, 41, 55, 0.95); /* slate-800 */
            border-color: rgba(255, 255, 255, 0.55);
        }

        .chord-action-button.edit {
            background: rgba(33, 150, 243, 0.2);
            border-color: rgba(33, 150, 243, 0.5);
        }


        .chord-action-button.duplicate {
            background: rgba(156, 39, 176, 0.2);
            border-color: rgba(156, 39, 176, 0.5);
        }

        .header-buttons {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
            pointer-events: auto;
            z-index: 99;
            position: relative;
            flex-wrap: wrap;
            row-gap: 6px;
        }

        .extension-header:hover {
            /* Minimal hover feedback to avoid interfering with tap/hold system */
            background: rgba(255, 255, 255, 0.05);
        }

        .extension-header:active {
            /* Completely disable active state visual feedback - header taps should have no visual change */
            /* Use a minimal property that doesn't change appearance */
            pointer-events: auto;
        }
        
        /* Prevent touch-pressed class from altering header colors; preserve root-based background */
        .extension-header.touch-pressed {
            transform: none !important;
            transition: none !important;
        }

        /* Extension footer for ARP/CHORD trigger buttons */
        .extension-footer {
            height: 48px;
            min-height: 48px;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 6px 14px 6px; /* Added bottom padding to prevent menu bar overlap */
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            gap: 4px;
        }

        .trigger-button {
            flex: 1;
            height: 36px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .trigger-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .trigger-button:active {
            transform: translateY(0) scale(0.95);
            background: rgba(255, 255, 255, 0.3);
        }

        .trigger-button.arp-trigger {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.2);
        }

        .trigger-button.arp-trigger:hover {
            background: rgba(16, 185, 129, 0.3);
            border-color: #10b981;
        }

        .trigger-button.chord-trigger {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.2);
        }

        .trigger-button.chord-trigger:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
        }

        /* Mode-specific colors for unified trigger button */
        .trigger-button.mode-arp {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.2);
        }

        .trigger-button.mode-arp:hover {
            background: rgba(16, 185, 129, 0.3);
            border-color: #10b981;
        }

        .trigger-button.mode-chord {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.2);
        }

        .trigger-button.mode-chord:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
        }

        .trigger-button.mode-off {
            background: rgba(127, 140, 141, 0.2);
            border-color: rgba(127, 140, 141, 0.4);
            cursor: not-allowed;
            opacity: 0.6;
        }

        .trigger-button.active {
            background: rgba(255, 255, 255, 0.4) !important;
            border-color: white !important;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
        }

        /* Touch feedback styles */
        .touch-pressed {
            background: rgba(233, 69, 96, 0.3) !important;
            transform: scale(0.98);
            transition: background 0.1s, transform 0.1s;
        }

        .touch-long-press {
            background: rgba(233, 69, 96, 0.5) !important;
            transform: scale(1.02);
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
            transition: background 0.2s, transform 0.2s, box-shadow 0.2s;
        }

        .strings-column {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            padding: 0; /* no inner gaps */
            overflow: hidden; /* Prevent scrollbars */
            min-height: 0; /* allow shrinking when header grows */
            max-height: calc(100% - 50px); /* Leave space for header within resizable container */
            box-sizing: border-box;
            /* High-contrast backdrop for neon strings */
            background: #000000;
            /* Subtle root tint overlay, if provided */
            background-image: var(--root-tint-gradient, none);
            background-repeat: no-repeat;
            background-size: cover;
            /* Ensure strings don't overflow into header/footer areas */
            margin-top: 4px;
            margin-bottom: 4px;
        }

        .note-label {
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
            color: #8fb3d3;
            text-align: center;
            padding: 1px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Hit area fills the lane from string to string (no gaps) */
        .string {
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center; /* center the visible core */
            justify-content: stretch;
            flex: 1 1 0;
            margin: 0; /* no gaps */
            padding: 0; /* keep tight */
            overflow: visible; /* allow glow to bloom */
            min-height: 6px; /* Increased minimum height for better touch sensitivity */
        }

        /* String container flexibility for compression */
        .strings-container {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            min-height: 80px; /* Minimum compressed height */
            overflow: hidden;
        }

        /* The actual visible 6px neon line lives inside the hit area */
    .string-core {
            position: relative;
            width: 100%;
            height: 6px; /* Increased from 4px for better visibility */
            border-radius: 3px; /* Adjusted for new height */
            transition: transform 0.08s ease, box-shadow 0.1s ease, opacity 0.1s ease, filter 0.1s ease;
            transform-origin: center;
            will-change: transform;
            pointer-events: none; /* events on the hit area (.string) */
        }

        .string:hover .string-core {
            transform: scaleY(1.2);
            filter: brightness(1.05);
        }

        .string.active .string-core {
            transform: scaleY(1.25);
            filter: brightness(1.15);
        }

    .string-wave {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.1s;
            background: transparent; /* Removed gradient animation that caused purple lines */
            /* background-size: 20px 100%; */
            /* animation: wave-flow 1s linear infinite; */
        }

    .string.active .string-wave {
            opacity: 1;
        }

        @keyframes wave-flow {
            0% {
                background-position-x: 0;
            }
            100% {
                background-position-x: 20px;
            }
        }

        /* Subtle vertical vibration tied to frequency (period set via --vib-period) */
        @keyframes vibrate-y {
            0% { transform: translateY(0) scaleY(1); }
            20% { transform: translateY(-2px) scaleY(1.12); }
            50% { transform: translateY(0) scaleY(1); }
            80% { transform: translateY(2px) scaleY(1.12); }
            100% { transform: translateY(0) scaleY(1); }
        }

        .string-core.vibrating {
            animation: vibrate-y var(--vib-period, 60ms) ease-in-out infinite;
        }

        /* Subtle highlight band for middle octaves (3–4) */
        .string.mid-octave {
            background: rgba(255, 255, 255, 0.035);
        }
        .string.mid-octave .string-core {
            filter: brightness(1.12) saturate(1.06);
        }

        .note-labels {
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #8fb3d3;
            text-align: center;
            padding: 2px;
        }

        .frequency-display {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #bdc3c7;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .string:hover .frequency-display {
            opacity: 1;
        }

        .current-chord {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 12px;
            border: 2px solid #4a6870;
            z-index: 1000;
        }

        .current-chord h3 {
            color: #e74c3c;
            margin-bottom: 8px;
            font-size: 24px;
            text-align: center;
        }

        .current-chord div {
            font-size: 16px;
            text-align: center;
            color: #8fb3d3;
        }

        .root-notes-selector {
            display: flex;
            gap: 4px;
            align-items: center;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap;
        }
        /* panelHost removed: legacy reference stripped */

        .root-notes-selector .section-title {
            font-size: 18px;
            color: #8fb3d3;
            margin-right: 20px;
            white-space: nowrap;
        }

        .root-chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(20px, 1fr));
            grid-template-rows: 1fr;
            gap: 1px;
            flex: 1;
            width: 100%;
            max-height: none !important;
            height: 100% !important;
            position: relative;
        }

        .root-btn {
            flex: 1;
            min-width: 20px;
            height: 45px;
            background: linear-gradient(145deg, #2c5aa0, #1e3a8a);
            border: 1px solid #4a90e2;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .root-btn:hover {
            background: linear-gradient(145deg, #3d6bb5, #2949a0);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .root-btn:active {
            background: linear-gradient(145deg, #1e3a8a, #1a2f70);
            transform: translateY(0px) scale(0.95);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        /* Touch-specific feedback states for root buttons */
        .root-btn.touch-pressed {
            background: linear-gradient(145deg, #1e3a8a, #1a2f70);
            transform: translateY(0px) scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .root-btn.touch-long-press {
            background: linear-gradient(145deg, #4d7bc5, #3959b0);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(74, 144, 226, 0.6);
            border-color: #6aa0e2;
        }

        .root-btn.active {
            background: linear-gradient(145deg, #f59e0b, #d97706);
            border-color: #fbbf24;
            color: #000;
            font-weight: bold;
        }

        /* Generic panel buttons (bottom/top bar etc.) */
    .panel-btn {
            background: #1f3744;
            color: #e8f5ff;
            border: 1px solid #4a6870;
            border-radius: 10px;
            padding: 10px 14px;
            min-width: 48px;
            height: 44px;
            font-size: 14px;
            line-height: 1;
            cursor: pointer;
        }

    /* Reserve space for bottom brand footer */
    body { padding-bottom: 32px; }

    /* Make transport buttons finger friendly */
    #playSeqBtn, #stopSeqBtn { border-radius: 10px; padding: 10px 12px !important; height: 44px; font-size: 14px !important; }

        /* Larger, finger-friendly controls on touch screens */
        @media (pointer: coarse) {
            :root { --bar-h: 64px; }
            body { font-size: 18px; }
            .section-title { font-size: 22px; }
            .control-panel { gap: 18px; }

            .tuning-btn { padding: 10px 14px; font-size: 14px; border-width: 2px; border-radius: 8px; }

            .chord-grid { grid-template-columns: repeat(auto-fit, minmax(84px, 1fr)); gap: 10px; }
            .chord-btn { min-width: 84px; min-height: 84px; font-size: 16px; border-width: 3px; border-radius: 12px; }

            .quality-btn { padding: 14px; font-size: 16px; border-width: 2px; }

            .lock-button, .chord-action-button { width: 44px; height: 44px; font-size: 20px; border-width: 2px; }

            .root-btn { height: 56px; font-size: 16px; border-width: 2px; }

            .panel-btn { padding: 14px 18px; height: 52px; font-size: 18px; border-width: 2px; border-radius: 12px; }

            .note-labels { height: 36px; font-size: 11px; }
            .note-label { height: 26px; font-size: 10px; }

            /* Increase string lane height for easier targeting without changing visible core thickness */
            .string { min-height: 28px; }
            .string-core { height: 5px; }
        }

        /* ================= Piano Keyboard Revamp (Top Row) ================ */
        /* Wrapper row to place transpose controls to the left of the keyboard */
        .keyboard-row {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin: 8px 0 0 0;
        }
        .transpose-controls-left {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            user-select: none;
        }
        .transpose-controls-left button {
            background:#1f3a4a;
            color:#e8f5ff;
            border:1px solid #3b6a7a;
            border-radius:6px;
            padding:4px 6px;
            font-size:14px;
            width: 36px;
            cursor: pointer;
        }
        .transpose-controls-left .delta {
            color:#9db6c8;
            font-weight:700;
            font-size:14px;
            min-height: 18px;
        }
        /* Inline mode controls placed between transpose and keyboard */
        .mode-controls {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin: 0 10px 0 2px;
            user-select: none;
        }
        .mode-controls .mode-btn {
            background: #2a4858;
            color: #e8f5ff;
            border: 1px solid #4a6870;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            white-space: nowrap;
        }
        
        /* Centralized controls row styling */
        #centralizedControlsRow {
            flex-wrap: wrap;
            gap: 8px;
        }
        
        /* Mode buttons horizontal layout */
        #modeButtonsHorizontal {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        /* Responsive design for mobile */
        @media (max-width: 768px) {
            #universalMenu {
                gap: 4px;
                font-size: 10px;
            }
            
            #centralizedControlsRow {
                flex-direction: column;
                gap: 8px;
                align-items: center;
            }
            
            #modeButtonsHorizontal {
                justify-content: center;
            }
            
            .transpose-controls-left button {
                width: 28px;
                height: 28px;
                font-size: 14px;
            }
            
            /* Stack transpose and keyboard controls vertically on phones */
            #centralizedControlsRow > div {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
            }
        }
        
        @media (max-width: 480px) {
            #universalMenu {
                gap: 2px;
            }
            
            #centralizedControlsRow {
                padding: 6px;
                gap: 6px;
            }
            
            #modeButtonsHorizontal {
                gap: 4px;
            }
            
            .mode-btn {
                padding: 6px 8px;
                font-size: 10px;
            }
            
            /* Vertical stacking for very small screens */
            #centralizedControlsRow {
                flex-direction: column;
            }
            
            /* Make buttons evenly spaced on phones */
            #modeButtonsHorizontal {
                width: 100%;
                justify-content: space-around;
            }
        }
        .mode-controls .mode-btn.active { background: #3498db; border-color: #2980b9; }

        /* Universal menu and mode button styling */
        #universalMenu {
            min-height: 40px;
        }
        
        #modeButtonsStack .mode-btn {
            background: #1a2530; /* Start dark */
            color: #9db6c8; /* Dim text */
            border: 1px solid #3a4850;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            white-space: nowrap;
            min-width: 70px;
            text-align: center;
            transition: all 0.2s ease;
        }
        
        #modeButtonsStack .mode-btn:hover {
            background: #2a3540;
            border-color: #5a6870;
        }
        
        #modeButtonsStack .mode-btn.active {
            background: #3498db; /* Light up when active */
            border-color: #2980b9;
            color: #ffffff;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.5);
        }
        
        /* Desktop mode buttons styling */
        .root-notes-selector .mode-btn {
            background: #1a2530; /* Start dark */
            color: #9db6c8; /* Dim text */
            border: 1px solid #3a4850;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            white-space: nowrap;
            min-width: 70px;
            text-align: center;
            transition: all 0.2s ease;
        }
        
        .root-notes-selector .mode-btn:hover {
            background: #2a3540;
            border-color: #5a6870;
        }
        
        .root-notes-selector .mode-btn.active {
            background: #3498db !important; /* Light up when active */
            border-color: #2980b9 !important;
            color: #ffffff !important;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.5) !important;
        }
        
        /* More specific targeting for desktop mode buttons */
        #modeStrum.active,
    #modeChordArp.active,
        #universalBass.active {
            background: #3498db !important;
            border-color: #2980b9 !important;
            color: #ffffff !important;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.5) !important;
        }
        /* MIDI status LED */
        .midi-led {
            display:inline-block;
            width:10px;
            height:10px;
            border-radius:50%;
            background:#3a3f46;
            border:1px solid #555;
            box-shadow:0 0 2px #000 inset;
            transition:background 0.25s, box-shadow 0.25s, filter 0.25s;
            position:relative;
            top:1px;
        }
        .midi-led.on {
            background:#10b981;
            border-color:#0d8f66;
            box-shadow:0 0 4px 1px rgba(16,185,129,0.9), 0 0 10px 3px rgba(16,185,129,0.4);
            filter:brightness(1.2);
        }
        
        
        #topContainer {
            position: fixed; /* Fixed positioning to stay below browser UI */
            top: 40px; /* Leave space for browser UI and bookmarks */
            left: 0;
            right: 0;
            z-index: 1000;
            margin-bottom: 0; /* No margin needed with fixed positioning */
            padding: 12px 16px; /* Increased padding for better spacing */
            background: rgba(0, 0, 0, 0.98); /* Black semi-transparent background */
            backdrop-filter: blur(8px);
            border-bottom: 1px solid #333333;
        }

        /* Ensure panel toggles show a clear active glow (used by BASS/GLIDE buttons) */
        .panel-btn.active {
            background: #0ea5e9 !important;
            color: #05222b !important;
            border-color: #0284c7 !important;
            box-shadow: 0 0 10px 2px rgba(56, 189, 248, 0.7), 0 0 18px 6px rgba(14, 165, 233, 0.5) !important;
            position: relative;
            z-index: 0; /* keep inside normal stacking without clipping */
        }
        .piano-keyboard {
            position: relative;
            width: 66.666vw; /* fixed 2/3 viewport width */
            max-width: 1500px; /* cap width on large screens */
            height: 200px; /* fixed height */
            margin: 12px auto 8px auto; /* centered near top */
            user-select: none;
            background: transparent; /* remove purple rectangle so keys float on blue */
            border-radius: 8px;
            /* remove dark border/inset so it blends with background */
            box-shadow: none;
            overflow: hidden;
            padding-top: 4px; /* slight top padding so glow/outline never alters outer box */
            padding-left: 8px;
        }
        /* Reserve vertical space inside for active glow so layout never shifts */
        .piano-keyboard .white-key.root-btn,
        .piano-keyboard .black-key.root-btn,
        .piano-keyboard .edo-dot { will-change: transform; }
        /* Neutralize any accidental layout influence from outlines */
        .piano-keyboard .white-key.root-btn.active,
        .piano-keyboard .black-key.root-btn.active,
        .piano-keyboard .edo-dot.active { outline-offset: 0; }
    /* Light currently active chord tones on the keyboard */
    .piano-keyboard .chord-tone { filter: brightness(1.25) contrast(1.1); box-shadow: 0 0 12px 3px rgba(255,255,200,0.5); }
    /* Prevent reflow on hover/active transitions */
        .piano-keyboard .white-key.root-btn,
        .piano-keyboard .black-key.root-btn { position:absolute; }
        /* Hardware accelerate transforms for smoother glow without jitter */
    .piano-keyboard, .piano-keyboard * { backface-visibility:hidden; }
    /* Subtle drag hint overlay */
    .piano-keyboard .drag-hint { position:absolute; top:8px; left:50%; transform:translateX(-50%); font-size:12px; color:#cfe6ff; opacity:.18; pointer-events:none; transition: opacity .2s ease; }
    .piano-keyboard:hover .drag-hint { opacity:.28; }
    .piano-keyboard.is-dragging .drag-hint { opacity:.6; }
    @media (max-width: 900px){ }
        /* Ensure retro font everywhere */
        button, .root-btn, .extension-header, .control-panel, input, select, .edo-dot { font-family: var(--retro-font) !important; }
        /* Base circle key */
        .piano-keyboard .white-key.root-btn,
        .piano-keyboard .black-key.root-btn {
            position:absolute;
            width:70px;
            height:70px;
            z-index:2; /* keep keys above micro dots so labels (like B) remain visible */
            border-radius:50%;
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:14px;
            font-weight:bold;
            cursor:pointer;
            transform:translate(-50%, -50%);
            transition:filter .15s, transform .1s;
            box-shadow:0 4px 10px rgba(0,0,0,0.6), inset 0 -4px 6px rgba(0,0,0,0.4);
        }
        .piano-keyboard .white-key.root-btn {
            background:radial-gradient(circle at 30% 30%, #ffffff, #d9d9d9 60%, #bdbdbd);
            color:#222;
            top:78%; /* bring upward so full circle visible */
        }
        .piano-keyboard .white-key.root-btn.disabled { filter:grayscale(60%) brightness(0.8); opacity:.6; }
        .piano-keyboard .white-key.root-btn.active { outline:3px solid #ffd046; box-shadow:0 0 14px 4px rgba(255,208,70,0.7); }
        .piano-keyboard .black-key.root-btn {
            background:radial-gradient(circle at 30% 30%, #444, #111 65%, #000);
            color:#eee;
            top:26%; /* adjust for reduced height */
            width:68px;
            height:68px;
        }
        .piano-keyboard .black-key.root-btn.disabled { filter:grayscale(60%) brightness(0.6); opacity:.55; }
        .piano-keyboard .black-key.root-btn.active { outline:3px solid #9d6bff; box-shadow:0 0 16px 4px rgba(157,107,255,0.8); }
        .piano-keyboard .white-key.root-btn:active, .piano-keyboard .black-key.root-btn:active { transform:translate(-50%, -50%) scale(.94); }
        .piano-keyboard .white-key.root-btn:hover, .piano-keyboard .black-key.root-btn:hover { filter:brightness(1.15); }

        .piano-keyboard .microtone-key.root-btn { display:none; }
        .piano-keyboard .microtone-key.root-btn span { pointer-events:none; }

        /* 96-EDO microtone dot system */
        .piano-keyboard .edo-dot {
            position:absolute;
            width:26px;
            height:26px;
            z-index:1; /* ensure dots don't obscure white/black key labels */
            border-radius:50%;
            transform:translateX(-50%);
            box-shadow:0 1px 3px rgba(0,0,0,0.6), inset 0 0 3px rgba(255,255,255,0.4);
            cursor:pointer;
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:11px;
            font-weight:bold;
            color:#fff;
            text-shadow:0 1px 2px rgba(0,0,0,0.9);
            padding:2px;
            box-sizing:border-box;
            transition: opacity .12s ease; /* smooth edge fade */
        }
        .piano-keyboard .edo-dot.blue { background:radial-gradient(circle at 30% 30%, #6fa9ff, #2563eb 60%, #1e3a8a); }
        .piano-keyboard .edo-dot.green { background:radial-gradient(circle at 30% 30%, #5ef0b2, #0d9e6f 60%, #065f46); }
        .piano-keyboard .edo-dot.red { background:radial-gradient(circle at 30% 30%, #ff9a9a, #dc2626 60%, #7f1d1d); }
    .piano-keyboard .edo-dot.active { outline:2px solid #fff; box-shadow:0 0 10px 4px rgba(255,255,255,0.9); filter:brightness(1.2); }
    .piano-keyboard .edo-dot.red.active { box-shadow:0 0 12px 5px rgba(220,38,38,0.9),0 0 6px 3px rgba(255,255,255,0.8); }
    .piano-keyboard .edo-dot.green.active { box-shadow:0 0 12px 5px rgba(13,158,111,0.9),0 0 6px 3px rgba(255,255,255,0.8); }
    .piano-keyboard .edo-dot.blue.active { box-shadow:0 0 12px 5px rgba(37,99,235,0.9),0 0 6px 3px rgba(255,255,255,0.8); }
    /* Chord-builder selection glow (non-root) */
    .piano-keyboard .edo-dot.selected { outline:3px solid #f39c12; box-shadow:0 0 14px 5px rgba(243,156,18,0.85),0 0 6px 3px rgba(255,255,255,0.5); filter:brightness(1.15); }
        /* Vertical lanes (percent from top of keyboard height) */
    /* Updated vertical lane centers to match reference image (from top to bottom: black, blue, green, red, white) */
    .piano-keyboard .edo-lane-blue  { top:39%; }
    .piano-keyboard .edo-lane-green { top:52%; }
    .piano-keyboard .edo-lane-red   { top:65%; }

        /* ================================================================== */

        /* ================= Drum Grid (Skeleton) ================ */
    .drum-grid-container { display:block !important; width:100%; max-width:none; margin:0 auto; height:auto; min-height:400px; box-sizing:border-box; overflow:visible; scrollbar-width: none; -ms-overflow-style: none; }
    .drum-grid-container::-webkit-scrollbar { display: none; }
        .drum-grid-header { display:flex; align-items:center; gap:10px; margin:6px 0 8px 0; font-size:12px; color:#cfe6ff; }
    .drum-grid { display:grid; grid-template-rows: repeat(9, 1fr); gap:1px; height: calc(100% - 28px); }
    .drum-row { display:grid; grid-template-columns: 88px 1fr 100px 46px 76px 170px; align-items:center; gap:4px; }
        .drum-label { font-size:12px; color:#e0e8ff; opacity:.9; text-align:right; padding-right:6px; white-space:nowrap; }
    .drum-lane { position:relative; display:grid; grid-template-columns: repeat(var(--steps-per-bar, 16), 1fr); gap:4px; height:22px; align-items:center; justify-items:center; }
    .drum-step { width:16px; height:16px; border-radius:50%; background:radial-gradient(circle at 30% 30%, #6886ff, #2b50ea 60%, #1c2b74); opacity:.35; cursor:pointer; transition:transform .08s ease, opacity .12s ease, box-shadow .12s ease, background .12s ease; }
    .drum-step.active { opacity:1; box-shadow:0 0 10px 3px rgba(120,180,255,0.6); background:radial-gradient(circle at 30% 30%, #8fb3ff, #5a7dff 60%, #3148b3); }
        .drum-step:active { transform:scale(.9); }
        .drum-lane::before { content:""; position:absolute; left:0; right:0; top:50%; height:1px; background:linear-gradient(90deg, rgba(255,255,255,0.06) 0%, rgba(255,255,255,0.18) 50%, rgba(255,255,255,0.06) 100%); pointer-events:none; }
        .drum-lane .beat-divider { position:absolute; top:0; bottom:0; width:1px; background:rgba(255,255,255,0.12); pointer-events:none; }
        .drum-volume { width:100%; }
        .drum-fx { display:flex; align-items:center; gap:6px; font-size:10px; color:#9db6c8; justify-content:flex-start; }
        .drum-playhead { position:absolute; top:-4px; bottom:-4px; width:2px; background:#ffd046; opacity:.75; pointer-events:none; box-shadow:0 0 10px 2px rgba(255,208,70,0.6); transform:translateX(0); }
    .drum-fx { display:flex; align-items:center; gap:4px; justify-content:center; }
    .drum-midi { display:flex; align-items:center; gap:4px; justify-content:center; }
    .drum-midi input { width:72px; background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:2px 4px; font-size:11px; }
    .drum-params { display:flex; align-items:center; gap:6px; justify-content:flex-start; }
    .drum-params .mini { -webkit-appearance:none; appearance:none; height:16px; width:48px; background:#2a4858; border:1px solid #4a6870; border-radius:8px; outline:none; }
    .drum-params .mini::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; width:10px; height:10px; border-radius:50%; background:#ffd046; cursor:pointer; }
    .drum-params .mini::-moz-range-thumb { width:10px; height:10px; border:none; border-radius:50%; background:#ffd046; cursor:pointer; }
    .drum-params label { font-size:9px; color:#cfe6ff; opacity:.8; }
    /* Visual emphasis: steps 1,5,9,13 slightly larger and tinted */
    .drum-step.beat-accent { 
        /* Subtle ring highlight on downbeats without covering the active light */
        box-shadow: 0 0 0 2px rgba(158,198,255,0.55) inset, 0 0 4px rgba(106,168,255,0.45);
        /* Keep same size and background so .active remains visible */
    }
    .drum-step.beat-accent.active {
        /* Combine the active glow with the accent ring */
        box-shadow: 0 0 0 2px rgba(158,198,255,0.65) inset, 0 0 10px 3px rgba(120,180,255,0.6);
        opacity: 1;
    }
        /* Bass row: show NPC text inside steps and selection ring */
        .drum-row.bass-row .drum-step::after { content: attr(data-npc); position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:11px; color:#ecf4ff; opacity:0.95; }
        .drum-row.bass-row .drum-step.selected { outline:2px solid #ffd046; outline-offset:1px; }

        /* Bass tie overlay pills (joined dots visual) */
        .drum-row.bass-row .drum-lane { position:relative; }
        .drum-row.bass-row .bass-tie-layer { position:absolute; inset:0; pointer-events:none; z-index:0; }
    .drum-row.bass-row .bass-tie-pill { position:absolute; top:50%; height:12px; transform:translateY(-50%); border-radius:8px; background:linear-gradient(90deg, rgba(143,179,255,0.7), rgba(90,125,255,0.7)); box-shadow:0 0 14px 3px rgba(120,180,255,0.55); }
        .drum-row.bass-row .drum-step { position:relative; z-index:1; }
        @media (max-width: 640px){
            .drum-row { grid-template-columns: 70px 1fr 80px 60px; gap:4px; }
            .drum-label { font-size:10px; }
        }

        /* When drums grid is visible, increase its area and compress strings */
        body.drums-mode .root-notes-area { height: 352px; }
        body.drums-mode .strum-area { margin-top: 8px; }
        body.drums-mode .strings-column { max-height: calc(100vh - 468px); }

        /* Chord creation mode styles */
        .chord-creation-mode .root-notes-area {
            background: rgba(0, 60, 30, 0.9);
            border-color: #2E8B57;
        }

        .chord-creation-mode .root-notes-area::before {
            content: "?? Select intervals for your chord - Click root buttons to add/remove notes";
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #90EE90;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 8px;
            border-radius: 4px;
            z-index: 10;
        }

        .chord-creation-mode .root-btn {
            background: #2a4858;
            border-color: #4a6870;
        }

        .chord-creation-mode .root-btn:hover {
            background: #3a5868;
            border-color: #5a7880;
        }

        .chord-creation-mode .root-btn.selected {
            background: #e74c3c;
            border-color: #c0392b;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.7);
        }

        .chord-creation-mode .root-btn.preview {
            background: #f39c12;
            border-color: #e67e22;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        .chord-types-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .chord-types-selector .section-title {
            font-size: 12px;
            color: #8fb3d3;
            margin-right: 10px;
        }

        .quality-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .quality-selector .section-title {
            font-size: 12px;
            color: #8fb3d3;
            margin-right: 10px;
        }

        .volume-control {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4a6870;
            display: flex;
            flex-direction: column;
            gap: 12px;
            font-size: 11px;
        }


        .osc-btn {
            padding: 10px;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 6px;
            font-size: 11px;
            transition: all 0.2s;
            text-align: center;
            font-weight: bold;
        }

        /* Square, tappable oscillator shape buttons */
        .oscillator-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(54px, 1fr));
            gap: 8px;
        }
        .oscillator-controls .osc-btn {
            padding: 0 !important; /* override inline paddings */
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px !important;
            border-radius: 10px;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .osc-btn.active {
            background: #27ae60;
            border-color: #2ecc71;
            box-shadow: 0 0 8px rgba(39, 174, 96, 0.5);
        }

        .multi-osc-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 6px;
        }

        .osc-group {
            border: 1px solid rgba(74, 104, 112, 0.3);
            border-radius: 4px;
            padding: 6px;
        }

        .osc-group h5 {
            font-size: 8px;
            color: #8fb3d3;
            margin-bottom: 4px;
        }

        .osc-mix-controls {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }

        .effects-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .effect-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .effect-group label {
            font-size: 8px;
            color: #8fb3d3;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .slider-value {
            font-size: 9px;
            color: #bdc3c7;
            text-align: center;
        }

        @media (max-width: 768px) {
            .control-panel {
                height: 60px;
                padding: 5px;
                gap: 8px;
            }
            
            .tuning-btn {
                padding: 4px 6px;
                font-size: 10px;
            }
            
            .chord-header {
                height: 30px;
                font-size: 8px;
            }
            
            /* Microtonal spacing: minimum 1px per microtone */
            .string {
                min-height: 1px; /* 1 microtone = 1px minimum */
                height: auto; /* Allow flexible sizing based on available space */
                margin: 0; /* No gaps between strings for tight packing */
                flex: 1 1 0; /* Equal distribution of available space */
            }
            
            .string-core {
                height: 1px; /* Visible string line */
                min-height: 1px;
            }
            
            .note-labels {
                height: 25px;
                font-size: 7px;
            }
            
            .volume-control {
                min-width: 120px;
                max-width: 140px;
                padding: 6px;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            /* Compact top container for landscape */
            #topContainer {
                padding: 2px 4px;
                min-height: 35px;
            }
            
            #universalMenu {
                min-height: 30px;
                gap: 2px;
            }
            
            /* Ultra-compact universal menu buttons for landscape */
            #universalMenu .panel-btn,
            #universalMenu input,
            #universalMenu select {
                font-size: 8px;
                padding: 2px 4px;
                height: 24px;
                min-width: 0;
            }
            
            #edoQuickInput {
                width: 32px !important;
                font-size: 8px !important;
            }
            
            .control-panel {
                height: 50px;
                padding: 3px;
            }
            
            .chord-header {
                height: 25px;
                font-size: 7px;
            }
            
            .note-labels {
                height: 20px;
                font-size: 6px;
            }
            
            /* Mobile landscape: Use available space efficiently with microtonal spacing */
            .string {
                min-height: 2px; /* Increased from 1px for better visibility */
                height: auto; /* Flexible sizing to fit available viewport */
                margin: 0; /* No gaps for maximum density */
                flex: 1 1 0; /* Equal distribution of available vertical space */
            }
            
            .string-core {
                height: 2px; /* Increased from 1px for better touch sensitivity */
                min-height: 2px;
            }
            
            /* Ensure strings container uses full available height */
            .strings-column {
                max-height: calc(100vh - 120px); /* Account for top controls and bottom menu */
                min-height: calc(100vh - 120px);
                overflow: hidden;
            }
        }

        /* Tablet-specific adjustments for better string visibility */
        @media (min-width: 769px) and (max-width: 1024px) {
            .string {
                min-height: 2px; /* Slightly thicker strings for tablets */
                height: auto;
                margin: 0.5px 0; /* Tiny gap for visual separation */
                flex: 1 1 auto;
            }
            
            .string-core {
                height: 2px;
                min-height: 2px;
            }
        }

        /* Mobile portrait: Compact layout with menu optimization */
        @media (orientation: portrait) and (max-width: 768px) {
            /* Compact menu for mobile portrait */
            #topContainer {
                padding: 6px 12px !important; /* Reduce padding to minimize blue space */
                top: 20px !important; /* Closer to top */
            }
            
            #universalMenu {
                gap: 3px; /* Tighter spacing */
                min-height: auto;
            }
            
            /* Force body padding adjustment for reduced header */
            body {
                padding-top: calc(100px + env(safe-area-inset-top)) !important;
            }
            
            /* Adjust instrument container for smaller header */
            .instrument {
                margin-top: 90px !important; /* Less space for smaller header */
                height: calc(100vh - 90px);
            }
            /* Fix body padding for mobile */
            body {
                padding-top: calc(env(safe-area-inset-top) + 10px); /* Minimal top padding */
                overflow-y: auto; /* Allow scrolling if needed */
            }
            
            /* Fix top container positioning */
            #topContainer {
                position: fixed; /* Fixed positioning to stay at top */
                top: env(safe-area-inset-top);
                left: 0;
                right: 0;
                z-index: 1000;
                padding: 6px 8px;
                min-height: auto; /* Let content determine height */
                background: rgba(26, 26, 46, 0.95); /* Semi-transparent background */
                backdrop-filter: blur(10px);
                border-bottom: 1px solid #4a6870;
            }
            
            #universalMenu {
                display: flex;
                flex-wrap: wrap;
                gap: 4px; /* Increased gap for better spacing */
                align-items: flex-start;
                justify-content: flex-start;
                line-height: 1.2;
            }
            
            /* Row-based mobile layout - 3 clean rows with narrower buttons */
            .mobile-row-1 {
                order: 1;
                flex-basis: calc(14.28% - 3px); /* 7 items per row, narrower buttons */
                margin-bottom: 3px;
            }
            
            .mobile-row-2 {
                order: 2;
                flex-basis: calc(14.28% - 3px); /* 7 items per row, narrower buttons */
                margin-bottom: 3px;
            }
            
            .mobile-row-3 {
                order: 3;
                flex-basis: calc(14.28% - 3px); /* 7 items per row, narrower buttons */
                margin-bottom: 3px;
            }
            
            /* Make all universal menu buttons consistent for mobile - narrower */
            #universalMenu .panel-btn,
            #universalMenu input,
            #universalMenu select,
            #universalMenu div {
                font-size: 9px !important; /* Smaller font */
                padding: 4px 6px !important; /* Less padding */
                min-width: 0;
                height: 28px; /* Shorter height */
                border-radius: 4px;
            }
            
            /* Preserve active states for mobile buttons */
            #universalMenu .panel-btn.active {
                background: #0ea5e9 !important;
                color: #05222b !important;
                border-color: #0284c7 !important;
                box-shadow: 0 0 10px 2px rgba(56, 189, 248, 0.7), 0 0 18px 6px rgba(14, 165, 233, 0.5) !important;
            }
            
            /* Preserve mode button active states */
            #universalMenu .mode-btn.active,
            .mode-btn.active {
                background: #3498db !important;
                border-color: #2980b9 !important;
                color: #ffffff !important;
                box-shadow: 0 0 8px rgba(52, 152, 219, 0.5) !important;
            }
            
            /* Special sizing for specific elements */
            #universalMenu input[type="number"] {
                width: 45px !important;
            }
            
            #universalMenu select {
                width: auto !important;
                min-width: 60px !important;
            }
            
            /* Ensure labels are readable */
            #universalMenu label {
                font-size: 9px !important;
                color: #9db6c8 !important;
            }
            
            /* Hide duplicate keyboard toggle in keyboard section for mobile */
            #keyboardToggle {
                display: none !important;
            }
            #keyboardToggle + label {
                display: none !important;
            }
            div[style*="KEYBOARD"] {
                display: none !important;
            }
            
            /* Hide master volume control in portrait mode - use phone volume instead */
            .mobile-row-6[style*="margin-left:auto"] {
                display: none !important;
            }
            
            /* Fix help and dice buttons - prevent stretching */
            #tutorialButton, #randomDiceButton {
                flex-basis: calc(14.28% - 2px) !important;
                width: auto !important;
                min-width: 32px !important;
                height: 28px !important;
                padding: 4px !important;
                font-size: 12px !important;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                border-radius: 4px;
                margin-bottom: 3px;
            }
            
            #universalMenu label {
                font-size: 8px !important;
            }
            
            /* EDO input specifically */
            #edoQuickInput {
                width: 35px !important;
                font-size: 9px !important;
            }
            
            /* Adjust instrument to account for fixed header */
            .instrument {
                margin-top: 120px; /* Space for fixed header */
                height: calc(100vh - 120px);
            }
            
            /* Mode buttons positioning for mobile */
            .root-notes-selector {
                padding-top: 10px !important;
            }
            
            /* Adjust transpose and mode buttons for mobile */
            .transpose-controls-left {
                left: 5px !important;
                top: 60px !important; /* Center with green keyboard keys */
            }
            
            .transpose-controls-left button {
                width: 28px !important;
                height: 28px !important;
                font-size: 14px !important;
            }
            
            /* Mode buttons for mobile */
            .root-notes-selector > div:nth-child(2) {
                left: 40px !important;
                top: 60px !important; /* Center with green keyboard keys */
            }
            
            .root-notes-selector > div:nth-child(2) button {
                width: 60px !important;
                padding: 4px 6px !important;
                font-size: 9px !important;
            }
            
            /* Keyboard toggle for mobile */
            .root-notes-selector > div:nth-child(3) > div {
                left: 120px !important;
                top: 5px !important;
            }
            
            /* Piano keyboard grid responsive - bring up and center on F# */
            .root-chord-grid {
                margin-top: 20px !important; /* Bring keyboard up to be visible */
                max-width: 95% !important;
                padding: 0 5px; /* Move left by reducing left padding */
                transform: translateX(-15px); /* Shift entire keyboard left */
            }
            
            /* Chord columns responsive */
            .extension-columns {
                padding: 10px 5px;
                flex-wrap: wrap; /* Allow wrapping to multiple rows */
                max-height: none; /* Remove height constraint for wrapping */
            }
            
            /* Force 2-row layout when more than 8 chords in vertical */
            .extension-columns:has(.extension-column:nth-child(9)) {
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                align-content: flex-start;
            }
            
            .extension-column {
                margin: 0 2px 4px 2px; /* Add bottom margin for multiple rows */
                min-width: 60px;
                flex: 0 0 calc(12.5% - 4px); /* 8 columns per row */
            }
            
            /* String area adjustments */
            .strum-area {
                padding-top: 10px;
            }
            
            .chord-header {
                height: 25px;
                font-size: 9px;
                padding: 3px;
            }
            
            .note-labels {
                height: 20px;
                font-size: 7px;
            }
            
            /* Ensure chord box bottom is visible */
            .strings-column {
                max-height: calc(100vh - 200px);
                overflow-y: auto;
            }
            
            /* XENON footer adjustments */
            #brandFooter {
                font-size: 12px !important;
                padding: 4px 8px !important;
            }
        }
        
        /* Left Sidebar Styles */
        .left-sidebar {
            position: fixed;
            left: 0;
            top: 0; /* Start from top since no transport row */
            width: 80px;
            height: 100vh; /* Full height */
            background: #000000; /* Black background for clean modal layer */
            border-right: 2px solid #333333; /* Dark gray border instead of blue */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 8px 20px 8px; /* Reduced top padding; transpose cluster now sticky at top */
            gap: 8px;
            z-index: 1000;
            overflow-y: auto;
        }
        
        .sidebar-btn {
            width: 64px;
            height: 40px; /* Smaller height for more buttons */
            background: linear-gradient(145deg, #2a4858, #1e3544);
            border: 1px solid #4a6870;
            border-radius: 8px;
            color: #e8f5ff;
            font-size: 9px; /* Smaller font */
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .sidebar-btn:hover {
            background: linear-gradient(145deg, #3a5868, #2e4554);
            border-color: #6a8890;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }
        
        .sidebar-btn.active {
            background: linear-gradient(145deg, #4a90e2, #357abd);
            border-color: #5aa3f0;
            color: #ffffff;
            box-shadow: 0 0 12px rgba(74, 144, 226, 0.5);
        }
        
        .sidebar-btn.active:hover {
            background: linear-gradient(145deg, #5aa3f0, #4080cd);
        }
        
        /* Main content offset for sidebar */
        .main-content {
            margin-left: 80px;
            min-height: calc(100vh - 22px); /* Account for transport row */
            background: linear-gradient(135deg, #0f1419 0%, #1a1a2e 35%, #16213e 100%);
        }
        
        /* Floating Modal Styles */
        .floating-modal {
            position: fixed;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border: 3px solid #4a90e2;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.8), 0 0 20px rgba(74, 144, 226, 0.3);
            z-index: 2000;
            display: none;
            min-width: 100px; /* Allow scaling down to 100x100 */
            min-height: 100px;
            resize: both;
            overflow: auto;
            /* Support extreme scaling */
            font-size: calc(max(8px, min(14px, 1.2vw))); /* Scale font size with viewport */
        }
        
        /* Scale modal content at small sizes */
        .floating-modal[style*="width: 100px"], .floating-modal[style*="width: 1"], 
        .floating-modal[style*="height: 100px"], .floating-modal[style*="height: 1"] {
            font-size: 6px;
        }
        
        /* Make buttons and controls scale down proportionally */
        .floating-modal .osc-btn, .floating-modal .synth-slider {
            min-width: 30px;
            min-height: 20px;
            font-size: inherit;
            padding: 2px 4px;
        }
        
        .modal-header {
            background: linear-gradient(90deg, #4a6870, #3a5860);
            padding: 8px 12px;
            border-radius: 10px 10px 0 0;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #e8f5ff;
            font-weight: bold;
            font-size: 12px;
        }
        
        .modal-close {
            background: #e74c3c;
            border: none;
            border-radius: 4px;
            color: white;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-body {
            padding: 16px;
            color: #e8f5ff;
        }
        
        /* Additional mobile styles */
        @media (max-width: 480px) {
            .left-sidebar {
                width: 60px;
                padding: 10px 4px;
            }
            .sidebar-btn {
                width: 52px;
                height: 40px;
                font-size: 9px;
            }
            .main-content {
                margin-left: 60px;
            }
            .extension-columns {
                margin-bottom: 80px; /* Space above XENON menu bar */
            }
            
            .string {
                min-height: 3px; /* Increased for better mobile touch sensitivity */
                height: auto;
                margin: 0;
                flex: 1 1 0;
            }
            
            .string-core {
                height: 3px; /* Thicker strings for mobile */
                min-height: 3px;
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 12000;
        }

        .modal-content {
            background: #2a2a2a;
            color: white;
            padding: 20px;
            border-radius: 10px;
            width: min(96vw, 900px);
            max-height: 94vh;
            overflow-y: auto; /* allow scroll if truly needed */
            scrollbar-width: none; /* hide scrollbar in Firefox */
            border: 2px solid #666;
        }
        .modal-content::-webkit-scrollbar { display: none; } /* hide scrollbar in WebKit */

        .add-column-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .add-chord-btn {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .add-chord-btn:hover {
            background: linear-gradient(135deg, #357abd, #2868a3);
            transform: translateY(-2px);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        /* Tutorial System Styles */
        .tutorial-highlight {
            box-shadow: 0 0 20px #8fb3d3, 0 0 40px #8fb3d3, 0 0 60px #8fb3d3 !important;
            border: 3px solid #8fb3d3 !important;
            filter: brightness(1.5) contrast(1.2) !important;
            position: relative !important;
            z-index: 9500 !important;
            background: rgba(143, 179, 211, 0.15) !important;
            border-radius: 8px !important;
        }

    /* TIME modal compact styles */
    #timeModal .modal-content { width: min(92vw, 520px); }
    #timeModal .time-grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    #timeModal label { font-size:11px; color:#9db6c8; }

        #tutorialOverlay {
            backdrop-filter: blur(2px);
        }

        /* Mobile/touch optimizations */
        @media (hover: none), (pointer: coarse) {
            .osc-btn { min-height: 44px; padding: 10px 12px; font-size: 12px; }
            .synth-slider { height: 28px; }
            .slider-value { font-size: 11px !important; }
            .effect-group label, .section-title { font-size: 13px; }
        }

        /* Larger slider thumbs on touch devices */
        .synth-slider::-webkit-slider-thumb { width: 22px; height: 22px; }
        .synth-slider::-moz-range-thumb { width: 22px; height: 22px; }

        @media (max-width: 768px) {
            /* Stack dense grids for small screens to avoid horizontal scroll */
            .panel-content { grid-template-columns: 1fr !important; gap: 12px; }
            .modal-content { width: 96vw; max-height: 94vh; }
        }

        #tutorialBox {
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-height: 88vh;
            overflow-y: auto;
            position: fixed !important;
            top: calc(var(--bar-h) + env(safe-area-inset-top) + 6px) !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            z-index: 2010 !important;
        }

    #tutorialButton, #randomDiceButton { transition: transform 0.3s ease, box-shadow 0.3s ease; }

        #tutorialButton:hover, #randomDiceButton:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

    #randomDiceButton { transition: transform 0.6s ease; }

        /* Add pulsing animation for tutorial and dice buttons */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(143, 179, 211, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(143, 179, 211, 0); }
            100% { box-shadow: 0 0 0 0 rgba(143, 179, 211, 0); }
        }

        #tutorialButton {
            animation: pulse 2s infinite;
        }

        @keyframes diceRoll {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(720deg); }
        }

        /* Drag & drop chord boxes */
        .extension-column.dragging {
            opacity: 0.98;
            cursor: grabbing;
        }
        .extension-column.placeholder {
            background: rgba(255,255,255,0.06);
        }
        .extension-column.delete-intent .extension-header {
            background: #8b1e1e !important;
            border-color: #ef4444 !important;
        }

        /* Flash highlight for call-to-action buttons */
        @keyframes flashCTA {
            0% { box-shadow: 0 0 0 0 rgba(80, 200, 120, 0.85); transform: translateZ(0); }
            50% { box-shadow: 0 0 0 10px rgba(80, 200, 120, 0); }
            100% { box-shadow: 0 0 0 0 rgba(80, 200, 120, 0); }
        }
        .flash-cta {
            animation: flashCTA 1.8s ease-out infinite;
        }
        .flash-cta-alt {
            animation: flashCTA 2.2s ease-out infinite;
        }

        /* Lightweight tooltip bubble */
        .hint-bubble {
            position: absolute;
            z-index: 1000;
            background: #0f2a3a;
            color: #dff3ff;
            border: 1px solid #2b5567;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 12px;
            white-space: nowrap;
            box-shadow: 0 6px 18px rgba(0,0,0,0.35);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Floating Transport Modal -->
    <div id="transportModal" style="position:fixed;top:20px;right:20px;background:rgba(0,0,0,0.95);border:2px solid #333333;border-radius:12px;padding:20px;display:flex;align-items:center;gap:15px;z-index:12000;backdrop-filter:blur(8px);box-shadow:0 8px 32px rgba(0,0,0,0.8);">
        <button id="playStopTransportBtn" style="width:60px;height:48px;background:#27ae60;border:2px solid #2ecc71;border-radius:8px;color:#fff;font-size:24px;cursor:pointer;display:flex;align-items:center;justify-content:center;">▶</button>
        <label style="display:flex;align-items:center;gap:8px;color:#e8f5ff;font-size:14px;font-weight:bold;">
            <input id="loopToggle" type="checkbox" style="transform:scale(1.2);" checked> LOOP
        </label>
        <label style="display:flex;align-items:center;gap:8px;color:#e8f5ff;font-size:14px;font-weight:bold;">
            BPM <input id="transportBpm" type="number" min="20" max="300" value="120" style="width:60px;height:32px;background:#1a1a2e;color:#fff;border:2px solid #4a6870;border-radius:6px;font-size:14px;padding:4px 8px;text-align:center;">
        </label>
        <label style="display:flex;align-items:center;gap:8px;color:#e8f5ff;font-size:14px;font-weight:bold;">
            EDO <input id="edoQuickInputTransport" type="number" min="5" max="52" value="24" title="Steps per octave" style="width:50px;height:32px;background:#1a1a2e;color:#fff;border:2px solid #4a6870;border-radius:6px;font-size:14px;padding:4px 6px;text-align:center;">
        </label>
        <label style="display:flex;align-items:center;gap:8px;color:#e8f5ff;font-size:14px;font-weight:bold;">
            VOL <input id="transportMasterVolume" type="range" min="0" max="10" value="10" style="width:80px;height:32px;" title="Master Volume">
        </label>
    </div>
        </label>
    </div>
    <!-- Top control bar (moved from bottom); uses CSS var --bar-h and safe-area insets -->
    <div id="bottomBar" style="position:fixed;top:0;left:0;right:0;height:var(--bar-h);display:none;align-items:center;justify-content:flex-start;gap:14px;padding:0 calc(18px + env(safe-area-inset-right)) 0 calc(18px + env(safe-area-inset-left));background:#000000;border-bottom:2px solid #333333;z-index:9600;font-family:var(--retro-font);">
        <!-- Centered brand -->
    </div>
    
    <!-- Bottom brand footer bar -->
    <div id="brandFooter" style="position:fixed;left:0;right:0;bottom:0;height:28px;background:#000000;border-top:1px solid #333333;display:flex;align-items:center;justify-content:center;z-index:1000;">
        <a id="brandLink" href="https://fastfast.bandcamp.com/" target="_blank" rel="noopener noreferrer" style="color:#e8f5ff;text-decoration:none;font-weight:700;letter-spacing:1px;font-size:14px;text-decoration:none;">XENON</a>
    </div>
    <div id="topContainer" style="display:none;">
        <!-- Universal permanent top menu -->
        <div id="universalMenu" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
            <!-- ROW 1: + EDO OSC FX SEQ PLAY -->
            <button id="createNewChordBtn" class="panel-btn mobile-row-1" title="Add Chord" style="font-weight:bold;">+</button>
            <button id="insertLeftBracketBtn" class="panel-btn mobile-row-1" title="Insert [ start repeat" style="font-weight:bold;">[</button>
            <button id="insertRightBracketBtn" class="panel-btn mobile-row-1" title="Insert ] / ]xN end repeat" style="font-weight:bold;">]</button>
            <div class="mobile-row-1" style="display:flex;align-items:center;gap:6px;">
                <span style="font-size:12px;color:#9db6c8;">EDO</span>
                <input id="edoQuickInput" type="number" min="5" max="52" value="24" title="Steps per octave" style="width:56px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:4px 6px;font-size:13px;" />
            </div>
            <button class="panel-btn mobile-row-1" data-panel="osc" title="Oscillator settings">OSC</button>
            <button class="panel-btn mobile-row-1" data-panel="fx" title="Effects">FX</button>
            <button id="openTextChordParserBtn" class="panel-btn mobile-row-1" title="Type or paste a chord sequence">SEQ</button>
            <button id="playStopToggleBtn" class="panel-btn mobile-row-1" title="Play/Stop sequence" style="background:#27ae60;border-color:#2ecc71;">PLAY</button>
            <!-- TIME button removed; its controls are now embedded in DRUMS header -->
            
            <!-- TIME submenu moved to modal -->
            
            <!-- ROW 3: KBD, SAVE XEN, LOAD XEN, DICE, ? (PRESET button removed in favor of full-session XEN save) -->
            <!-- Keyboard toggle first in row 3 -->
            <div class="mobile-row-3" style="display:flex;align-items:center;gap:6px;">
                <label style="font-size:11px;color:#9db6c8;">KBD</label>
                <input id="keyboardToggleMenu" type="checkbox" title="Show/Hide Piano Keyboard" checked />
            </div>
            
            <!-- PRESET button removed (all state now captured by SAVE XEN). Sequence preset logic still accessible via advanced panels. -->
            <button id="bottomExportOMGBtn" class="panel-btn mobile-row-3" title="Export full session (.XEN)" style="background:#10b981;border-color:#34d399;">SAVE XEN</button>
            <button id="bottomImportOMGBtn" class="panel-btn mobile-row-3" title="Import .XEN session" style="background:#9b59b6;border-color:#8e44ad;">LOAD XEN</button>
            <button id="randomDiceButton" class="panel-btn mobile-row-3" title="Randomize Settings">🎲</button>
            <button id="tutorialButton" class="panel-btn mobile-row-3" title="Start Tutorial">?</button>
            
            <!-- MASTER slider moved to main menu line -->
            <div class="mobile-row-6" style="display:flex;align-items:center;gap:6px;margin-left:auto;">
                <label for="masterVolume" style="font-size:12px;color:#9db6c8;">MASTER</label>
                <input type="range" id="masterVolume" min="0" max="10" value="10" style="width:120px; accent-color:#2d9c5d;">
                <span id="masterVolumeValue" style="font-size:11px; color:#b7d4e6; width:40px; text-align:right;">100%</span>
            </div>
        </div>
    </div>

    <div style="padding-top:0px;"> <!-- No extra padding needed now -->
    </div>
    </div>
    <!-- TIME modal removed -->
    <!-- Floating FX Modal (reuses original FX panel content) -->
    <div id="fxModal" class="floating-modal" style="top:120px; left:160px; width:900px; height:640px; display:none; overflow:hidden;">
        <div class="modal-header">
            <span>Effects</span>
            <div style="display:flex; gap:6px; align-items:center;">
                <button id="closeFxModal" class="modal-close" style="background:#e74c3c;">×</button>
            </div>
        </div>
        <div class="modal-body" style="height:calc(100% - 44px); overflow:hidden; padding:14px;">
            <div class="synth-section" id="effectsSection" style="padding:0 4px 8px 4px; overflow:hidden;">
                <h4 style="font-size:15px; margin-bottom:8px; color:#9b59b6;">Effects</h4>
                <div id="effectsPresetsBar" style="display:flex; align-items:center; gap:8px; margin:6px 0 10px 0;">
                    <label for="effectsPresetSelect" style="font-size:12px; color:#8fb3d3;">Preset</label>
                    <select id="effectsPresetSelect" style="background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:6px 8px; min-width:200px;"></select>
                    <button class="osc-btn" id="effectsPresetApply" title="Apply selected FX" style="background:#3498db; border-color:#2980b9;">Apply</button>
                    <button class="osc-btn" id="effectsPresetSave" title="Save current FX as preset" style="background:#10b981; border-color:#059669;">Save</button>
                    <button class="osc-btn" id="effectsPresetDelete" title="Delete selected FX preset" style="background:#e74c3c; border-color:#c0392b;">Delete</button>
                </div>
                <div style="margin-bottom:10px;">
                    <label style="font-size:15px; color:#e67e22;">Drive</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Amount</label>
                            <input type="range" class="synth-slider" id="driveAmount" min="0" max="100" value="0" style="height:20px;">
                            <div class="slider-value" id="driveAmountValue" style="font-size:9px;">0%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Mix</label>
                            <input type="range" class="synth-slider" id="driveMix" min="0" max="100" value="0" style="height:20px;">
                            <div class="slider-value" id="driveMixValue" style="font-size:9px;">0%</div>
                        </div>
                    </div>
                    <!-- Drive per-effect tone controls -->
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px; margin-top:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">HP Cut</label>
                            <input type="range" class="synth-slider" id="driveHpCutoff" min="0" max="100" value="0" style="height:20px;">
                            <div class="slider-value" id="driveHpCutoffValue" style="font-size:9px;">off</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">LP Cut</label>
                            <input type="range" class="synth-slider" id="driveLpCutoff" min="0" max="100" value="100" style="height:20px;">
                            <div class="slider-value" id="driveLpCutoffValue" style="font-size:9px;">off</div>
                        </div>
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <label style="font-size:15px; color:#f59e0b;">Delay</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Time</label>
                            <input type="range" class="synth-slider" id="delayTime" min="0" max="1000" value="280" style="height:20px;">
                            <div class="slider-value" id="delayTimeValue" style="font-size:9px;" contenteditable="true" title="Type ms or musical token (e.g., 1/4). Hold Shift while dragging for fine ms.">280ms</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Feedback</label>
                            <input type="range" class="synth-slider" id="delayFeedback" min="0" max="95" value="25" style="height:20px;">
                            <div class="slider-value" id="delayFeedbackValue" style="font-size:9px;">25%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">LP Cut</label>
                            <input type="range" class="synth-slider" id="delayLpCutoff" min="0" max="100" value="73" style="height:20px;">
                            <div class="slider-value" id="delayLpCutoffValue" style="font-size:9px;">6kHz</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">HP Cut</label>
                            <input type="range" class="synth-slider" id="delayHpCutoff" min="0" max="100" value="0" style="height:20px;">
                            <div class="slider-value" id="delayHpCutoffValue" style="font-size:9px;">off</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Mix</label>
                            <input type="range" class="synth-slider" id="delayMix" min="0" max="100" value="0" style="height:20px;">
                            <div class="slider-value" id="delayMixValue" style="font-size:9px;">0%</div>
                        </div>
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <label style="font-size:15px; color:#2ecc71;">Filters</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Cutoff (LP ↔ HP)</label>
                            <!-- Dual-handle filter edges: left = HP edge, right = LP edge (log scale) -->
                            <div style="display:flex; gap:8px; align-items:center; width:100%">
                                <div style="flex:1">
                                    <input type="range" class="synth-slider" id="filterLow" min="0" max="100" value="0" style="height:20px;">
                                    <div class="slider-value" id="filterLowValue" style="font-size:9px;">HP 20Hz</div>
                                </div>
                                <div style="flex:1">
                                    <input type="range" class="synth-slider" id="filterHigh" min="0" max="100" value="100" style="height:20px;">
                                    <div class="slider-value" id="filterHighValue" style="font-size:9px;">LP 20kHz</div>
                                </div>
                            </div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Resonance (Q)</label>
                            <input type="range" class="synth-slider" id="filterRes" min="0.1" max="20" step="0.1" value="1" style="height:20px;">
                            <div class="slider-value" id="filterResValue" style="font-size:9px;">Q 1.0</div>
                        </div>
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <label style="font-size:15px; color:#9b59b6;">Reverb</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Wet</label>
                            <input type="range" class="synth-slider" id="reverbWet" min="0" max="10" value="1" style="height:20px;">
                            <div class="slider-value" id="reverbWetValue" style="font-size:9px;">10%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Room</label>
                            <input type="range" class="synth-slider" id="reverbRoom" min="0" max="10" value="5" style="height:20px;">
                            <div class="slider-value" id="reverbRoomValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Decay</label>
                            <input type="range" class="synth-slider" id="reverbDecay" min="0" max="100" value="20" style="height:20px;">
                            <div class="slider-value" id="reverbDecayValue" style="font-size:9px;">2.0s</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">LP Cut</label>
                            <input type="range" class="synth-slider" id="reverbFilterCutoff" min="0" max="100" value="70" style="height:20px;">
                            <div class="slider-value" id="reverbFilterCutoffValue" style="font-size:9px;">8kHz</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">HP Cut</label>
                            <input type="range" class="synth-slider" id="reverbHpCutoff" min="0" max="100" value="0" style="height:20px;">
                            <div class="slider-value" id="reverbHpCutoffValue" style="font-size:9px;">off</div>
                        </div>
                    </div>
                </div>
                <div>
                    <label style="font-size:15px; color:#e74c3c;">Panning</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Mode</label>
                            <select id="panningMode" style="width:100%; padding:3px; background:#2a4858; color:#fff; border:1px solid #4a6870; border-radius:3px; font-size:10px; height:24px;">
                                <option value="center">Center</option>
                                <option value="frequency">Freq</option>
                                <option value="random">Random</option>
                                <option value="rotating">Rotate</option>
                                <option value="alternating">Alt</option>
                            </select>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Width</label>
                            <input type="range" class="synth-slider" id="panningWidth" min="0" max="100" value="80" style="height:20px;">
                            <div class="slider-value" id="panningWidthValue" style="font-size:9px;">80%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Speed</label>
                            <input type="range" class="synth-slider" id="panningSpeed" min="200" max="10000" value="2000" style="height:20px;">
                            <div class="slider-value" id="panningSpeedValue" style="font-size:9px;" contenteditable="true" title="Type ms (or s). Hold Shift while dragging for fine ms.">2.0s</div>
                        </div>
                        <div style="display:flex; align-items:center; justify-content:center;">
                            <div class="mix-btn" id="panningReset" style="font-size:9px; padding:4px; cursor:pointer;">Reset</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating OSC Modal (reuses original OSC panel content) -->
    <div id="oscModal" class="floating-modal" style="top:80px; left:220px; width:1000px; height:700px; display:none; overflow:hidden;">
        <div class="modal-header">
            <span>Oscillators</span>
            <div style="display:flex; gap:6px; align-items:center;">
                <button id="closeOscModal" class="modal-close" style="background:#e74c3c;">×</button>
            </div>
        </div>
        <div class="modal-body" style="height:calc(100% - 44px); overflow:hidden; padding:14px;">
            <div class="synth-section" id="oscillatorsSection" style="padding:0 4px 8px 4px; overflow:hidden;">
                <!-- Instrument Presets Toolbar -->
                <div id="instrumentPresetsBar" style="display:flex; align-items:center; gap:8px; margin:6px 0 10px 0;">
                    <label for="instrumentPresetSelect" style="font-size:12px; color:#8fb3d3;">Preset</label>
                    <select id="instrumentPresetSelect" style="background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:6px 8px; min-width:200px;"></select>
                    <button class="osc-btn" id="instrumentPresetApply" title="Apply selected preset" style="background:#3498db; border-color:#2980b9;">Apply</button>
                    <button class="osc-btn" id="instrumentPresetSave" title="Save current instrument as preset" style="background:#10b981; border-color:#059669;">Save</button>
                    <button class="osc-btn" id="instrumentPresetDelete" title="Delete selected preset" style="background:#e74c3c; border-color:#c0392b;">Delete</button>
                </div>
                <!-- Instrument Tabs: STRUM 1, STRUM 2, CHORD, ARP, BASS -->
                <div id="oscTabsBar" style="display:flex; gap:6px; margin-bottom:8px; flex-wrap:wrap;">
                    <button class="osc-btn osc-tab-btn active" data-tab="strum1">STRUM 1</button>
                    <button class="osc-btn osc-tab-btn" data-tab="strum2">STRUM 2</button>
                    <button class="osc-btn osc-tab-btn" data-tab="chord">CHORD</button>
                    <button class="osc-btn osc-tab-btn" data-tab="arp">ARP</button>
                    <button class="osc-btn osc-tab-btn" data-tab="bass">BASS</button>
                </div>
                <!-- MIDI Settings: Octave + Velocity -->
                <div id="midiSettingsRow" style="display:flex; gap:10px; align-items:flex-end; margin:6px 0 10px 0; flex-wrap:wrap;">
                    <div style="display:flex; flex-direction:column; gap:4px; min-width:150px;">
                        <label for="midiOctaveOffset" style="font-size:11px; color:#9db6c8;">MIDI Octave Offset</label>
                        <select id="midiOctaveOffset" title="Transpose outgoing MIDI in octaves" style="background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:6px 8px;">
                            <option value="-3">-3</option>
                            <option value="-2">-2</option>
                            <option value="-1">-1</option>
                            <option value="0" selected>0</option>
                            <option value="1">+1</option>
                            <option value="2">+2</option>
                            <option value="3">+3</option>
                        </select>
                    </div>
                    <div style="display:flex; flex-direction:column; gap:4px; min-width:180px;">
                        <label for="midiDefaultVelocity" style="font-size:11px; color:#9db6c8;">MIDI Default Velocity</label>
                        <input id="midiDefaultVelocity" type="number" min="1" max="127" value="100" title="Default velocity for outgoing MIDI" style="width:100%;background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:6px 8px;font-size:13px;" />
                    </div>
                </div>
                <!-- STRUM 1 tab - OSC 1 only -->
                <div id="tab-strum1" style="display:block; border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2);">
                    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                        <h5 style="font-size:12px; margin:0; color:#8fb3d3;">STRUM 1</h5>
                        <span style="font-size:10px; color:#9db6c8; background:#203848; border:1px solid #4a6870; padding:2px 6px; border-radius:4px;">OSC 1</span>
                    </div>
                    <div class="midi-per-section" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px 0;align-items:flex-end;">
                        <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                            <label style="font-size:10px;color:#9db6c8;">MIDI IN</label>
                            <input id="midiIn-strum1" type="number" min="0" max="15" value="1" title="Listen on MIDI input channel (0-15; 0=omni)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                        </div>
                        <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                            <label style="font-size:10px;color:#9db6c8;">MIDI OUT</label>
                            <select id="midiOut-strum1" title="Select MIDI output port (by name)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;"></select>
                        </div>
                        <div style="display:flex;flex-direction:column;gap:3px;min-width:130px;">
                            <label style="font-size:10px;color:#9db6c8;">MIDI OCTAVE</label>
                            <select id="midiOct-strum1" title="Per-section octave transpose for outgoing MIDI" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;">
                                <option value="-3">-3</option>
                                <option value="-2">-2</option>
                                <option value="-1">-1</option>
                                <option value="0" selected>0</option>
                                <option value="1">+1</option>
                                <option value="2">+2</option>
                                <option value="3">+3</option>
                            </select>
                        </div>
                        <div style="display:flex;flex-direction:column;gap:3px;min-width:150px;">
                            <label style="font-size:10px;color:#9db6c8;">MIDI VELOCITY</label>
                            <input id="midiVel-strum1" type="number" min="1" max="127" value="100" title="Default velocity for this section" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                        </div>
                    </div>
                        <div class="oscillator-controls" style="margin-bottom:8px;">
                            <div class="osc-btn active" data-wave="sine" data-osc="1" style="font-size:11px; padding:6px 8px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-osc="1" style="font-size:11px; padding:6px 8px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-osc="1" style="font-size:11px; padding:6px 8px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-osc="1" style="font-size:11px; padding:6px 8px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-osc="1" style="font-size:11px; padding:6px 8px;">Nse</div>
                            <div class="osc-btn" data-wave="pulse" data-osc="1" style="font-size:11px; padding:6px 8px;">Pulse</div>
                            <div class="osc-btn" data-wave="fullrect" data-osc="1" style="font-size:11px; padding:6px 8px;">FRect</div>
                            <div class="osc-btn" data-wave="halfrect" data-osc="1" style="font-size:11px; padding:6px 8px;">HRect</div>
                            
                            <div class="osc-btn" data-wave="parabolic" data-osc="1" style="font-size:11px; padding:6px 8px;">Para</div>
                            <div class="osc-btn" data-wave="stair" data-osc="1" style="font-size:11px; padding:6px 8px;">Stair</div>
                        </div>
                        <div class="slider-container pulse-width-container" data-osc="1" style="display:none; margin-bottom:6px;">
                            <label style="font-size:9px;">Pulse Width</label>
                            <input type="range" class="synth-slider" id="osc1PulseWidth" min="5" max="95" value="50" style="height:20px;">
                            <div class="slider-value" id="osc1PulseWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container" data-osc="1" style="margin-bottom:6px;">
                            <label style="font-size:9px;">Width of Shape</label>
                            <input type="range" class="synth-slider" id="osc1ShapeWidth" min="0" max="100" value="50" style="height:20px;">
                            <div class="slider-value" id="osc1ShapeWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="osc1Level" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="osc1LevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Fine</label>
                                <input type="range" class="synth-slider" id="osc1Detune" min="-50" max="50" value="0" style="height:20px;">
                                <div class="slider-value" id="osc1DetuneValue" style="font-size:9px;">0¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="osc1Octave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="osc1OctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="osc1Coarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="osc1CoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR 1</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="attackSlider" min="0" max="1000" value="5" style="height:18px;">
                                <div class="slider-value" id="attackValue" style="font-size:8px;" contenteditable="true" title="Type ms. Hold Shift while dragging for fine ms.">5ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="decaySlider" min="0" max="1000" value="200" style="height:18px;">
                                <div class="slider-value" id="decayValue" style="font-size:8px;" contenteditable="true" title="Type ms. Hold Shift while dragging for fine ms.">200ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="sustainSlider" min="0" max="100" value="0" style="height:18px;">
                                <div class="slider-value" id="sustainValue" style="font-size:8px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="releaseSlider" min="0" max="1000" value="1000" style="height:18px;">
                                <div class="slider-value" id="releaseValue" style="font-size:8px;" contenteditable="true" title="Type ms. Hold Shift while dragging for fine ms.">1000ms</div>
                            </div>
                        </div>
                        <!-- FX Send Checkbox -->
                        <div style="display:flex; align-items:center; justify-content:center; margin-top:8px; padding:6px; background:rgba(155,89,182,0.1); border-radius:4px; border:1px solid #9b59b6;">
                            <label style="display:flex; align-items:center; gap:6px; font-size:10px; color:#9b59b6; cursor:pointer;">
                                <input type="checkbox" id="strum1FxSend" checked style="margin:0; transform:scale(1.2);">
                                <span>Send to FX</span>
                            </label>
                        </div>
                    </div>
                    <!-- STRUM 2 tab - OSC 2 only -->
                    <div id="tab-strum2" style="display:none; border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2);">
                        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                            <h5 style="font-size:12px; margin:0; color:#8fb3d3;">STRUM 2</h5>
                            <span style="font-size:10px; color:#9db6c8; background:#203848; border:1px solid #4a6870; padding:2px 6px; border-radius:4px;">OSC 2</span>
                        </div>
                        <div class="midi-per-section" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px 0;align-items:flex-end;">
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI IN</label>
                                <input id="midiIn-strum2" type="number" min="0" max="15" value="1" title="Listen on MIDI input channel (0-15; 0=omni)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OUT</label>
                                <select id="midiOut-strum2" title="Select MIDI output port (by name)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;"></select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:130px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OCTAVE</label>
                                <select id="midiOct-strum2" title="Per-section octave transpose for outgoing MIDI" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;">
                                    <option value="-3">-3</option>
                                    <option value="-2">-2</option>
                                    <option value="-1">-1</option>
                                    <option value="0" selected>0</option>
                                    <option value="1">+1</option>
                                    <option value="2">+2</option>
                                    <option value="3">+3</option>
                                </select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:150px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI VELOCITY</label>
                                <input id="midiVel-strum2" type="number" min="1" max="127" value="100" title="Default velocity for this section" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                        </div>
                        <div class="oscillator-controls" style="margin-bottom:8px;">
                            <div class="osc-btn active" data-wave="sine" data-osc="2" style="font-size:11px; padding:6px 8px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-osc="2" style="font-size:11px; padding:6px 8px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-osc="2" style="font-size:11px; padding:6px 8px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-osc="2" style="font-size:11px; padding:6px 8px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-osc="2" style="font-size:11px; padding:6px 8px;">Nse</div>
                            <div class="osc-btn" data-wave="pulse" data-osc="2" style="font-size:11px; padding:6px 8px;">Pulse</div>
                            <div class="osc-btn" data-wave="fullrect" data-osc="2" style="font-size:11px; padding:6px 8px;">FRect</div>
                            <div class="osc-btn" data-wave="halfrect" data-osc="2" style="font-size:11px; padding:6px 8px;">HRect</div>
                            <div class="osc-btn" data-wave="parabolic" data-osc="2" style="font-size:11px; padding:6px 8px;">Para</div>
                            <div class="osc-btn" data-wave="stair" data-osc="2" style="font-size:11px; padding:6px 8px;">Stair</div>
                        </div>
                        <div class="slider-container pulse-width-container" data-osc="2" style="display:none; margin-bottom:6px;">
                            <label style="font-size:9px;">Pulse Width</label>
                            <input type="range" class="synth-slider" id="osc2PulseWidth" min="5" max="95" value="50" style="height:20px;">
                            <div class="slider-value" id="osc2PulseWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container" data-osc="2" style="margin-bottom:6px;">
                            <label style="font-size:9px;">Width of Shape</label>
                            <input type="range" class="synth-slider" id="osc2ShapeWidth" min="0" max="100" value="50" style="height:20px;">
                            <div class="slider-value" id="osc2ShapeWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="osc2Level" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="osc2LevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Fine</label>
                                <input type="range" class="synth-slider" id="osc2Detune" min="-50" max="50" value="-7" style="height:20px;">
                                <div class="slider-value" id="osc2DetuneValue" style="font-size:9px;">-7¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="osc2Octave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="osc2OctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="osc2Coarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="osc2CoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR 2</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="osc2AttackSlider" min="0" max="1000" value="5" style="height:18px;">
                                <div class="slider-value" id="osc2AttackValue" style="font-size:8px;" contenteditable="true" title="Type ms. Hold Shift while dragging for fine ms.">5ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="osc2DecaySlider" min="0" max="1000" value="30" style="height:18px;">
                                <div class="slider-value" id="osc2DecayValue" style="font-size:8px;" contenteditable="true" title="Type ms. Hold Shift while dragging for fine ms.">30ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="osc2SustainSlider" min="0" max="100" value="0" style="height:18px;">
                                <div class="slider-value" id="osc2SustainValue" style="font-size:8px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="osc2ReleaseSlider" min="0" max="1000" value="1000" style="height:18px;">
                                <div class="slider-value" id="osc2ReleaseValue" style="font-size:8px;" contenteditable="true" title="Type ms. Hold Shift while dragging for fine ms.">1000ms</div>
                            </div>
                        </div>
                        <!-- FX Send Checkbox -->
                        <div style="display:flex; align-items:center; justify-content:center; margin-top:8px; padding:6px; background:rgba(155,89,182,0.1); border-radius:4px; border:1px solid #9b59b6;">
                            <label style="display:flex; align-items:center; gap:6px; font-size:10px; color:#9b59b6; cursor:pointer;">
                                <input type="checkbox" id="strum2FxSend" checked style="margin:0; transform:scale(1.2);">
                                <span>Send to FX</span>
                            </label>
                        </div>
                    </div>
                    <!-- CHORD instrument panel -->
                    <div id="tab-chord" style="display:none; border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2);">
                        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                            <h5 style="font-size:12px; margin:0; color:#8fb3d3;">CHORD</h5>
                            <span style="font-size:10px; color:#9db6c8; background:#203848; border:1px solid #4a6870; padding:2px 6px; border-radius:4px;">OSC 3</span>
                        </div>
                        <div class="midi-per-section" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px 0;align-items:flex-end;">
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI IN</label>
                                <input id="midiIn-chord" type="number" min="0" max="15" value="1" title="Listen on MIDI input channel (0-15; 0=omni)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OUT</label>
                                <select id="midiOut-chord" title="Select MIDI output port (by name)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;"></select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:130px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OCTAVE</label>
                                <select id="midiOct-chord" title="Per-section octave transpose for outgoing MIDI" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;">
                                    <option value="-3">-3</option>
                                    <option value="-2">-2</option>
                                    <option value="-1">-1</option>
                                    <option value="0" selected>0</option>
                                    <option value="1">+1</option>
                                    <option value="2">+2</option>
                                    <option value="3">+3</option>
                                </select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:150px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI VELOCITY</label>
                                <input id="midiVel-chord" type="number" min="1" max="127" value="100" title="Default velocity for this section" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                        </div>
                        <div class="oscillator-controls" style="margin-bottom:8px;">
                            <div class="osc-btn active" data-wave="sine" data-inst="chord" style="font-size:11px; padding:6px 8px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-inst="chord" style="font-size:11px; padding:6px 8px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-inst="chord" style="font-size:11px; padding:6px 8px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-inst="chord" style="font-size:11px; padding:6px 8px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-inst="chord" style="font-size:11px; padding:6px 8px;">Nse</div>
                            <div class="osc-btn" data-wave="pulse" data-inst="chord" style="font-size:11px; padding:6px 8px;">Pulse</div>
                            <div class="osc-btn" data-wave="fullrect" data-inst="chord" style="font-size:11px; padding:6px 8px;">FRect</div>
                            <div class="osc-btn" data-wave="halfrect" data-inst="chord" style="font-size:11px; padding:6px 8px;">HRect</div>
                            <div class="osc-btn" data-wave="parabolic" data-inst="chord" style="font-size:11px; padding:6px 8px;">Para</div>
                            <div class="osc-btn" data-wave="stair" data-inst="chord" style="font-size:11px; padding:6px 8px;">Stair</div>
                        </div>
                        <div class="slider-container" style="display:none; margin-bottom:6px;" id="chordPulseWidthContainer">
                            <label style="font-size:9px;">Pulse Width</label>
                            <input type="range" class="synth-slider" id="chordPulseWidth" min="5" max="95" value="50" style="height:20px;">
                            <div class="slider-value" id="chordPulseWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container" style="margin-bottom:6px;">
                            <label style="font-size:9px;">Width of Shape</label>
                            <input type="range" class="synth-slider" id="chordShapeWidth" min="0" max="100" value="50" style="height:20px;">
                            <div class="slider-value" id="chordShapeWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="chordLevel" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="chordLevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Fine</label>
                                <input type="range" class="synth-slider" id="chordDetune" min="-50" max="50" value="0" style="height:20px;">
                                <div class="slider-value" id="chordDetuneValue" style="font-size:9px;">0¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="chordOctave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="chordOctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="chordCoarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="chordCoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="chordAttackSlider" min="0" max="1000" value="10" style="height:18px;">
                                <div class="slider-value" id="chordAttackValue" style="font-size:8px;">10ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="chordDecaySlider" min="0" max="1000" value="200" style="height:18px;">
                                <div class="slider-value" id="chordDecayValue" style="font-size:8px;">200ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="chordSustainSlider" min="0" max="100" value="70" style="height:18px;">
                                <div class="slider-value" id="chordSustainValue" style="font-size:8px;">70%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="chordReleaseSlider" min="0" max="1000" value="500" style="height:18px;">
                                <div class="slider-value" id="chordReleaseValue" style="font-size:8px;">500ms</div>
                            </div>
                        </div>
                        <!-- FX Send Checkbox -->
                        <div style="display:flex; align-items:center; justify-content:center; margin-top:8px; padding:6px; background:rgba(155,89,182,0.1); border-radius:4px; border:1px solid #9b59b6;">
                            <label style="display:flex; align-items:center; gap:6px; font-size:10px; color:#9b59b6; cursor:pointer;">
                                <input type="checkbox" id="chordFxSend" style="margin:0; transform:scale(1.2);">
                                <span>Send to FX</span>
                            </label>
                        </div>
                    </div>
                    <!-- ARP instrument panel -->
                    <div id="tab-arp" style="display:none; border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2);">
                        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                            <h5 style="font-size:12px; margin:0; color:#8fb3d3;">ARP</h5>
                            <span style="font-size:10px; color:#9db6c8; background:#203848; border:1px solid #4a6870; padding:2px 6px; border-radius:4px;">OSC 5</span>
                        </div>
                        <div class="midi-per-section" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px 0;align-items:flex-end;">
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI IN</label>
                                <input id="midiIn-arp" type="number" min="0" max="15" value="1" title="Listen on MIDI input channel (0-15; 0=omni)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OUT</label>
                                <select id="midiOut-arp" title="Select MIDI output port (by name)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;"></select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:130px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OCTAVE</label>
                                <select id="midiOct-arp" title="Per-section octave transpose for outgoing MIDI" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;">
                                    <option value="-3">-3</option>
                                    <option value="-2">-2</option>
                                    <option value="-1">-1</option>
                                    <option value="0" selected>0</option>
                                    <option value="1">+1</option>
                                    <option value="2">+2</option>
                                    <option value="3">+3</option>
                                </select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:150px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI VELOCITY</label>
                                <input id="midiVel-arp" type="number" min="1" max="127" value="100" title="Default velocity for this section" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                        </div>
                        <div class="oscillator-controls" style="margin-bottom:8px;">
                            <div class="osc-btn active" data-wave="sine" data-inst="arp" style="font-size:11px; padding:6px 8px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-inst="arp" style="font-size:11px; padding:6px 8px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-inst="arp" style="font-size:11px; padding:6px 8px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-inst="arp" style="font-size:11px; padding:6px 8px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-inst="arp" style="font-size:11px; padding:6px 8px;">Nse</div>
                            <div class="osc-btn" data-wave="pulse" data-inst="arp" style="font-size:11px; padding:6px 8px;">Pulse</div>
                            <div class="osc-btn" data-wave="fullrect" data-inst="arp" style="font-size:11px; padding:6px 8px;">FRect</div>
                            <div class="osc-btn" data-wave="halfrect" data-inst="arp" style="font-size:11px; padding:6px 8px;">HRect</div>
                            <div class="osc-btn" data-wave="parabolic" data-inst="arp" style="font-size:11px; padding:6px 8px;">Para</div>
                            <div class="osc-btn" data-wave="stair" data-inst="arp" style="font-size:11px; padding:6px 8px;">Stair</div>
                        </div>
                        <div class="slider-container" style="display:none; margin-bottom:6px;" id="arpPulseWidthContainer">
                            <label style="font-size:9px;">Pulse Width</label>
                            <input type="range" class="synth-slider" id="arpPulseWidth" min="5" max="95" value="50" style="height:20px;">
                            <div class="slider-value" id="arpPulseWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container" style="margin-bottom:6px;">
                            <label style="font-size:9px;">Width of Shape</label>
                            <input type="range" class="synth-slider" id="arpShapeWidth" min="0" max="100" value="50" style="height:20px;">
                            <div class="slider-value" id="arpShapeWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="arpLevel" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="arpLevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Fine</label>
                                <input type="range" class="synth-slider" id="arpDetune" min="-50" max="50" value="0" style="height:20px;">
                                <div class="slider-value" id="arpDetuneValue" style="font-size:9px;">0¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="arpOctave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="arpOctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="arpCoarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="arpCoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="arpAttackSlider" min="0" max="1000" value="10" style="height:18px;">
                                <div class="slider-value" id="arpAttackValue" style="font-size:8px;">10ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="arpDecaySlider" min="0" max="1000" value="200" style="height:18px;">
                                <div class="slider-value" id="arpDecayValue" style="font-size:8px;">200ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="arpSustainSlider" min="0" max="100" value="70" style="height:18px;">
                                <div class="slider-value" id="arpSustainValue" style="font-size:8px;">70%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="arpReleaseSlider" min="0" max="1000" value="500" style="height:18px;">
                                <div class="slider-value" id="arpReleaseValue" style="font-size:8px;">500ms</div>
                            </div>
                        </div>
                        <!-- FX Send Checkbox -->
                        <div style="display:flex; align-items:center; justify-content:center; margin-top:8px; padding:6px; background:rgba(155,89,182,0.1); border-radius:4px; border:1px solid #9b59b6;">
                            <label style="display:flex; align-items:center; gap:6px; font-size:10px; color:#9b59b6; cursor:pointer;">
                                <input type="checkbox" id="arpFxSend" checked style="margin:0; transform:scale(1.2);">
                                <span>Send to FX</span>
                            </label>
                        </div>
                    </div>
                    <!-- BASS instrument panel -->
                    <div id="tab-bass" style="display:none; border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2);">
                        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                            <h5 style="font-size:12px; margin:0; color:#8fb3d3;">BASS</h5>
                            <span style="font-size:10px; color:#9db6c8; background:#203848; border:1px solid #4a6870; padding:2px 6px; border-radius:4px;">OSC 4</span>
                        </div>
                        <div class="midi-per-section" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px 0;align-items:flex-end;">
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI IN</label>
                                <input id="midiIn-bass" type="number" min="0" max="15" value="1" title="Listen on MIDI input channel (0-15; 0=omni)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:110px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OUT</label>
                                <select id="midiOut-bass" title="Select MIDI output port (by name)" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;"></select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:130px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI OCTAVE</label>
                                <select id="midiOct-bass" title="Per-section octave transpose for outgoing MIDI" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;">
                                    <option value="-3">-3</option>
                                    <option value="-2">-2</option>
                                    <option value="-1">-1</option>
                                    <option value="0" selected>0</option>
                                    <option value="1">+1</option>
                                    <option value="2">+2</option>
                                    <option value="3">+3</option>
                                </select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:3px;min-width:150px;">
                                <label style="font-size:10px;color:#9db6c8;">MIDI VELOCITY</label>
                                <input id="midiVel-bass" type="number" min="1" max="127" value="100" title="Default velocity for this section" style="background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:4px 6px;font-size:12px;width:100%;" />
                            </div>
                        </div>
                        <div class="oscillator-controls" style="margin-bottom:8px;">
                            <div class="osc-btn active" data-wave="sine" data-inst="bass" style="font-size:11px; padding:6px 8px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-inst="bass" style="font-size:11px; padding:6px 8px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-inst="bass" style="font-size:11px; padding:6px 8px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-inst="bass" style="font-size:11px; padding:6px 8px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-inst="bass" style="font-size:11px; padding:6px 8px;">Nse</div>
                            <div class="osc-btn" data-wave="pulse" data-inst="bass" style="font-size:11px; padding:6px 8px;">Pulse</div>
                            <div class="osc-btn" data-wave="fullrect" data-inst="bass" style="font-size:11px; padding:6px 8px;">FRect</div>
                            <div class="osc-btn" data-wave="halfrect" data-inst="bass" style="font-size:11px; padding:6px 8px;">HRect</div>
                            <div class="osc-btn" data-wave="parabolic" data-inst="bass" style="font-size:11px; padding:6px 8px;">Para</div>
                            <div class="osc-btn" data-wave="stair" data-inst="bass" style="font-size:11px; padding:6px 8px;">Stair</div>
                        </div>
                        <div class="slider-container" style="display:none; margin-bottom:6px;" id="bassPulseWidthContainer">
                            <label style="font-size:9px;">Pulse Width</label>
                            <input type="range" class="synth-slider" id="bassPulseWidth" min="5" max="95" value="50" style="height:20px;">
                            <div class="slider-value" id="bassPulseWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container" style="margin-bottom:6px;">
                            <label style="font-size:9px;">Width of Shape</label>
                            <input type="range" class="synth-slider" id="bassShapeWidth" min="0" max="100" value="50" style="height:20px;">
                            <div class="slider-value" id="bassShapeWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="bassLevel" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="bassLevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Fine</label>
                                <input type="range" class="synth-slider" id="bassDetune" min="-50" max="50" value="0" style="height:20px;">
                                <div class="slider-value" id="bassDetuneValue" style="font-size:9px;">0¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="bassOctave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="bassOctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="bassCoarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="bassCoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="bassAttackSlider" min="0" max="1000" value="5" style="height:18px;">
                                <div class="slider-value" id="bassAttackValue" style="font-size:8px;">5ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="bassDecaySlider" min="0" max="1000" value="80" style="height:18px;">
                                <div class="slider-value" id="bassDecayValue" style="font-size:8px;">80ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="bassSustainSlider" min="0" max="100" value="85" style="height:18px;">
                                <div class="slider-value" id="bassSustainValue" style="font-size:8px;">85%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="bassReleaseSlider" min="0" max="1000" value="120" style="height:18px;">
                                <div class="slider-value" id="bassReleaseValue" style="font-size:8px;">120ms</div>
                            </div>
                        </div>
                        <!-- FX Send Checkbox -->
                        <div style="display:flex; align-items:center; justify-content:center; margin-top:8px; padding:6px; background:rgba(155,89,182,0.1); border-radius:4px; border:1px solid #9b59b6;">
                            <label style="display:flex; align-items:center; gap:6px; font-size:10px; color:#9b59b6; cursor:pointer;">
                                <input type="checkbox" id="bassFxSend" style="margin:0; transform:scale(1.2);">
                                <span>Send to FX</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Tuning Modal (EDO & Session) -->
    <div id="tuningModal" class="floating-modal" style="top:140px; left:400px; width:420px; height:340px; display:none; overflow:hidden;">
        <div class="modal-header">
            <span>Tuning / Session</span>
            <div style="display:flex; gap:6px; align-items:center;">
                <button id="closeTuningModal" class="modal-close" style="background:#e74c3c;">×</button>
            </div>
        </div>
        <div class="modal-body" style="height:calc(100% - 44px); overflow:hidden; padding:14px;">
            <div class="synth-section" id="tuningSelector" style="padding:0 4px 8px 4px; overflow:hidden;">
                <h4 style="font-size:15px; margin-bottom:8px;">EDO Configuration</h4>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:10px;">
                    <div class="slider-container">
                        <label style="font-size:11px;">Divisions</label>
                        <input type="number" id="edoDivisions" min="5" max="52" value="24" style="width:100%; padding:4px; background:#2a4858; color:#fff; border:1px solid #4a6870; border-radius:4px; font-size:11px;">
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <button id="resetChordsBtn" class="osc-btn" style="width:100%; font-size:12px; padding:8px; background:#e74c3c; border-color:#c0392b; margin-top:5px;">Clear Unlocked</button>
                </div>
                <div style="margin-bottom:10px; display:flex; gap:5px;">
                    <button id="saveSessionBtn" class="osc-btn" style="flex:1; font-size:11px; padding:6px; background:#3498db; border-color:#2980b9;">💾</button>
                    <button id="loadSessionBtn" class="osc-btn" style="flex:1; font-size:11px; padding:6px; background:#9b59b6; border-color:#8e44ad;">📂</button>
                    <input type="file" id="loadSessionInput" accept=".xen" style="display:none;">
                </div>
            </div>
        </div>
    </div>
    </div>
    <div class="instrument">
        <!-- Root Notes at Top -->
        <div class="root-notes-area">
            <div class="root-notes-selector" style="display:flex;align-items:flex-start;justify-content:center;gap:12px;padding:10px;position:relative;">
                <!-- Left Sidebar with Module Buttons and Menu Controls -->
                <div class="left-sidebar">
                    <!-- Module Buttons -->
                    <button id="keyboardBtn" class="sidebar-btn active" title="Toggle Piano Keyboard" onclick="sidebarBtnClick('keyboard')">KEYS</button>
                    <button id="strumBtn" class="sidebar-btn" title="Toggle Strum Mode" onclick="sidebarBtnClick('strum')">STRUM</button>
                    <button id="patternBtn" class="sidebar-btn" title="Toggle Pattern Editor" onclick="sidebarBtnClick('pattern')">PATTERN</button>
                    <button id="chordsBtn" class="sidebar-btn active" title="Toggle Chord Mode" onclick="sidebarBtnClick('chords')">CHORDS</button>
                    <button id="drumsBtn" class="sidebar-btn" title="Toggle Drums" onclick="sidebarBtnClick('drums')">DRUMS</button>
                    <button id="bassBtn" class="sidebar-btn active" title="Toggle Bass" onclick="sidebarBtnClick('bass')">BASS</button>
                    <button id="midiBtn" class="sidebar-btn" title="Toggle MIDI" onclick="sidebarBtnClick('midi')">MIDI</button>
                    
                    <!-- Menu Controls moved from top -->
                    <button id="createNewChordBtnSidebar" class="sidebar-btn" title="Add Chord" style="background:#27ae60;border-color:#2ecc71;">+</button>

                    <button id="oscPanelBtn" class="sidebar-btn" title="Oscillator settings">OSC</button>
                    <button id="fxPanelBtn" class="sidebar-btn" title="Effects">FX</button>
                    <button id="seqPanelBtn" class="sidebar-btn" title="Type or paste a chord sequence">SEQ</button>
                    <button id="loadXenBtn" class="sidebar-btn" title="Import .XEN session" style="background:#9b59b6;border-color:#8e44ad;">LOAD</button>
                    <button id="saveXenBtn" class="sidebar-btn" title="Export full session (.XEN)" style="background:#10b981;border-color:#34d399;">SAVE</button>
                    <button id="randomDiceBtnSidebar" class="sidebar-btn" title="Randomize Settings">🎲</button>
                    <button id="tutorialBtnSidebar" class="sidebar-btn" title="Start Tutorial">?</button>
                    
                    <!-- Transpose controls moved to top-right of sidebar -->
                    <div id="sidebarTransposeCluster" style="position:sticky;top:4px;margin-top:4px;display:flex;flex-direction:column;align-items:center;gap:3px;padding:2px 0;z-index:5;">
                        <button id="transposeUpBtn" style="width:34px;height:18px;background:#27ae60;border:1px solid #2ecc71;border-radius:4px;color:#fff;font-size:11px;font-weight:600;line-height:1;cursor:pointer;">▲</button>
                        <div class="delta" id="transposeDelta" style="font-size:9px;color:#9db6c8;text-align:center;min-width:30px;">±0</div>
                        <button id="transposeDownBtn" style="width:34px;height:18px;background:#e74c3c;border:1px solid #c0392b;border-radius:4px;color:#fff;font-size:11px;font-weight:600;line-height:1;cursor:pointer;">▼</button>
                    </div>
                </div>
                
                <!-- Main Content Area -->
                <div class="main-content">
                    <!-- Main Chord Canvas Area -->
                    <div class="chord-canvas-container" style="padding: 20px; min-height: calc(100vh - 100px);">
                        <!-- Piano Keyboard (toggleable) -->
                        <div id="keyboardSection" class="keyboard-section" style="margin-bottom: 20px; display: none;">
                            <div class="root-chord-grid" id="rootGrid" style="max-width:100%; margin:0 auto;"></div>
                        </div>
                        
                        <!-- Main Chord Sequence Area -->
                        <div class="chord-sequence-area" style="flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 400px; /* removed vertical border */ border: none; border-radius: 12px; background: rgba(42, 72, 88, 0.1);">
                            <!-- Empty canvas ready for docking modals -->
                        </div>
                    </div>
                </div>

        <!-- Floating Drum Modal -->
        <div id="drumModal" class="floating-modal" style="top: 100px; left: 200px; width: 900px; height: 600px;">
            <div class="modal-header">
                <span>Drum Sequencer</span>
                <button class="modal-close" onclick="closeDrumModalOnly()">×</button>
            </div>
            <div class="modal-body" style="padding: 15px; height: calc(100% - 60px); overflow: visible;">
                <div class="drum-grid-container" style="height: 100%; overflow: visible;">
                    <div class="drum-grid-header">
                        <span style="opacity:.8;">Pattern</span>
                        <input id="drumPatternNumber" type="number" min="1" max="128" value="1" style="width:64px;background:#2a4858;color:#fff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;" />
                        <button id="drumDuplicateBtn" title="Duplicate to next empty (Ctrl+D)" style="background:#214051;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;font-size:10px;cursor:pointer;">DUP</button>
                        <!-- Drum MIDI OUT (per-section) -->
                        <span style="font-size:10px;opacity:.7;">OUT</span>
                        <select id="midiOut-drum" title="Drum MIDI OUT (select a Web MIDI output port)"
                            style="min-width:120px;max-width:220px;background:#0d2938;color:#e8f5ff;border:1px solid #2b5567;border-radius:6px;padding:2px 6px;font-size:11px;">
                            <option value="">(All Outputs)</option>
                        </select>

                        <!-- Compact TIME controls -->
                        <input id="drumBpmMini" type="number" min="20" max="300" placeholder="BPM" title="Tempo (mirrors TIME modal)"
                            style="width:58px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 6px;font-size:11px;" />
                        <input id="drumTSMini" list="tsOptions" type="text" placeholder="TS" title="Time Signature (e.g., 4/4, 7/8)"
                            style="width:58px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 6px;font-size:11px;" />
                        <input id="drumQuantMini" list="quantOptions" type="text" placeholder="QNT" title="Quantization (e.g., 1/16, 1/8T, tuplet:5/4)"
                            style="width:64px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 6px;font-size:11px;" />
                        
                        <!-- Universal controls -->
                        <select id="universalHold" title="Hold Length" style="width:70px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 4px;font-size:11px;">
                            <option value="beat:1">1bt</option>
                            <option value="beat:2">2bt</option>
                            <option value="bar:1" selected>1bar</option>
                            <option value="bar:2">2bar</option>
                            <option value="bar:4">4bar</option>
                            <option value="bar:8">8bar</option>
                            <option value="bar:16">16b</option>
                        </select>
                        <input id="universalSwing" type="number" min="0" max="75" value="0" title="Swing %" style="width:48px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 4px;font-size:11px;"/>
                        <span style="font-size:10px;opacity:.6;">One bar, 16 steps</span>
                    </div>
                    <div class="drum-grid" id="drumGrid"></div>
                </div>
            </div>
        </div>

        <!-- Floating Pattern Modal -->
        <div id="patternModal" class="floating-modal" style="top: 150px; left: 250px; width: 1000px; height: 700px;">
            <div class="modal-header">
                <span>Pattern Editor</span>
                <button class="modal-close" onclick="closePatternModalOnly()">×</button>
            </div>
            <div class="modal-body" style="padding: 15px; height: calc(100% - 60px); overflow: visible;">
                <div class="drum-grid-container" style="position:relative; height: 100%; overflow: visible;">
                    <div class="drum-grid-header" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
                        <span style="opacity:.8;">Pattern</span>
                        <input id="patternPatternNumber" type="number" min="1" max="128" value="1" style="width:64px;background:#2a4858;color:#fff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;" />
                        <button id="patternDuplicateBtn" title="Duplicate to next empty" style="background:#214051;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;font-size:10px;cursor:pointer;">DUP</button>
                        <div style="display:inline-flex;align-items:center;gap:4px;">
                            <button id="patternLenDec" style="padding:2px 6px;">-</button>
                            <span>LEN <span id="patternLenValue" style="display:inline-block;min-width:20px;text-align:center;">16</span></span>
                            <button id="patternLenInc" style="padding:2px 6px;">+</button>
                        </div>
                        <select id="universalPattern" title="ARP Pattern" style="width:80px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 4px;font-size:11px;">
                            <option value="up" selected>Up</option>
                            <option value="down">Down</option>
                            <option value="updown">UpDn</option>
                            <option value="downup">DnUp</option>
                            <option value="walk-up">Walk↑</option>
                            <option value="walk-down">Walk↓</option>
                            <option value="alt-ends">AltEnd</option>
                            <option value="alt-center">AltCtr</option>
                            <option value="random">Rand</option>
                            <option value="custom">CUSTOM</option>
                        </select>
                        <input id="universalPatternText" type="text" placeholder="Pattern" title="Pattern tokens (auto-sync)" style="width:120px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:6px;padding:2px 4px;font-size:11px;" />
                        <select id="patternQuant" title="Pattern Quant" style="background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 4px;font-size:11px;">
                            <option value="1/4">1/4</option>
                            <option value="1/8">1/8</option>
                            <option value="1/16" selected>1/16</option>
                            <option value="1/32">1/32</option>
                        </select>
                        <select id="patternHold" title="Pattern Hold" style="background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 4px;font-size:11px;">
                            <option value="step">step</option>
                            <option value="beat:1" selected>1bt</option>
                            <option value="beat:2">2bt</option>
                            <option value="bar:1">1bar</option>
                        </select>
                        <input id="universalNpc" type="number" min="1" max="64" value="3" title="Notes Per Cycle (NPC)" style="width:60px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 4px;font-size:11px;" />
                        <span style="font-size:10px;opacity:.6;">Independent cycle (1-64)</span>
                    </div>
                    <div class="drum-grid" id="patternGrid" data-length="16" style="grid-template-rows:repeat(9,1fr);position:relative;"></div>
                    <div id="patternResizeHandle" title="Drag to resize pattern length" style="position:absolute;top:32px;right:-4px;width:8px;height:calc(100% - 40px);cursor:ew-resize;background:linear-gradient(to right, rgba(255,255,255,0.15), rgba(255,255,255,0));"></div>
                </div>
            </div>
        </div>
            </div>
        </div>

        <!-- Floating Bass Modal -->
        <div id="bassModal" class="floating-modal" style="top: 180px; left: 300px; width: 800px; height: 500px;">
            <div class="modal-header">
                <span>Bass Editor</span>
                <button class="modal-close" onclick="closeBassModalOnly()">×</button>
            </div>
            <div class="modal-body" style="padding: 15px; height: calc(100% - 60px); overflow: visible;">
                <div class="drum-grid-container" style="position:relative; height: 100%; overflow: visible;">
                    <div class="drum-grid-header" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
                        <span style="opacity:.8;">Bass Pattern</span>
                        <input id="bassPatternNumber" type="number" min="1" max="128" value="1" style="width:64px;background:#2a4858;color:#fff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;" />
                        <button id="bassDuplicateBtn" title="Duplicate to next empty" style="background:#214051;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 6px;font-size:10px;cursor:pointer;">DUP</button>
                        <div style="display:inline-flex;align-items:center;gap:4px;">
                            <button id="bassLenDec" style="padding:2px 6px;">-</button>
                            <span id="bassLenDisplay" style="min-width:28px;text-align:center;font-size:11px;">16</span>
                            <button id="bassLenInc" style="padding:2px 6px;">+</button>
                        </div>
                        <select id="bassQuantizeSelect" style="background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 4px;font-size:10px;">
                            <option value="step:1">1step</option>
                            <option value="step:2">2step</option>
                            <option value="beat:1">1beat</option>
                            <option value="beat:2">2beat</option>
                            <option value="bar:1">1bar</option>
                        </select>
                        <input id="bassNpc" type="number" min="1" max="9" value="1" title="Notes Per Cycle (NPC)" style="width:60px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:2px 4px;font-size:11px;" />
                        <span style="font-size:10px;opacity:.6;">Bass cycle (1-64)</span>
                    </div>
                    <div class="drum-grid" id="bassGrid" data-length="16" style="grid-template-rows:repeat(9,1fr);position:relative;height:400px;"></div>
                    <div id="bassResizeHandle" title="Drag to resize bass pattern length" style="position:absolute;top:32px;right:-4px;width:8px;height:calc(100% - 40px);cursor:ew-resize;background:linear-gradient(to right, rgba(255,255,255,0.15), rgba(255,255,255,0));"></div>
                </div>
            </div>
        </div>

        <!-- Floating Keyboard Modal (590x320 with Keys Visible) -->
        <div id="keyboardModal" class="floating-modal" style="top: 22px; left: 80px; width: 590px; height: 320px; display: block; z-index: 10000;">
            <div class="modal-header">
                <span>Keyboard</span>
                <div style="display:flex;align-items:center;gap:8px;">
                    <label style="display:flex;align-items:center;gap:3px;color:#9db6c8;font-size:9px;">
                        EDO <input id="edoQuickInputKeyboard" type="number" min="5" max="52" value="24" title="Steps per octave" style="width:40px;height:16px;background:#2a4858;color:#fff;border:1px solid #4a6870;border-radius:2px;font-size:9px;padding:1px 2px;">
                    </label>
                    <button class="modal-close" onclick="closeKeyboardModalOnly()">×</button>
                </div>
            </div>
            <div class="modal-body" style="padding: 8px; height: calc(100% - 60px); overflow: hidden;">
                <div id="keyboardContainer" style="width: 100%; height: 100%;">
                    <!-- Transpose controls -->
                    <div style="display: flex; justify-content: flex-end; align-items: center; margin-bottom: 8px; gap: 8px;">
                        <button id="transposeUpBtnModal" style="width:32px;height:24px;background:#27ae60;border:1px solid #2ecc71;border-radius:4px;color:#fff;font-size:10px;font-weight:bold;cursor:pointer;">▲</button>
                        <div style="color:#9db6c8;font-size:9px;min-width:32px;text-align:center;">Transpose</div>
                        <button id="transposeDownBtnModal" style="width:32px;height:24px;background:#e74c3c;border:1px solid #c0392b;border-radius:4px;color:#fff;font-size:10px;font-weight:bold;cursor:pointer;">▼</button>
                    </div>
                    <!-- Root grid will be moved here -->
                    <div id="modalRootGrid" style="width: 100%; height: calc(100% - 40px); overflow: hidden;"></div>
                </div>
            </div>
        </div>

        <!-- Fretboard/Strings with Resize Handle -->
        <div class="chord-resize-container" style="position: absolute; top: 0; bottom: 28px; left: 80px; right: 0;">
            <div class="chord-resize-handle" id="chordResizeHandle">
                <div class="resize-grip"></div>
            </div>
            <div class="strum-area" id="strumArea" style="position: absolute; top: 50vh; bottom: 0; left: 0; right: 0; margin-left: 0;">
                <div class="extension-columns" id="extensionColumns"></div>
            </div>
        </div>


    <!-- Unified Chord Builder Modal -->
    <div id="chordBuilderModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; max-width: 95%; max-height: 95%; overflow-y: auto; width: 800px;">
            <h3 id="chordBuilderTitle">Enhanced Chord Builder</h3>
            
            <!-- Chord Name Input -->
            <div style="margin: 20px 0;">
                <label>Chord Name (flavor only, no root):</label>
                <input type="text" id="chordBuilderName" placeholder="e.g. maj7#11, min9, sus2add6" style="width: 300px; padding: 8px; margin-left: 10px; background: #2a4858; color: #fff; border: 1px solid #4a6870; border-radius: 4px;">
            </div>
            
            <!-- Chord Extensions Checkboxes -->
            <div style="margin: 20px 0;">
                <h4 style="margin: 0 0 10px 0; color: #4a90e2;">🎵 Diatonic Extensions (Select Multiple)</h4>
                <div id="chordExtensionsCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; margin-bottom: 15px; padding: 15px; border: 2px solid #4a6870; border-radius: 8px; background: rgba(0, 20, 40, 0.3);">
                    <!-- Extension checkboxes will be populated here -->
                </div>
            </div>
            
            <!-- Microtonal Intervals Section -->
            <div id="microtonalSection" style="margin: 20px 0;">
                <h4 style="margin: 0 0 10px 0; color: #27ae60;">🔍 Microtonal Intervals</h4>
                <div style="font-size: 12px; color: #8fb3d3; margin-bottom: 8px;">
                    <span style="color: #4a90e2;"> </span> Diatonic approximations &nbsp;
                    <span style="color: #27ae60;"> </span> Neutral/Xenharmonic &nbsp;
                    <span style="color: #f39c12;"> </span> Quarter-tone regions &nbsp;
                    <span style="color: #e74c3c;"> </span> Chromatic equivalents
                </div>
                <div id="microtonalCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 6px; max-height: 300px; overflow-y: auto; padding: 15px; border: 2px solid #4a6870; border-radius: 8px; background: rgba(0, 20, 40, 0.3);">
                    <!-- Microtonal interval checkboxes will be populated here -->
                </div>
            </div>
            
            <!-- Preview Section -->
            <div style="margin: 20px 0; padding: 15px; border: 2px solid #8e44ad; border-radius: 8px; background: rgba(142, 68, 173, 0.1);">
                <h4 style="margin: 0 0 10px 0; color: #8e44ad;">🎧 Chord Preview</h4>
                <div id="chordPreviewDisplay" style="font-family: var(--retro-font); font-size: 14px; color: #8fb3d3; min-height: 40px; padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 4px;">
                    No intervals selected
                </div>
            </div>
            
            <!-- Favorites Section -->
            <div id="favoritesSection" style="margin: 20px 0; padding: 15px; border: 1px solid #4a6870; border-radius: 8px; background: rgba(42, 72, 88, 0.3);">
                <h4 style="margin: 0 0 10px 0; color: #f39c12;">? Favorite Chords</h4>
                <div id="chordBuilderFavoritesList" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 10px; min-height: 60px;">
                    <!-- Favorite chords will be populated here -->
                </div>
                <div style="font-size: 12px; color: #8fb3d3;">
                    Click any favorite to load its pattern into the builder
                </div>
            </div>
            
            <!-- Actions -->
            <div style="margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="osc-btn" id="closeChordBuilder">Close</button>
                <button class="osc-btn" id="saveChordBuilder" style="background: #27ae60;">✅ Save Chord</button>
                <button class="osc-btn" id="addToFavoritesBuilder" style="background: #f39c12;">★ Add to Favorites</button>
                <button class="osc-btn" id="previewChordBuilder" style="background: #8e44ad;">🔊 Preview</button>
                <button class="osc-btn" id="clearChordBuilder" style="background: #e74c3c;">❌ Clear</button>
            </div>
        </div>
    </div>


    <!-- Edit Pattern Modal -->
    <div id="editPatternModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; max-width: 80%; max-height: 80%; overflow-y: auto;">
            <h3 id="editPatternTitle">Edit Note Pattern</h3>
            <div style="margin: 20px 0;">
                <label>Pattern Name:</label>
                <input type="text" id="editPatternName" style="width: 200px; padding: 5px; margin-left: 10px; background: #2a4858; color: #fff; border: 1px solid #4a6870; border-radius: 4px;">
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Intervals from Root (semitones):</label>
                <div id="intervalEditor" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-top: 10px;"></div>
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Quick Patterns:</label>
                <div style="display: flex; gap: 5px; margin-top: 5px; flex-wrap: wrap;">
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7])">Major</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 3, 7])">Minor</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 10])">Dom7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 11])">Maj7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 3, 7, 10])">m7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 2, 7])">Sus2</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 5, 7])">Sus4</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 9])">6th</button>
                </div>
            </div>
            <div style="margin-top: 20px;">
                <button class="osc-btn" id="closeEditPatternModal">Close</button>
                <button class="osc-btn" id="saveEditPattern">Save Pattern</button>
            </div>
        </div>
    </div>

    <!-- Chord Name Modal -->
    <div id="chordNameModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; min-width: 400px;">
            <h3 style="color: #8fb3d3; margin-bottom: 20px; text-align: center;">💾 Save Your Chord</h3>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #8fb3d3;">Chord Name:</label>
                <input type="text" id="chordNameInput" placeholder="e.g. C, Dm, F?7, etc." style="width: 100%; padding: 10px; background: #2a4858; color: #fff; border: 2px solid #4a6870; border-radius: 6px; font-size: 16px;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #8fb3d3;">Selected Intervals:</label>
                <div id="selectedIntervalsDisplay" style="background: #2a4858; padding: 10px; border-radius: 6px; color: #fff; font-family: var(--retro-font);"></div>
            </div>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="osc-btn" id="cancelChordName" style="background: #666; border-color: #888;">Cancel</button>
                <button class="osc-btn" id="saveChordName" style="background: #2E8B57; border-color: #3CB371;">✅ Save Chord</button>
            </div>
        </div>
    </div>

    <!-- Text -> Chords Parser Modal -->
    <div id="textChordModal" class="floating-modal" style="display:none; top: 120px; left: 220px; width: 800px; height: 600px; z-index: 10000;">
        <div class="modal-header">
            <span>Chord Sequence Editor</span>
            <button class="modal-close" id="closeTextChordModalBtn">×</button>
        </div>
        <div class="modal-body" style="padding: 15px; height: calc(100% - 60px); overflow-y: auto;">
            <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px; flex-wrap:wrap;">
                <label style="display:flex; align-items:center; gap:6px; color:#8fb3d3; font-size:12px;">
                    <input id="seqRepeat" type="checkbox" style="transform:translateY(1px)"> Repeat unique sections
                </label>
            </div>
            <div style="display:flex; align-items:center; gap:10px; margin:6px 0 8px 0;">
                <label style="font-size:12px;color:#9db6c8;">EDO</label>
                <input id="seqEdoInput" type="number" min="5" max="52" value="24" title="Steps per octave for this sequence" style="width:64px;background:#102a3a;color:#e8f5ff;border:1px solid #2b5567;border-radius:4px;padding:4px 6px;font-size:12px;" />
                <span style="font-size:11px;color:#6ea4bf;">Saved with preset and applied on load</span>
            </div>
            <textarea id="textChordInput" placeholder="EXAMPLE CHORDS: C Am F G
MICROTONAL CHORDS ^ means up one step, v means down one step: C A^m Fvm G7
ROMAN NUMERALS: I vi IV V
ROMAN NUMERALS with up/down: I^ viv ii7 vii7
REPEATS: [C Am F G]x4 
NESTED REPEATS: [[C Am F G]x2 [C Dm Em F^]x2]x4
| DIVIDER COLUMN" style="width:100%; min-height:160px; background:#102a3a; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; line-height:1.5; resize:vertical;"></textarea>

            <!-- Sequence preset controls -->
            <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
                <select id="seqPresetDropdown" style="background:#08222b; color:#e8f5ff; border:1px solid #1f5566; padding:6px; border-radius:6px; min-width:220px;"></select>
                <button class="osc-btn" id="addSeqPresetBtn" title="Save current text as a new preset">Save Preset</button>
                <button class="osc-btn" id="deleteSeqPresetBtn" title="Delete selected preset" style="background:#d9534f; border-color:#c9302c;">Delete</button>
                <button class="osc-btn" id="selectSeqPresetBtn" title="Load selected preset into textarea">Load</button>
            </div>

            <div style="margin-top:8px; display:flex; align-items:center; gap:10px;">
                <div style="font-size:12px; color:#8fb3d3;">Unique chords found:</div>
                <div id="textChordCount" style="font-size:12px; color:#f0f6ff;">0</div>
                <div style="margin-left:auto; display:flex; gap:8px;">
                    <button class="osc-btn" id="parseTextChordsBtn" style="background:#3498db; border-color:#2980b9;">Create Sequence</button>
                </div>
            </div>

            <div id="textChordResults" style="margin-top:10px; display:grid; grid-template-columns:repeat(auto-fill, minmax(120px, 1fr)); gap:8px;"></div>
        </div>
    </div>

    <!-- Tutorial Overlay -->
    <div id="tutorialOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999;">
        <div id="tutorialBox" style="position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: #1a1a2e; border: 2px solid #4a6870; border-radius: 10px; padding: 20px; max-width: 600px; max-height: 70vh; overflow-y: auto; z-index: 10000; box-shadow: 0 10px 30px rgba(0,0,0,0.8);">
            <h3 id="tutorialTitle" style="color: #8fb3d3; margin-top: 0;">Welcome to XENON</h3>
            <p id="tutorialText" style="color: #fff; line-height: 1.5;">Click Next to start the tutorial.</p>
            <div style="margin-top: 15px; text-align: center; font-size: 12px; color: #8fb3d3; opacity: 0.9; background: rgba(74, 104, 112, 0.2); padding: 8px; border-radius: 5px;">
                💡 Press ESC, click outside, or use Skip Tutorial to exit anytime
            </div>
            <div style="margin-top: 20px; text-align: right;">
                <button id="tutorialPrev" class="osc-btn" style="margin-right: 10px;">Previous</button>
                <button id="tutorialNext" class="osc-btn">Next</button>
                <button id="tutorialSkip" class="osc-btn" style="margin-left: 10px; background: #dc2626;">Skip Tutorial</button>
            </div>
        </div>
    </div>

    
    

    <script>
        // Define modal functions early for immediate access
        window.showKeyboardModal = function() {
            console.log('Opening keyboard modal');
            const modal = document.getElementById('keyboardModal');
            if (modal) {
                modal.style.display = 'block';
                bringModalToFront('keyboardModal');
                
                // Move root grid into modal
                const modalRootGrid = document.getElementById('modalRootGrid');
                const rootGrid = document.getElementById('rootGrid');
                
                if (modalRootGrid && rootGrid) {
                    // Clear any existing content and move the grid
                    modalRootGrid.innerHTML = '';
                    modalRootGrid.appendChild(rootGrid);
                    rootGrid.style.display = 'block';
                    console.log('Root grid moved to modal');
                }
                
                // Ensure keyboard is fully generated/regenerated every time
                if (window.omnichord && typeof omnichord.generateRootButtons === 'function') {
                    omnichord.generateRootButtons();
                    console.log('Keyboard buttons regenerated');
                }
                
                // Wire up modal transpose buttons
                const transposeUp = document.getElementById('transposeUpBtnModal');
                const transposeDown = document.getElementById('transposeDownBtnModal');
                const originalUp = document.getElementById('transposeUpBtn');
                const originalDown = document.getElementById('transposeDownBtn');
                if (transposeUp && originalUp && !transposeUp._wired) {
                    transposeUp._wired = true;
                    transposeUp.addEventListener('click', () => originalUp.click());
                }
                if (transposeDown && originalDown && !transposeDown._wired) {
                    transposeDown._wired = true;
                    transposeDown.addEventListener('click', () => originalDown.click());
                }
                
                // Ensure modal is draggable
                if (!modal._draggableSet) {
                    makeDraggable(modal);
                    modal._draggableSet = true;
                    console.log('Modal made draggable');
                }
            }
        };
        
        window.closeKeyboardModal = function() {
            console.log('Closing keyboard modal AND disabling keyboard');
            const modal = document.getElementById('keyboardModal');
            if (modal) modal.style.display = 'none';
            const btn = document.getElementById('keyboardBtn');
            if (btn) btn.classList.remove('active');
            // Move root grid back to main area (but keep it hidden)
            const keyboardSection = document.getElementById('keyboardSection');
            const rootGrid = document.getElementById('rootGrid');
            if (keyboardSection && rootGrid) {
                keyboardSection.appendChild(rootGrid);
            }
        };
        
        window.closeKeyboardModalOnly = function() {
            console.log('Closing keyboard modal only (keeping keyboard enabled)');
            const modal = document.getElementById('keyboardModal');
            if (modal) modal.style.display = 'none';
            // Don't disable the keyboard - keep button active
        };
        
        window.showDrumModal = function() {
            console.log('Opening drum modal');
            const modal = document.getElementById('drumModal');
            if (modal) {
                modal.style.display = 'block';
                bringModalToFront('drumModal');
                // Ensure drum grid is visible
                const drumContainer = modal.querySelector('.drum-grid-container');
                if (drumContainer) {
                    drumContainer.style.display = 'block';
                }
                // Make draggable if not already
                if (!modal._draggableSet) {
                    makeDraggable(modal);
                    modal._draggableSet = true;
                }
            }
        };
        
        window.closeDrumModal = function() {
            console.log('Closing drum modal AND disabling drums');
            const modal = document.getElementById('drumModal');
            if (modal) modal.style.display = 'none';
            const btn = document.getElementById('drumsBtn');
            if (btn) btn.classList.remove('active');
            // Disable drums
            if (window.omnichord && typeof omnichord.toggleDrumsMode === 'function') {
                omnichord.drumsEnabled = false;
            }
        };
        
        window.closeDrumModalOnly = function() {
            console.log('Closing drum modal only (keeping drums enabled)');
            const modal = document.getElementById('drumModal');
            if (modal) modal.style.display = 'none';
            // Don't disable the drums - keep button active
        };
        
        window.showPatternModal = function() {
            console.log('Opening pattern modal');
            const modal = document.getElementById('patternModal');
            if (modal) {
                modal.style.display = 'block';
                bringModalToFront('patternModal');
                // Ensure pattern grid is visible
                const patternContainer = modal.querySelector('.drum-grid-container');
                if (patternContainer) {
                    patternContainer.style.display = 'block';
                }
                // Make draggable if not already
                if (!modal._draggableSet) {
                    makeDraggable(modal);
                    modal._draggableSet = true;
                }
            }
        };
        
        window.closePatternModal = function() {
            console.log('Closing pattern modal AND disabling pattern');
            const modal = document.getElementById('patternModal');
            if (modal) modal.style.display = 'none';
            const btn = document.getElementById('patternBtn');
            if (btn) btn.classList.remove('active');
            // Disable pattern
            if (window._patternTransport) window._patternTransport.running = false;
        };
        
        window.closePatternModalOnly = function() {
            console.log('Closing pattern modal only (keeping pattern enabled)');
            const modal = document.getElementById('patternModal');
            if (modal) modal.style.display = 'none';
            // Don't disable the pattern - keep button active and transport running
        };
        
        // Bass modal functions
        window.showBassModal = function() {
            console.log('Opening bass modal');
            const modal = document.getElementById('bassModal');
            if (modal) {
                modal.style.display = 'block';
                bringModalToFront('bassModal');
                
                // Generate bass grid if not already built
                const bassContainer = modal.querySelector('.drum-grid-container');
                if (bassContainer) {
                    bassContainer.style.display = 'block';
                    // Build bass pattern grid if not already done
                    const bassGrid = document.getElementById('bassGrid');
                    if (bassGrid && !bassGrid.dataset.built) {
                        generateBassPatternGrid(bassGrid);
                        bassGrid.dataset.built = '1';
                    }
                }
                makeDraggable(modal);
            }
        };
        
        window.closeBassModal = function() {
            console.log('Closing bass modal and disabling bass');
            const modal = document.getElementById('bassModal');
            if (modal) modal.style.display = 'none';
            const btn = document.getElementById('bassBtn');
            if (btn) btn.classList.remove('active');
        };
        
        window.closeBassModalOnly = function() {
            console.log('Closing bass modal only (keeping bass enabled)');
            const modal = document.getElementById('bassModal');
            if (modal) modal.style.display = 'none';
            // Don't disable the bass - keep button active
        };

        // *** FIX 2: Generate bass pattern grid identical to pattern grid but for bass notes ***
        window.generateBassPatternGrid = function(bassGrid) {
            if (!bassGrid) return;
            
            console.log('🎸 Generating bass pattern grid (9 rows)...');
            
            // Clear existing content
            bassGrid.innerHTML = '';
            bassGrid.dataset.built = '1';
            
            // Get pattern length from bass controls
            const bassLenDisplay = document.getElementById('bassLenDisplay');
            const stepsPerBar = Math.max(4, parseInt(bassLenDisplay?.textContent || '16', 10));
            
            // Create 9 bass rows (NOTE 9 down to NOTE 1) - identical to pattern structure
            const rowLabels = ['NOTE 9','NOTE 8','NOTE 7','NOTE 6','NOTE 5','NOTE 4','NOTE 3','NOTE 2','NOTE 1'];
            
            rowLabels.forEach((labelName, rowIdx) => {
                const row = document.createElement('div');
                row.className = 'drum-row bass-row pattern-row';
                
                const label = document.createElement('div');
                label.className = 'drum-label';
                label.textContent = labelName;
                row.appendChild(label);
                
                const lane = document.createElement('div');
                lane.className = 'drum-lane pattern-lane bass-lane';
                lane.dataset.row = String(rowIdx);
                try { lane.style.setProperty('--steps-per-bar', String(stepsPerBar)); } catch(_){ }
                
                // Beat dividers
                const fullBeats = Math.max(0, Math.floor(stepsPerBar/4));
                for (let b=1; b<fullBeats; b++) {
                    const div = document.createElement('div');
                    div.className = 'beat-divider';
                    div.style.left = `${(b/fullBeats)*100}%`;
                    lane.appendChild(div);
                }
                
                // Create steps with full bass behavior (identical to pattern)
                for (let sIdx=0; sIdx<stepsPerBar; sIdx++) {
                    const st = document.createElement('div');
                    st.className = 'drum-step pattern-step bass-step' + ((sIdx%4===0)?' beat-accent':'');
                    st.dataset.step = String(sIdx);
                    st.title = `${labelName} • Step ${sIdx+1}`;
                    
                    // *** IDENTICAL PATTERN BEHAVIOR: Click to toggle ***
                    st.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (st.classList.contains('active')) {
                            st.classList.remove('active');
                        } else {
                            st.classList.add('active');
                        }
                        // Update bass pattern computation
                        try { computeBassPatternFromGrid(); } catch(_){}
                    });
                    
                    lane.appendChild(st);
                }
                
                row.appendChild(lane);
                bassGrid.appendChild(row);
            });
            
            console.log('✅ Bass pattern grid (9 rows) generated successfully');
        };
        
        // *** Bass pattern computation from 9-row grid (identical to pattern logic) ***
        window.computeBassPatternFromGrid = function() {
            try {
                const bassGrid = document.getElementById('bassGrid');
                if (!bassGrid) return;
                
                const lanes = Array.from(bassGrid.querySelectorAll('.bass-lane'));
                if (lanes.length < 9) return;
                
                const npcLanes = lanes.slice(0,9);
                const steps = Array.from(npcLanes[0].querySelectorAll('.bass-step'));
                const maxVisible = Math.max(1, Math.min(steps.length, parseInt(bassGrid.dataset.length||String(steps.length),10)||steps.length));
                const tokens = [];
                
                for (let i=0;i<maxVisible;i++){
                    const activeNums = [];
                    for (let idx=0; idx<npcLanes.length; idx++){
                        const cell = npcLanes[idx].querySelector(`.bass-step[data-step="${i}"]`);
                        if (cell && cell.classList.contains('active')) activeNums.push(9-idx);
                    }
                    if (activeNums.length === 0) tokens.push('x');
                    else if (activeNums.length === 1) tokens.push(String(activeNums[0]));
                    else tokens.push('['+activeNums.join(' ')+']');
                }
                
                // Store computed bass pattern
                bassGrid._computedPattern = tokens.join(' ');
                console.log('🎸 Bass pattern computed:', bassGrid._computedPattern);
            } catch(_) {
                console.error('Error computing bass pattern:', _);
            }
        };
        
        
        // Make modals draggable by header
        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const header = element.querySelector('.modal-header');
            if (!header) {
                console.log('No modal header found for dragging');
                return;
            }
            
            header.style.cursor = 'move';
            header.onmousedown = dragMouseDown;
            
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }
        
        // Make bracket markers and chord columns draggable for section rearrangement
        function makeBracketDraggable(marker) {
            if (marker._draggableWired) return; // Prevent duplicate wiring
            marker._draggableWired = true;
            
            marker.draggable = true;
            marker.style.cursor = 'grab';
            
            // Ensure the marker has the correct class for drop detection
            if (marker.classList.contains('extension-column')) {
                // Chord columns keep their class but also become draggable
            } else if (!marker.classList.contains('repeat-marker-column')) {
                marker.classList.add('repeat-marker-column');
            }
            
            marker.addEventListener('dragstart', (e) => {
                marker.style.cursor = 'grabbing';
                e.dataTransfer.setData('text/plain', marker.textContent);
                e.dataTransfer.effectAllowed = 'move';
                marker.classList.add('dragging');
                console.log('🎵 Started dragging element:', marker.textContent || marker.className);
            });
            
            marker.addEventListener('dragend', (e) => {
                marker.style.cursor = 'grab';
                marker.classList.remove('dragging');
                document.querySelectorAll('.drop-target').forEach(el => {
                    el.classList.remove('drop-target');
                });
                console.log('🎵 Finished dragging element:', marker.textContent || marker.className);
            });
        }
        
        // Make chord columns accept bracket drops (using event delegation for dynamic elements)
        function makeChordColumnsDroppable() {
            const container = document.getElementById('extensionColumns');
            if (!container) return;
            
            // Remove any existing listeners to prevent duplicates
            if (container._dropListenersAdded) return;
            container._dropListenersAdded = true;
            
            // Use event delegation to handle all current and future chord columns
            container.addEventListener('dragover', (e) => {
                const dragging = document.querySelector('.dragging');
                if (dragging && (dragging.classList.contains('repeat-marker-column') || dragging.classList.contains('extension-column'))) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    // Clear existing drop targets
                    document.querySelectorAll('.drop-target').forEach(el => {
                        el.classList.remove('drop-target');
                    });
                    
                    // Add drop target to any column type if hovering over them
                    const target = e.target.closest('.extension-column, .repeat-marker-column');
                    if (target && target !== dragging) {
                        target.classList.add('drop-target');
                    }
                    
                    // Also allow dropping on the container itself for end-position drops
                    container.style.backgroundColor = 'rgba(46,204,113,0.05)';
                }
            });
            
            container.addEventListener('dragleave', (e) => {
                const target = e.target.closest('.extension-column');
                if (target && !container.contains(e.relatedTarget)) {
                    target.classList.remove('drop-target');
                }
                
                // Clear container drop styling when leaving the container
                if (e.target === container && !container.contains(e.relatedTarget)) {
                    container.style.backgroundColor = '';
                }
            });
            
            container.addEventListener('drop', (e) => {
                e.preventDefault();
                const dragging = document.querySelector('.dragging');
                if (dragging && (dragging.classList.contains('repeat-marker-column') || dragging.classList.contains('extension-column'))) {
                    const target = e.target.closest('.extension-column, .repeat-marker-column');
                    
                    if (target && target !== dragging) {
                        // Insert before the target element
                        container.insertBefore(dragging, target);
                        console.log('🎵 Dropped element before:', target.textContent || target.querySelector('.extension-header')?.textContent);
                        target.classList.remove('drop-target');
                    } else {
                        // Enhanced drop-anywhere logic for container
                        const rect = container.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        
                        // Find all draggable elements (chords and brackets)
                        const allElements = Array.from(container.children).filter(el => 
                            (el.classList.contains('extension-column') || el.classList.contains('repeat-marker-column')) && el !== dragging
                        );
                        
                        if (allElements.length === 0) {
                            // Empty container, just append
                            container.appendChild(dragging);
                            console.log('🎵 Dropped in empty container');
                        } else {
                            // Find insertion point based on mouse position
                            let insertBefore = null;
                            let minDistance = Infinity;
                            
                            for (const el of allElements) {
                                const elRect = el.getBoundingClientRect();
                                const elCenterX = elRect.left + elRect.width / 2 - rect.left;
                                const distance = Math.abs(x - elCenterX);
                                
                                if (x < elCenterX && distance < minDistance) {
                                    minDistance = distance;
                                    insertBefore = el;
                                }
                            }
                            
                            if (insertBefore) {
                                container.insertBefore(dragging, insertBefore);
                                console.log('🎵 Dropped before closest element');
                            } else {
                                // Drop at the end
                                container.appendChild(dragging);
                                console.log('🎵 Dropped at end');
                            }
                        }
                    }
                    
                    // Clear all drop targets and container styling
                    document.querySelectorAll('.drop-target').forEach(el => {
                        el.classList.remove('drop-target');
                    });
                    container.style.backgroundColor = '';
                    
                    // Update the data model to reflect the change
                    window.omnichord?._updateBracketPositions?.();
                }
            });
        }
        
        // Chord section resize functionality
        function initChordResize() {
            const handle = document.getElementById('chordResizeHandle');
            const strumArea = document.getElementById('strumArea');
            
            if (!handle || !strumArea) return;
            
            // Initialize positions
            const initialTop = window.innerHeight * 0.5; // 50vh in pixels
            strumArea.style.top = initialTop + 'px';
            handle.style.top = (initialTop - 12) + 'px';
            
            let isResizing = false;
            let startY = 0;
            let startTop = 0;
            
            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startY = e.clientY;
                startTop = parseInt(strumArea.style.top) || initialTop;
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'ns-resize';
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const deltaY = e.clientY - startY;
                // Ensure minimum space for compressed strings (150px from bottom)
                const minTop = 200; // Minimum top position
                const maxTop = window.innerHeight - 178; // 150px for strings + 28px for XENON bar
                const newTop = Math.max(minTop, Math.min(maxTop, startTop + deltaY));
                
                strumArea.style.top = newTop + 'px';
                handle.style.top = (newTop - 12) + 'px';
                
                // Update string compression based on new size
                setTimeout(() => updateStringCompression(), 10);
                
                // Don't change keyboard modal size - keep it minimal
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.userSelect = '';
                    document.body.style.cursor = '';
                }
            });
        }
        
        // Monitor and adjust string compression based on available space
        function updateStringCompression() {
            const extensionColumns = document.querySelectorAll('.extension-column');
            
            extensionColumns.forEach(column => {
                const stringsContainer = column.querySelector('.strings-container');
                if (!stringsContainer) return;
                
                const availableHeight = column.offsetHeight;
                const headerHeight = 40;
                const stringsHeight = availableHeight - headerHeight;
                
                // Remove existing compression classes
                column.removeAttribute('data-compressed');
                
                // Apply compression based on available space
                if (stringsHeight < 60) {
                    column.setAttribute('data-compressed', 'heavy');
                } else if (stringsHeight < 100) {
                    column.setAttribute('data-compressed', 'true');
                }
            });
        }

        // Ensure chord visibility on creation
        function ensureChordVisibility() {
            const strumArea = document.getElementById('strumArea');
            const extensionColumns = document.getElementById('extensionColumns');
            
            if (!strumArea || !extensionColumns) return;
            
            const chords = extensionColumns.querySelectorAll('.extension-column');
            if (chords.length === 0) return;
            
            // Calculate minimum space needed for compressed chords
            const headerHeight = 40; // Approximate header height
            const minStringsHeight = 110; // Minimum compressed string section height
            const minTotalHeight = headerHeight + minStringsHeight + 20; // Add padding
            
            // Check current positioning
            const currentTop = parseInt(strumArea.style.top) || window.innerHeight * 0.5;
            const availableHeight = window.innerHeight - currentTop - 28; // Account for XENON bar
            
            // If not enough space, adjust position but respect limits
            if (availableHeight < minTotalHeight && chords.length > 0) {
                const maxTop = window.innerHeight - 178; // 150px for compressed strings + 28px XENON bar
                const newTop = Math.min(currentTop, maxTop);
                
                if (newTop !== currentTop) {
                    strumArea.style.top = newTop + 'px';
                    
                    const handle = document.getElementById('chordResizeHandle');
                    if (handle) {
                        handle.style.top = (newTop - 12) + 'px';
                    }
                }
            }
        }

        // Modal management - ensure newly opened modals appear on top
        function bringModalToFront(modalId) {
            // Reset all floating modals to base z-index
            document.querySelectorAll('.floating-modal').forEach(modal => {
                modal.classList.remove('modal-active');
                modal.style.zIndex = '10000';
            });
            // Bring specified modal to front with higher z-index
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.add('modal-active');
                modal.style.display = 'block';
                modal.style.zIndex = '10001';
                console.log('Brought modal to front:', modalId, 'z-index:', modal.style.zIndex);
            }
        }

        // Fix bracket movement - allow ] to move to far right
        function fixBracketMovement() {
            const brackets = document.querySelectorAll('.bracket-marker');
            brackets.forEach(bracket => {
                if (bracket.textContent === ']') {
                    // Allow ] brackets to be dropped after the last chord
                    const extensionColumns = document.getElementById('extensionColumns');
                    if (extensionColumns) {
                        // Add a drop zone at the end for ] brackets
                        const endDropZone = document.createElement('div');
                        endDropZone.className = 'bracket-drop-zone end-zone';
                        endDropZone.style.cssText = 'width: 20px; min-width: 20px; height: 100%; background: transparent; border-left: 2px dashed transparent; transition: all 0.2s;';
                        
                        endDropZone.addEventListener('dragover', (e) => {
                            e.preventDefault();
                            endDropZone.style.borderLeftColor = '#3b82f6';
                            endDropZone.style.background = 'rgba(59, 130, 246, 0.1)';
                        });
                        
                        endDropZone.addEventListener('dragleave', () => {
                            endDropZone.style.borderLeftColor = 'transparent';
                            endDropZone.style.background = 'transparent';
                        });
                        
                        endDropZone.addEventListener('drop', (e) => {
                            e.preventDefault();
                            const draggedBracket = document.querySelector('.bracket-marker.dragging');
                            if (draggedBracket && draggedBracket.textContent === ']') {
                                // Move bracket to end
                                extensionColumns.appendChild(draggedBracket);
                            }
                            endDropZone.style.borderLeftColor = 'transparent';
                            endDropZone.style.background = 'transparent';
                        });
                        
                        if (!extensionColumns.querySelector('.end-zone')) {
                            extensionColumns.appendChild(endDropZone);
                        }
                    }
                }
            });
        }
        
        // Ensure functions are globally available
        window.makeBracketDraggable = makeBracketDraggable;
        window.makeChordColumnsDroppable = makeChordColumnsDroppable;
        window.initChordResize = initChordResize;
        window.ensureChordVisibility = ensureChordVisibility;
        window.updateStringCompression = updateStringCompression;
        window.bringModalToFront = bringModalToFront;
        window.fixBracketMovement = fixBracketMovement;
        
        // Add click-to-front functionality for all floating modals
        const floatingModals = document.querySelectorAll('.floating-modal');
        floatingModals.forEach(modal => {
            if (modal && !modal._clickToFrontWired) {
                modal._clickToFrontWired = true;
                modal.addEventListener('mousedown', (e) => {
                    // Only bring to front if clicking on the modal itself, not if it's already the top modal
                    if (e.target === modal || modal.contains(e.target)) {
                        bringModalToFront(modal.id);
                    }
                });
            }
        });
        
        // Fix SEQ modal opening
        const seqBtn = document.getElementById('seqPanelBtn');
        if (seqBtn) {
            seqBtn.addEventListener('click', () => {
                bringModalToFront('textChordModal');
            });
        }
        
        const openTextChordParserBtn = document.getElementById('openTextChordParserBtn');
        if (openTextChordParserBtn) {
            openTextChordParserBtn.addEventListener('click', () => {
                bringModalToFront('textChordModal');
            });
        }
        
        // Universal EDO Synchronization System
        function initUniversalEDOSync() {
            const edoInputs = [
                'edoQuickInputTransport',    // Top transport bar
                'edoQuickInput',             // Main panel
                'edoQuickInputKeyboard',     // Keyboard modal
                'seqEdoInput',               // Sequence modal
                'edoDivisions'               // Tuning modal
            ];
            
            function syncAllEDOInputs(newValue, sourceId) {
                const validValue = Math.max(5, Math.min(52, parseInt(newValue) || 24));
                
                // Update all EDO inputs except the source
                edoInputs.forEach(inputId => {
                    const input = document.getElementById(inputId);
                    if (input && inputId !== sourceId) {
                        input.value = String(validValue);
                    }
                });
                
                // Check if playback is active - if so, defer EDO change to next cycle
                const isPlaying = window.omnichord && window.omnichord._arpTransport && window.omnichord._arpTransport.isRunning;
                
                if (isPlaying) {
                    // Defer EDO change by 2 beats during playback
                    if (window.scheduleDeferred && typeof window.scheduleDeferred === 'function') {
                        window.scheduleDeferred({ edo: validValue });
                    }
                } else {
                    // Apply immediately if stopped
                    if (window.omnichord && typeof omnichord.updateTuningSystem === 'function') {
                        omnichord.updateTuningSystem(validValue);
                    }
                    
                    // If a sequence is loaded in the SEQ modal, regenerate it with the new EDO
                    const textChordInput = document.getElementById('textChordInput');
                    if (textChordInput && textChordInput.value.trim().length > 0) {
                        // Trigger sequence regeneration by calling the same method the button uses
                        if (window.omnichord && typeof window.omnichord.createSequenceFromTextarea === 'function') {
                            console.log('🔄 Regenerating chord sequence with new EDO:', validValue);
                            window.omnichord.createSequenceFromTextarea();
                        }
                    }
                }
                
                return validValue;
            }
            
            // Attach listeners to all EDO inputs
            edoInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    // Remove any existing listeners to avoid duplicates
                    input.removeEventListener('change', input._edoSyncHandler);
                    input.removeEventListener('input', input._edoSyncHandler);
                    
                    // Create the sync handler
                    input._edoSyncHandler = function(e) {
                        syncAllEDOInputs(this.value, inputId);
                    };
                    
                    // Listen for both change and input events
                    input.addEventListener('change', input._edoSyncHandler);
                    input.addEventListener('input', input._edoSyncHandler);
                }
            });
            
            // Initialize all inputs to same value (24)
            syncAllEDOInputs(24, null);
        }
        
        window.initUniversalEDOSync = initUniversalEDOSync;
        
        // Add CSS for drop targets
        if (!document.getElementById('bracketDragStyles')) {
            const style = document.createElement('style');
            style.id = 'bracketDragStyles';
            style.textContent = `
                .drop-target {
                    outline: 2px dashed #3b82f6 !important;
                    background: rgba(59, 130, 246, 0.1) !important;
                }
                .dragging {
                    opacity: 0.5;
                }
                .bracket-drop-zone.end-zone {
                    min-width: 20px;
                    height: 100%;
                    transition: all 0.2s;
                }
                .bracket-drop-zone.end-zone:hover,
                .bracket-drop-zone.end-zone.drag-over {
                    border-left: 2px dashed #3b82f6 !important;
                    background: rgba(59, 130, 246, 0.1) !important;
                }
            `;
            document.head.appendChild(style);
        }

        
        // Define sidebar button handler early for onclick access
        window.sidebarBtnClick = function(buttonType) {
            console.log(`${buttonType.toUpperCase()} button clicked`);
            const btn = document.getElementById(buttonType + 'Btn');
            if (!btn) return;
            
            switch(buttonType) {
                case 'keyboard':
                    console.log('Keyboard button clicked, current active state:', btn.classList.contains('active'));
                    btn.classList.toggle('active');
                    if (btn.classList.contains('active')) {
                        console.log('Enabling keyboard and showing modal');
                        // Enable keyboard and show modal
                        showKeyboardModal();
                        bringModalToFront('keyboardModal');
                    } else {
                        console.log('Disabling keyboard and closing modal');
                        // Disable keyboard and close modal
                        closeKeyboardModal();
                    }
                    break;
                    
                case 'strum':
                    btn.classList.toggle('active');
                    if (window.omnichord && typeof omnichord.toggleStrumMode === 'function') {
                        omnichord.toggleStrumMode();
                    }
                    break;
                    
                case 'pattern':
                    btn.classList.toggle('active');
                    if (btn.classList.contains('active')) {
                        // Enable pattern and show modal
                        showPatternModal();
                        if (window._patternTransport) window._patternTransport.running = true;
                        // If pattern grid is blank, enable ARP as fallback
                        if (window.omnichord && typeof omnichord.toggleChordArpMode === 'function') {
                            // Check if pattern is empty and enable ARP if so
                            omnichord.checkPatternForArp();
                        }
                    } else {
                        // Disable pattern and close modal
                        const modal = document.getElementById('patternModal');
                        if (modal) modal.style.display = 'none';
                        if (window._patternTransport) window._patternTransport.running = false;
                    }
                    break;
                    
                case 'chords':
                    btn.classList.toggle('active');
                    // Toggle chord functionality
                    if (window.omnichord) {
                        omnichord.chordsEnabled = btn.classList.contains('active');
                    }
                    break;
                    
                case 'drums':
                    btn.classList.toggle('active');
                    if (btn.classList.contains('active')) {
                        // Enable drums and show modal
                        showDrumModal();
                        if (window.omnichord) omnichord.drumsEnabled = true;
                    } else {
                        // Disable drums and close modal
                        const modal = document.getElementById('drumModal');
                        if (modal) modal.style.display = 'none';
                        if (window.omnichord) omnichord.drumsEnabled = false;
                    }
                    break;
                    
                case 'bass':
                    btn.classList.toggle('active');
                    if (btn.classList.contains('active')) {
                        // Enable bass and show modal
                        showBassModal();
                        if (window.omnichord && typeof omnichord.toggleBassMode === 'function') {
                            omnichord.toggleBassMode();
                        }
                    } else {
                        // Disable bass and close modal
                        const modal = document.getElementById('bassModal');
                        if (modal) modal.style.display = 'none';
                        if (window.omnichord && typeof omnichord.toggleBassMode === 'function') {
                            omnichord.toggleBassMode();
                        }
                    }
                    break;
                    
                case 'midi':
                    // Sidebar MIDI button: ensure loopMIDI present, initialize MIDI, map outputs, mute internal sound.
                    (async ()=>{
                        try {
                            // If already enabled, clicking turns it off via existing hidden toggle
                            if (window.midi && window.midi.enabled) {
                                const midiToggle = document.getElementById('midiToggle');
                                if (midiToggle && typeof midiToggle.click === 'function') midiToggle.click();
                                btn.classList.remove('active');
                                return;
                            }
                            // Attempt init if not enabled
                            if (window.midi && !window.midi.enabled) {
                                if (window.midi._initializing) return; // guard
                                window.midi._initializing = true;
                                const ok = await window.midi.init();
                                window.midi._initializing = false;
                                if (!ok) return;
                                // Detect loopMIDI outputs
                                let hasLoop = false; let firstLoopId = null; let firstLoopName = null;
                                try {
                                    const outsArr = Array.from(window.midi.outputs.values());
                                    for (const o of outsArr) { const nm = String(o.name||o.id||''); if (/loopmidi/i.test(nm)) { hasLoop = true; if (!firstLoopId){ firstLoopId=o.id; firstLoopName=nm; } } }
                                } catch(_) {}
                                if (!hasLoop) {
                                    // Allow enable if any outputs exist (hardware) OR selects already show items.
                                    let anyOutputs = false;
                                    try { anyOutputs = window.midi.outputs && window.midi.outputs.size > 0; } catch(_) {}
                                    if (!anyOutputs) {
                                        let uiVisible = false;
                                        try {
                                            const selIds = ['midiOutputSelect','midiStrumOutput','midiChordOutput','midiArpOutput','midiBassOutput','midiDrumOutput'];
                                            for (const id of selIds) { const el = document.getElementById(id); if (el && el.options && el.options.length > 0) { uiVisible = true; break; } }
                                        } catch(_) {}
                                        if (!uiVisible && !window._xenMidiInitGuard.prompted) {
                                            window._xenMidiInitGuard.prompted = true;
                                            try { window.alert('No MIDI outputs detected yet. (Optional) Install loopMIDI if you need virtual routing:\nhttps://www.tobias-erichsen.de/software/loopmidi.html'); } catch(_) {}
                                        }
                                    }
                                    // Continue enabling regardless; future hot-plug will populate.
                                }
                                // Auto-map if none chosen
                                try {
                                    const haveAny = Object.values(window.midi.outputPortMap||{}).some(v=>!!v);
                                    if (!haveAny && firstLoopId) {
                                        ['strum1','strum2','chord','arp','bass','drum','default'].forEach(sec=>{ window.midi.outputPortMap[sec] = firstLoopId; });
                                        console.log(`[MIDI] (Sidebar) Auto-mapped loopMIDI port '${firstLoopName}' to all sections.`);
                                    }
                                } catch(_) {}
                                // Apply UI population
                                try { window.midi.applySettingsToUI(); } catch(_) {}
                                // Mute internal oscillators while MIDI active
                                try {
                                    const oc = window.omnichord; if (oc) { if (oc._preMidiMasterVolume===undefined) oc._preMidiMasterVolume=oc.masterVolume; oc.masterVolume=0.0001; if (oc.gainNode) oc.gainNode.gain.value = oc.volume * oc.masterVolume; if (oc.dryGainNode) oc.dryGainNode.gain.value = oc.masterVolume; if (oc.reverbOutGain) oc.reverbOutGain.gain.value = oc.masterVolume; }
                                } catch(_) {}
                                btn.classList.add('active');
                                if (window.omnichord) window.omnichord.midiBypassOscillators = true;
                                // Also mark hidden toggle button state if present
                                const midiToggle = document.getElementById('midiToggle');
                                if (midiToggle) midiToggle.classList.add('active');
                            }
                        } catch(e){ console.warn('Sidebar MIDI activation error', e); }
                        try { window.midi && window.midi.markActivity(); } catch(_) {}
                    })();
                    break;
            }
        };
        
        console.log('Sidebar functions and handlers ready');
        
        // Console logging: DISABLED by default. To enable, set localStorage.muteConsole = '0'.
        (function(){
            try {
                const flag = (typeof window !== 'undefined' && window.localStorage) ? window.localStorage.getItem('muteConsole') : null;
                // DISABLE CONSOLE LOGGING by default for performance
                const shouldMute = true; // Mute logs by default for speed
                if (shouldMute && window.console) {
                    const methods = ['log','info','debug','warn','error','trace','group','groupCollapsed','groupEnd','time','timeEnd','table'];
                    methods.forEach(function(m){ if (typeof window.console[m] === 'function') window.console[m] = function(){}; });
                } else if (window && window.console && typeof window.console.info === 'function') {
                    console.info('[XENON] Console logging ENABLED');
                }
                // Expose quick toggles
                window.enableLogs = function(){ try{ if (window.localStorage) { localStorage.setItem('muteConsole','0'); location.reload(); } }catch(_){} };
                window.disableLogs = function(){ try{ if (window.localStorage) { localStorage.setItem('muteConsole','1'); location.reload(); } }catch(_){} };
                window.testLogs = function(){ console.log('Console test - if you see this, logs are enabled'); console.warn('Warning test'); console.error('Error test'); };
            } catch(_) {}
        })();
        class MicrotonalOmnichord { 
            constructor() {
                // Debug instrumentation (console-only)
                this._debug = false;
                this._debugLogs = [];
                this._debugMax = 500;
                this._debugUI = false; // keep panel off; use console logs only
                try { /* debug muted by default */ } catch(_){ }
                this.audioContext = null;
                this.gainNode = null;
                // Initialize separate oscillator pools for independent playback
                this.activeOscillators = new Map(); // Default/legacy pool
                this.activeStrumOscillators = new Map(); // STRUM mode during PLAY
                this.activeChordOscillators = new Map(); // CHORD mode  
                this.activeArpOscillators = new Map(); // ARP mode
                this.activeBassOscillators = new Map(); // BASS notes
                this.currentTuning = 24;
                this.currentRoot = 0;
                this.currentQuality = 'major';
                this.volume = 0.75; // Max volume at -9dB (matches slider at 100%)
                this.masterVolume = 0.708; // Max at -3dB (0.708 linear gain) instead of -6dB
                this.isPlayingStrings = false;
                this.triggeredStrings = new Set();
                this.activeTouches = new Map();
                // Track last-hit string per pointer (mouse or each touch) to avoid retriggers on the same string while sustaining
                this._pointerLastStringKey = new Map();
                // Track last user interaction time to reset transport phase in touch mode
                this._lastInteractionAt = (performance && performance.now) ? performance.now() : Date.now();
                this.gamelanMode = false;
                // Track the column element that's currently active/last-played for live keyboard edits
                this.currentActiveColumnEl = null;
                // When true, render chord extensions (9/11/13) in higher octaves (two-octave split).
                // When false, fold all degrees into a single octave.
                // Default to compact one-octave voicing as requested.
                this.splitExtendedChordsAcrossOctaves = false;
                // Keyboard rotation across EDO steps (drag left/right rotates visible order)
                this.keyboardRotation = 0;
                // Global keyboard listener guard/handle
                this._keyboardListenerAttached = false;
                this._keyboardHandler = null;
                // Editing flow flags
                this.isEditingChord = false;
                // Global transpose accumulator (steps from session start)
                this.transposeDelta = 0;
                // Debounced edit/save timers
                this.editArmed = false;
                this._editArmTimer = null;
                this._editSaveTimer = null;
                this.editingOriginalIndex = null;
                
                // ADSR envelope settings
                this.envelope = {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0.7,
                    release: 0.8
                };
                
                // OSC 2 ADSR envelope settings
                this.osc2Envelope = {
                    attack: 0.005,
                    decay: 0.03,
                    sustain: 0.5,
                    release: 1.0
                };
                
                this.oscillatorType = 'sawtooth';
                
                // Dual oscillator settings with proper dB scaling
                this.oscillators = {
                    // pulseWidth (0-1) for 'pulse'; detune in cents; shapeWidth (0-1) controls waveform width/skew:
                    // - sine: phase-skewed sine (narrow = steep peak)
                    // - sawtooth: phase-skewed slope (narrow = fast rise)
                    // - square: PWM duty (narrow = skinny high)
                    osc1: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                    osc2: { type: 'sine', detune: -7, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 }
                }

                // New: four-instrument independent config/state
                // STRUM uses osc1+osc2 as its pair; CHORD and BASS use single-voice configs below
                this.instruments = {
                    strum1: {
                        // mirrors osc1
                        osc: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                        env: { attack: 0.0, decay: 0.2, sustain: 0.0, release: 0.8 },
                        fxSend: true
                    },
                    strum2: {
                        // mirrors osc2
                        osc: { type: 'sine', detune: -7, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                        env: { attack: 0.0, decay: 0.03, sustain: 0.0, release: 1.0 },
                        fxSend: true
                    },
                    chord: {
                        osc: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                        env: { attack: 0.01, decay: 0.2, sustain: 0.9, release: 0.3 },
                        fxSend: false
                    },
                    arp: {
                        osc: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                        env: { attack: 0.01, decay: 0.2, sustain: 0.9, release: 0.3 },
                        fxSend: true
                    },
                    bass: {
                        osc: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5, shapeWidth: 0.5 },
                        env: { attack: 0.005, decay: 0.08, sustain: 0.9, release: 0.12 },
                        fxSend: false
                    }
                };

                // Drum module state
                this._drums = {
                    stepsPerBar: 16,
                    lastStep: -1
                };
                // Track active drum voices so STOP can silence them immediately
                this._activeDrumVoices = new Set();

                // Held bass feature guard and state (follows chord header root; never arpeggiated)
                this._heldBassEnabled = true; // tied to chord bass toggle
                this._heldBassVoice = null;
                this._heldBassLiveFreq = null;

                // Custom oscillator wavetable cache
                this._customWaveCache = new Map();
                // Touch/click gesture defaults
                this.touchGestures = {
                    longPressDelay: 550,
                    chordNameLongPressDelay: 300
                };
                
                
                // Store original UI state for piano lock system
                this.originalUIState = null;

                // Piano-lock system state
                // Ensure these are always initialized so the 🎹 button works immediately
                this.pianoLockedChords = new Map();
                this.preloadedPresets = new Map();
                this.pianoLockPresetCounter = 0;
                
                // Panning settings
                this.panning = {
                    mode: 'center', // 'center', 'frequency', 'random', 'rotating', 'alternating'
                    width: 0.8, // How wide the stereo field is
                    speed: 2000, // Speed for rotating/alternating modes (ms)
                    rotationAngle: 0, // Current rotation angle
                    alternateState: false // Current side for alternating
                };
                
                // Simple reverb settings
                this.reverb = {
                    wet: 0.00, // 0% reverb by default
                    decay: 0.0, // 0 seconds decay
                    roomSize: 0.5,
                    filterCutoff: 8000
                };
                
                // Audio nodes
                this.reverbNode = null;
                this.wetGainNode = null;
                this.dryGainNode = null;
                this.reverbFilterNode = null;
                // Drive state (indexsun variant)
                this.drive = {
                    amount: 0, // 0..100
                    mix: 0     // 0..100 (% wet)
                };
                
                // No default chord extensions - start completely empty unless locked chords exist
                this.defaultChordExtensions = [];
                
                // Load user's chord configuration and locked chords
                const savedChords = this.loadChordConfiguration();
                const lockedChords = this.loadLockedChords();
                
                // Clear unlocked chords from memory on first start - only load pre-locked chords
                console.log('?? Clearing unlocked chords from memory on startup');
                
                // Start with only locked chords (if any exist)
                if (lockedChords && lockedChords.length > 0) {
                    console.log('?? Loading only pre-locked chords from previous session:', lockedChords.length, 'chords');
                    this.chordExtensions = lockedChords.map(locked => ({
                        name: locked.chordName,
                        intervals: locked.intervals,
                        getChordIntervals(extensions = []) {
                            // Return canonical 12-TET semitone intervals; mapping to current EDO happens in mapIntervalToEDO
                            let intervals = [0]; // Root (0 semitones)

                            // Base triad (in semitones)
                            switch (this.currentQuality) {
                                case 'major':
                                    intervals.push(4); // Major third
                                    intervals.push(7); // Perfect fifth
                                    break;
                                case 'minor':
                                    intervals.push(3); // Minor third
                                    intervals.push(7); // Perfect fifth
                                    break;
                                case 'neutral':
                                    intervals.push(3.5); // Neutral third (microtonal)
                                    intervals.push(7);
                                    break;
                            }

                            // Apply extensions (still in semitones)
                            extensions.forEach(ext => {
                                switch (ext) {
                                    case '6':
                                        intervals.push(9);
                                        break;
                                    case '7':
                                        intervals.push(10);
                                        break;
                                    case 'maj7':
                                        intervals.push(11);
                                        break;
                                    case '9':
                                        intervals.push(10); // include 7th
                                        intervals.push(14); // 9th
                                        break;
                                    case 'sus2':
                                        intervals = intervals.filter(i => i !== 4 && i !== 3 && i !== 3.5);
                                        intervals.push(2);
                                        break;
                                    case 'sus4':
                                        intervals = intervals.filter(i => i !== 4 && i !== 3 && i !== 3.5);
                                        intervals.push(5);
                                        break;
                                    case 'add9':
                                        intervals.push(14);
                                        break;
                                    case '13':
                                        intervals.push(10); // 7th
                                        intervals.push(21); // 13th
                                        break;
                                    case '#11':
                                        intervals.push(18);
                                        break;
                                    case '7#9':
                                        intervals.push(10);
                                        intervals.push(15);
                                        break;
                                    case '#9':
                                        intervals.push(15);
                                        break;
                                    case 'n7':
                                        intervals.push(10.5); // neutral 7th
                                        break;
                                    default:
                                        break;
                                }
                            });

                            return intervals;
                        }
                    }));
                } else {
                    // No pre-locked chords; start with an empty palette
                    this.chordExtensions = [];
                }
                this.previewInterval = null;
                this.tempChordAudio = new Map(); // For preview audio
                // Track selection entry order for slash-bass inference
                this.selectedIntervals = [];
                this.selectedIntervalsOrder = [];
                // Track a newly created blank chord to inherit notes on first external strum
                this.pendingBlankChordId = null;
                
                // Clean up corrupted palette data
                this.cleanupPaletteData();
                
                // Initialize audio immediately (will be suspended until a gesture, then resumed)
                this.initAudio();
                // Also set up resume attempts on common gestures to satisfy autoplay policies
                const tryResume = () => { if (this.audioContext && this.audioContext.state === 'suspended') { this.audioContext.resume().catch(()=>{}); } };
                document.addEventListener('pointerdown', tryResume, { once: false });
                document.addEventListener('keydown', tryResume, { once: false });
                document.addEventListener('click', tryResume, { once: false });
                document.addEventListener('touchstart', tryResume, { once: false, passive: false });
                this.initEventListeners();
                // Always enable global keyboard shortcuts (including +/- for transpose)
                this.setupKeyboardInput();
                this.generateRootButtons();
                this.generateExtensionColumns();
                // Ensure we always have an active column so keyboard taps edit that chord
                try {
                    const firstCol = document.querySelector('.extension-column');
                    if (firstCol) { this.currentActiveColumnEl = firstCol; }
                } catch(_) {}
                
                // Ready for chord creation with New Chord button, but don't auto-enter chord mode
                console.log('?? Ready for chord creation - tuning and root can be changed freely');
                // DO NOT auto-enter chord creation mode - let user click "New Chord" when ready
                // Arm editing after idle
                this._scheduleEditArm();
                
                this.updateChordDisplay();
                this.setupSonicChords();
                this.initChordBuilder();

                // Text → Chords parser wiring
                this.initTextChordParser();

                // Wire instrument presets UI
                this.wireInstrumentPresetsUI();
            }

            // ---- DRUMS: transport-driven scheduler and simple synthesis ----
            _drumsOnTransportTick(){
                try {
                    // Only drive drums while PLAY is active
                    if (!this._isSequencing) return;
                    if (!this._arpTransport) return;
                    const tpBar = this._arpTransport.ticksPerBar || 16;
                    // Derive steps per bar from beatsPerBar (4 steps per beat)
                    const beatsPerBar = this._arpTransport.beatsPerBar || 4;
                    let steps = Math.max(4, Math.round((beatsPerBar||4) * 4));
                    if (tpBar <= 0 || steps <= 0) return;
                    // Map current tick into [0..steps-1]
                    const curTick = this._arpTransport.tickCounter|0;
                    // At bar boundary, apply either manual override (highest precedence) or mapped pattern from active column
                    if (curTick === 0) {
                        if (this._drumPendingPattern != null) {
                            try {
                                const n = Math.max(1, parseInt(this._drumPendingPattern,10) || 1);
                                const patEl = document.getElementById('drumPatternNumber');
                                if (patEl) {
                                    patEl.value = String(n);
                                    patEl.dispatchEvent(new Event('change', { bubbles: true }));
                                }
                            } catch(_) {}
                            this._drumPendingPattern = null;
                        } else {
                            // No manual override: use mapped value from the currently active column if present
                            try {
                                const col = (this._arp?.column) || this.currentActiveColumnEl || document.querySelector('.extension-column');
                                const mapped = col ? parseInt(col.dataset.drumPattern || '', 10) : NaN;
                                if (Number.isFinite(mapped)) {
                                    const patEl = document.getElementById('drumPatternNumber');
                                    if (patEl && String(patEl.value) !== String(mapped)) {
                                        patEl.value = String(mapped);
                                        patEl.dispatchEvent(new Event('change', { bubbles: true }));
                                    }
                                }
                            } catch(_) {}
                        }
                    }
                    const stepIdx = Math.floor((curTick / tpBar) * steps) | 0;
                    if (!this._drums) this._drums = { stepsPerBar: steps, lastStep: -1 };
                    else this._drums.stepsPerBar = steps;

                    // Move playheads
                    const lanes = document.querySelectorAll('.drum-lane');
                    if (lanes && lanes.length){
                        const leftPct = (stepIdx / steps) * 100;
                        lanes.forEach(lane => {
                            try { lane.style.setProperty('--steps-per-bar', String(steps)); } catch(_){ }
                            const ph = lane.querySelector('.drum-playhead');
                            if (ph) ph.style.left = leftPct + '%';
                        });
                    }

                    // Pattern playhead: loop strictly over pattern LEN (independent visual cycle)
                    try {
                        const patternGrid = document.getElementById('patternGrid');
                        if (patternGrid){
                            const patternLen = Math.max(1, Math.min(64, parseInt(patternGrid.dataset.length||'16',10)||16));
                            // Use current drum transport fractional position within bar to drive pattern cycle per bar.
                            const frac = (curTick / tpBar); // 0..1 over one bar
                            const pStepIdx = Math.min(patternLen-1, Math.floor(frac * patternLen));
                            const pLeftPct = (pStepIdx / patternLen) * 100;
                            const pLanes = patternGrid.querySelectorAll('.pattern-lane');
                            pLanes.forEach(pl => { const ph = pl.querySelector('.pattern-playhead'); if (ph) ph.style.left = pLeftPct + '%'; });
                        }
                    } catch(_){ }

                    // Trigger on step change only
                    if (this._drums.lastStep === stepIdx) return;
                    this._drums.lastStep = stepIdx;

                    // For each lane, if step active, fire one-shot drum; handle BASS from dedicated bass modal
                    lanes.forEach((lane, rowIdx) => {
                        const stepEl = lane.querySelector(`.drum-step[data-step="${stepIdx}"]`);
                        const rowEl = lane.closest('.drum-row');
                        const volEl = rowEl ? rowEl.querySelector('.drum-volume') : null;
                        const fxEl = rowEl ? rowEl.querySelector('.drum-fx input[type="checkbox"]') : null;
                        const vol = volEl ? Math.max(0, Math.min(1, parseInt(volEl.value||'80',10)/100)) : 0.8;
                        const sendToFX = fxEl ? !!fxEl.checked : false;

                        // Skip bass processing here - it's now handled separately from bass modal
                        if (stepEl && stepEl.classList.contains('active')){
                            // Fire internal synth
                            this._triggerDrumSound(rowIdx|0, vol, sendToFX);
                            // Also mirror per-lane MIDI if provided
                            try {
                                const midi = window.midi; if (midi && midi.enabled && rowIdx < 9) {
                                    const ctrls = lane._controls || {};
                                    const noteStr = (ctrls.midiInput?.value||'').trim();
                                    const midiNote = this._parseMidiNoteName(noteStr);
                                    if (Number.isFinite(midiNote)) {
                                        const vel = Math.round(vol * 127);
                                        const ch = (midi.channelMap && (midi.channelMap.drum||midi.channelMap.default||6))|0;
                                        const outSel = (typeof midi.outputForSource === 'function') ? midi.outputForSource('drum') : null;
                                        midi.sendNoteOn(midiNote, vel, ch, outSel);
                                        setTimeout(()=>{ try { midi.sendNoteOff(midiNote, ch, outSel); } catch(_){} }, 120);
                                    }
                                }
                            } catch(_){}
                        }
                    });

                    // *** FIX 3: Handle BASS from dedicated bass modal grid (9-row pattern) ***
                    try {
                        const bassBtn = document.getElementById('bassBtn');
                        const isBassEnabled = bassBtn && bassBtn.classList.contains('active');
                        
                        if (isBassEnabled) {
                            const bassGrid = document.getElementById('bassGrid');
                            
                            // Use bass pattern computation like ARP patterns
                            if (bassGrid && bassGrid._computedPattern) {
                                const bassPattern = String(bassGrid._computedPattern).trim();
                                const tokens = [];
                                let i=0; const N = bassPattern.length;
                                
                                // Parse bass pattern text like custom pattern
                                while (i<N) {
                                    const ch = bassPattern[i];
                                    if (ch === ' ') { i++; continue; }
                                    if (ch === 'x' || ch === 'X') { tokens.push(null); i++; continue; }
                                    if (ch === '[') {
                                        i++;
                                        const group = [];
                                        while (i<N && bassPattern[i] !== ']') {
                                            const c = bassPattern[i];
                                            if (/[0-9]/.test(c)) {
                                                let num = c; i++;
                                                while (i<N && /[0-9]/.test(bassPattern[i])) { num += bassPattern[i++]; }
                                                const npcVal = parseInt(num,10);
                                                if (Number.isFinite(npcVal) && npcVal>=1 && npcVal<=9) group.push(npcVal);
                                                continue;
                                            } else if (c === ' ') { i++; continue; }
                                            else { i++; }
                                        }
                                        if (i<N && bassPattern[i] === ']') i++;
                                        tokens.push(group.length ? group : null);
                                        continue;
                                    }
                                    if (/[0-9]/.test(ch)) {
                                        let num = ch; i++;
                                        while (i<N && /[0-9]/.test(bassPattern[i])) { num += bassPattern[i++]; }
                                        const npcVal = parseInt(num,10);
                                        if (Number.isFinite(npcVal) && npcVal>=1 && npcVal<=9) tokens.push(npcVal); else tokens.push(null);
                                        continue;
                                    }
                                    i++;
                                }
                                
                                // Get bass token for current step
                                const patternLength = Math.max(1, tokens.length);
                                const tokenIdx = stepIdx % patternLength;
                                const bassToken = tokens[tokenIdx];
                                
                                if (bassToken !== null) {
                                    const col = (this._arp?.column) || this.currentActiveColumnEl || document.querySelector('.extension-column');
                                    const edo = this.currentTuning||12;
                                    const norm = (x)=> ((x%edo)+edo)%edo;
                                    const rootAbs = (typeof this._getEffectiveColumnRootStep === 'function' && col) ? this._getEffectiveColumnRootStep(col) : (this.currentRoot||0);
                                    
                                    let rel = [];
                                    try {
                                        const rows = Array.from(col.querySelectorAll('.strings-column .string'));
                                        const steps = rows.map(r=> parseInt(r.dataset.noteIndex,10)).filter(n=>Number.isFinite(n));
                                        const uniqRel = Array.from(new Set(steps.map(st=> norm(st - rootAbs))));
                                        if (typeof this.stepToSemitone === 'function') {
                                            rel = uniqRel.sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo));
                                        } else {
                                            rel = uniqRel.sort((a,b)=> a-b);
                                        }
                                    } catch(_) { rel = []; }
                                    
                                    // Handle bass token (can be single NPC or array of NPCs)
                                    const npcList = Array.isArray(bassToken) ? bassToken : [bassToken];
                                    
                                    npcList.forEach(npc => {
                                        if (Number.isFinite(npc)) {
                                            const step = this._npcToChordStep(npc, rel);
                                            if (Number.isFinite(step)) {
                                                const uniq = Array.isArray(rel) ? rel.map(norm).sort((a,b)=>a-b).filter((v,i,a)=> i===0 || a[i-1]!==v) : [];
                                                const cycle = (uniq.length>0) ? Math.floor((Math.max(1,npc)-1)/uniq.length) : 0;
                                                const abs = norm(rootAbs + step);
                                                // Bass octave range C1-C3: Prefer octave 1 for first pass, octave 2 for second, octave 3 for third
                                                const baseOct = Math.max(1, Math.min(3, 1 + cycle));
                                                const f = this.getFrequency(abs, baseOct, edo);
                                                this.playFrequency(f, null, 'bass');
                                                
                                                // Gate bass note
                                                try {
                                                    const bpmEl = document.getElementById('universalBpm');
                                                    const bpm = Math.max(20, parseInt(bpmEl?.value||this._arpTransport?.bpm||120,10));
                                                    const quantStr = (document.getElementById('universalQuant')?.value) || this._arpTransport?.quant || '1/16';
                                                    const quantMs = Math.max(5, this._parseQuantToMs(quantStr, bpm) || 0);
                                                    const holdSpec = (document.getElementById('universalHold')?.value) || (document.getElementById('chordHold')?.value) || 'bar:1';
                                                    const [kind, valStr] = String(holdSpec).split(':');
                                                    const n = Math.max(1, parseInt(valStr||'1',10));
                                                    const tsRaw = String(document.getElementById('universalTimeSignature')?.value||'4/4');
                                                    let tsNum=4, tsDen=4; 
                                                    try{ 
                                                        const parts = tsRaw.split('/'); 
                                                        const a=parseInt(parts[0],10); 
                                                        const b=parseInt(parts[1],10); 
                                                        if(Number.isFinite(a)&&a>0) tsNum=a; 
                                                        if(Number.isFinite(b)&&b>0) tsDen=b; 
                                                    }catch(_){ }
                                                    const beatMs = 60000/Math.max(20,bpm);
                                                    const beatsPerBar = (tsNum*4)/tsDen;
                                                    const barMs = beatMs * beatsPerBar;
                                                    const holdMs = (kind==='beat') ? n*beatMs : n*barMs;
                                                    const gateMs = Math.max(5, Math.min(holdMs, quantMs));
                                                    setTimeout(()=>{ try { this.stopFrequency(f, null, 'bass'); } catch(_){ } }, gateMs);
                                                } catch(_){ }
                                            }
                                        }
                                    });
                                }
                            }
                        }
                    } catch(_) { /* ignore bass errors */ }
                } catch(_) { /* ignore */ }
            }

            // Map NPC number (1=root, 2=third, 3=fifth, etc.) to chord relative step
            _npcToChordStep(npc, chordRelSteps){
                try {
                    const rel = Array.isArray(chordRelSteps) ? chordRelSteps.slice() : [];
                    if (!rel.length || !Number.isFinite(npc) || npc <= 0) return null;
                    // Sort by ascending within octave, unique by value
                    const edo = this.currentTuning || 12;
                    const norm = (x)=> ((x%edo)+edo)%edo;
                    const uniq = [];
                    rel.map(norm).sort((a,b)=>a-b).forEach(v=>{ if (!uniq.includes(v)) uniq.push(v); });
                    if (!uniq.length) return null;
                    // Map 1→0th, 2→1st, 3→2nd... wrap around for numbers beyond chord size
                    const idx = (npc - 1) % uniq.length;
                    return uniq[idx];
                } catch(_) { return null; }
            }

            // Read per-lane drum parameters (pitch semis, attack/decay ms)
            _getDrumLaneParams(rowIdx){
                try {
                    const lane = document.querySelector(`.drum-lane[data-row="${rowIdx}"]`);
                    const ctrls = lane ? (lane._controls||{}) : {};
                    const pitch = Math.max(-24, Math.min(24, parseInt(ctrls.pPitch?.value)||0));
                    const attackMs = Math.max(0, Math.min(200, parseInt(ctrls.pAtk?.value)||2));
                    const decayMs = Math.max(5, Math.min(2000, parseInt(ctrls.pDec?.value)||180));
                    return { pitch, attackMs, decayMs };
                } catch(_) { return { pitch:0, attackMs:2, decayMs:180 }; }
            }

            async _triggerDrumSound(rowIdx, volume=0.8, sendToFX=false){
                try {
                    const ok = await this.ensureAudioContext(); if (!ok) return;
                    const ac = this.audioContext; if (!ac) return;

                    // Output mixer for this hit
                    const outGain = ac.createGain();
                    const mainVol = (this.volume || 1);
                    const master = (this.masterVolume || 1);
                    outGain.gain.value = Math.max(0, Math.min(1, volume)) * mainVol * master;

                    // Voice tracking container so STOP can silence immediately
                    const voice = { env: null, out: outGain, sources: [] };

                    // Voice graph per lane type
                    let sourceNode = null;
                    let postNode = outGain; // final node before routing

                    const now = ac.currentTime;
                    const env = ac.createGain(); env.gain.value = 0; env.connect(outGain);
                    voice.env = env;

                    const makeNoise = () => this.createNoiseSource();

                    // Per-lane parameters
                    const { pitch, attackMs, decayMs } = this._getDrumLaneParams(rowIdx);
                    const att = Math.max(0.001, attackMs/1000);
                    const dec = Math.max(0.03, decayMs/1000);
                    const ratio = Math.pow(2, (pitch||0)/12);
                    const endAt = (extra=0)=> now + att + dec + extra;

                    if (rowIdx === 0){
                        // KICK: decaying sine with quick pitch drop
                        const osc = ac.createOscillator();
                        osc.type = 'sine';
                        const startF = 120 * ratio; const endF = 45 * ratio; const dur = Math.min(dec, 0.25);
                        osc.frequency.setValueAtTime(startF, now);
                        osc.frequency.exponentialRampToValueAtTime(Math.max(20, endF), now + dur);
                        const g = ac.createGain(); g.gain.value = 1;
                        osc.connect(g); g.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = osc; postNode = outGain;
                        voice.sources.push(osc);
                        osc.start(now); osc.stop(endAt(0.1));
                    } else if (rowIdx === 1){
                        // SNARE: noise burst + faint tone
                        const noise = makeNoise();
                        const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1800; bp.Q.value=0.6;
                        noise.connect(bp); bp.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = noise; voice.sources.push(noise); sourceNode.start(); noise.stop(endAt(0.1));
                        // add a quiet body
                        const osc = ac.createOscillator(); osc.type='sine'; osc.frequency.setValueAtTime(180 * ratio, now);
                        const g = ac.createGain(); g.gain.value = 0.25; osc.connect(g); g.connect(env);
                        voice.sources.push(osc);
                        osc.start(now); osc.stop(endAt(0.05));
                    } else if (rowIdx === 2){
                        // CLOSED HAT: highpassed noise short
                        const noise = makeNoise();
                        const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=8000; hp.Q.value=0.7;
                        noise.connect(hp); hp.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = noise; voice.sources.push(noise); sourceNode.start(); noise.stop(endAt(0.05));
                    } else if (rowIdx === 3){
                        // OPEN HAT: longer noise
                        const noise = makeNoise();
                        const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000; hp.Q.value=0.7;
                        noise.connect(hp); hp.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = noise; voice.sources.push(noise); sourceNode.start(); noise.stop(endAt(0.1));
                    } else if (rowIdx === 4 || rowIdx === 5){
                        // TOM 1/2: pitch depends slightly on row
                        const base = (rowIdx===4? 220: 160) * ratio;
                        const osc = ac.createOscillator(); osc.type='sine';
                        osc.frequency.setValueAtTime(base*1.3, now);
                        osc.frequency.exponentialRampToValueAtTime(base, now + Math.min(dec, 0.24));
                        const g = ac.createGain(); g.gain.value=1; osc.connect(g); g.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = osc; voice.sources.push(osc); osc.start(now); osc.stop(endAt(0.1));
                    } else if (rowIdx === 6){
                        // CLAP: short wideband noise with quick pre-echo feel
                        const noise = makeNoise();
                        const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1600; bp.Q.value=0.9;
                        noise.connect(bp); bp.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = noise; voice.sources.push(noise); sourceNode.start(); noise.stop(endAt(0.05));
                    } else if (rowIdx === 7){
                        // CRASH: noisy, bright, long decay
                        const noise = makeNoise();
                        const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=4000; hp.Q.value=0.6;
                        noise.connect(hp); hp.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = noise; voice.sources.push(noise); sourceNode.start(); noise.stop(endAt(0.2));
                    } else if (rowIdx === 8){
                        // CLAVE: very short click
                        const osc = ac.createOscillator(); osc.type='square'; osc.frequency.setValueAtTime(1200 * ratio, now);
                        const g = ac.createGain(); g.gain.value = 0.4; osc.connect(g); g.connect(env);
                        env.gain.setValueAtTime(0, now);
                        env.gain.linearRampToValueAtTime(1, now + att);
                        env.gain.exponentialRampToValueAtTime(0.0008, now + att + dec);
                        sourceNode = osc; voice.sources.push(osc); osc.start(now); osc.stop(endAt(0.05));
                    }

                    // Route output: FX send or dry path (reuse existing master routing)
                    if (sendToFX && this.gainNode) {
                        outGain.connect(this.gainNode);
                    } else {
                        if (!this.dryGainNode) {
                            this.dryGainNode = ac.createGain();
                            this.dryGainNode.connect(ac.destination);
                            this.dryGainNode.gain.value = this.masterVolume || 1;
                        }
                        outGain.connect(this.dryGainNode);
                    }

                    // Register voice and clean it up when all sources end
                    try {
                        const cleanup = () => {
                            try { env.disconnect(); } catch(_){}
                            try { outGain.disconnect(); } catch(_){}
                        };
                        let pending = voice.sources.length;
                        if (pending === 0) {
                            // No sources? nothing to track
                            return;
                        }
                        const onEnded = () => {
                            pending = Math.max(0, pending - 1);
                            if (pending === 0) {
                                this._activeDrumVoices.delete(voice);
                                cleanup();
                            }
                        };
                        voice.sources.forEach(s => { try { s.onended = onEnded; } catch(_){} });
                        this._activeDrumVoices.add(voice);
                    } catch(_) {}
                } catch(_) { /* ignore */ }
            }

            // Force-stop all drum voices immediately (used by STOP)
            stopAllDrums(){
                try {
                    const ac = this.audioContext;
                    const now = ac ? ac.currentTime : 0;
                    const voices = Array.from(this._activeDrumVoices || []);
                    voices.forEach(v => {
                        try {
                            if (v && v.env && v.env.gain) {
                                try { v.env.gain.cancelScheduledValues(now); } catch(_){ }
                                try { v.env.gain.setValueAtTime(v.env.gain.value || 0, now); } catch(_){ }
                                try { v.env.gain.linearRampToValueAtTime(0.0001, now + 0.01); } catch(_){ }
                            }
                            if (v && v.out && v.out.gain) {
                                try { v.out.gain.cancelScheduledValues(now); } catch(_){ }
                                try { v.out.gain.setValueAtTime(v.out.gain.value || 0, now); } catch(_){ }
                                try { v.out.gain.linearRampToValueAtTime(0.0001, now + 0.01); } catch(_){ }
                            }
                            (v.sources||[]).forEach(s => {
                                try { if (typeof s.stop === 'function') s.stop(now + 0.01); } catch(_){}
                                try { if (typeof s.disconnect === 'function') s.disconnect(); } catch(_){}
                                try { s.onended = null; } catch(_){}
                            });
                            try { if (v.env && typeof v.env.disconnect === 'function') v.env.disconnect(); } catch(_){}
                            try { if (v.out && typeof v.out.disconnect === 'function') v.out.disconnect(); } catch(_){}
                        } catch(_){}
                        try { this._activeDrumVoices.delete(v); } catch(_){}
                    });
                } catch(_) { }
            }

            _resetDrumPlayhead(){
                try {
                    if (this._drums) this._drums.lastStep = -1;
                    document.querySelectorAll('.drum-playhead').forEach(ph => { ph.style.left = '0%'; });
                } catch(_) { }
            }

            // After 500ms idle, arm editing so the next keyboard taps go into chordbox
            _scheduleEditArm() {
                clearTimeout(this._editArmTimer);
                this._editArmTimer = setTimeout(() => { this.editArmed = true; }, 500);
            }

            // After any change, debounce save by 500ms; saving here just refreshes header/strings
            _scheduleEditSave(column) {
                clearTimeout(this._editSaveTimer);
                this._editSaveTimer = setTimeout(() => {
                    try {
                        if (column) this.highlightKeyboardForColumn(column);
                    } catch {}
                }, 500);
            }

            // Compute a subtle vibration period in ms for a given frequency and step index
            // Uses audio period (1/f) clamped to sensible range and snaps roots to wavelength series 1,2,4,8,16,32,64,128 as slower pulses
            computeVibrationPeriod(freq, stepIndex = 0) {
                const baseMs = Math.max(12, Math.min(90, 1000 / Math.max(1, freq))); // 12–90ms
                // Treat exact roots (interval 0) specially if the EDO step index equals currentRoot
                // We can't know the interval reliably here in all contexts; as a proxy: if stepIndex % currentTuning == currentRoot treat as root
                try {
                    const isRootish = ((stepIndex % this.currentTuning) === (this.currentRoot % this.currentTuning));
                    if (isRootish) {
                        // Map to one of 1..128 multipliers but cap to a gentle 32x to avoid too slow visuals
                        const multipliers = [1,2,4,8,16,32];
                        const idx = Math.min(multipliers.length - 1, Math.floor((freq || 1) / 110));
                        return Math.round(baseMs * multipliers[idx]);
                    }
                } catch {}
                return Math.round(baseMs);
            }

            // Initialize standard chord types with proper musical symbols
            initializeStandardChordTypes() {
                return [
                    // Triads
                    { name: '', symbol: '', intervals: [0, 4, 7], description: 'Major triad' },
                    { name: 'm', symbol: 'm', intervals: [0, 3, 7], description: 'Minor triad' },
                    { name: '°', symbol: '°', intervals: [0, 3, 6], description: 'Diminished triad' },
                    { name: '+', symbol: '+', intervals: [0, 4, 8], description: 'Augmented triad' },
                    { name: 'sus2', symbol: 'sus2', intervals: [0, 2, 7], description: 'Suspended 2nd' },
                    { name: 'sus4', symbol: 'sus4', intervals: [0, 5, 7], description: 'Suspended 4th' },
                    
                    // Seventh chords
                    { name: '7', symbol: '7', intervals: [0, 4, 7, 10], description: 'Dominant 7th' },
                    { name: 'M7', symbol: 'Δ7', intervals: [0, 4, 7, 11], description: 'Major 7th' },
                    { name: 'm7', symbol: 'm7', intervals: [0, 3, 7, 10], description: 'Minor 7th' },
                    { name: 'mM7', symbol: 'mΔ7', intervals: [0, 3, 7, 11], description: 'Minor major 7th' },
                    { name: '°7', symbol: '°7', intervals: [0, 3, 6, 9], description: 'Diminished 7th' },
                    { name: 'ø7', symbol: 'ø7', intervals: [0, 3, 6, 10], description: 'Half-diminished 7th' },
                    { name: '+7', symbol: '+7', intervals: [0, 4, 8, 10], description: 'Augmented 7th' },
                    
                    // Extended chords
                    { name: '9', symbol: '9', intervals: [0, 4, 7, 10, 14], description: 'Dominant 9th' },
                    { name: 'M9', symbol: 'Δ9', intervals: [0, 4, 7, 11, 14], description: 'Major 9th' },
                    { name: 'm9', symbol: 'm9', intervals: [0, 3, 7, 10, 14], description: 'Minor 9th' },
                    { name: '11', symbol: '11', intervals: [0, 4, 7, 10, 14, 17], description: 'Dominant 11th' },
                    { name: 'M11', symbol: 'Δ11', intervals: [0, 4, 7, 11, 14, 17], description: 'Major 11th' },
                    { name: 'm11', symbol: 'm11', intervals: [0, 3, 7, 10, 14, 17], description: 'Minor 11th' },
                    { name: '13', symbol: '13', intervals: [0, 4, 7, 10, 14, 17, 21], description: 'Dominant 13th' },
                    { name: 'M13', symbol: 'Δ13', intervals: [0, 4, 7, 11, 14, 17, 21], description: 'Major 13th' },
                    { name: 'm13', symbol: 'm13', intervals: [0, 3, 7, 10, 14, 17, 21], description: 'Minor 13th' },
                    
                    // Altered dominants
                    { name: '7♭5', symbol: '7♭5', intervals: [0, 4, 6, 10], description: 'Dominant 7 flat 5' },
                    { name: '7#5', symbol: '7♯5', intervals: [0, 4, 8, 10], description: 'Dominant 7 sharp 5' },
                    { name: '7♭9', symbol: '7♭9', intervals: [0, 4, 7, 10, 13], description: 'Dominant 7 flat 9' },
                    { name: '7#9', symbol: '7♯9', intervals: [0, 4, 7, 10, 15], description: 'Dominant 7 sharp 9' },
                    { name: '7♭5♭9', symbol: '7♭5♭9', intervals: [0, 4, 6, 10, 13], description: 'Dominant 7 flat 5 flat 9' },
                    { name: '7#5#9', symbol: '7♯5♯9', intervals: [0, 4, 8, 10, 15], description: 'Dominant 7 sharp 5 sharp 9' },
                    
                    // Add chords (no 3rd)
                    { name: 'add9', symbol: 'add9', intervals: [0, 4, 7, 14], description: 'Major add 9' },
                    { name: 'madd9', symbol: 'madd9', intervals: [0, 3, 7, 14], description: 'Minor add 9' },
                    { name: 'add11', symbol: 'add11', intervals: [0, 4, 7, 17], description: 'Major add 11' },
                    { name: 'madd11', symbol: 'madd11', intervals: [0, 3, 7, 17], description: 'Minor add 11' },
                    
                    // Slash chords (bass notes)
                    { name: '/3', symbol: '/3', intervals: [4, 0, 7], description: 'Major first inversion' },
                    { name: '/5', symbol: '/5', intervals: [7, 0, 4], description: 'Major second inversion' },
                    { name: 'm/♭3', symbol: 'm/♭3', intervals: [3, 0, 7], description: 'Minor first inversion' },
                    { name: 'm/5', symbol: 'm/5', intervals: [7, 0, 3], description: 'Minor second inversion' }
                ];
            }
            
            // Generate standard chord progressions for practice
            generateStandardChordProgression(rootNote = 'C', progressionType = 'ii-V-I') {
                const progressions = {
                    'ii-V-I': ['m7', '7', 'M7'],
                    'vi-IV-I-V': ['m', '', '', '7'],
                    'I-vi-IV-V': ['', 'm', '', '7'],
                    'blues': ['7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '7'],
                    'jazz-blues': ['M7', '7', 'M7', 'M7', '7', '7', 'M7', 'm7', 'm7', '7', 'M7', '7']
                };
                
                const progression = progressions[progressionType] || progressions['ii-V-I'];
                const chords = [];
                
                progression.forEach((chordSymbol, index) => {
                    const chordType = this.standardChordTypes.find(type => type.symbol === chordSymbol);
                    if (chordType) {
                        chords.push({
                            root: rootNote,
                            type: chordType,
                            symbol: rootNote + chordSymbol
                        });
                    }
                });
                
                return chords;
            }
            
            // Create basic chord set for beginners
            createBasicChordSet() {
                // User-requested basic chord set (only these, no others)
                const basicChords = [
                    { name: 'Major',        symbol: '',   intervals: [0,4,7],          description: 'Major triad' },
                    { name: 'Minor',        symbol: 'm',  intervals: [0,3,7],          description: 'Minor triad' },
                    { name: '7th',          symbol: '7',  intervals: [0,4,7,10],       description: 'Dominant 7th' },
                    { name: 'minor 7th',    symbol: 'm7', intervals: [0,3,7,10],       description: 'Minor 7th' },
                    { name: 'Major 7th',    symbol: 'M7', intervals: [0,4,7,11],       description: 'Major 7th' },
                    { name: '6th',          symbol: '6',  intervals: [0,4,7,9],        description: 'Major 6th' },
                    { name: '9th',          symbol: '9',  intervals: [0,4,7,10,14],    description: 'Dominant 9th' },
                    { name: 'sus4',         symbol: 'sus4', intervals:[0,5,7],         description: 'Suspended 4th' },
                    { name: 'sus2',         symbol: 'sus2', intervals:[0,2,7],         description: 'Suspended 2nd' },
                    { name: 'Diminished',   symbol: 'dim', intervals:[0,3,6],          description: 'Diminished triad' },
                    { name: 'Augmented',    symbol: 'aug', intervals:[0,4,8],          description: 'Augmented triad' }
                ];

                this.chordExtensions = basicChords.map(chord => ({
                    name: chord.name,
                    intervals: chord.intervals,
                    description: chord.description,
                    symbol: chord.symbol,
                    isCustom: false
                }));

                console.log('✓ Created requested basic chord set:', this.chordExtensions.length, 'chords');
                this.updateChordDisplay();
                this.generateExtensionColumns();
            }

            cleanupPaletteData() {
                // Clean up any corrupted palette chord data
                if (this.paletteChords && Array.isArray(this.paletteChords)) {
                    const originalLength = this.paletteChords.length;
                    this.paletteChords = this.paletteChords.filter(chord => {
                        return chord && typeof chord === 'object' && chord.name && chord.intervals;
                    });
                    
                    if (this.paletteChords.length !== originalLength) {
                        console.log('?? Cleaned up corrupted palette data:', originalLength, '->', this.paletteChords.length);
                    }
                } else {
                    console.log('?? Resetting corrupted palette data');
                    this.paletteChords = [];
                }
            }

            

            // =============================================================================
            // UNIFIED CHORD BUILDER MODULE - Single source of truth for all chord creation
            // =============================================================================
            
            initChordBuilder() {
                
                // New chord creation button → WYSIWYG: spawn a blank editable column immediately
                document.getElementById('createNewChordBtn').addEventListener('click', () => {
                    try { this.createBlankChordColumn(); } catch (e) { console.error('Create blank chord failed:', e); }
                });
                // Insert [ and ] markers quickly
                const leftBtn = document.getElementById('insertLeftBracketBtn');
                if (leftBtn) leftBtn.addEventListener('click', () => {
                    const lvl = Math.max(0, parseInt(prompt('Nest level (0=outer, 1=inner,...):','0')||'0',10));
                    this.chordExtensions.push({
                        name: '[', isCustom: true, isRepeatMarker: true,
                        nestLevel: lvl, id: 'bracket_start_L'+lvl+'_'+Date.now(), position: this.chordExtensions.length
                    });
                    this.generateExtensionColumns();
                });
                const rightBtn = document.getElementById('insertRightBracketBtn');
                if (rightBtn) rightBtn.addEventListener('click', () => {
                    const lvl = Math.max(0, parseInt(prompt('Nest level to close (0=outer,1=inner,...):','0')||'0',10));
                    const countStr = prompt('Repeat count: 0 = infinite; leave blank for single (no repeat label)','2');
                    let count = null;
                    if (countStr !== null && countStr.trim() !== '') count = Math.max(0, parseInt(countStr,10)||0);
                    const marker = {
                        name: (count==null ? ']' : (count===0?']':`]x${count}`)),
                        isCustom: true, isRepeatMarker: true,
                        nestLevel: lvl, id: 'bracket_end_L'+lvl+'_'+Date.now(), position: this.chordExtensions.length
                    };
                    if (count!=null) marker.repeatCount = count;
                    this.chordExtensions.push(marker);
                    this.generateExtensionColumns();
                });
                
                
                // Reset chords button
                document.getElementById('resetChordsBtn').addEventListener('click', () => {
                    if (confirm('Clear all unlocked chords? This will remove only unlocked chords, preserving all locked chords.')) {
                        this.clearUnlockedChords();
                    }
                });
                
                // Save session button
                document.getElementById('saveSessionBtn').addEventListener('click', () => {
                    this.saveSessionToFile();
                });
                
                // Load session button
                document.getElementById('loadSessionBtn').addEventListener('click', () => {
                    document.getElementById('loadSessionInput').click();
                });
                
                // File input for loading sessions
                document.getElementById('loadSessionInput').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadSessionFromFile(file)
                            .then(() => {
                                alert('Session loaded successfully!');
                            })
                            .catch((error) => {
                                alert('Error loading session: ' + error.message);
                            });
                    }
                });
                
                // New transpose button event listeners
                document.getElementById('transposeUpBtn').addEventListener('click', () => {
                    try { this.applyTransposeStep(1); } catch(e) { console.error('Transpose up failed:', e); }
                });
                
                document.getElementById('transposeDownBtn').addEventListener('click', () => {
                    try { this.applyTransposeStep(-1); } catch(e) { console.error('Transpose down failed:', e); }
                });
                
                // Keyboard toggle functionality + Drum view toggle
                const keyboardToggle = document.getElementById('keyboardToggle');
                const keyboardToggleMenu = document.getElementById('keyboardToggleMenu');
                const drumsToggle = document.getElementById('drumsToggle');
                const drumsBtn = document.getElementById('drumsModuleBtn');
                const drumGridContainer = document.getElementById('drumGridContainer');
                const rootGrid = document.getElementById('rootGrid');
                
                const toggleKeyboard = (show) => {
                    const rootNotesArea = document.querySelector('.root-notes-area');
                    if (rootNotesArea) {
                        rootNotesArea.style.display = show ? 'block' : 'none';
                    }
                    // Sync both toggles
                    if (keyboardToggle) keyboardToggle.checked = show;
                    if (keyboardToggleMenu) keyboardToggleMenu.checked = show;
                };

                const showDrums = (on) => {
                    if (!drumGridContainer || !rootGrid) return;
                    if (on) {
                        // Ensure the section is visible when entering drums view
                        try { toggleKeyboard(true); } catch {}
                        try { if (this._drums) this._drums.lastStep = -1; } catch {}
                    }
                    drumGridContainer.style.display = on ? 'block' : 'none';
                    if (drumsToggle) drumsToggle.checked = on;
                    try {
                        document.body.classList.toggle('drums-mode', !!on);
                        if (on) {
                            // After render, scroll drum container to bottom so BASS row is visible
                            requestAnimationFrame(() => {
                                try {
                                    drumGridContainer.scrollTop = drumGridContainer.scrollHeight;
                                } catch(_) {}
                            });
                        }
                    } catch (_){ }
                };
                
                if (keyboardToggle) {
                    keyboardToggle.addEventListener('change', (e) => {
                        toggleKeyboard(e.target.checked);
                    });
                }
                
                if (keyboardToggleMenu) {
                    keyboardToggleMenu.addEventListener('change', (e) => {
                        toggleKeyboard(e.target.checked);
                    });
                }

                if (drumsToggle && !drumsToggle._wired) {
                    drumsToggle._wired = true;
                    drumsToggle.addEventListener('change', (e) => {
                        showDrums(!!e.target.checked);
                    });
                }

                if (drumsBtn && !drumsBtn._wired) {
                    drumsBtn._wired = true;
                    drumsBtn.addEventListener('click', () => {
                        // Toggle drums view on button click
                        const next = !(drumsToggle && drumsToggle.checked);
                        showDrums(next);
                    });
                }

                // PATTERN button toggling (shows pattern grid to the right without hiding drums)
                try {
                    const patternBtn = document.getElementById('patternModuleBtn');
                    const patternContainer = document.getElementById('patternGridContainer');
                    const drumsContainer = document.getElementById('drumGridContainer');
                    const wrapper = document.getElementById('rhythmGridsWrapper');
                    if (patternBtn && patternContainer && !patternBtn._wired) {
                        patternBtn._wired = true;
                        patternBtn.addEventListener('click', () => {
                            // Toggle pattern visibility
                            const visible = patternContainer.style.display !== 'none';
                            if (visible) {
                                patternContainer.style.display = 'none';
                                patternBtn.classList.remove('active');
                            } else {
                                patternContainer.style.display = 'block';
                                patternBtn.classList.add('active');
                                // Ensure drums visible too
                                try { showDrums(true); } catch(_){ }
                                // Scroll horizontally to show pattern grid if wrapper scrolls
                                try {
                                    if (wrapper) {
                                        requestAnimationFrame(()=>{
                                            wrapper.scrollTo({ left: wrapper.scrollWidth, behavior: 'smooth' });
                                        });
                                    }
                                } catch(_){ }
                            }
                        });
                        // Start hidden to keep original layout
                        patternContainer.style.display = 'none';
                    }
                } catch(_){ }

                // Derive pattern text from pattern grid (NPC rows 1-9) and keep universalPatternText updated (respect current LEN, hide tail)
                try {
                    const patternGrid = document.getElementById('patternGrid');
                    const patternTextEl = document.getElementById('universalPatternText');
                    if (patternGrid && patternTextEl && !patternGrid._patternSync) {
                        patternGrid._patternSync = true;
                        const recompute = () => {
                            try {
                                // Always populate pattern text when CUSTOM mode is selected
                                const universalPattern = document.getElementById('universalPattern');
                                if (!universalPattern || universalPattern.value !== 'custom') {
                                    // For non-CUSTOM modes, still update internal pattern but don't show in text field
                                    // This ensures pattern dots work correctly in all modes
                                }
                                
                                const lanes = Array.from(patternGrid.querySelectorAll('.pattern-lane'));
                                if (lanes.length < 9) return;
                                const npcLanes = lanes.slice(0,9);
                                const steps = Array.from(npcLanes[0].querySelectorAll('.pattern-step'));
                                const maxVisible = Math.max(1, Math.min(steps.length, parseInt(patternGrid.dataset.length||String(steps.length),10)||steps.length));
                                const tokens = [];
                                for (let i=0;i<maxVisible;i++){
                                    const activeNums = [];
                                    for (let idx=0; idx<npcLanes.length; idx++){
                                        const cell = npcLanes[idx].querySelector(`.pattern-step[data-step="${i}"]`);
                                        if (cell && cell.classList.contains('active')) activeNums.push(9-idx);
                                    }
                                    if (activeNums.length === 0) tokens.push('x');
                                    else if (activeNums.length === 1) tokens.push(String(activeNums[0]));
                                    else tokens.push('['+activeNums.join(' ')+']');
                                }
                                
                                // Store pattern internally for all modes
                                patternGrid._computedPattern = tokens.join(' ');
                                
                                // Only show in text field for CUSTOM mode
                                if (universalPattern && universalPattern.value === 'custom') {
                                    patternTextEl.value = tokens.join(' ');
                                } else {
                                    patternTextEl.value = ''; // Clear text field for non-CUSTOM modes
                                }
                            } catch(_){ }
                        };
                        patternGrid._recomputePatternText = recompute;
                        patternGrid.addEventListener('click', (e)=>{ if (e.target?.classList?.contains('pattern-step')) recompute(); });
                        patternBtn?.addEventListener('click', ()=> setTimeout(recompute,50));
                    }
                } catch(_){ }

                // Drum pattern number: clone on increment
                try {
                    const patNum = document.getElementById('drumPatternNumber');
                    if (patNum && !patNum._wired){
                        patNum._wired = true;
                        // Simple in-memory pattern store keyed by number
                        this._drumPatterns = this._drumPatterns || new Map();
                        const captureGrid = ()=>{
                            const lanes = Array.from(document.querySelectorAll('.drum-row:not(.bass-row) .drum-lane'));
                            return lanes.map(lane=>{
                                const steps = Array.from(lane.querySelectorAll('.drum-step')).map(s=> s.classList.contains('active') ? 1 : 0);
                                return steps;
                            });
                        };
                        const applyGrid = (gridArr)=>{
                            if (!Array.isArray(gridArr)) return;
                            const lanes = Array.from(document.querySelectorAll('.drum-row:not(.bass-row) .drum-lane'));
                            lanes.forEach((lane, i)=>{
                                const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                const row = gridArr[i] || [];
                                steps.forEach((s, j)=>{ if (row[j]) s.classList.add('active'); else s.classList.remove('active'); });
                            });
                        };
                        // Helper: immediate autosave to current slot
                        this._saveDrumPattern = () => {
                            try {
                                const n = Math.max(1, parseInt(document.getElementById('drumPatternNumber')?.value||'1',10));
                                this._drumPatterns.set(n, captureGrid());
                            } catch(_) {}
                        };
                        // Helper: duplicate current pattern to next empty slot and select it
                        this._duplicateCurrentDrumPattern = () => {
                            try {
                                const cur = Math.max(1, parseInt(document.getElementById('drumPatternNumber')?.value||'1',10));
                                this._drumPatterns.set(cur, captureGrid());
                                let target = null;
                                for (let k = cur+1; k <= 128; k++) { if (!this._drumPatterns.has(k)) { target = k; break; } }
                                if (!target) return;
                                const src = this._drumPatterns.get(cur) || captureGrid();
                                const cloned = JSON.parse(JSON.stringify(src));
                                this._drumPatterns.set(target, cloned);
                                const patEl = document.getElementById('drumPatternNumber');
                                if (patEl) {
                                    patEl.value = String(target);
                                    patEl.dispatchEvent(new Event('change', { bubbles: true }));
                                    patEl.title = `Duplicated → ${target}`;
                                    patEl.style.outline = '2px solid #00d1b2';
                                    setTimeout(()=>{ try { patEl.style.outline=''; } catch(_){} }, 260);
                                }
                            } catch(_) {}
                        };
                        // Wire duplicate button
                        try {
                            const dupBtn = document.getElementById('drumDuplicateBtn');
                            if (dupBtn && !dupBtn._wired) { dupBtn._wired = true; dupBtn.addEventListener('click', (e)=>{ e.preventDefault(); try{ this._duplicateCurrentDrumPattern(); } catch(_){} }); }
                        } catch(_){}
                        // Initialize pattern 1 from current grid if empty
                        if (!this._drumPatterns.has(1)) this._drumPatterns.set(1, captureGrid());
                        patNum.addEventListener('change', (e)=>{
                            let v = parseInt(e.target.value,10); if(!Number.isFinite(v) || v<1) v=1; e.target.value=String(v);
                            const prev = this._lastDrumPatternNumber || 1;
                            // If increasing and new slot empty, clone from previous
                            if (v>prev && !this._drumPatterns.has(v)){
                                this._drumPatterns.set(v, JSON.parse(JSON.stringify(this._drumPatterns.get(prev) || captureGrid())));
                            } else {
                                // Before switching away, save current
                                this._drumPatterns.set(prev, captureGrid());
                            }
                            // Apply selected pattern
                            const patt = this._drumPatterns.get(v);
                            if (patt) applyGrid(patt);
                            this._lastDrumPatternNumber = v;
                        });
                        this._lastDrumPatternNumber = parseInt(patNum.value,10) || 1;
                    }
                } catch(_){ }

                // Wire DRUM mini TIME controls to universal transport (mirror both ways)
                try {
                    const miniIds = ['drumBpmMini','drumTSMini','drumQuantMini'];
                    const exists = miniIds.some(id => document.getElementById(id));
                    if (exists) {
                        const link = (miniId, uniId, eventName='change') => {
                            const m = document.getElementById(miniId);
                            const u = document.getElementById(uniId);
                            if (!m) return;
                            // Mini → Universal
                            if (!m._wiredMini) {
                                m._wiredMini = true;
                                m.addEventListener('change', () => {
                                    try { if (u) { u.value = String(m.value); u.dispatchEvent(new Event(eventName, { bubbles:true })); } } catch(_){}
                                    // Persist mini as default too
                                    try { localStorage.setItem(miniId, String(m.value)); } catch(_){ }
                                });
                                m.addEventListener('input', () => { try { localStorage.setItem(miniId, String(m.value)); } catch(_){ } });
                            }
                            // Universal → Mini
                            if (u && !u._wiredUniToMini) {
                                u._wiredUniToMini = true;
                                u.addEventListener('change', () => { try { m.value = String(u.value); } catch(_){} });
                                u.addEventListener('input',  () => { try { m.value = String(u.value); } catch(_){} });
                            }
                            // Seed from universal on first wire, else from localStorage
                            try {
                                const ls = localStorage.getItem(miniId);
                                if (u) { m.value = String(u.value); }
                                else if (ls != null) { m.value = String(ls); }
                            } catch(_){ }
                        };
                        // Map: mini → universal ids
                        link('drumBpmMini',   'universalBpm', 'input');
                        link('drumTSMini',    'universalTimeSignature', 'change');
                        link('drumQuantMini', 'universalQuant', 'change');
                        // Removed drumNpcMini & drumSwingMini (single NPC & Swing now elsewhere)
                    }
                } catch(_){ }
                
                // EDO inputs are now handled by universal sync system
                // Individual handlers removed to prevent conflicts

                // Build initial drum grid skeleton once
                const drumNames = [
                    'KICK','SNARE','CH HAT','OP HAT','TOM 1','TOM 2','CLAP','CRASH','CLAVE'
                ];
                const grid = document.getElementById('drumGrid');
                if (grid && !grid.dataset.built) {
                    grid.dataset.built = '1';
                    // Determine steps per bar from time signature (4 steps per beat)
                    (function(){ /* placeholder to keep section collapsed in some editors */ })();
                    let tsNum=4, tsDen=4; try{
                        const tsRaw = String(document.getElementById('universalTimeSignature')?.value||'4/4');
                        const parts = tsRaw.split('/');
                        const a=parseInt(parts[0],10); const b=parseInt(parts[1],10);
                        if(Number.isFinite(a)&&a>0) tsNum=a; if(Number.isFinite(b)&&b>0) tsDen=b;
                    }catch(_){}
                    const beatsPerBar = (tsNum*4)/tsDen;
                    const stepsPerBar = Math.max(4, Math.round(beatsPerBar * 4));
                    // GM defaults for channel 10 per common mapping
                    const gmNotes = ['C2','D2','F#2','A#2','D3','C3','E2','C#3','G#2'];
                    drumNames.forEach((name, rowIdx) => {
                        const row = document.createElement('div');
                        row.className = 'drum-row' + (name==='BASS' ? ' bass-row' : '');

                        const label = document.createElement('div');
                        label.className = 'drum-label';
                        label.textContent = name;
                        row.appendChild(label);

                        const lane = document.createElement('div');
                        lane.className = 'drum-lane';
                        lane.dataset.row = String(rowIdx);
                        try { lane.style.setProperty('--steps-per-bar', String(stepsPerBar)); } catch(_){ }

                        // Beat dividers at each beat boundary
                        const fullBeats = Math.max(0, Math.floor(beatsPerBar));
                        for (let b=1; b<fullBeats; b++){
                            const div = document.createElement('div');
                            div.className = 'beat-divider';
                            div.style.left = `${(b/beatsPerBar)*100}%`;
                            lane.appendChild(div);
                        }
                        // Steps
                        for (let i=0;i<stepsPerBar;i++){
                            const s = document.createElement('div');
                            s.className = 'drum-step' + ((i%4===0)?' beat-accent':'');
                            s.dataset.step = String(i);
                            s.title = `${name} • Step ${i+1}`;
                            if (name === 'BASS') {
                                s.dataset.npc = '';
                                // Drag-to-extend sustain (ties) on mousedown
                                s.addEventListener('mousedown', (e) => {
                                    if (e.button !== 0) return;
                                    e.preventDefault();
                                    const startIdx = i;
                                    const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                    const applyLen = (toIdx) => {
                                        const len = Math.max(1, (toIdx|0) - startIdx + 1);
                                        s.dataset.len = String(len);
                                        for (let k = 0; k < steps.length; k++) {
                                            if (k > startIdx && k <= startIdx + len - 1) steps[k].dataset.tie = '1';
                                            else if (k > startIdx) delete steps[k].dataset.tie;
                                        }
                                    };
                                    const onMove = (ev) => {
                                        const rect = lane.getBoundingClientRect();
                                        const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
                                        const idx = Math.max(0, Math.min(stepsPerBar-1, Math.floor((x / rect.width) * stepsPerBar)));
                                        applyLen(idx);
                                        try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                                    };
                                    const onUp = () => {
                                        document.removeEventListener('mousemove', onMove);
                                        document.removeEventListener('mouseup', onUp);
                                        try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                                        try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                    };
                                    document.addEventListener('mousemove', onMove);
                                    document.addEventListener('mouseup', onUp);
                                });

                                // Click: quick root on empty, second click opens change, rest → root
                                s.addEventListener('click', (e) => {
                                    e.preventDefault();
                                    const prev = (s.dataset.npc||'');
                                    if (prev === '') {
                                        s.dataset.npc = '1'; s.classList.add('active'); if (!s.dataset.len) s.dataset.len = '1';
                                    } else if (prev && prev.toLowerCase() !== 'x') {
                                        s.classList.add('selected');
                                        const valIn = window.prompt('Bass NPC (1–9) or x for rest', String(prev).toLowerCase());
                                        s.classList.remove('selected');
                                        if (valIn == null) return;
                                        const val = String(valIn).trim();
                                        if (val === '') { s.dataset.npc=''; s.classList.remove('active'); delete s.dataset.len; return; }
                                        if (/^x$/i.test(val)) { s.dataset.npc='x'; s.classList.remove('active'); delete s.dataset.len; return; }
                                        if (/^[1-9]$/.test(val)) { s.dataset.npc=val; s.classList.add('active'); if (!s.dataset.len) s.dataset.len='1'; }
                                    } else {
                                        s.dataset.npc = '1'; s.classList.add('active'); if (!s.dataset.len) s.dataset.len = '1';
                                    }

                                    // Audition current selection
                                    try {
                                        const col = (this._arp?.column) || this.currentActiveColumnEl || document.querySelector('.extension-column');
                                        const edo = this.currentTuning||12; const norm=(x)=>((x%edo)+edo)%edo;
                                        const rootAbs = (typeof this._getEffectiveColumnRootStep === 'function' && col) ? this._getEffectiveColumnRootStep(col) : (this.currentRoot||0);
                                        let rel = [];
                                        try {
                                            const rows = Array.from(col.querySelectorAll('.strings-column .string'));
                                            const steps = rows.map(r=> parseInt(r.dataset.noteIndex,10)).filter(n=>Number.isFinite(n));
                                            const uniqRel = Array.from(new Set(steps.map(st=> norm(st - rootAbs))));
                                            rel = (typeof this.stepToSemitone === 'function') ? uniqRel.sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo)) : uniqRel.sort((a,b)=>a-b);
                                        } catch(_) { rel = []; }
                                        const npc = parseInt(s.dataset.npc||'1',10);
                                        const step = this._npcToChordStep(npc, rel);
                                        if (Number.isFinite(step)){
                                            const uniq = Array.isArray(rel) ? rel.map(norm).sort((a,b)=>a-b).filter((v,i,a)=> i===0 || a[i-1]!==v) : [];
                                            const cycle = (uniq.length>0) ? Math.floor((Math.max(1,npc)-1)/uniq.length) : 0;
                                            const abs = norm(rootAbs + step);
                                            const baseOct = Math.max(1, Math.min(3, 2 + cycle));
                                            const f = this.getFrequency(abs, baseOct, edo);
                                            this.playFrequency(f, null, 'bass');
                                            try {
                                                const bpmEl = document.getElementById('universalBpm');
                                                const bpm = Math.max(20, parseInt(bpmEl?.value||this._arpTransport?.bpm||120,10));
                                                const quantStr = (document.getElementById('universalQuant')?.value) || this._arpTransport?.quant || '1/16';
                                                const quantMs = Math.max(5, this._parseQuantToMs(quantStr, bpm) || 0);
                                                const holdSpec = (document.getElementById('universalHold')?.value) || (document.getElementById('chordHold')?.value) || 'bar:1';
                                                const [kind, valStr] = String(holdSpec).split(':');
                                                const n = Math.max(1, parseInt(valStr||'1',10));
                                                const tsRaw = String(document.getElementById('universalTimeSignature')?.value||'4/4');
                                                let tsNum=4, tsDen=4; try{ const parts = tsRaw.split('/'); const a=parseInt(parts[0],10); const b=parseInt(parts[1],10); if(Number.isFinite(a)&&a>0) tsNum=a; if(Number.isFinite(b)&&b>0) tsDen=b; }catch(_){ }
                                                const beatMs = 60000/Math.max(20,bpm);
                                                const beatsPerBar = (tsNum*4)/tsDen;
                                                const barMs = beatMs * beatsPerBar;
                                                const holdMs = (kind==='beat') ? n*beatMs : n*barMs;
                                                const gateMs = Math.max(5, Math.min(holdMs, quantMs));
                                                setTimeout(()=>{ try { this.stopFrequency(f, null, 'bass'); } catch(_){ } }, gateMs);
                                            } catch(_){ }
                                        }
                                    } catch(_){ }
                                    // After change, update tie overlays
                                    try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                                    // Autosave pattern after change
                                    try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                });

                                    // Right-click to delete/rest and clear ties from this head
                                    s.addEventListener('contextmenu', (e) => {
                                        e.preventDefault();
                                        try {
                                            const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                            const idx = parseInt(s.dataset.step||'0',10) || 0;
                                            if (s.dataset.tie === '1') {
                                                // Find head before this index with a len
                                                let headIdx = -1;
                                                for (let k = idx - 1; k >= 0; k--) {
                                                    if (steps[k].dataset.len) { headIdx = k; break; }
                                                }
                                                if (headIdx >= 0) {
                                                    const newLen = Math.max(1, idx - headIdx);
                                                    steps[headIdx].dataset.len = String(newLen);
                                                }
                                                // Remove tie mark from this and onward
                                                for (let k = idx; k < steps.length; k++) { delete steps[k].dataset.tie; }
                                                // Clear any npc on this continuation cell (usually none)
                                                s.dataset.npc = '';
                                                s.classList.remove('active');
                                            } else {
                                                // Head or standalone: clear ties after it and its own len
                                                for (let k = idx + 1; k < steps.length; k++) { delete steps[k].dataset.tie; }
                                                delete s.dataset.len;
                                                s.dataset.npc = '';
                                                s.classList.remove('active');
                                            }
                                            // Rebuild overlays
                                            this.rebuildBassTieOverlays(lane);
                                        } catch(_) { }
                                        // Autosave after delete/rest adjustments
                                        try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                    });
                            } else {
                                s.addEventListener('click', (e) => {
                                    e.preventDefault();
                                    const nowActive = !s.classList.contains('active');
                                    if (nowActive) s.classList.add('active'); else s.classList.remove('active');
                                    // Click-audition: if turning on, preview the hit without touching transport
                                    try {
                                        if (nowActive){
                                            const row = s.closest('.drum-row');
                                            const lane = s.closest('.drum-lane');
                                            const rowIdx = lane ? parseInt(lane.dataset.row||'0',10):0;
                                            const volEl = row ? row.querySelector('.drum-volume') : null;
                                            const fxEl = row ? row.querySelector('.drum-fx input[type="checkbox"]') : null;
                                            const vol = volEl ? Math.max(0, Math.min(1, parseInt(volEl.value||'80',10)/100)) : 0.8;
                                            const sendToFX = fxEl ? !!fxEl.checked : false;
                                            this._triggerDrumSound(rowIdx|0, vol, sendToFX);
                                        }
                                    } catch(_){}
                                    // Autosave drum grid after toggle
                                    try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ }
                                });
                            }
                            lane.appendChild(s);
                        }
                        // Playhead element
                        const ph = document.createElement('div');
                        ph.className = 'drum-playhead';
                        ph.style.left = '0%';
                        lane.appendChild(ph);

                        // For bass lane, add an overlay layer for tie visuals
                        if (name === 'BASS') {
                            const layer = document.createElement('div');
                            layer.className = 'bass-tie-layer';
                            lane.insertBefore(layer, lane.firstChild);
                            try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                        }

                        row.appendChild(lane);

                        const vol = document.createElement('input');
                        vol.type = 'range';
                        vol.min = '0'; vol.max = '100'; vol.value = '80';
                        vol.className = 'drum-volume';
                        vol.title = `${name} Volume`;
                        vol.style.cssText = 'margin:0 8px; width:100px; vertical-align:middle;';
                        vol.addEventListener('input', ()=>{ try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ } try { if (window.omnichord && omnichord._arpTransport && omnichord._arpTransport.isRunning) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: true }); } } catch(_){ } });
                        row.appendChild(vol);

                        const fx = document.createElement('label');
                        fx.className = 'drum-fx';
                        fx.style.cssText = 'display:inline-flex;align-items:center;gap:4px;margin-right:8px;';
                        const fxChk = document.createElement('input');
                        fxChk.type = 'checkbox'; fxChk.checked = false; fxChk.title = `${name} → FX`;
                        fxChk.addEventListener('change', ()=>{ try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ } try { if (window.omnichord && omnichord._arpTransport && omnichord._arpTransport.isRunning) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: true }); } } catch(_){ } });
                        fx.appendChild(fxChk);
                        const fxSpan = document.createElement('span');
                        fxSpan.textContent = 'FX';
                        fx.appendChild(fxSpan);
                        row.appendChild(fx);

                        // MIDI out field per lane (skip on BASS which is melodic)
                        const midiWrap = document.createElement('div');
                        midiWrap.className = 'drum-midi';
                        midiWrap.style.cssText = 'display:inline-flex;align-items:center;gap:4px;margin:0 8px;';
                        const midiInput = document.createElement('input');
                        midiInput.type = 'text';
                        midiInput.placeholder = 'MIDI note';
                        midiInput.value = (name!=='BASS' ? (gmNotes[rowIdx]||'C2') : '');
                        midiInput.title = 'Send this GM note on Ch10 when step hits (e.g., C2, D#2)';
                        midiInput.addEventListener('change', ()=>{ try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ } try { if (window.omnichord && omnichord._arpTransport && omnichord._arpTransport.isRunning) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: true }); } } catch(_){ } });
                        midiWrap.appendChild(midiInput);
                        row.appendChild(midiWrap);

                        // Per-lane params: Pitch offset (semitones), Attack, Decay
                        const params = document.createElement('div');
                        params.className = 'drum-params';
                        params.style.cssText = 'display:inline-flex;align-items:center;gap:6px;margin-left:8px;';
                        const pPitch = document.createElement('input'); pPitch.type='range'; pPitch.min='-12'; pPitch.max='12'; pPitch.value='0'; pPitch.className='mini'; pPitch.title=`${name} Pitch`; params.appendChild(pPitch);
                        pPitch.addEventListener('input', ()=>{ try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ } try { if (window.omnichord && omnichord._arpTransport && omnichord._arpTransport.isRunning) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: true }); } } catch(_){ } });
                        const pAtk = document.createElement('input'); pAtk.type='range'; pAtk.min='0'; pAtk.max='100'; pAtk.value='2'; pAtk.className='mini'; pAtk.title=`${name} Attack`; params.appendChild(pAtk);
                        pAtk.addEventListener('input', ()=>{ try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ } try { if (window.omnichord && omnichord._arpTransport && omnichord._arpTransport.isRunning) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: true }); } } catch(_){ } });
                        const pDec = document.createElement('input'); pDec.type='range'; pDec.min='5'; pDec.max='1000'; pDec.value='180'; pDec.className='mini'; pDec.title=`${name} Decay`; params.appendChild(pDec);
                        pDec.addEventListener('input', ()=>{ try { if (typeof this._saveDrumPattern === 'function') this._saveDrumPattern(); } catch(_){ } try { if (window.omnichord && omnichord._arpTransport && omnichord._arpTransport.isRunning) { const scheduleDeferred = window.scheduleDeferred; if (scheduleDeferred) scheduleDeferred({ drums: true }); } } catch(_){ } });
                        row.appendChild(params);

                        // Store handles for playback
                        lane._controls = { vol, fxChk, midiInput, pPitch, pAtk, pDec, name };

                        grid.appendChild(row);

                        // Bass lane: click anywhere maps to nearest step prompt
                        if (name === 'BASS') {
                            lane.addEventListener('click', (e) => {
                                if (e.target && e.target.classList && e.target.classList.contains('drum-step')) return; // step handler already does prompt
                                const rect = lane.getBoundingClientRect();
                                const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
                                const idx = Math.max(0, Math.min(stepsPerBar-1, Math.floor((x / rect.width) * stepsPerBar)));
                                const targetStep = lane.querySelector(`.drum-step[data-step="${idx}"]`);
                                if (targetStep) targetStep.click();
                            });
                            // Bass label: run 16-step prompt sequence (default 1)
                            label.addEventListener('click', (e) => {
                                e.preventDefault();
                                const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                const clearTiesFrom = (fromIdx) => {
                                    for (let k = fromIdx + 1; k < steps.length; k++) { delete steps[k].dataset.tie; }
                                    delete steps[fromIdx].dataset.len;
                                };
                                for (let i = 0; i < steps.length; i++) {
                                    const s = steps[i];
                                    s.classList.add('selected');
                                    const prev = (s.dataset.npc||'').toLowerCase();
                                    const deflt = prev !== '' ? prev : '1';
                                    let val = window.prompt(`BASS NPC for step ${i+1} (1–9, x=rest)`, deflt);
                                    s.classList.remove('selected');
                                    if (val == null) break; // cancel ends the sequence
                                    val = String(val).trim();
                                    if (val === '') { s.dataset.npc=''; s.classList.remove('active'); clearTiesFrom(i); continue; }
                                    if (/^x$/i.test(val)) { s.dataset.npc='x'; s.classList.remove('active'); clearTiesFrom(i); continue; }
                                    if (/^[1-9]$/.test(val)) { s.dataset.npc=val; s.classList.add('active'); if (!s.dataset.len) s.dataset.len='1'; }
                                    try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                                }
                            });
                        }
                    });
                }
                // Build PATTERN grid (harmonic/arpeggio + bass) once
                (function(){
                    const patternGrid = document.getElementById('patternGrid');
                    if (!patternGrid || patternGrid.dataset.built) return;
                    patternGrid.dataset.built = '1';
                    // Pattern length independent from time signature; defaults to 16, user adjustable 1-64
                    let stepsPerBar = Math.max(1, Math.min(64, parseInt(patternGrid.dataset.length||'16',10) || 16));
                    const beatsPerBar = 4; // only used for visual beat dividers (every 4 steps baseline)
                    // Row labels: NPC1-9 then BASS (bottom)
                    // Display NOTE 9 (highest) at top descending to NOTE 1 then BASS
                    const rowLabels = ['NOTE 9','NOTE 8','NOTE 7','NOTE 6','NOTE 5','NOTE 4','NOTE 3','NOTE 2','NOTE 1'];
                    // Shadow state (persistent up to max 64) so shortening LEN hides, not destroys
                    const shadowState = { // rowIdx -> stepIdx -> data
                        // structure: { [row]: { [step]: { active:1, len, tie, npc } } }
                    };
                    // Shared handler attachment so rebuild can rewire events
                    const attachHandlers = () => {
                        const lanes = Array.from(patternGrid.querySelectorAll('.pattern-lane'));
                        lanes.forEach((lane, rIdx) => {
                            const isBass = (rIdx===9);
                            const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                            steps.forEach(st => {
                                if (st._wiredPattern) return; st._wiredPattern = true;
                                // Bass already had specialized logic at creation; skip here if bass
                                if (isBass) return;
                                // LEFT CLICK toggle/prepare drag length
                                st.addEventListener('mousedown', (e)=>{
                                    if (e.button!==0) return; e.preventDefault();
                                    const startIdx = parseInt(st.dataset.step||'0',10) || 0;
                                    const stepsLocal = Array.from(lane.querySelectorAll('.pattern-step'));
                                    // Activate if inactive
                                    if (!st.classList.contains('active')){ st.classList.add('active'); st.dataset.len='1'; }
                                    else { // prepare to resize existing length
                                        const existingLen = parseInt(st.dataset.len||'1',10)||1;
                                        for (let k=startIdx+1;k<=startIdx+existingLen-1;k++){ if (stepsLocal[k]) delete stepsLocal[k].dataset.tie; }
                                        st.dataset.len='1';
                                    }
                                    const applyLen = (toIdx) => {
                                        const len = Math.max(1, toIdx - startIdx + 1);
                                        st.dataset.len = String(len);
                                        for (let k=0;k<stepsLocal.length;k++){
                                            if (k>startIdx && k<=startIdx+len-1) stepsLocal[k].dataset.tie='1'; else if (k>startIdx) delete stepsLocal[k].dataset.tie;
                                        }
                                        // Update shadow state ties
                                        persistRow(rIdx);
                                    };
                                    const move = (ev)=>{
                                        const rect = lane.getBoundingClientRect();
                                        const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
                                        const idx = Math.max(0, Math.min(stepsLocal.length-1, Math.floor((x/rect.width)*stepsLocal.length)));
                                        applyLen(idx);
                                    };
                                    const up = ()=>{
                                        document.removeEventListener('mousemove', move);
                                        document.removeEventListener('mouseup', up);
                                        persistRow(rIdx);
                                        try { if (typeof window.omnichord?._saveDrumPattern==='function') window.omnichord._saveDrumPattern(); } catch(_){ }
                                    };
                                    document.addEventListener('mousemove', move);
                                    document.addEventListener('mouseup', up);
                                });
                                // RIGHT CLICK remove note and ties
                                st.addEventListener('contextmenu',(e)=>{
                                    e.preventDefault();
                                    const idx = parseInt(st.dataset.step||'0',10) || 0;
                                    const stepsLocal = Array.from(lane.querySelectorAll('.pattern-step'));
                                    if (st.dataset.tie==='1'){
                                        // Find head
                                        let headIdx=-1; for (let k=idx-1;k>=0;k--){ if (stepsLocal[k].dataset.len){ headIdx=k; break; } }
                                        if (headIdx>=0){ const newLen=Math.max(1, idx-headIdx); stepsLocal[headIdx].dataset.len=String(newLen); }
                                        for (let k=idx;k<stepsLocal.length;k++){ delete stepsLocal[k].dataset.tie; }
                                    } else {
                                        // Clear head and ties
                                        const len = parseInt(st.dataset.len||'1',10)||1;
                                        for (let k=idx+1;k<=idx+len-1;k++){ if (stepsLocal[k]) delete stepsLocal[k].dataset.tie; }
                                        delete st.dataset.len;
                                        st.classList.remove('active');
                                    }
                                    persistRow(rIdx);
                                    try { if (typeof window.omnichord?._saveDrumPattern==='function') window.omnichord._saveDrumPattern(); } catch(_){ }
                                });
                            });
                        });
                    };
                    function persistRow(rIdx){
                        const lane = patternGrid.querySelector(`.pattern-lane[data-row="${rIdx}"]`);
                        if (!lane) return;
                        const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                        shadowState[rIdx] = shadowState[rIdx] || {};
                        steps.forEach(st=>{
                            const si = parseInt(st.dataset.step||'0',10)||0;
                            if (st.classList.contains('active')){
                                const obj = { active:1 };
                                if (st.dataset.len) obj.len=st.dataset.len;
                                if (st.dataset.tie==='1') obj.tie=1;
                                if (rIdx===9 && st.dataset.npc) obj.npc=st.dataset.npc; // bass
                                shadowState[rIdx][si]=obj;
                            } else {
                                // Keep shadow data if beyond current visible length; remove if within and cleared
                                if (si < stepsPerBar && shadowState[rIdx][si]) delete shadowState[rIdx][si];
                            }
                        });
                    }
                    function restoreVisibleFromShadow(){
                        Array.from(patternGrid.querySelectorAll('.pattern-lane')).forEach(lane=>{
                            const rIdx = parseInt(lane.dataset.row||'0',10)||0;
                            const rowState = shadowState[rIdx]; if (!rowState) return;
                            Array.from(lane.querySelectorAll('.pattern-step')).forEach(st=>{
                                const si = parseInt(st.dataset.step||'0',10)||0;
                                const saved = rowState[si];
                                if (!saved) return;
                                st.classList.add('active');
                                if (saved.len) st.dataset.len=saved.len; else st.dataset.len='1';
                                if (saved.tie) st.dataset.tie='1'; else delete st.dataset.tie;
                                if (rIdx===9 && saved.npc){ st.dataset.npc=saved.npc; }
                            });
                        });
                    }
                    // Helper to create a row
                    rowLabels.forEach((labelName, rowIdx) => {
                        const row = document.createElement('div');
                        row.className = 'drum-row pattern-row' + (labelName==='BASS' ? ' bass-row' : '');
                        const label = document.createElement('div');
                        label.className = 'drum-label';
                        label.textContent = labelName;
                        row.appendChild(label);
                        const lane = document.createElement('div');
                        lane.className = 'drum-lane pattern-lane';
                        lane.dataset.row = String(rowIdx);
                        try { lane.style.setProperty('--steps-per-bar', String(stepsPerBar)); } catch(_){ }
                        // Beat dividers
                        const fullBeats = Math.max(0, Math.floor(stepsPerBar/4));
                        for (let b=1; b<fullBeats; b++) {
                            const div = document.createElement('div');
                            div.className = 'beat-divider';
                            div.style.left = `${(b/fullBeats)*100}%`;
                            lane.appendChild(div);
                        }
                        // Steps creation
                        for (let sIdx=0; sIdx<stepsPerBar; sIdx++) {
                            const st = document.createElement('div');
                            st.className = 'drum-step pattern-step' + ((sIdx%4===0)?' beat-accent':'');
                            st.dataset.step = String(sIdx);
                            st.title = `${labelName} • Step ${sIdx+1}`;
                            if (labelName === 'BASS') {
                                // Bass behaves similarly to removed drum bass lane (drag length + npc selection)
                                st.dataset.npc = '';
                                st.addEventListener('mousedown', (e) => {
                                    if (e.button !== 0) return; e.preventDefault();
                                    const startIdx = sIdx;
                                    const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                                    const applyLen = (toIdx) => {
                                        const len = Math.max(1, (toIdx|0) - startIdx + 1);
                                        st.dataset.len = String(len);
                                        for (let k=0;k<steps.length;k++) {
                                            if (k>startIdx && k<= startIdx+len-1) steps[k].dataset.tie='1'; else if (k>startIdx) delete steps[k].dataset.tie;
                                        }
                                    };
                                    const onMove = (ev) => {
                                        const rect = lane.getBoundingClientRect();
                                        const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
                                        const idx = Math.max(0, Math.min(stepsPerBar-1, Math.floor((x/rect.width)*stepsPerBar)));
                                        applyLen(idx);
                                        try { if (typeof window.omnichord?.rebuildBassTieOverlays === 'function') window.omnichord.rebuildBassTieOverlays(lane); } catch(_){ }
                                    };
                                    const onUp = () => { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); try { if (typeof window.omnichord?.rebuildBassTieOverlays === 'function') window.omnichord.rebuildBassTieOverlays(lane); } catch(_){ } try { if (typeof window.omnichord?._saveDrumPattern==='function') window.omnichord._saveDrumPattern(); } catch(_){ } };
                                    document.addEventListener('mousemove', onMove);
                                    document.addEventListener('mouseup', onUp);
                                });
                                st.addEventListener('click', (e) => {
                                    e.preventDefault();
                                    const prev = (st.dataset.npc||'');
                                    if (prev === '') { st.dataset.npc='1'; st.classList.add('active'); if (!st.dataset.len) st.dataset.len='1'; }
                                    else if (prev && prev.toLowerCase() !== 'x') {
                                        st.classList.add('selected');
                                        const valIn = window.prompt('Bass NPC (1–9) or x for rest', String(prev).toLowerCase());
                                        st.classList.remove('selected');
                                        if (valIn == null) return; const val = String(valIn).trim();
                                        if (val === '') { st.dataset.npc=''; st.classList.remove('active'); delete st.dataset.len; }
                                        else if (/^x$/i.test(val)) { st.dataset.npc='x'; st.classList.remove('active'); delete st.dataset.len; }
                                        else if (/^[1-9]$/.test(val)) { st.dataset.npc=val; st.classList.add('active'); if (!st.dataset.len) st.dataset.len='1'; }
                                    } else { st.dataset.npc='1'; st.classList.add('active'); if (!st.dataset.len) st.dataset.len='1'; }
                                    try { if (typeof window.omnichord?._saveDrumPattern==='function') window.omnichord._saveDrumPattern(); } catch(_){ }
                                });
                                st.addEventListener('contextmenu', (e) => {
                                    e.preventDefault();
                                    try {
                                        const steps = Array.from(lane.querySelectorAll('.pattern-step'));
                                        const idx = parseInt(st.dataset.step||'0',10) || 0;
                                        if (st.dataset.tie === '1') {
                                            let headIdx=-1; for (let k=idx-1;k>=0;k--){ if (steps[k].dataset.len){ headIdx=k; break; } }
                                            if (headIdx>=0){ const newLen=Math.max(1, idx-headIdx); steps[headIdx].dataset.len=String(newLen); }
                                            for (let k=idx;k<steps.length;k++){ delete steps[k].dataset.tie; }
                                            st.dataset.npc=''; st.classList.remove('active');
                                        } else {
                                            for (let k=idx+1;k<steps.length;k++){ delete steps[k].dataset.tie; }
                                            delete st.dataset.len; st.dataset.npc=''; st.classList.remove('active');
                                        }
                                    } catch(_){ }
                                    try { if (typeof window.omnichord?._saveDrumPattern==='function') window.omnichord._saveDrumPattern(); } catch(_){ }
                                });
                            } else {
                                st.addEventListener('click', (e) => { e.preventDefault(); /* drag handles main behavior */ });
                            }
                            lane.appendChild(st);
                        }
                        // Playhead visual
                        const ph = document.createElement('div'); ph.className='drum-playhead pattern-playhead'; ph.style.left='0%'; lane.appendChild(ph);
                        // Bass overlay layer
                        if (labelName==='BASS') {
                            const layer = document.createElement('div'); layer.className='bass-tie-layer'; lane.insertBefore(layer, lane.firstChild);
                        }
                        row.appendChild(lane);
                        patternGrid.appendChild(row);
                    });
                    // Expose update function (without new global section) to rebuild steps when length changes
                    patternGrid._rebuildLength = (newLen)=>{
                        newLen = Math.max(1, Math.min(64, newLen|0));
                        if (parseInt(patternGrid.dataset.length||'0',10) === newLen) return;
                        patternGrid.dataset.length = String(newLen);
                        // Capture existing active state per (row, step)
                        const state = {};
                        Array.from(patternGrid.querySelectorAll('.pattern-lane')).forEach((lane, rIdx)=>{
                            Array.from(lane.querySelectorAll('.pattern-step')).forEach(st=>{
                                const si = parseInt(st.dataset.step||'0',10);
                                if (!state[rIdx]) state[rIdx] = {};
                                if (st.classList.contains('active')) state[rIdx][si] = st.dataset.npc ? { npc: st.dataset.npc, len: st.dataset.len, tie: st.dataset.tie } : { active:1 };
                            });
                        });
                        // Clear rows (keep labels)
                        Array.from(patternGrid.querySelectorAll('.pattern-lane')).forEach(l=>{
                            // remove old steps & playhead & beat dividers but keep tie layer if bass
                            Array.from(l.querySelectorAll('.pattern-step,.beat-divider,.drum-playhead')).forEach(n=>n.remove());
                        });
                        // Rebuild with new length
                        stepsPerBar = newLen;
                        Array.from(patternGrid.querySelectorAll('.pattern-lane')).forEach((lane)=>{
                            const rowIdx = parseInt(lane.dataset.row||'0',10);
                            const isBass = rowIdx===9;
                            const fullBeats = Math.max(0, Math.floor(newLen/4));
                            for (let b=1; b<fullBeats; b++) {
                                const div = document.createElement('div');
                                div.className='beat-divider';
                                div.style.left = `${(b/fullBeats)*100}%`;
                                lane.appendChild(div);
                            }
                            for (let i=0;i<newLen;i++){
                                const st = document.createElement('div');
                                st.className='drum-step pattern-step'+((i%4===0)?' beat-accent':'');
                                st.dataset.step=String(i);
                                if (isBass){ st.dataset.npc=''; }
                                // Restore state
                                const saved = state[rowIdx] && state[rowIdx][i];
                                if (saved){
                                    st.classList.add('active');
                                    if (saved.npc){ st.dataset.npc=saved.npc; if (saved.len) st.dataset.len=saved.len; if (saved.tie) st.dataset.tie='1'; }
                                }
                                // Reattach event handlers (simplified: reuse click logic via delegation below)
                                lane.appendChild(st);
                            }
                            const ph=document.createElement('div'); ph.className='drum-playhead pattern-playhead'; ph.style.left='0%'; lane.appendChild(ph);
                        });
                        // Reattach handlers and restore any shadow state for visible region
                        try { attachHandlers(); } catch(_){ }
                        try { restoreVisibleFromShadow(); } catch(_){ }
                        try { if (patternGrid._recomputePatternText) patternGrid._recomputePatternText(); } catch(_){ }
                        try { const valSpan=document.getElementById('patternLenValue'); if (valSpan) valSpan.textContent=String(newLen); } catch(_){ }
                    };
                    // Initial handler attach
                    try { attachHandlers(); restoreVisibleFromShadow(); } catch(_){ }
                    // Wire length buttons
                    try {
                        const inc=document.getElementById('patternLenInc');
                        const dec=document.getElementById('patternLenDec');
                        const valSpan=document.getElementById('patternLenValue');
                        if (valSpan) valSpan.textContent=patternGrid.dataset.length||'16';
                        if (inc && !inc._wired){ inc._wired=true; inc.addEventListener('click',()=> patternGrid._rebuildLength(Math.min(64,(parseInt(patternGrid.dataset.length||'16',10)||16)+1))); }
                        if (dec && !dec._wired){ dec._wired=true; dec.addEventListener('click',()=> patternGrid._rebuildLength(Math.max(1,(parseInt(patternGrid.dataset.length||'16',10)||16)-1))); }
                        const handle=document.getElementById('patternResizeHandle');
                        if (handle && !handle._wired){
                            handle._wired=true;
                            handle.addEventListener('mousedown',(e)=>{
                                e.preventDefault();
                                const startX=e.clientX; const startLen=parseInt(patternGrid.dataset.length||'16',10)||16;
                                const move=(ev)=>{
                                    const dx=ev.clientX-startX; // ~8px per step heuristic
                                    const delta=Math.round(dx/8);
                                    const newLen=Math.min(64, Math.max(1, startLen+delta));
                                    patternGrid._rebuildLength(newLen);
                                };
                                const up=()=>{ document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); };
                                document.addEventListener('mousemove',move); document.addEventListener('mouseup',up);
                            });
                        }
                    } catch(_){ }
                })();
            }

            // Build or refresh bass tie overlay pills for a lane
            rebuildBassTieOverlays(lane){
                try {
                    if (!lane || !lane.closest('.bass-row')) return;
                    let layer = lane.querySelector('.bass-tie-layer');
                    if (!layer) {
                        layer = document.createElement('div');
                        layer.className = 'bass-tie-layer';
                        lane.insertBefore(layer, lane.firstChild);
                    }
                    while (layer.firstChild) layer.removeChild(layer.firstChild);
                    const steps = Array.from(lane.querySelectorAll('.drum-step'));
                    const total = steps.length;
                    const laneRect = lane.getBoundingClientRect();
                    const stepW = total > 0 ? (laneRect.width / total) : 0;
                    for (let i=0;i<total;i++){
                        const head = steps[i];
                        const npc = (head.dataset.npc||'').toLowerCase();
                        const len = parseInt(head.dataset.len||'1',10);
                        if (!npc || npc==='x') continue;
                        if (!Number.isFinite(len) || len<=1) continue;
                        const left = (i/total)*100;
                        const widthPct = (Math.min(total, i+len) - i) / total * 100;
                        const pill = document.createElement('div');
                        pill.className = 'bass-tie-pill';
                        pill.style.left = left + '%';
                        pill.style.width = widthPct + '%';
                        layer.appendChild(pill);
                    }
                } catch(_) { }
            }
            
            // ============= NEW CHORD CREATION SYSTEM =============
            
            enterChordCreationMode() {
                console.log('?? Entering chord creation mode');
                this.chordCreationMode = true;
                // When entering fresh creation mode (not from edit), clear edit flags
                if (!this.isEditingChord) {
                    this.editingOriginalIndex = null;
                }
                // Start blank: no notes pre-selected
                this.selectedIntervals = [];
                this.previewInterval = null;
                
                // Change UI to creation mode
                document.body.classList.add('chord-creation-mode');
                
                // Add a preview chord column immediately
                this.addPreviewChordColumn();
                
                // Update create button to save mode
                const createBtn = document.getElementById('createNewChordBtn');
                createBtn.textContent = 'Save Chord';
                createBtn.style.background = '#e74c3c';
                createBtn.style.borderColor = '#c0392b';
                
                // Update root button behavior for interval selection
                if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
                this.setupIntervalSelection();
            }

            // Parse MIDI note name like C2, D#2, Gb1 to MIDI number (12-TET only)
            _parseMidiNoteName(name){
                try {
                    if (!name) return null;
                    const m = String(name).trim().match(/^([A-Ga-g])([#b♯♭]?)(-?\d{1,2})$/);
                    if (!m) return null;
                    const letters = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };
                    let semi = letters[m[1].toUpperCase()];
                    const acc = m[2]||'';
                    if (acc === '#' || acc === '♯') semi += 1;
                    if (acc === 'b' || acc === '♭') semi -= 1;
                    const octave = parseInt(m[3],10);
                    const midi = (octave + 1) * 12 + ((semi % 12) + 12) % 12;
                    return Math.max(0, Math.min(127, midi));
                } catch(_) { return null; }
            }
            
            exitChordCreationMode() {
                console.log('?? Exiting chord creation mode');
                this.chordCreationMode = false;
                this.isEditingChord = false;
                this.editingOriginalIndex = null;
                // Return to blank state
                this.selectedIntervals = [];
                this.previewInterval = null;
                
                // Stop any preview audio
                this.stopPreviewAudio();
                
                // Remove preview column if it exists
                this.removePreviewChordColumn();
                
                // Restore UI
                document.body.classList.remove('chord-creation-mode');
                
                // Restore create button
                const createBtn = document.getElementById('createNewChordBtn');
                createBtn.textContent = '+';
                createBtn.style.background = '';
                createBtn.style.borderColor = '';
                
                // Restore normal root button behavior
                this.restoreNormalRootButtons();
            }
            
            setupIntervalSelection() {
                // Target all elements with data-step (keys + micro dots)
                const interactive = document.querySelectorAll('#rootGrid [data-step]');
                interactive.forEach(el => {
                    const step = parseInt(el.dataset.step,10);
                    // Replace node to remove previous listeners (root selection)
                    const clone = el.cloneNode(true);
                    el.parentNode.replaceChild(clone, el);
                    clone.classList.remove('preview');
                    // Maintain root highlight separately (active) but allow selection highlighting (selected)
                    // Consider selection across any octave layer: highlight base key if any selected iv maps to this step mod EDO
                    const edo = this.currentTuning || 12;
                    const isSelected = (this.selectedIntervals||[]).some(iv => ((iv % edo)+edo)%edo === step);
                    if (isSelected) clone.classList.add('selected'); else clone.classList.remove('selected');
                    clone.addEventListener('click', (e)=>{
                        e.stopPropagation();
                        // Clear any hover preview so the clicked element's state updates immediately
                        this.previewInterval = null;
                        try {
                            document.querySelectorAll('#rootGrid [data-step].preview').forEach(x=> x.classList.remove('preview'));
                        } catch {}
                        this.toggleInterval(step);
                    });
                    clone.addEventListener('mouseenter', ()=> this.previewInterval(step));
                    clone.addEventListener('mouseleave', ()=> this.clearPreview());
                });
            }
            
            toggleInterval(interval) {
                
                // dataset.step is already the absolute step; pan offset was applied during generation
                const absStep = interval;
                const index = this.selectedIntervals.indexOf(absStep);
                if (index > -1) {
                    // Remove interval
                    this.selectedIntervals.splice(index, 1);
                    const oi = this.selectedIntervalsOrder.indexOf(absStep);
                    if (oi > -1) this.selectedIntervalsOrder.splice(oi, 1);
                } else {
                    // Add interval
                    this.selectedIntervals.push(absStep);
                    this.selectedIntervals.sort((a, b) => a - b);
                    // Preserve entry order separately (no sorting)
                    if (!this.selectedIntervalsOrder.includes(absStep)) this.selectedIntervalsOrder.push(absStep);
                }
                
                // Update button states
                this.updateIntervalButtons();

                // Do not force any note if empty; allow blank state
                // Update the preview chord column immediately
                this.updatePreviewChordColumn();
                // Immediate name update (lowest note as root)
                try {
                    const header = document.querySelector('#previewChordColumn .chord-name');
                    if (header) {
                        if (this.selectedIntervals.length>1) {
                            const edo = this.currentTuning || 12;
                            const absSteps = this.selectedIntervals.map(iv => ((iv % edo) + edo) % edo);
                            const preferredBass = (this.selectedIntervalsOrder && this.selectedIntervalsOrder.length>0)
                                ? ((this.selectedIntervalsOrder[0] % edo)+edo)%edo : null;
                            header.textContent = this.computeFullChordNameFromAbsoluteSteps(absSteps, edo, preferredBass) || 'New Chord';
                        } else {
                            header.textContent = 'Select notes…';
                        }
                    }
                } catch {}
                
                console.log('🎵 Selected intervals (steps):', this.selectedIntervals);
                console.log('🎵 Button clicked (step -> abs):', interval, '->', absStep);
            }
            
            previewInterval(interval) {
                // In chord creation mode, intervals are direct microtonal steps
                if (this.selectedIntervals.includes(interval)) return;
                
                this.previewInterval = interval;
                this.updateIntervalButtons();
                
                // Play single note preview using microtonal interval
                this.playNotePreview(interval);
            }

            // Create a brand-new blank chord column (no carry-over), set it active, and arm editing
            createBlankChordColumn() {
                // Ensure chord extensions array exists
                if (!Array.isArray(this.chordExtensions)) this.chordExtensions = [];
                
                // Check if this is the first chord - if so, add loop brackets
                const isFirstChord = this.chordExtensions.length === 0;
                
                if (isFirstChord) {
                    // Add opening bracket with proper moveable attributes
                    const startBracket = {
                        name: '[', type: 'bracket', isRepeatMarker: true,
                        nestLevel: 1, id: 'bracket_start_L1_' + Date.now(), position: this.chordExtensions.length,
                        bracketType: 'open', moveable: true, isLoopMarker: true
                    };
                    this.chordExtensions.push(startBracket);
                }
                
                // Find the position to insert the new chord (before any closing brackets)
                let insertPosition = this.chordExtensions.length;
                if (!isFirstChord) {
                    // Look for the last closing bracket and insert before it
                    for (let i = this.chordExtensions.length - 1; i >= 0; i--) {
                        const ext = this.chordExtensions[i];
                        if (ext.isRepeatMarker && (ext.name === ']' || /^\]x\d+$/.test(ext.name))) {
                            insertPosition = i;
                        } else {
                            // Stop at the first non-closing bracket element from the right
                            break;
                        }
                    }
                }
                
                const id = `custom_${Date.now()}_${Math.floor(Math.random()*1e6)}`;
                const newChord = {
                    id,
                    name: 'New',
                    intervals: [], // start blank; user taps to add
                    isCustom: true,
                    quality: 'custom',
                    position: insertPosition
                };
                
                // Insert the chord at the calculated position
                this.chordExtensions.splice(insertPosition, 0, newChord);
                
                // Update positions for all elements after the insertion
                for (let i = insertPosition + 1; i < this.chordExtensions.length; i++) {
                    this.chordExtensions[i].position = i;
                }
                
                if (isFirstChord) {
                    // Add closing bracket with proper moveable attributes
                    const endBracket = {
                        name: ']', type: 'bracket', isRepeatMarker: true,
                        nestLevel: 1, id: 'bracket_end_L1_' + Date.now(), position: this.chordExtensions.length,
                        bracketType: 'close', moveable: true, isLoopMarker: true
                    };
                    this.chordExtensions.push(endBracket);
                }
                // Track this as a pending blank chord eligible for inheritance on next external strum
                this.pendingBlankChordId = id;
                if (typeof this.saveChordConfiguration === 'function') {
                    try { this.saveChordConfiguration(); } catch (_) {}
                }
                // Regenerate grid and focus the new column
                this.generateExtensionColumns();
                
                // Check for modal collisions and auto-close if they overlap the new chord area
                this.closeModalsOverlappingChordArea();
                
                // Find the column by data-chord-id
                const column = document.querySelector(`.extension-column[data-chord-id='${id}']`);
                if (column) {
                    // Initialize per-column state
                    column.dataset.localTranspose = '0';
                    // Replace strings with a blank prompt area
                    try { this.generateStringsForColumn(column, [], true); } catch (_) {}
                    // Make it the active column and clear keyboard highlights
                    this.currentActiveColumnEl = column;
                    this.editArmed = true; // ready to capture key taps
                    try { this.highlightKeyboardForColumn(column); } catch(_) {}
                    // Scroll into view slightly
                    try { column.scrollIntoView({behavior:'smooth', block:'nearest', inline:'center'}); } catch(_){ }
                    // Immediately focus the chord name for typing a symbol (e.g., Dm, Em7)
                    try {
                        const nameEl = column.querySelector('.extension-header .chord-name');
                        if (nameEl) {
                            nameEl.setAttribute('contenteditable', 'true');
                            nameEl.setAttribute('spellcheck', 'false');
                            nameEl.focus();
                            // Select all text for quick overwrite
                            const sel = window.getSelection && window.getSelection();
                            if (sel && document.createRange) {
                                const range = document.createRange();
                                range.selectNodeContents(nameEl);
                                sel.removeAllRanges();
                                sel.addRange(range);
                            }
                        }
                    } catch (_) {}
                }
            }
            
            // Auto-close modals that overlap the chord area when creating new chords
            closeModalsOverlappingChordArea() {
                try {
                    const chordArea = document.getElementById('extensionColumns');
                    if (!chordArea) return;
                    
                    const chordRect = chordArea.getBoundingClientRect();
                    const modalIds = ['fxModal', 'oscModal', 'tuningModal', 'keyboardModal', 'textChordModal'];
                    
                    modalIds.forEach(modalId => {
                        const modal = document.getElementById(modalId);
                        if (modal && modal.style.display !== 'none') {
                            const modalRect = modal.getBoundingClientRect();
                            
                            // Check if modal overlaps with chord area
                            const overlaps = !(
                                modalRect.right < chordRect.left || 
                                modalRect.left > chordRect.right || 
                                modalRect.bottom < chordRect.top || 
                                modalRect.top > chordRect.bottom
                            );
                            
                            if (overlaps) {
                                modal.style.display = 'none';
                                console.log('🎵 Auto-closed modal', modalId, 'to avoid overlapping new chord');
                            }
                        }
                    });
                } catch (e) {
                    console.warn('Modal collision detection failed:', e);
                }
            }
            
            clearPreview() {
                this.previewInterval = null;
                this.updateIntervalButtons();
                this.stopPreviewAudio();
            }
            
        updateIntervalButtons() {
                const all = document.querySelectorAll('#rootGrid [data-step]');
                all.forEach(el=>{
                    const step = parseInt(el.dataset.step,10);
                    el.classList.remove('selected','preview');
            const edo = this.currentTuning || 12;
            const isSelected = (this.selectedIntervals||[]).some(iv => ((iv % edo)+edo)%edo === step);
            if (isSelected) {
                        el.classList.add('selected');
                    } else if (this.previewInterval === step) {
                        el.classList.add('preview');
                    }
                });
            }
            
            async playNotePreview(interval) {
                this.stopPreviewAudio();
                
                const audioReady = await this.ensureAudioContext();
                if (!audioReady) return;
                
                // Use current tuning and audition around middle octave for audibility
                // In chord-creation mode, the interval is already an absolute EDO step.
                // Otherwise, treat it as relative to the current root.
                const edo = this.currentTuning || 12;
                const absStep = this.chordCreationMode
                    ? ((interval % edo) + edo) % edo
                    : (((this.currentRoot || 0) + (interval % edo)) % edo + edo) % edo;
                const frequency = this.getFrequency(absStep, 4, this.currentTuning);
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.05);
                
                oscillator.connect(gainNode);
                // Route through master chain (global wet/dry + reverb)
                gainNode.connect(this.gainNode);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.3);
                
                this.tempChordAudio.set('preview', { oscillator, gainNode });
            }
            
            async playChordPreview() {
                this.stopPreviewAudio();
                
                const audioReady = await this.ensureAudioContext();
                if (!audioReady || this.selectedIntervals.length === 0) return;
                
                // Play all selected intervals as a chord
                this.selectedIntervals.forEach((interval, index) => {
                    const edo = this.currentTuning || 12;
                    const absStep = this.chordCreationMode
                        ? ((interval % edo) + edo) % edo
                        : (((this.currentRoot || 0) + (interval % edo)) % edo + edo) % edo;
                    const frequency = this.getFrequency(absStep, 4, this.currentTuning);
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.05, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 1.0);
                    
                    oscillator.connect(gainNode);
                    // Route through master chain (global wet/dry + reverb)
                    gainNode.connect(this.gainNode);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 1.0);
                    
                    this.tempChordAudio.set(`chord-${index}`, { oscillator, gainNode });
                });
            }
            
            stopPreviewAudio() {
                this.tempChordAudio.forEach(({ oscillator, gainNode }) => {
                    try {
                        gainNode.gain.setValueAtTime(gainNode.gain.value, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.05);
                        oscillator.stop(this.audioContext.currentTime + 0.05);
                    } catch(e) { /* ignore stop errors */ }
                });
                this.tempChordAudio.clear();
            }
            
            saveNewChordAutomatic() {
                if (this.selectedIntervals.length < 2) {
                    alert('Please select at least 2 intervals (including root)');
                    return;
                }
                
                // Always compute name with the lowest note as root
                this.finalizePreviewChord(null);
                
                console.log(`?? Auto-saved new chord from lowest note root`, this.selectedIntervals);
                
                // Exit creation mode
                this.exitChordCreationMode();
            }
            
            saveNewChord() {
                let chordName = document.getElementById('chordNameInput').value.trim();
                
                if (!chordName) {
                    // Fall back to computed root+quality from preview
                    if (this.selectedIntervals.length >= 2) {
                        this.finalizePreviewChord(null);
                        this.exitChordCreationMode();
                        return;
                    } else {
                        alert('Please select at least 2 intervals (including root)');
                        return;
                    }
                }
                
                if (this.selectedIntervals.length < 2) {
                    alert('Please select at least 2 intervals (including root)');
                    return;
                }
                // Prefer the provided name but we still re-root by lowest tone when saving
                this.finalizePreviewChord(chordName);
                console.log(`?? Saved new chord with provided name (re-rooted by lowest tone): ${chordName}`, this.selectedIntervals);
                
                // Exit creation mode
                this.exitChordCreationMode();
            }
            
            addPreviewChordColumn() {
                // Create a temporary preview chord column at the end
                const extensionColumns = document.getElementById('extensionColumns');
                if (!extensionColumns) return;
                
                const previewColumn = document.createElement('div');
                previewColumn.className = 'extension-column preview-chord-column';
                previewColumn.id = 'previewChordColumn';
                previewColumn.style.border = '3px dashed #2E8B57';
                previewColumn.style.background = 'rgba(46, 139, 87, 0.1)';
                
                // Add header
                const header = document.createElement('div');
                header.className = 'extension-header';
                header.style.background = 'rgba(46, 139, 87, 0.8)';
                header.innerHTML = '<span class="chord-name">New Chord</span>';
                previewColumn.appendChild(header);
                
                // Add strings container
                const stringsContainer = document.createElement('div');
                stringsContainer.className = 'strings-column';
                stringsContainer.id = 'previewStringsContainer';
                previewColumn.appendChild(stringsContainer);
                
                // Add note labels
                const noteLabels = document.createElement('div');
                noteLabels.className = 'note-labels';
                noteLabels.id = 'previewNoteLabels';
                previewColumn.appendChild(noteLabels);
                
                extensionColumns.appendChild(previewColumn);
                
                // Add touch gesture support for strumming the preview chord
                this.addTouchGestureToElement(previewColumn, 'chord');
                this.addClickGestureToElement(previewColumn, 'chord');
                
                // Initial update with root note
                this.updatePreviewChordColumn();
            }
            
            updatePreviewChordColumn() {
                const stringsContainer = document.getElementById('previewStringsContainer');
                const noteLabels = document.getElementById('previewNoteLabels');
                const header = document.querySelector('#previewChordColumn .chord-name');
                
                if (!stringsContainer || !noteLabels || !header) return;
                
                // Clear existing strings
                stringsContainer.innerHTML = '';
                
                // Name from lowest absolute steps for consistency with main columns.
                // Prefer the first-selected tone as the bass to avoid accidental C injection.
                if (this.selectedIntervals && this.selectedIntervals.length > 1) {
                    const edo = this.currentTuning || 12;
                    const absSteps = this.selectedIntervals.map(iv => ((iv % edo) + edo) % edo);
                    const preferredBass = (this.selectedIntervalsOrder && this.selectedIntervalsOrder.length>0)
                        ? ((this.selectedIntervalsOrder[0] % edo) + edo) % edo
                        : null;
                    const label = this.computeFullChordNameFromAbsoluteSteps(absSteps, edo, preferredBass);
                    header.textContent = label || 'New Chord';
                } else {
                    header.textContent = 'Select notes…';
                }
                
                // Use the same string generation as the main fretboard
                this.generateStringsForPreviewColumn(stringsContainer, this.selectedIntervals);
                
                // Update note labels
                const noteNames = this.selectedIntervals.map(interval => {
                    const edo = this.currentTuning || 12;
                    const absStep = ((interval % edo) + edo) % edo;
                    return this.getMicrotonalNoteName(absStep);
                });
                noteLabels.textContent = noteNames.join(' ');
            }
            
            generateStringsForPreviewColumn(container, intervals) {
                // Clear any existing content
                container.innerHTML = '';
                const tuningSize = this.currentTuning || this.getTuningStepsPerOctave();
                // Nothing to show until we have at least 2 tones (root + one)
                const nonRoot = (intervals||[]).filter(iv => iv !== 0);
                if (!intervals || intervals.length < 2 || nonRoot.length === 0) {
                    return;
                }
                
                // Use the EXACT same system as generateStringsForColumn 
                const noteNames = this.getNoteNames();
                // Optionally duplicate selected intervals up one octave for quick two-octave entries
                let ivs = [...intervals];
                
                // Generate string frequencies for full C1-C8 octave range (8 full octaves)
                const stringFreqs = [];
                for (let octave = 1; octave <= 8; octave++) {
                    ivs.forEach(interval => {
                        // In creation preview, intervals are absolute EDO steps
                        const step = ((interval % tuningSize) + tuningSize) % tuningSize;
                        const freq = this.getFrequency(step, octave, this.currentTuning);
                        stringFreqs.push({ freq, step, octave, interval });
                    });
                }
                
                // Sort for preview based on Play Mode: low-high => low at top; else high at top
                try {
                    const __pm = (this.playMode || 'high-low');
                    const __desc = (__pm === 'low-high') ? false : true;
                    stringFreqs.sort((a,b)=> __desc ? (b.freq - a.freq) : (a.freq - b.freq));
                } catch(_) {
                    // Fallback to a stable order if playMode is not available
                    // Avoid recursion: fall back directly to immediate chord play
                    try { this.playChordChordsMode(columnElement, clientY); } catch(_){ }
                }
                
                // Calculate string sizing to MATCH main column behavior (fill height uniformly)
                const previewColumn = document.getElementById('previewChordColumn');
                const availableHeight = (previewColumn ? previewColumn.offsetHeight : 500);
                const headerHeight = 40;
                const stringsHeight = availableHeight - headerHeight - 2; // minimal padding
                const numStrings = stringFreqs.length || 1;
                const stringHeight = Math.max(1, Math.floor(stringsHeight / numStrings) - 0.5);
                const stringMargin = 0.2; // minimal margin for tight packing
                
                // Style the container exactly like main columns
                container.style.cssText = `
                    flex: 1;
                    overflow: hidden;
                    padding: 1px;
                    height: calc(100% - ${headerHeight}px);
                    display: flex;
                    flex-direction: column;
                    justify-content: space-evenly;
                `;
                // Subtle root tint for preview using detected root from selected intervals
                try {
                    const edo = this.currentTuning || 12;
                    const t = (this.transposeDelta || 0) % edo;
                    const steps = (intervals||[]).map(s => (((s + t) % edo) + edo) % edo).sort((a,b)=> this.stepToSemitone(a, edo)-this.stepToSemitone(b, edo));
                    const bass = steps[0];
                    const semi = this.stepToSemitone(bass, edo);
                    const accent = this.getChromaticColorForSemitone(semi) || '#000000';
                    const tint = (hex => {
                        const m = /^#?([0-9a-f]{6})$/i.exec(hex || '');
                        if (!m) return 'rgba(0,0,0,0)';
                        const n = parseInt(m[1], 16);
                        let r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                        r = Math.max(6, Math.floor(r * 0.08));
                        g = Math.max(6, Math.floor(g * 0.08));
                        b = Math.max(6, Math.floor(b * 0.08));
                        return `linear-gradient(to bottom, rgba(${r},${g},${b},0.12), rgba(${r},${g},${b},0.08))`;
                    })(accent);
                    container.style.setProperty('--root-tint-gradient', tint);
                } catch (_) {}
                
                stringFreqs.forEach((stringData, stringIndex) => {
                    const stringEl = document.createElement('div');
                    stringEl.className = 'string';
                    stringEl.dataset.index = stringIndex;
                    stringEl.dataset.column = 'preview';
                    stringEl.dataset.frequency = stringData.freq;
                    stringEl.dataset.noteIndex = stringData.step;
                    stringEl.dataset.octave = String(stringData.octave);
                    // Highlight mid octaves (3–4)
                    try {
                        const oct = parseInt(stringEl.dataset.octave, 10);
                        if (oct === 3 || oct === 4) stringEl.classList.add('mid-octave');
                    } catch(_) {}

                    // Universal pitch color and glow
                        const uni = this.getUniversalPitchColorForStep(stringData.step, tuningSize);
                        const baseColor = uni.color;
                    const glowColor = (baseColor && baseColor.toLowerCase() === '#000000') ? '#555555' : baseColor;
                    stringEl.dataset.glowColor = glowColor;

                    // Visible core
                    const core = document.createElement('div');
                    core.className = 'string-core';
                    core.style.background = baseColor;
                    core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;

                    // Tooltip
                    stringEl.title = `${noteNames[stringData.step] || `Note ${stringData.step}`} - Oct${stringData.octave} - ${stringData.freq.toFixed(1)}Hz`;

                    // Hover effects
                    stringEl.addEventListener('mouseenter', () => {
                        core.style.transform = 'scaleY(1.25)';
                        core.style.boxShadow = `0 0 6px ${glowColor}, 0 0 14px ${glowColor}CC, 0 0 28px ${glowColor}88`;
                    });
                    stringEl.addEventListener('mouseleave', () => {
                        core.style.transform = 'scaleY(1)';
                        core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;
                    });

                    // Click handlers
                    stringEl.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        this.playPreviewString(stringEl, stringData.freq, stringData.interval);
                    });
                    stringEl.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.playPreviewString(stringEl, stringData.freq, stringData.interval);
                    });

                    // Attach core and row
                    stringEl.appendChild(core);
                    container.appendChild(stringEl);

                    // Precompute vibration period and store on core
                    const period = this.computeVibrationPeriod(stringData.freq, stringData.step);
                    core.style.setProperty('--vib-period', period + 'ms');
                });
                // Ensure all generated octave strings fit within visible area (rescale heights if needed)
                this.ensureStringsFullyVisible(container);
            }
            
            playPreviewString(stringElement, frequency, interval) {
                // Neon active feedback using per-string glow color
                const glow = stringElement.dataset.glowColor || this.getUniversalPitchColorForStep(parseInt(stringElement.dataset.noteIndex||'0',10), this.currentTuning||12).color || '#FFFFFF';
                const core = stringElement.querySelector('.string-core');
                if (core) {
                    core.style.transform = 'scaleY(1.3)';
                    core.style.boxShadow = `0 0 6px ${glow}, 0 0 16px ${glow}B3, 0 0 24px ${glow}80`;
                    core.style.filter = 'brightness(1.15)';
                    // Start vibration briefly for preview
                    const period = this.computeVibrationPeriod(frequency, parseInt(stringElement.dataset.noteIndex||'0',10));
                    core.style.setProperty('--vib-period', period + 'ms');
                    core.classList.add('vibrating');
                    setTimeout(()=> core.classList.remove('vibrating'), 220);
                }

                // Play the note using the same system as main strings
                this.playStringNote(frequency, interval);

                // Reset visual state after a delay
                setTimeout(() => {
                    if (core) {
                        core.style.transform = 'scaleY(1)';
                        core.style.boxShadow = `0 0 4px ${glow}, 0 0 10px ${glow}AA, 0 0 18px ${glow}66`;
                        core.style.filter = 'brightness(1)';
                    }
                }, 200);
            }
            
            async playStringNote(frequency, interval) {
                const ready = await this.ensureAudioContext();
                if (!ready) return;
                
                // Use the current oscillator and envelope settings
                let source;
                const gainNode = this.audioContext.createGain();
                
                // Apply current oscillator settings
                const t = this.oscillators.osc1.type;
                if (t === 'noise') {
                    // Brown noise preview with a peaking EQ centered at the played frequency
                    const noise = this.createNoiseSource();
                    const peak = this.audioContext.createBiquadFilter();
                    peak.type = 'peaking';
                    peak.frequency.setValueAtTime(Math.max(10, Math.min(this.audioContext.sampleRate/2, frequency)), this.audioContext.currentTime);
                    // Map Shape Width (0..1) to Q (0.5..60) exponentially for musical feel
                    {
                        const sw = Math.max(0, Math.min(1, this.oscillators.osc1.shapeWidth ?? 0.5));
                        const minQ = 0.5, maxQ = 60;
                        const q = minQ * Math.pow(maxQ / minQ, sw);
                        peak.Q.setValueAtTime(q, this.audioContext.currentTime);
                    }
                    // Level controls resonance gain: 0..+48 dB; 0 dB yields plain brown noise
                    const lvlNorm = Math.max(0, Math.min(1, (this.oscillators.osc1.level || 0) / 0.125));
                    peak.gain.setValueAtTime(lvlNorm * 48, this.audioContext.currentTime);
                    noise.connect(peak);
                    source = peak;
                    // Start/stop the buffer source based on envelope timing
                    // We'll capture the underlying buffer source to stop later
                    source.__noiseSource = noise;
                } else {
                    source = this.audioContext.createOscillator();
                    if (['sine','sawtooth','square','pulse','fullrect','halfrect','parabolic','stair'].includes(t)) {
                        source.setPeriodicWave(this.getCustomPeriodicWave(t, this.oscillators.osc1.pulseWidth, this.oscillators.osc1.shapeWidth));
                    } else { source.type = t; }
                    source.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                }
                
                // Apply current ADSR envelope
                const now = this.audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                // Let master gainNode handle global volume; keep per-note envelope in a musical range
                gainNode.gain.linearRampToValueAtTime(1.0, now + this.envelope.attack);
                gainNode.gain.exponentialRampToValueAtTime(Math.max(0, Math.min(1, this.envelope.sustain)), now + this.envelope.attack + this.envelope.decay);
                // Release to zero after decay completes
                gainNode.gain.linearRampToValueAtTime(0, now + this.envelope.attack + this.envelope.decay + this.envelope.release);
                
                // Connect through reverb if enabled
                source.connect(gainNode);
                // Always route into master gainNode so global wet/dry split handles reverb
                gainNode.connect(this.gainNode);
                
                // Start/stop respecting noise vs oscillator
                if (t === 'noise' && source.__noiseSource) {
                    try { source.__noiseSource.start(); } catch(_) {}
                    try { source.__noiseSource.stop(now + this.envelope.attack + this.envelope.decay + this.envelope.release); } catch(_) {}
                } else {
                    source.start();
                    source.stop(now + this.envelope.attack + this.envelope.decay + this.envelope.release);
                }
                
                // Store for cleanup
                this.tempChordAudio.set(`preview-${Date.now()}`, { oscillator: source, gainNode });
            }
            
            removePreviewChordColumn() {
                const previewColumn = document.getElementById('previewChordColumn');
                if (previewColumn) {
                    previewColumn.remove();
                }
            }
            
            finalizePreviewChord(chordName) {
                // Remove the preview column
                this.removePreviewChordColumn();
                
                // Compute lowest interval as chord root anchor and normalize intervals
                const edo = this.currentTuning || 12;
                const ivs = [...this.selectedIntervals];
                // Do not save truly blank or single-note chords
                const nonRootCount = ivs.filter(v=> v !== 0).length;
                if (!ivs.length || nonRootCount === 0) {
                    console.warn('Skipping save: blank chord has no tones beyond root.');
                    return;
                }
                const minIv = Math.min(...ivs);
                const normalized = ivs.map(iv => ((iv - minIv) % edo + edo) % edo).sort((a,b)=>{
                    const sa = this.stepToSemitone(a, edo); const sb = this.stepToSemitone(b, edo); return sa - sb;
                });
                // Compute absolute step for the chord root from lowest note (rootless)
                const baseRootAbs = ((minIv % edo) + edo) % edo;
                // Build a musically sensible label (root + quality + optional slash-bass)
                const absForLabel = ivs.map(iv => ((iv % edo) + edo) % edo);
                // Prefer the first-selected tone as preferred bass to preserve user intent (e.g., EGB → Em)
                const preferredBassFinalize = (this.selectedIntervalsOrder && this.selectedIntervalsOrder.length>0)
                    ? ((this.selectedIntervalsOrder[0] % edo) + edo) % edo
                    : null;
                const computedLabel = this.computeFullChordNameFromAbsoluteSteps(absForLabel, edo, preferredBassFinalize);
                // If user typed a name, keep it; otherwise use computedLabel
                let finalName = (chordName && chordName.trim()) ? chordName.trim() : (computedLabel || 'New Chord');
                
                // Decide target position
                const replacing = !!this.isEditingChord && typeof this.editingOriginalIndex === 'number' && this.editingOriginalIndex >= 0;
                const position = replacing ? this.editingOriginalIndex : this.chordExtensions.length;

                // Decide a persistent header accent color for this chord (per-chord color)
                // Use the current root neon color as the chord's header accent, with a safe fallback
                let headerAccentColor = '#14b8a6';
                try {
                    const c = this.getIntervalColor(0)?.color;
                    headerAccentColor = (!c || c.toLowerCase() === '#000000') ? '#333333' : c;
                } catch {}
                
                // Preserve existing chord metadata if editing in place
                let preserved = {};
                if (replacing && this.chordExtensions[position]) {
                    const oldChord = this.chordExtensions[position];
                    preserved = {
                        id: oldChord.id,
                        createdAt: oldChord.createdAt,
                        headerColor: oldChord.headerColor,
                        originalTuning: oldChord.originalTuning,
                        originalGamelanMode: oldChord.originalGamelanMode,
                        lastTuning: oldChord.lastTuning,
                        originalIntervals: oldChord.originalIntervals
                    };
                }

                // Create new chord extension with exact intervals and position tracking
                const newChord = {
                    name: finalName,
                    extensions: [],
                    intervals: normalized,
                    isCustom: true,
                    id: preserved.id || ('custom_' + Date.now()),
                    createdAt: preserved.createdAt || Date.now(),
                    position: position, // Track exact position in array
                    // Keep the original root for reference but don't auto-lock
                    originalRoot: this.currentRoot,
                    // Track tuning metadata to support future remaps between EDOs
                    originalTuning: preserved.originalTuning || this.currentTuning,
                    originalGamelanMode: preserved.originalGamelanMode ?? this.gamelanMode,
                    lastTuning: this.currentTuning,
                    // Persist a header color so saved chords can keep distinct colors
                    headerColor: preserved.headerColor || headerAccentColor,
                    // Per-chord fixed root lock (abs step in its tuning)
                    fixedRootStepAbs: baseRootAbs,
                    fixedRootTuning: edo,
                    // Capture the original intervals at creation/edit baseline for future EDO remaps
                    originalIntervals: preserved.originalIntervals || normalized.slice()
                };
                
                console.log('🔧 finalizePreviewChord - saving chord:', {
                    name: chordName,
                    intervals: [...this.selectedIntervals],
                    isCustom: true,
                    currentTuning: this.currentTuning,
                    selectedIntervals: this.selectedIntervals
                });
                
                // Add to chord extensions: replace original index when editing, else append
                if (replacing) {
                    // Replace in place to preserve column position and identity
                    this.chordExtensions.splice(position, 1, newChord);
                } else {
                    this.chordExtensions.push(newChord);
                }

                // Normalize positions to keep exact ordering stable
                this.normalizeChordPositions();
                
                // Save and regenerate without creating variants
                this.saveChordConfiguration();
                this.regenerateColumnsWithoutVariants();
                
                // Clear selection and exit chord creation mode
                this.selectedIntervals = [];
                this.isChordCreationMode = false;
                this.isEditingChord = false;
                this.editingOriginalIndex = null;
                // Clear pending flag since notes were saved
                this.pendingBlankChordId = null;
                
                // Restore normal root button functionality
                this.restoreNormalRootButtons();
                
                console.log(`? Created chord: ${finalName} at position ${position} with intervals:`, normalized);
            }

            // Keep chord.position fields in sync with array order
            normalizeChordPositions() {
                if (!Array.isArray(this.chordExtensions)) return;
                for (let i = 0; i < this.chordExtensions.length; i++) {
                    const c = this.chordExtensions[i];
                    if (c && c.position !== i) c.position = i;
                }
            }
            
            regenerateColumnsWithoutVariants() {
                // Regenerate only the exact chords without creating maj/min/neu variants
                this.generateExactChordColumns();
                this.updateChordDisplay();
            }
            
            generateExactChordColumns() {
                console.log('Generating exact chord columns (no variants)');
                const container = document.getElementById('extensionColumns');
                
                // Clear container completely to remove any leftover columns
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.gap = '0px';
                container.style.width = '100%';
                container.style.height = '100%';
                // Reset to one row by default; we may split into two rows below
                container.style.flexDirection = 'row';
                
                // Initialize hiddenColumns if not exists
                if (!this.hiddenColumns) {
                    this.hiddenColumns = [];
                }
                
                // Sort chordExtensions by position to maintain exact order
                const sortedExtensions = [...this.chordExtensions].sort((a, b) => {
                    const posA = a.position !== undefined ? a.position : this.chordExtensions.indexOf(a);
                    const posB = b.position !== undefined ? b.position : this.chordExtensions.indexOf(b);
                    return posA - posB;
                });
                
                // Map chord extensions to per-instance identifiers for hiding
                const chordIds = sortedExtensions.map((chord, index) => {
                    return (chord.id || (chord.name + '_' + index)).toLowerCase().replace(/\s+/g, '_');
                });
                
                // Filter visible chord extensions (maintain original order)
                const visibleExtensions = sortedExtensions.filter((chordExt, index) => {
                    const chordId = chordIds[index];
                    const isVisible = !this.hiddenColumns.includes(chordId);
                    return isVisible;
                });
                
                console.log('Creating exact chord columns:', visibleExtensions.length);
                
                // Layout: if >16, split into 2 rows. We'll create a wrapper for rows and append columns to row containers.
                const useTwoRows = visibleExtensions.length > 16;
                let rowTop, rowBottom;
                if (useTwoRows) {
                    container.style.flexDirection = 'column';
                    rowTop = document.createElement('div');
                    rowBottom = document.createElement('div');
                    // Use flex growth instead of fixed 50% height, and allow shrinking (minHeight:0) to avoid clipping
                    Object.assign(rowTop.style, { display:'flex', gap:'0px', width:'100%', flex:'1 1 0', minHeight:'0' });
                    Object.assign(rowBottom.style, { display:'flex', gap:'0px', width:'100%', flex:'1 1 0', minHeight:'0' });
                    container.appendChild(rowTop);
                    container.appendChild(rowBottom);
                }

                // Auto-insert an outer loop bracket at the very start and end of the grid
                const appendRepeatMarker = (target, name, opts={}) => {
                    const repeatCol = document.createElement('div');
                    repeatCol.className = 'repeat-marker-column';
                    repeatCol.style.width = '50px';
                    repeatCol.style.minWidth = '50px';
                    repeatCol.style.maxWidth = '50px';
                    repeatCol.style.height = '100%';
                    repeatCol.style.flex = '0 0 50px';
                    // Apply themed styling (GREEN = outer loop)
                    const theme = opts.colorTheme || { bg: 'linear-gradient(135deg, rgba(46,204,113,0.22) 0%, rgba(39,174,96,0.28) 100%)', border: 'rgba(46,204,113,0.7)', color: '#2ecc71' };
                    repeatCol.style.background = theme.bg;
                    repeatCol.style.border = `2px solid ${theme.border}`;
                    repeatCol.style.color = theme.color;
                    repeatCol.style.borderRadius = '8px';
                    repeatCol.style.display = 'flex';
                    repeatCol.style.alignItems = 'center';
                    repeatCol.style.justifyContent = 'center';
                    repeatCol.style.fontSize = '16px';
                    repeatCol.style.fontWeight = 'bold';
                    repeatCol.style.textShadow = '0 1px 2px rgba(0,0,0,0.3)';
                    repeatCol.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
                    repeatCol.style.cursor = 'default';
                    repeatCol.textContent = name; // "[", "]" or "]xN"
                    repeatCol.title = `Repeat marker: ${name} (Level 0) - auto outer loop`;
                    repeatCol.dataset.isRepeatMarker = 'true';
                    repeatCol.dataset.nestLevel = '0';
                    if (opts.autoOuter) repeatCol.dataset.autoOuter = 'true';
                    if (typeof opts.repeatCount === 'number') repeatCol.dataset.repeatCount = String(opts.repeatCount);
                    // End marker count editing (0 = infinite)
                    repeatCol.addEventListener('click', () => {
                        const txt = repeatCol.textContent.trim();
                        const isEnd = (txt === ']' || /^\]x\d+$/.test(txt));
                        if (!isEnd) return;
                        const cur = parseInt(repeatCol.dataset.repeatCount||'0',10);
                        const val = prompt('Repeat count (0 = infinite):', isNaN(cur)? '0' : String(cur));
                        if (val == null) return;
                        let n = Math.max(0, parseInt(val,10)||0);
                        if (n > 64) n = 64;
                        repeatCol.dataset.repeatCount = String(n);
                        repeatCol.textContent = (n === 0 ? ']' : `]x${n}`);
                    });
                    // Make bracket markers draggable for section rearrangement
                    if (typeof window.makeBracketDraggable === 'function') {
                        window.makeBracketDraggable(repeatCol);
                    }
                    target.appendChild(repeatCol);
                    return repeatCol;
                };

                // Detect explicit outer brackets coming from SEQ (level 0 at extremes)
                const firstIdx = visibleExtensions.findIndex(ext => !(ext.isSeparator || ext.name === '|'));
                const lastIdx = (function(){
                    for (let i = visibleExtensions.length - 1; i >= 0; i--) {
                        const ext = visibleExtensions[i];
                        if (!(ext.isSeparator || ext.name === '|')) return i;
                    }
                    return -1;
                })();
                // Wire OSC1/OSC2 sliders to MIDI tuning (coarse/fine+octave)
                (function(){
                    try {
                        const g = (id)=> document.getElementById(id);
                        const ch1 = ()=> (window.midi?.channelMap?.osc1) || 1;
                        const ch2 = ()=> (window.midi?.channelMap?.osc2) || 1;
                        const send1 = ()=>{
                            if (!window.midi || !window.midi.enabled) return;
                            const oct = parseInt(g('osc1Octave')?.value||'0',10)||0;
                            const coarse = parseInt(g('osc1Coarse')?.value||'0',10)||0;
                            const fine = parseFloat(g('osc1Detune')?.value||'0')||0;
                            window.midi.setCoarseTune((oct*12)+coarse, ch1());
                            window.midi.setFineTune(fine, ch1());
                        };
                        const send2 = ()=>{
                            if (!window.midi || !window.midi.enabled) return;
                            const oct = parseInt(g('osc2Octave')?.value||'0',10)||0;
                            const coarse = parseInt(g('osc2Coarse')?.value||'0',10)||0;
                            const fine = parseFloat(g('osc2Detune')?.value||'0')||0;
                            window.midi.setCoarseTune((oct*12)+coarse, ch2());
                            window.midi.setFineTune(fine, ch2());
                        };
                        ['osc1Octave','osc1Coarse','osc1Detune'].forEach(id=>{ const el=g(id); if (el && !el._wiredMidi){ el._wiredMidi=true; el.addEventListener('input', send1); }});
                        ['osc2Octave','osc2Coarse','osc2Detune'].forEach(id=>{ const el=g(id); if (el && !el._wiredMidi){ el._wiredMidi=true; el.addEventListener('input', send2); }});
                    } catch(_){}
                })();
                const hasExplicitOuterStart = (firstIdx >= 0) && !!visibleExtensions[firstIdx].isRepeatMarker && (visibleExtensions[firstIdx].name === '[') && ((visibleExtensions[firstIdx].nestLevel || 0) === 0);
                const hasExplicitOuterEnd = (lastIdx >= 0) && !!visibleExtensions[lastIdx].isRepeatMarker && ((visibleExtensions[lastIdx].name === ']') || (/^\]x\d+$/.test(visibleExtensions[lastIdx].name || ''))) && ((visibleExtensions[lastIdx].nestLevel || 0) === 0);

                // Prepend auto outer start marker on the first row (only if not explicitly provided by SEQ)
                const startRow = useTwoRows ? rowTop : container;
                if (!hasExplicitOuterStart) {
                    appendRepeatMarker(startRow, '[', { autoOuter: true });
                }

                

                // Create ONE column per chord extension (no variants) - maintain exact order
                visibleExtensions.forEach((chordExt, extensionIndex) => {
                    // Render repeat marker as a special thin column
                    if (chordExt.isRepeatMarker) {
                        const repeatCol = document.createElement('div');
                        repeatCol.className = 'repeat-marker-column';
                        repeatCol.style.width = '50px';
                        repeatCol.style.minWidth = '50px';
                        repeatCol.style.maxWidth = '50px';
                        repeatCol.style.height = '100%';
                        repeatCol.style.flex = '0 0 50px';
                        
                        // Apply color theme if available
                        if (chordExt.colorTheme) {
                            const theme = chordExt.colorTheme;
                            repeatCol.style.background = theme.bg;
                            repeatCol.style.border = `2px solid ${theme.border}`;
                            repeatCol.style.color = theme.color;
                        } else {
                            // Default styling for legacy repeat markers
                            repeatCol.style.background = 'linear-gradient(135deg, rgba(255,215,0,0.3) 0%, rgba(255,140,0,0.4) 100%)';
                            repeatCol.style.border = '2px solid rgba(255,215,0,0.6)';
                            repeatCol.style.color = '#FFD700';
                        }
                        
                        repeatCol.style.borderRadius = '8px';
                        repeatCol.style.display = 'flex';
                        repeatCol.style.alignItems = 'center';
                        repeatCol.style.justifyContent = 'center';
                        repeatCol.style.fontSize = '16px';
                        repeatCol.style.fontWeight = 'bold';
                        repeatCol.style.textShadow = '0 1px 2px rgba(0,0,0,0.3)';
                        repeatCol.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
                        repeatCol.style.cursor = 'default';
                        repeatCol.textContent = chordExt.name; // e.g., "x4", "[", "]", "]x4"
                        repeatCol.title = `Repeat marker: ${chordExt.name} (Level ${chordExt.nestLevel || 0}) - NO chord strings, just visual indicator`;
                        
                        // Mark as repeat marker so it gets filtered out during playback
                        repeatCol.dataset.isRepeatMarker = 'true';
                        repeatCol.dataset.nestLevel = chordExt.nestLevel || 0;
                        if (typeof chordExt.repeatCount === 'number') {
                            repeatCol.dataset.repeatCount = String(chordExt.repeatCount);
                        } else if (/^\]x(\d+)$/.test(chordExt.name||'')) {
                            repeatCol.dataset.repeatCount = String((chordExt.name.match(/^\]x(\d+)$/)||[])[1]||'');
                        }
                        
                        if (useTwoRows) {
                            const half = Math.ceil(visibleExtensions.length / 2);
                            const targetRow = extensionIndex < half ? rowTop : rowBottom;
                            targetRow.appendChild(repeatCol);
                        } else {
                            container.appendChild(repeatCol);
                        }
                        
                        // Make ALL bracket markers draggable for section rearrangement
                        if (typeof window.makeBracketDraggable === 'function') {
                            window.makeBracketDraggable(repeatCol);
                        }
                        
                        // Allow clicking repeat end markers to edit count (0 = infinite)
                        repeatCol.addEventListener('click', ()=>{
                            const txt = repeatCol.textContent.trim();
                            const isEnd = (txt === ']' || /^\]x\d+$/.test(txt));
                            if (!isEnd) return;
                            const cur = parseInt(repeatCol.dataset.repeatCount||'0',10);
                            const val = prompt('Repeat count (0 = infinite):', isNaN(cur)? '0': String(cur));
                            if (val == null) return;
                            let n = Math.max(0, parseInt(val,10)||0);
                            if (n > 64) n = 64;
                            repeatCol.dataset.repeatCount = String(n);
                            repeatCol.textContent = (n === 0 ? ']' : `]x${n}`);
                        });
                        return; // IMPORTANT: Return early - no chord processing!
                    }
                    
                    // Special case: separator → 30px spacer without strings
                    if (chordExt.isSeparator || chordExt.name === '|') {
                        const sepCol = document.createElement('div');
                        sepCol.className = 'extension-separator';
                        sepCol.style.width = '30px';
                        sepCol.style.minWidth = '30px';
                        sepCol.style.maxWidth = '30px';
                        sepCol.style.height = '100%';
                        sepCol.style.flex = '0 0 30px';
                        sepCol.style.background = 'transparent';
                        sepCol.style.borderLeft = '2px solid rgba(255,255,255,0.15)';
                        sepCol.style.boxShadow = 'inset 0 0 12px rgba(255,255,255,0.08)';
                        if (useTwoRows) {
                            const half = Math.ceil(visibleExtensions.length / 2);
                            const targetRow = extensionIndex < half ? rowTop : rowBottom;
                            targetRow.appendChild(sepCol);
                        } else {
                            container.appendChild(sepCol);
                        }
                        return; // next item
                    }
                    const column = document.createElement('div');
                    column.className = 'extension-column';
                    column.dataset.chordType = chordIds[extensionIndex];
                    // Persist absolute index back to the original array for precise operations
                    const absoluteIndex = (typeof chordExt.position === 'number') ? chordExt.position : (this.findChordIndex ? this.findChordIndex(chordExt) : extensionIndex);
                    column.dataset.originalPosition = absoluteIndex;
                    column.dataset.chordId = chordExt.id || chordIds[extensionIndex];
                    // Assign a unique DOM instance id for this box if missing
                    if (!column.dataset.instanceId) {
                        column.dataset.instanceId = `${column.dataset.chordId}__${Date.now()}_${Math.floor(Math.random()*1e6)}`;
                    }
                    column.style.flex = '1'; // Each column takes equal width
                    column.style.height = '100%';
                    column.style.border = 'none';
                    column.style.borderRadius = '0';
                    column.style.margin = '0';
                    column.style.padding = '0';
                    
                    // Make chord columns draggable for rearrangement
                    if (typeof window.makeBracketDraggable === 'function') {
                        window.makeBracketDraggable(column);
                    }
                    
                    // Create header with chord name and lock button
                    const header = document.createElement('div');
                    header.className = 'extension-header';
                    
                    // Create chord name span (inline-editable)
                    const chordName = document.createElement('span');
                    chordName.className = 'chord-name';
                    chordName.setAttribute('contenteditable', 'true');
                    chordName.setAttribute('spellcheck', 'false');
                    
                    // Check if this chord extension is locked and preserve its locked name
                    if (chordExt.isLocked && chordExt.lockedData) {
                        const lockedData = chordExt.lockedData;
                        const rootName = this.getNoteNames()[lockedData.lockedRoot] || lockedData.lockedRoot;
                        
                        // Use the locked name exactly as it was when locked
                        if (lockedData.chordName.match(/^[A-G][#b]?/)) {
                            chordName.textContent = lockedData.chordName;
                        } else {
                            chordName.textContent = `${rootName}${lockedData.chordName}`;
                        }
                        
                        chordName.style.color = '#4CAF50';
                        chordName.style.fontWeight = 'bold';
                        chordName.dataset.isLocked = 'true';
                        chordName.dataset.lockedName = chordName.textContent;
                        chordName.title = `?? LOCKED: ${rootName} root, ${lockedData.lockedTuning}TET, ${lockedData.lockedOsc1.type}/${lockedData.lockedOsc2.type} waves`;
                    } else {
                        // Regular unlocked chord - use current name
                        chordName.textContent = chordExt.name;
                    }
                    
                    
                    
                    // Create buttons container
                    const buttonsContainer = document.createElement('div');
                    buttonsContainer.className = 'header-buttons';

                    
                    // Add buttons to container
                    // Per-column transpose controls
                    const downBtn = document.createElement('button');
                    downBtn.className = 'chord-action-button transpose-down';
                    downBtn.title = 'Transpose this chord down one step';
                    downBtn.textContent = '▼';
                    const upBtn = document.createElement('button');
                    upBtn.className = 'chord-action-button transpose-up';
                    upBtn.title = 'Transpose this chord up one step';
                    upBtn.textContent = '▲';
                    // Prevent double-fire on touch (touchstart + synthetic click)
                    let _pressGuard = false;
                    const norm = (v, m)=> ((v % m) + m) % m;
                    const applyLocalTranspose = (delta)=>{
                        if (_pressGuard) return; // avoid accidental double-fire on first tap
                        _pressGuard = true;
                        const edoNow = chordExt.fixedRootTuning || this.currentTuning || 24; // use column/root tuning

                        // Non-baking model: update local offset only
                        const prevLocal = parseInt(column.dataset.localTranspose || '0', 10) || 0;
                        const nextLocal = norm(prevLocal + delta, edoNow);
                        column.dataset.localTranspose = String(nextLocal);
                        chordExt.localTranspose = nextLocal; // persist for regeneration

                        // Recompute label from absolute steps, mirroring global path
                        try {
                            // Prefer locked semantics for naming if this column is locked
                            const locked = (this.lockedChords?.get(column)) || chordExt.lockedData || null;
                            const hasFixed = (typeof chordExt.fixedRootStepAbs === 'number') && !!chordExt.fixedRootTuning;
                            const modelEdo = locked ? (locked.lockedTuning || edoNow) : (hasFixed ? (chordExt.fixedRootTuning || edoNow) : edoNow);
                            const mapStep = (step, srcEdo, dstEdo) => {
                                const cents = ((step % srcEdo + srcEdo) % srcEdo) * (1200 / srcEdo);
                                const dst = Math.round(cents / (1200 / dstEdo));
                                return ((dst % dstEdo) + dstEdo) % dstEdo;
                            };
                            const localDeltaModel = (modelEdo === edoNow) ? nextLocal : mapStep(nextLocal, edoNow, modelEdo);
                            if (locked) {
                                // For locked chords: name within locked tuning; do not add global transpose into the text
                                const baseRootModel = ((locked.lockedRoot ?? 0) % modelEdo + modelEdo) % modelEdo;
                                const effRootModel = (((baseRootModel) + localDeltaModel) % modelEdo + modelEdo) % modelEdo;
                                const rootName = this.getRootNameForStep(effRootModel, modelEdo);
                                const rawLockedName = (locked.chordName || '').trim();
                                const rest = rawLockedName.replace(/^[A-G][#b]?\s*/, '');
                                const label = `${rootName}${rest}`;
                                chordName.textContent = label;
                                chordName.dataset.lockedName = label;
                                chordExt.name = label;
                            } else {
                                // Unlocked or fixed-root chords: compute abs steps and let naming apply global delta exactly once
                                const baseRootModel = hasFixed
                                    ? (chordExt.fixedRootStepAbs || 0)
                                    : (((this.currentRoot || 0) % modelEdo) + modelEdo) % modelEdo;
                                const effRootModel = (((baseRootModel) + localDeltaModel) % modelEdo + modelEdo) % modelEdo;
                                const degreeStepsModel = chordExt.isCustom
                                    ? chordExt.intervals.map(iv => ((iv % modelEdo) + modelEdo) % modelEdo)
                                    : chordExt.intervals.map(iv => this.mapIntervalToEDO(iv, modelEdo));
                                // Build absolute steps: transposed root + each interval from the transposed root
                                const absModel = [effRootModel, ...degreeStepsModel.map(d => (effRootModel + d) % modelEdo)];
                                const absNow = (modelEdo === edoNow) ? absModel.map(s => ((s%edoNow)+edoNow)%edoNow)
                                                                    : absModel.map(s => mapStep(s, modelEdo, edoNow));
                                const recomputed = this.computeFullChordNameFromAbsoluteSteps(absNow, edoNow);
                                chordName.textContent = recomputed;
                                chordName.dataset.lockedName = recomputed;
                                chordExt.name = recomputed;
                            }
                        } catch(_) {}

                        // Do not mutate chord intervals or fixed root; regenerate strings using new local transpose
                        const oldContainer = column.querySelector('.strings-column');
                        if (oldContainer) oldContainer.remove();
                        
                        // Regenerate this column using the same logic as regenerateAllColumnsPreservingLocks
                        const isLocked = this.lockedChords && this.lockedChords.has(column);
                        if (isLocked) {
                            const lockedChord = this.lockedChords.get(column);
                            this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals, lockedChord);
                        } else {
                            // For unlocked columns, regenerate using current global settings and the chord model
                            console.log('🔧 DEBUG ACTIVE PATH: About to call generateStringsForColumn with intervals:', chordExt.intervals, 'isCustom:', chordExt.isCustom, 'chordName:', chordExt.name);
                            this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom || false);
                        }

                        // Update keyboard highlighting
                        try { this.highlightKeyboardForColumn(column); } catch {}
                        // release guard on next microtask to collapse duplicate events
                        Promise.resolve().then(()=>{ _pressGuard = false; });
                    };
                    const onPointer = (delta)=> (e)=>{ e.preventDefault(); e.stopPropagation(); applyLocalTranspose(delta); try{ this.highlightKeyboardForColumn(column);}catch{} };
                    upBtn.addEventListener('pointerdown', onPointer(+1));
                    downBtn.addEventListener('pointerdown', onPointer(-1));

                    buttonsContainer.appendChild(downBtn);
                    buttonsContainer.appendChild(upBtn);
                    
                    // Initialize per-column local transpose from model (default 0)
                    const initLocalTranspose = (typeof chordExt.localTranspose === 'number') ? chordExt.localTranspose : 0;
                    column.dataset.localTranspose = String(initLocalTranspose);

                    header.appendChild(chordName);
                    header.appendChild(buttonsContainer);
                    
                    // Color coding based on chord type
                    let qualityColor;
                    if (chordExt.name === 'Major') {
                        qualityColor = { bg: '#1e40af', border: '#3b82f6' };
                    } else if (chordExt.name === 'Neutral') {
                        qualityColor = { bg: '#059669', border: '#10b981' };
                    } else if (chordExt.name === 'Minor') {
                        qualityColor = { bg: '#dc2626', border: '#ef4444' };
                    } else if (chordExt.isCustom) {
                        // Custom chords get purple coloring
                        qualityColor = { bg: '#7c3aed', border: '#8b5cf6' };
                    } else {
                        // Default coloring for other chord types
                        qualityColor = { bg: '#374151', border: '#6b7280' };
                    }
                    
                    header.style.backgroundColor = qualityColor.bg;
                    header.style.borderColor = qualityColor.border;
                    header.style.color = 'white';
                    header.style.border = `1px solid ${qualityColor.border}`;

                    // Then apply header accent from this column's chord root (or locked root if locked)
                    try {
                        const isLocked = !!chordExt.isLocked && !!chordExt.lockedData;
                        let rootStep;
                        if (isLocked) {
                            const edo = chordExt.lockedData.lockedTuning || this.currentTuning || 12;
                            const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                            rootStep = ((chordExt.lockedData.lockedRoot ?? 0) + localDelta + edo) % edo;
            } else {
                            const label = (chordName.dataset.lockedName || chordName.textContent || '').trim();
                            const m = label.match(/^([A-G])([#b]?)([\^v]*)/);
                            if (m) {
                                const semi = this.rootToSemitone(m[1], m[2]||'');
                                let step = Math.round((semi * (this.currentTuning||12)) / 12);
                                const ups = (m[3].match(/\^/g) || []).length;
                                const downs = (m[3].match(/v/g) || []).length;
                rootStep = ((step + ups - downs) % (this.currentTuning||12) + (this.currentTuning||12)) % (this.currentTuning||12);
                            } else {
                                rootStep = this.currentRoot ?? 0;
                            }
                        }
                        const semi = this.stepToSemitone(rootStep, this.currentTuning || 12);
                        const accent = this.getChromaticColorForSemitone(semi);
                        const text = this.pickTextColor(accent);
                        header.style.background = accent;
                        header.style.borderBottom = `2px solid ${accent}`;
                        header.style.boxShadow = `0 0 10px ${accent}55`;
                        header.style.color = text;
                    } catch {}
                    
                    // Editing behavior: Enter to apply, Escape to cancel selection
                    const applyTypedName = () => {
                        try {
                            const raw = (chordName.textContent || '').trim();
                            if (!raw) return;
                            const added = (typeof this.addChordFromName === 'function') ? this.addChordFromName(raw) : null;
                            if (!added || !added.chord) {
                                // Unknown symbol -> brief visual error
                                const prevOutline = chordName.style.outline;
                                chordName.style.outline = '2px solid #e74c3c';
                                setTimeout(()=> { chordName.style.outline = prevOutline; }, 600);
                                // Keep the text but don't change model
                                return;
                            }
                            // Replace current model entry in-place with parsed result
                            let idx = (typeof column.dataset.originalPosition !== 'undefined') ? parseInt(column.dataset.originalPosition,10) : -1;
                            if (isNaN(idx) || idx < 0) idx = (this.chordExtensions||[]).indexOf(chordExt);
                            if (idx >= 0) {
                                // addChordFromName appends; remove the appended copy and use it to replace in place
                                const parsed = added.chord;
                                try { if (this.chordExtensions[this.chordExtensions.length-1] === parsed) this.chordExtensions.pop(); } catch(_){ }
                                // Preserve position and local transpose
                                parsed.position = chordExt.position;
                                parsed.localTranspose = chordExt.localTranspose || 0;
                                this.chordExtensions.splice(idx, 1, parsed);
                                // Keep DOM dataset mapping consistent
                                column.dataset.chordId = parsed.id || column.dataset.chordId;
                                column.dataset.originalPosition = String(idx);
                                // Update name display to normalized parsed name
                                chordName.textContent = parsed.name;
                                // Regenerate strings for this column
                                const old = column.querySelector('.strings-column');
                                if (old) old.remove();
                                this.generateStringsForColumn(column, parsed.intervals, parsed.isCustom || false);
                                // Save and refresh click/lock states
                                try { this.saveChordConfiguration?.(); } catch(_){}
                            }
                        } catch (err) { console.error('applyTypedName error:', err); }
                    };
                    chordName.addEventListener('keydown', (ev)=>{
                        if (ev.key === 'Enter') { ev.preventDefault(); applyTypedName(); chordName.blur(); }
                        else if (ev.key === 'Escape') { ev.preventDefault(); chordName.blur(); }
                    });
                    // Allow short tap on chord name to bubble so header can play; only long-press enters edit
                    chordName.addEventListener('click', (e)=>{ /* allow bubble for playback */ });
                    chordName.addEventListener('mousedown', (e)=>{ /* allow bubble for playback */ });
                    chordName.addEventListener('touchstart', (e)=>{ /* allow bubble for playback */ }, {passive:true});
                    
                    // Apply the same per-column root accent logic again (post-append)
                    try {
                        const isLocked = !!chordExt.isLocked && !!chordExt.lockedData;
                        let rootStep;
                        if (isLocked) {
                            const edo = chordExt.lockedData.lockedTuning || this.currentTuning || 12;
                            const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                            rootStep = ((chordExt.lockedData.lockedRoot ?? 0) + localDelta + edo) % edo;
            } else {
                            const label = (chordName.dataset.lockedName || chordName.textContent || '').trim();
                            const m = label.match(/^([A-G])([#b]?)([\^v]*)/);
                            if (m) {
                                const semi = this.rootToSemitone(m[1], m[2]||'');
                                let step = Math.round((semi * (this.currentTuning||12)) / 12);
                                const ups = (m[3].match(/\^/g) || []).length;
                                const downs = (m[3].match(/v/g) || []).length;
                rootStep = ((step + ups - downs) % (this.currentTuning||12) + (this.currentTuning||12)) % (this.currentTuning||12);
                            } else {
                                rootStep = this.currentRoot ?? 0;
                            }
                        }
                        const semi = this.stepToSemitone(rootStep, this.currentTuning || 12);
                        const accent = this.getChromaticColorForSemitone(semi);
                        const text = this.pickTextColor(accent);
                        header.style.background = accent;
                        header.style.borderBottom = `2px solid ${accent}`;
                        header.style.boxShadow = `0 0 10px ${accent}55`;
                        header.style.color = text;
                    } catch {}

                    column.appendChild(header);
                    
                    // Generate chord intervals and strings
                    const intervals = chordExt.intervals || this.getBaseTriadForQuality(chordExt.name.toLowerCase());
                    
                    // If this chord is locked, generate strings using its locked settings
                    if (chordExt.isLocked && chordExt.lockedData) {
                        console.log('?? Generating strings with locked settings for:', chordExt.name);
                        // Update header to effective root (locked root + local transpose)
                        try {
                            const edo = chordExt.lockedData.lockedTuning || this.currentTuning || 12;
                            const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                            const effRoot = ((chordExt.lockedData.lockedRoot ?? 0) + localDelta + edo) % edo;
                            const effRootName = this.getRootNameForStep(effRoot, edo);
                            const header = column.querySelector('.extension-header');
                            const nameEl = header?.querySelector('.chord-name');
                            if (nameEl) {
                                const rest = (chordExt.lockedData.chordName || '').replace(/^[A-G][#b]?\s*/, '');
                                nameEl.textContent = `${effRootName}${rest}`;
                                nameEl.dataset.lockedName = nameEl.textContent;
                            }
                        } catch {}
                        this.generateStringsForColumnWithLockedSettings(column, intervals, chordExt.lockedData);
                    } else {
                        // Regular chord - use current global settings
                        this.generateStringsForColumn(column, intervals, chordExt.isCustom);
                    }
                    
                    // Ensure columns generated via the exact path are draggable
                    if (this.attachColumnDragHandlers) {
                        this.attachColumnDragHandlers(column);
                    }
                    if (useTwoRows) {
                        const half = Math.ceil(visibleExtensions.length / 2);
                        const targetRow = extensionIndex < half ? rowTop : rowBottom;
                        targetRow.appendChild(column);
                        // If strings exist already, scale their container height to half
                        const sc = column.querySelector('.strings-column');
                        if (sc) {
                            const headerEl = column.querySelector('.extension-header');
                            const headerPx = Math.max(56, headerEl ? headerEl.offsetHeight : 56);
                            sc.style.height = `calc(100% - ${headerPx}px)`;
                        }
                    } else {
                        container.appendChild(column);
                    }
                });

                // Append auto outer end marker on the last row (only if not explicitly provided by SEQ)
                const endRow = useTwoRows ? rowBottom : container;
                // repeatCount 0 = infinite; actual looping is gated by LOOP checkbox at runtime
                if (!hasExplicitOuterEnd) {
                    appendRepeatMarker(endRow, ']', { autoOuter: true, repeatCount: 0 });
                }
                
                // Add click handlers and restore locked chord states after rendering
                setTimeout(() => {
                    this.addSimpleClickHandlers();
                    this.restoreLockedChordStates(); // Restore locked chord states
                }, 100);
            }
            
            generateStringsForColumnWithLockedSettings(column, intervals, lockedData) {
                // Check if we have exact frequencies captured - use those for perfect reproduction
                if (lockedData.exactFrequencies && lockedData.exactFrequencies.length > 0 && !this._transposing) {
                    this.generateStringsWithExactFrequencies(column, lockedData);
                    return; // Skip the rest of this method
                }
                
                // Store current settings to restore later
                const originalSettings = {
                    currentRoot: this.currentRoot,
                    currentTuning: this.currentTuning,
                    gamelanMode: this.gamelanMode,
                    volume: this.volume,
                    masterVolume: this.masterVolume
                };
                
                // Temporarily apply locked settings for string generation (with per-column local transpose in conjunction)
                const edo = lockedData.lockedTuning || this.currentTuning || 12;
                const globalDelta = (this.transposeDelta || 0) % edo;
                const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                this.currentRoot = ((lockedData.lockedRoot ?? 0) + (this._transposing ? globalDelta : 0) + localDelta + edo) % edo;
                this.currentTuning = lockedData.lockedTuning;
                this.gamelanMode = lockedData.lockedGamelanMode;
                this.volume = lockedData.lockedVolume.main;
                this.masterVolume = lockedData.lockedVolume.master;
                
                // Generate strings with locked settings
                this.generateStringsForColumn(column, intervals, lockedData.isCustom);
                
                // Store the display/effective root in the column's data attribute for reference during playback
                column.dataset.lockedRoot = String(this.currentRoot);
                
                // Add a visual indicator that this column is locked to a specific root
                const header = column.querySelector('.extension-header');
                if (header) {
                    const rootName = this.getRootNameForStep(this.currentRoot, lockedData.lockedTuning || this.currentTuning || 12);
                    const chordName = header.querySelector('.chord-name');
                    if (chordName) {
                        // Update the header to show it's locked to a specific root
                        chordName.textContent = `${rootName}${(lockedData.chordName||'').replace(/^[A-G][#b]?\s*/, '')}`;
                        chordName.dataset.lockedName = chordName.textContent;
                        chordName.style.color = '#ffcc00'; // Make it gold to indicate locked root
                        chordName.title = `LOCKED: ${rootName} root, ${lockedData.lockedTuning}TET tuning`;
                    }
                }
                
                // Restore original global settings
                this.currentRoot = originalSettings.currentRoot;
                this.currentTuning = originalSettings.currentTuning;
                this.gamelanMode = originalSettings.gamelanMode;
                this.volume = originalSettings.volume;
                this.masterVolume = originalSettings.masterVolume;
                
                console.log('?? Generated strings with locked settings and restored global settings');
                
                // Find the lock button and ensure it shows the correct state
                const lockButton = column.querySelector('.lock-button');
                if (lockButton) {
                    lockButton.innerHTML = '🔒';
                    lockButton.classList.add('locked');
                    lockButton.title = `Locked to ${this.getNoteNames()[this.currentRoot] || this.currentRoot} root with all settings`;
                }
            }
            
            generateChordName(intervals) {
                if (!intervals || intervals.length === 0) return '';
                if (intervals.length === 1) return '';
                
                // Use the new proper chord symbol system
                return this.getProperChordSymbol(intervals);
            }

            
            
            // Helper function to check if intervals match (accounting for octave wrapping)
            intervalsMatch(intervals1, intervals2) {
                if (intervals1.length !== intervals2.length) return false;
                
                // Normalize intervals to within one octave
                const normalize = (intervals) => intervals.map(i => i % 12).sort((a, b) => a - b);
                const norm1 = normalize(intervals1);
                const norm2 = normalize(intervals2);
                
                return norm1.every((interval, index) => interval === norm2[index]);
            }
            
            async playStringPreview(interval) {
                const ready = await this.ensureAudioContext();
                if (!ready) return;
                
                // Interpret interval as an absolute step plus global transpose (rootless)
                const absStep = (((interval % this.currentTuning) + (this.transposeDelta||0)) % this.currentTuning + this.currentTuning) % this.currentTuning;
                const frequency = this.getFrequency(absStep, 4, this.currentTuning);
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.8);
                
                oscillator.connect(gainNode);
                // Route through master chain (global wet/dry + reverb)
                gainNode.connect(this.gainNode);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.8);
            }
            
            restoreNormalRootButtons() {
                // Restore original root button functionality
                this.generateRootButtons();
            }

            // Apply a global transpose by n EDO steps; rootless: rename headers from absolute steps when possible and retune
            applyTransposeStep(n = 0) {
                console.log('=== TRANSPOSE DEBUG ===');
                console.log('applyTransposeStep called with n =', n);
                console.log('Before: this.transposeDelta =', this.transposeDelta);
                if (!n) return;
                const edo = this.currentTuning || 12;
                this.transposeDelta = (((this.transposeDelta || 0) + n) % edo + edo) % edo;
                console.log('After: this.transposeDelta =', this.transposeDelta);
                console.log('Current active column element:', this.currentActiveColumnEl);
                console.log('=== TRANSPOSE DEBUG END ===');
                // Refresh keyboard labels and chord-tone highlights
                try { this.generateRootButtons(); } catch (_) {}
                // Rename headers (build from each chord's fixed-root baseline; include LOCAL transpose only here; map via nearest-neighbor)
                // Note: computeFullChordNameFromAbsoluteSteps will apply the GLOBAL transpose when forming the label,
                // so we must NOT bake the global delta into abs steps here to avoid double application.
                document.querySelectorAll('.extension-column').forEach(col => {
                    const nameEl = col.querySelector('.extension-header .chord-name');
                    if (!nameEl) return;
                    const locked = !!col.querySelector('.lock-button')?.classList.contains('locked');
                    const labelRaw = (nameEl.dataset.lockedName || nameEl.textContent || '').trim().replace(/^🔒\s*/, '');
                    let model = null;
                    try {
                        let idx = col.dataset.originalPosition != null ? parseInt(col.dataset.originalPosition,10) : -1;
                        if (isNaN(idx) || idx < 0) {
                            const id = col.dataset.chordId;
                            idx = (this.chordExtensions || []).findIndex(c => (c.id===id));
                        }
                        model = (idx>=0)? this.chordExtensions[idx] : null;
                    } catch (_) { model = null; }

                    const edoNow = this.currentTuning || 12;
                    const localDeltaNow = ((+col.dataset.localTranspose || 0) % edoNow + edoNow) % edoNow;
                    const globalDeltaNow = ((this.transposeDelta || 0) % edoNow + edoNow) % edoNow;

                    if (model && typeof model.fixedRootStepAbs === 'number' && Array.isArray(model.intervals) && model.intervals.length>0) {
                        const modelEdo = model.fixedRootTuning || edoNow;
                        // Map a step between EDOs by cents (nearest neighbor)
                        const mapStep = (step, srcEdo, dstEdo) => {
                            const cents = ((step % srcEdo + srcEdo) % srcEdo) * (1200 / srcEdo);
                            const dst = Math.round(cents / (1200 / dstEdo));
                            return ((dst % dstEdo) + dstEdo) % dstEdo;
                        };
                        // Convert deltas if model EDO differs
                        const localDeltaModel = (modelEdo === edoNow) ? localDeltaNow : mapStep(localDeltaNow, edoNow, modelEdo);
                        // Do NOT bake global delta here; the naming function applies it when computing the label
                        const effRootModel = (((model.fixedRootStepAbs || 0) + localDeltaModel) % modelEdo + modelEdo) % modelEdo;
                        // Build degree steps in model's EDO
                        const degreeStepsModel = model.isCustom
                            ? model.intervals.map(iv => ((iv % modelEdo) + modelEdo) % modelEdo)
                            : model.intervals.map(iv => this.mapIntervalToEDO(iv, modelEdo));
                        // Ensure root (0) included and sorted unique
                        const uniqDegrees = Array.from(new Set([0, ...degreeStepsModel])).sort((a,b)=>a-b);
                        const absModel = [effRootModel, ...uniqDegrees.filter(d=>d!==0).map(d => (effRootModel + d) % modelEdo)];
                        // Map to current EDO if needed
                        const absNow = (modelEdo === edoNow) ? absModel.map(s => ((s%edoNow)+edoNow)%edoNow)
                                                            : absModel.map(s => mapStep(s, modelEdo, edoNow));
                        const recomputed = this.computeFullChordNameFromAbsoluteSteps(absNow, edoNow);
                        nameEl.textContent = locked ? `🔒 ${recomputed}` : recomputed;
                        nameEl.dataset.lockedName = nameEl.textContent;
                    } else {
                        // Fallback: parse current root and rotate by n, keep tail suffix
                        const m = labelRaw.match(/^([A-G])([#b]?)(.*)$/);
                        if (m) {
                            const semi = this.rootToSemitone(m[1], m[2]||'');
                            let step = this.semitoneToStep(semi, edoNow);
                            step = (((step + (this.transposeDelta||0) + localDeltaNow) % edoNow) + edoNow) % edoNow;
                            const newRoot = this.getRootNameForStep(step, edoNow);
                            nameEl.textContent = locked ? `🔒 ${newRoot}${m[3]||''}` : `${newRoot}${m[3]||''}`;
                            nameEl.dataset.lockedName = nameEl.textContent;
                        }
                    }
                });
                // Retune all strings/columns to reflect transpose
                this._transposing = true;
                try { this.regenerateAllColumnsPreservingLocks(); } finally { this._transposing = false; }
                // After transpose, warm all visible pianolocked columns for instant response
                try {
                    // Warm columns marked as piano-locked (use class marker or backend flags)
                    document.querySelectorAll('.extension-column.piano-locked-col').forEach(col => {
                        try { this.preloadPianoLockedChord(col); } catch(_) {}
                    });
                    // Fallback: scan columns and check their chord data for pianoLockedData
                    document.querySelectorAll('.extension-column').forEach(col => {
                        try {
                            const hdr = col.querySelector('.extension-header');
                            const cd = (typeof this.getChordDataFromColumn === 'function') ? this.getChordDataFromColumn(col, hdr) : null;
                            if (cd && cd.isPianoLocked) { try { this.preloadPianoLockedChord(col); } catch(_) {} }
                        } catch(_){}
                    });
                } catch(_) {}
                // Update delta indicator
                const deltaEl = document.getElementById('transposeDelta');
                if (deltaEl) deltaEl.textContent = String(this.transposeDelta);
                // Update any locked column header tooltips
                try {
                    document.querySelectorAll('.extension-column').forEach(col=>{
                        const btn = col.querySelector('.lock-button');
                        if (btn?.classList.contains('locked')){
                            const edoNow = this.currentTuning || 12;
                            const lockedChord = this.lockedChords?.get(col);
                            if (lockedChord) {
                                const localDelta = ((+col.dataset.localTranspose || 0) % edoNow + edoNow) % edoNow;
                                const effStep = (((lockedChord.lockedRoot ?? 0) + localDelta + (this.transposeDelta || 0)) % edoNow + edoNow) % edoNow;
                                const newRoot = this.getRootNameForStep(effStep, edoNow);
                                btn.title = `Locked to ${newRoot} root with all settings`;
                            }
                        }
                    });
                } catch (_) {}
                // Refresh keyboard highlights after global transpose
                console.log('About to call highlightKeyboardForColumn with:', this.currentActiveColumnEl);
                console.log('Current this.transposeDelta before highlighting:', this.transposeDelta);
                try { if (this.currentActiveColumnEl) this.highlightKeyboardForColumn(this.currentActiveColumnEl); } catch (e) { console.log('Error highlighting:', e); }
            }

            // ================== TEXT → CHORDS PARSER ==================
            initTextChordParser() {
                const openBtn = document.getElementById('openTextChordParserBtn');
                const modal = document.getElementById('textChordModal');
                const closeBtn = document.getElementById('closeTextChordModalBtn');
                const parseBtn = document.getElementById('parseTextChordsBtn');
                const textarea = document.getElementById('textChordInput');
                // Sequence preset controls
                const seqSelect = document.getElementById('seqPresetDropdown');
                const seqLoadBtn = document.getElementById('selectSeqPresetBtn');
                const seqSaveBtn = document.getElementById('addSeqPresetBtn');
                const seqDelBtn  = document.getElementById('deleteSeqPresetBtn');
                // Open the modal when SEQUENCE button is clicked
                if (openBtn && modal) {
                    openBtn.addEventListener('click', () => {
                        modal.style.display = 'block';
                        // Populate presets each open to pick up new saves/deletes
                        try { if (seqSelect) this.populateSeqPresetDropdown(seqSelect, this.getSequencePresets()); } catch(_) {}
                        // Initialize EDO field to current tuning
                        try { const ed = document.getElementById('seqEdoInput'); if (ed) ed.value = String(this.currentTuning || 24); } catch(_) {}
                        // Run an initial parse to populate palette/count
                        try { this.runTextChordParsing(); } catch(_) {}
                    });
                }
                // Update any locked column header tooltips
                if (closeBtn) closeBtn.addEventListener('click', ()=> { if(modal) modal.style.display='none'; });
                // Create Sequence now builds from textarea
                if (parseBtn) parseBtn.addEventListener('click', ()=> this.createSequenceFromTextarea());
                // Live preview of unique chords palette
                if (textarea) textarea.addEventListener('input', ()=> this.runTextChordParsing());
                // Dismiss on backdrop click
                if (modal) modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });

                // Wire sequence presets UI
                // Initial populate on load
                try { if (seqSelect) this.populateSeqPresetDropdown(seqSelect, this.getSequencePresets()); } catch(_) {}
                // Auto-load on selection change and close modal
                if (seqSelect && textarea && modal) {
                    seqSelect.addEventListener('change', () => {
                        const id = seqSelect.value || '';
                        if (!id) return;
                        const list = this.getSequencePresets();
                        const found = list.find(p=> p.id === id);
                        if (!found) return;
                        const textOnly = found.text || '';
                        const edo = Math.max(5, Math.min(52, parseInt(found.edo || this.currentTuning || 24)));
                        const seqEdo = document.getElementById('seqEdoInput');
                        if (seqEdo) seqEdo.value = String(edo);
                        // Apply EDO now so parsing reflects it
                        try { this.updateTuningSystem(edo); const qi=document.getElementById('edoQuickInput'); if(qi) qi.value=String(edo); const p=document.getElementById('edoDivisions'); if(p) p.value=String(edo);} catch {}
                        textarea.value = textOnly;
                        textarea.dispatchEvent(new Event('input'));
                        // Apply any saved FX state
                        try { if (found.fx && typeof this.applyEffectsState === 'function') this.applyEffectsState(found.fx); } catch(_) {}
                        // If it's a Roman sequence, immediately create columns
                        try {
                            const material = this.convertRomanNumeralsInline(textOnly);
                            let list = this.extractChordsFromTextPreserveOrder(material);
                            
                            // If preset has saved sequence order, use that instead
                            if (found.sequenceOrder && found.sequenceOrder.length > 0) {
                                list = found.sequenceOrder;
                            }
                            
                            if (list && list.length) {
                                this.transposeDelta = 0;
                                const deltaEl = document.getElementById('transposeDelta');
                                if (deltaEl) deltaEl.textContent = '0';
                                this.autoCreateColumnsFromText(list);
                            }
                        } catch(_) {}
                        modal.style.display = 'none';
                    });
                }
                // Make sequencer EDO field drive the global tuning as well (kept in sync with quick/panel inputs)
                try {
                    const seqEdoEl = document.getElementById('seqEdoInput');
                    if (seqEdoEl) {
                        const applySeqEdo = () => {
                            const v = Math.max(5, Math.min(52, parseInt(seqEdoEl.value || this.currentTuning || 24)));
                            seqEdoEl.value = String(v);
                            try {
                                this.updateTuningSystem(v);
                                const qi = document.getElementById('edoQuickInput');
                                if (qi) qi.value = String(v);
                                const p = document.getElementById('edoDivisions');
                                if (p) p.value = String(v);
                            } catch {}
                            // Live preview re-parse if user is drafting a sequence
                            try { if (textarea) this.runTextChordParsing(); } catch {}
                        };
                        seqEdoEl.addEventListener('change', applySeqEdo);
                        // Also react to Enter key while focused
                        seqEdoEl.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') { e.preventDefault(); applySeqEdo(); }});
                    }
                } catch (_) {}
                // Save: prompt for name and save current textarea as a new preset, then refresh dropdown
                if (seqSaveBtn) seqSaveBtn.addEventListener('click', () => {
                    if (!textarea) return;
                    const text = (textarea.value || '').trim();
                    if (!text) return;
                    const name = prompt('Preset name?', 'My Sequence');
                    if (!name) return;
                    const edoEl = document.getElementById('seqEdoInput');
                    const edo = Math.max(5, Math.min(52, parseInt(edoEl?.value || this.currentTuning || 24)));
                    const fx = (typeof this.captureEffectsState === 'function') ? this.captureEffectsState() : null;
                    this.saveSequencePreset({ text, name, edo, fx });
                    try { if (seqSelect) this.populateSeqPresetDropdown(seqSelect, this.getSequencePresets()); } catch(_) {}
                    const list = this.getSequencePresets();
                    if (seqSelect && list.length) seqSelect.value = list[0].id;
                });
                // Delete: remove selected preset
                if (seqDelBtn) seqDelBtn.addEventListener('click', () => {
                    if (!seqSelect) return;
                    const id = seqSelect.value || '';
                    if (!id) return;
                    const key = 'omni_seq_presets_v4';
                    try {
                        const list = this.getSequencePresets();
                        const next = list.filter(x => x.id !== id);
                        localStorage.setItem(key, JSON.stringify(next));
                        this.populateSeqPresetDropdown(seqSelect, next);
                    } catch(_) {}
                });
            }

            // ================== INSTRUMENT PRESETS (OSC/ADSR) ==================
            getInstrumentPresets() {
                const key = 'omni_instr_presets_v1';
                try {
                    const raw = localStorage.getItem(key);
                    const list = raw ? JSON.parse(raw) : [];
                    return Array.isArray(list) ? list : [];
                } catch (_) {
                    return [];
                }
            }
            saveInstrumentPresets(list) {
                const key = 'omni_instr_presets_v1';
                try { localStorage.setItem(key, JSON.stringify(list.slice(0, 200))); } catch (_) {}
            }
            populateInstrumentPresetDropdown(selectEl) {
                if (!selectEl) return;
                const list = this.getInstrumentPresets();
                selectEl.innerHTML = '';
                const def = document.createElement('option');
                def.value = '';
                def.textContent = 'Choose preset';
                selectEl.appendChild(def);
                list.forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p.id;
                    opt.textContent = p.name || p.id;
                    selectEl.appendChild(opt);
                });
            }
            captureInstrumentState() {
                return {
                    osc1: { ...this.oscillators.osc1 },
                    osc2: { ...this.oscillators.osc2 },
                    envelope: { ...this.envelope },
                    osc2Envelope: { ...this.osc2Envelope }
                };
            }
            applyInstrumentState(state) {
                if (!state) return;
                if (state.osc1) Object.assign(this.oscillators.osc1, state.osc1);
                if (state.osc2) Object.assign(this.oscillators.osc2, state.osc2);
                if (state.envelope) Object.assign(this.envelope, state.envelope);
                if (state.osc2Envelope) Object.assign(this.osc2Envelope, state.osc2Envelope);
                // Sync UI controls if panel is open
                const oscPanel = document.querySelector('.panel-content[data-panel="osc"]');
                if (oscPanel && window.getComputedStyle(oscPanel).display !== 'none') {
                    const syncOscUi = (num, data) => {
                        try {
                            document.querySelectorAll(`.osc-btn[data-osc="${num}"]`).forEach(b => b.classList.remove('active'));
                            const active = document.querySelector(`.osc-btn[data-osc="${num}"][data-wave="${data.type}"]`);
                            if (active) active.classList.add('active');
                            const pwContainer = document.querySelector(`.pulse-width-container[data-osc="${num}"]`);
                            if (pwContainer) pwContainer.style.display = (data.type === 'pulse') ? 'block' : 'none';
                            const pwSlider = document.getElementById(`osc${num}PulseWidth`);
                            const pwValue = document.getElementById(`osc${num}PulseWidthValue`);
                            if (pwSlider && typeof data.pulseWidth === 'number') {
                                const pct = Math.round((data.pulseWidth || 0.5) * 100);
                                pwSlider.value = String(pct);
                                if (pwValue) pwValue.textContent = `${pct}%`;
                            }
                            // Shape width
                            const swSlider = document.getElementById(`osc${num}ShapeWidth`);
                            const swValue = document.getElementById(`osc${num}ShapeWidthValue`);
                            if (swSlider && typeof data.shapeWidth === 'number') {
                                const swPct = Math.round((data.shapeWidth || 0.5) * 100);
                                swSlider.value = String(swPct);
                                if (swValue) swValue.textContent = `${swPct}%`;
                            }
                            const lvl = document.getElementById(`osc${num}Level`);
                            const lvlV = document.getElementById(`osc${num}LevelValue`);
                            if (lvl) { const slider = Math.round(((data.level || 0) / 0.125) * 10); lvl.value = String(slider); if (lvlV) lvlV.textContent = `${slider * 10}%`; }
                            const det = document.getElementById(`osc${num}Detune`);
                            const detV = document.getElementById(`osc${num}DetuneValue`);
                            if (det) { det.value = String(Math.round(data.detune || 0)); if (detV) detV.textContent = `${Math.round(data.detune || 0)}¢`; }
                            const oct = document.getElementById(`osc${num}Octave`);
                            const octV = document.getElementById(`osc${num}OctaveValue`);
                            if (oct) { oct.value = String(data.octave || 0); if (octV) octV.textContent = String(data.octave || 0); }
                            const crs = document.getElementById(`osc${num}Coarse`);
                            const crsV = document.getElementById(`osc${num}CoarseValue`);
                            if (crs) { crs.value = String(data.coarse || 0); if (crsV) crsV.textContent = `${data.coarse || 0} steps`; }
                        } catch(_) {}
                    };
                    // ADSR 1
                    const a = document.getElementById('attackSlider');
                    const d = document.getElementById('decaySlider');
                    const s = document.getElementById('sustainSlider');
                    const r = document.getElementById('releaseSlider');
                    const av = document.getElementById('attackValue');
                    const dv = document.getElementById('decayValue');
                    const sv = document.getElementById('sustainValue');
                    const rv = document.getElementById('releaseValue');
                    if (a) { const ms = Math.round((this.instruments.strum1.env.attack||0)*1000); a.value = String(ms); if (av) av.textContent = `${ms}ms`; }
                    if (d) { const ms = Math.round((this.instruments.strum1.env.decay||0)*1000); d.value = String(ms); if (dv) dv.textContent = `${ms}ms`; }
                    if (s) { const pct = Math.round((this.instruments.strum1.env.sustain||0)*100); s.value = String(pct); if (sv) sv.textContent = `${pct}%`; }
                    if (r) { const ms = Math.round((this.instruments.strum1.env.release||0)*1000); r.value = String(ms); if (rv) rv.textContent = `${ms}ms`; }
                    // ADSR 2
                    const a2 = document.getElementById('osc2AttackSlider');
                    const d2 = document.getElementById('osc2DecaySlider');
                    const s2 = document.getElementById('osc2SustainSlider');
                    const r2 = document.getElementById('osc2ReleaseSlider');
                    const a2v = document.getElementById('osc2AttackValue');
                    const d2v = document.getElementById('osc2DecayValue');
                    const s2v = document.getElementById('osc2SustainValue');
                    const r2v = document.getElementById('osc2ReleaseValue');
                    if (a2) { const ms = Math.round((this.instruments.strum2.env.attack||0)*1000); a2.value = String(ms); if (a2v) a2v.textContent = `${ms}ms`; }
                    if (d2) { const ms = Math.round((this.instruments.strum2.env.decay||0)*1000); d2.value = String(ms); if (d2v) d2v.textContent = `${ms}ms`; }
                    if (s2) { const pct = Math.round((this.instruments.strum2.env.sustain||0)*100); s2.value = String(pct); if (s2v) s2v.textContent = `${pct}%`; }
                    if (r2) { const ms = Math.round((this.instruments.strum2.env.release||0)*1000); r2.value = String(ms); if (r2v) r2v.textContent = `${ms}ms`; }
                    // Waves and per-osc UI
                    syncOscUi(1, this.oscillators.osc1);
                    syncOscUi(2, this.oscillators.osc2);
                }
            }
            // ================== EFFECTS PRESETS ==================
            getEffectsPresets() {
                const key = 'omni_fx_presets_v1';
                try { const raw = localStorage.getItem(key); const list = raw ? JSON.parse(raw) : []; return Array.isArray(list)? list: []; } catch(_) { return []; }
            }
            saveEffectsPresets(list) {
                const key = 'omni_fx_presets_v1';
                try { localStorage.setItem(key, JSON.stringify(list.slice(0,200))); } catch(_) {}
            }
            populateEffectsPresetDropdown(selectEl) {
                if (!selectEl) return; const list = this.getEffectsPresets(); selectEl.innerHTML='';
                const def=document.createElement('option'); def.value=''; def.textContent='Choose preset'; selectEl.appendChild(def);
                list.forEach(p=>{ const opt=document.createElement('option'); opt.value=p.id; opt.textContent=p.name||p.id; selectEl.appendChild(opt); });
            }
            captureEffectsState() {
                return {
                    drive: {
                        amount: parseFloat(document.getElementById('driveAmount')?.value || 0),
                        mix: parseFloat(document.getElementById('driveMix')?.value || 0),
                        hp: parseFloat(document.getElementById('driveHpCutoff')?.value || 0),
                        lp: parseFloat(document.getElementById('driveLpCutoff')?.value || 100)
                    },
                    delay: {
                        timeMs: parseFloat(document.getElementById('delayTime')?.value || 280),
                        feedback: parseFloat(document.getElementById('delayFeedback')?.value || 0),
                        lp: parseFloat(document.getElementById('delayLpCutoff')?.value || 73),
                        hp: parseFloat(document.getElementById('delayHpCutoff')?.value || 0),
                        mix: parseFloat(document.getElementById('delayMix')?.value || 0)
                    },
                    filters: {
                        low: parseFloat(document.getElementById('filterLow')?.value || 0),
                        high: parseFloat(document.getElementById('filterHigh')?.value || 100),
                        q: parseFloat(document.getElementById('filterRes')?.value || 1)
                    },
                    reverb: {
                        wet: parseFloat(document.getElementById('reverbWet')?.value || 1),
                        room: parseFloat(document.getElementById('reverbRoom')?.value || 5),
                        decay: parseFloat(document.getElementById('reverbDecay')?.value || 20),
                        lp: parseFloat(document.getElementById('reverbFilterCutoff')?.value || 70),
                        hp: parseFloat(document.getElementById('reverbHpCutoff')?.value || 0)
                    },
                    panning: {
                        mode: document.getElementById('panningMode')?.value || 'center',
                        width: parseFloat(document.getElementById('panningWidth')?.value || 80),
                        speedMs: parseFloat(document.getElementById('panningSpeed')?.value || 2000)
                    }
                };
            }
            applyEffectsState(state) {
                if (!state) return;
                try {
                    const setVal = (id, val, textFormatter)=>{ const el=document.getElementById(id); if(el){ el.value=String(val); const vEl=document.getElementById(id+"Value"); if(vEl){ vEl.textContent = textFormatter? textFormatter(val): String(val); } el.dispatchEvent(new Event('input')); } };
                    if (state.drive){ setVal('driveAmount', state.drive.amount, v=> `${Math.round(v)}%`); setVal('driveMix', state.drive.mix, v=> `${Math.round(v)}%`); setVal('driveHpCutoff', state.drive.hp); setVal('driveLpCutoff', state.drive.lp); }
                    if (state.delay){ setVal('delayTime', state.delay.timeMs, v=> `${Math.round(v)}ms`); setVal('delayFeedback', state.delay.feedback, v=> `${Math.round(v)}%`); setVal('delayLpCutoff', state.delay.lp); setVal('delayHpCutoff', state.delay.hp); setVal('delayMix', state.delay.mix, v=> `${Math.round(v)}%`); }
                    if (state.filters){ setVal('filterLow', state.filters.low); setVal('filterHigh', state.filters.high); setVal('filterRes', state.filters.q, v=> `Q ${Number(v).toFixed(1)}`); }
                    if (state.reverb){ setVal('reverbWet', state.reverb.wet, v=> `${Math.round(v*10)}%`); setVal('reverbRoom', state.reverb.room, v=> `${Math.round((v||0)*10)}%`); setVal('reverbDecay', state.reverb.decay, v=> `${(Number(v)/10).toFixed(1)}s`); setVal('reverbFilterCutoff', state.reverb.lp); setVal('reverbHpCutoff', state.reverb.hp); }
                    if (state.panning){ const pm=document.getElementById('panningMode'); if(pm) { pm.value = state.panning.mode||'center'; pm.dispatchEvent(new Event('change')); } setVal('panningWidth', state.panning.width, v=> `${Math.round(v)}%`); setVal('panningSpeed', state.panning.speedMs, v=> `${(Number(v)/1000).toFixed(1)}s`); }
                } catch(_) {}
            }
            wireEffectsPresetsUI() {
                const sel = document.getElementById('effectsPresetSelect');
                const btnApply = document.getElementById('effectsPresetApply');
                const btnSave = document.getElementById('effectsPresetSave');
                const btnDel  = document.getElementById('effectsPresetDelete');
                if (sel) this.populateEffectsPresetDropdown(sel);
                if (btnApply) btnApply.addEventListener('click', ()=>{ const id=sel?.value||''; if(!id) return; const list=this.getEffectsPresets(); const found=list.find(p=>p.id===id); if(found) this.applyEffectsState(found.state); });
                if (btnSave) btnSave.addEventListener('click', ()=>{ const name=prompt('Preset name?','My FX'); if(!name) return; const list=this.getEffectsPresets(); const id=`FX${Date.now()}`; list.unshift({ id, name, state: this.captureEffectsState() }); this.saveEffectsPresets(list); if (sel){ this.populateEffectsPresetDropdown(sel); sel.value=id; } });
                if (btnDel) btnDel.addEventListener('click', ()=>{ const id=sel?.value||''; if(!id) return; const list=this.getEffectsPresets(); const next=list.filter(p=>p.id!==id); this.saveEffectsPresets(next); if (sel) this.populateEffectsPresetDropdown(sel); });
            }
            wireInstrumentPresetsUI() {
                const sel = document.getElementById('instrumentPresetSelect');
                const btnApply = document.getElementById('instrumentPresetApply');
                const btnSave = document.getElementById('instrumentPresetSave');
                const btnDel = document.getElementById('instrumentPresetDelete');
                if (sel) this.populateInstrumentPresetDropdown(sel);
                if (btnApply) btnApply.addEventListener('click', () => {
                    const id = sel?.value || '';
                    if (!id) return;
                    const list = this.getInstrumentPresets();
                    const found = list.find(p => p.id === id);
                    if (found) this.applyInstrumentState(found.state);
                });
                if (btnSave) btnSave.addEventListener('click', () => {
                    const name = prompt('Preset name?','My Instrument');
                    if (!name) return;
                    const list = this.getInstrumentPresets();
                    const id = `P${Date.now()}`;
                    list.unshift({ id, name, state: this.captureInstrumentState() });
                    this.saveInstrumentPresets(list);
                    if (sel) { this.populateInstrumentPresetDropdown(sel); sel.value = id; }
                });
                if (btnDel) btnDel.addEventListener('click', () => {
                    const id = sel?.value || '';
                    if (!id) return;
                    const list = this.getInstrumentPresets();
                    const next = list.filter(p => p.id !== id);
                    this.saveInstrumentPresets(next);
                    if (sel) this.populateInstrumentPresetDropdown(sel);
                });
            }

            runTextChordParsing() {
                const input = document.getElementById('textChordInput');
                const resultsGrid = document.getElementById('textChordResults');
                const countEl = document.getElementById('textChordCount');
                if (!input || !resultsGrid || !countEl) return;
                const text = input.value || '';
                // Always convert Roman numerals inline while leaving ordinary chord tokens as-is
                const material = this.convertRomanNumeralsInline(text);
                // Build a unique chord palette (deduped, first-appearance order)
                const unique = this.extractUniqueChordsFromEntireText(material);
                // Render clickable cards that append to textarea
                resultsGrid.innerHTML = '';
                unique.forEach(ch => {
                    const card = document.createElement('div');
                    card.style.cssText = 'padding:10px; border:1px solid #2b5567; border-radius:8px; background:#102a3a; color:#e8f5ff; font-family:var(--retro-font); display:flex; align-items:center; justify-content:center; min-height:46px;';
                    card.textContent = ch;
                    card.tabIndex = 0;
                    card.style.cursor = 'pointer';
                    const append = ()=>{
                        const ta = document.getElementById('textChordInput');
                        if (!ta) return;
                        const sep = /[\s\n]$/.test(ta.value || '') || !ta.value ? '' : ' ';
                        ta.value = (ta.value || '') + sep + ch;
                        ta.focus();
                        ta.setSelectionRange(ta.value.length, ta.value.length);
                        ta.dispatchEvent(new Event('input'));
                    };
                    card.addEventListener('click', append);
                    card.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); append(); } });
                    resultsGrid.appendChild(card);
                });
                countEl.textContent = String(unique.length);
                // Keep last palette for potential future use
                this._lastParsedChordsPalette = unique;
            }

            // New: create sequence from current textarea content; honors Roman detection and Repeat Unique Sections
            createSequenceFromTextarea() {
                const input = document.getElementById('textChordInput');
                const modal = document.getElementById('textChordModal');
                if (!input) return;
                let text = input.value || '';
                
                // Auto-wrap sequences in brackets if not already present to ensure looping
                const trimmed = text.trim();
                if (trimmed && !trimmed.startsWith('[') && !trimmed.includes('[')) {
                    text = '[' + trimmed + ']';
                    console.log('🎵 Auto-wrapped sequence in brackets for looping:', text);
                }
                
                const material = this.convertRomanNumeralsInline(text);
                
                // ALWAYS use bracket-aware parsing for proper repeat marker support
                const list = this.extractChordsFromTextPreserveOrder(material);
                
                try { console.log('[SEQ] material =', material, '| list =', list, '| EDO =', this.currentTuning); } catch {}
                if (!list.length) return;
                // Reset global transpose and rebuild
                this.transposeDelta = 0;
                const deltaEl = document.getElementById('transposeDelta');
                if (deltaEl) deltaEl.textContent = '0';
                this.autoCreateColumnsFromText(list);
                if (modal) modal.style.display='none';
            }

            // Unique chords across the entire text in order of first appearance
            extractUniqueChordsFromEntireText(text) {
                const out = [];
                const seen = new Set();
                if (!text) return out;
                const lines = String(text).split(/\r?\n/);
                for (const line of lines) {
                    const s = line.trim();
                    if (!s) continue;
                    const matches = this.scanChordMatches(s);
                    for (const m of matches) {
                        const norm = this.normalizeChordToken(m.raw);
                        if (!norm) continue;
                        if (!seen.has(norm)) { seen.add(norm); out.push(norm); }
                    }
                }
                return out;
            }

            // Heuristic: consider this text a Roman sequence only if most tokens are Roman numerals (with optional degree accidentals and extensions)
            isRomanSequence(text) {
                if (!text) return false;
                const tokens = [];
                String(text).split(/\r?\n/).forEach(line => {
                    line.split(/[\s\|]+|[–—-]/g).map(s=>s.trim()).filter(Boolean).forEach(t=>tokens.push(t));
                });
                if (tokens.length === 0) return false;
                // Roman token: optional leading b/#, then roman (I,II,III,IV,V,VI,VII in any case), optional extension tail
                const romanRe = /^(?:b+|#+)?(?:i{1,3}|iv|v|vi{0,3}|I{1,3}|IV|V|VI{0,3})(?:maj7|M7|Δ7|m7|7|9|11|13|maj9|M9|Δ9|add(?:9|11|13)|[#b](?:5|9|11|13))?$/;
                let romanCount = 0;
                for (const tok of tokens) {
                    if (romanRe.test(tok)) romanCount++;
                }
                if (romanCount === 0) return false;
                // Require a majority to avoid mixing modes
                return romanCount / tokens.length >= 0.6;
            }

            // Detect unique repeating blocks from multi-line input; returns array of arrays (each block => list of chords).
            extractUniqueBlocks(text) {
                if (!text) return [];
                const lines = String(text).split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
                const out = [];
                const seen = new Set();
                for (const line of lines) {
                    const tokens = this.extractUniqueChordsFromText(line);
                    if (!tokens.length) continue;
                    const key = tokens.join(' ');
                    if (!seen.has(key)) { seen.add(key); out.push(tokens); }
                }
                return out;
            }

            // New: Extract chords in order (no dedupe), across lines, preserving repeats
            // Now supports bracket notation: [C F G Am x4 Am F G C x 4] x4
            extractChordsFromTextPreserveOrder(text) {
                if (!text) return [];
                
                // Parse for VISUAL DISPLAY - keep compact form with repeat markers
                const compactChords = this.parseCompactChordSequence(text);
                console.log('🎵 Compact parsing:', text, '→', compactChords);
                
                // Debug log the parsed structure  
                const debugStructure = compactChords.map(item => {
                    if (item.startsWith('__REPEAT_')) return `[REPEAT:${item.replace('__REPEAT_', '').replace('__', '')}]`;
                    if (item.startsWith('__BRACKET_')) return `[BRACKET:${item.replace('__BRACKET_', '').replace('__', '')}]`;
                    if (item === '__SECTION__') return '[SECTION]';
                    return item;
                });
                console.log('🎵 Parsed structure:', debugStructure.join(' | '));
                
                return compactChords;
            }

            // Parse compact chord sequence keeping repeat markers for visual display
            parseCompactChordSequence(text) {
                if (!text || typeof text !== 'string') return [];
                
                const lines = String(text).split(/\r?\n/);
                const out = [];
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (!trimmed) continue;
                    
                    // Handle section separators
                    const s = trimmed.replace(/(^|\s)[^\s|:]+\s*:\s*/g, ' | ');
                    const sections = s.split('|');
                    
                    sections.forEach((seg, idx) => {
                        const segment = seg.trim();
                        if (!segment) return;
                        
                        // Parse bracket notation for compact display
                        const parsedSegment = this.parseSegmentWithRepeats(segment);
                        out.push(...parsedSegment);
                        
                        if (idx < sections.length - 1) out.push('__SECTION__');
                    });
                }
                
                return out;
            }

            // Expand compact sequence for playback (expands all repeats)
            expandSequenceForPlayback(compactSequence) {
                console.log('🎵 Expanding sequence for playbook:', compactSequence);
                
                // Check if loop is enabled
                const loopToggle = document.getElementById('loopToggle');
                const loopEnabled = loopToggle ? loopToggle.checked : true;
                
                const expanded = [];
                let i = 0;

                const isMarker = (t)=> typeof t === 'string' && t.startsWith('__');
                const isChord = (t)=> typeof t === 'string' && !t.startsWith('__');

                while (i < compactSequence.length) {
                    const token = compactSequence[i];

                    // Case 1: Combined bracket end+repeat e.g., __BRACKET_END_REPEAT_L1_4__
                    if (typeof token === 'string' && token.match(/^__BRACKET_END_REPEAT_L\d+_\d+__$/)) {
                        const m = token.match(/^__BRACKET_END_REPEAT_L(\d+)_(\d+)__$/);
                        const level = parseInt(m[1], 10);
                        const count = Math.max(1, parseInt(m[2], 10));
                        console.log('🎵 Bracket END-REPEAT found:', token, 'level:', level, 'count:', count);

                        // Only process repeats if loop is enabled
                        if (loopEnabled) {
                            // Collect chords since the matching BRACKET_START of the same level
                            const slice = [];
                            let j = expanded.length - 1;
                            while (j >= 0) {
                                const prev = expanded[j];
                                if (typeof prev === 'string' && prev === `__BRACKET_START_L${level}__`) {
                                    break; // reached the boundary for this level
                                }
                                if (isChord(prev)) {
                                    slice.unshift(prev);
                                }
                                // Skip markers of any kind (including inner bracket markers and repeat tokens)
                                j--;
                            }
                            console.log('🎵 Slice to repeat (level', level, '):', slice);
                            for (let rep = 1; rep < count; rep++) {
                                expanded.push(...slice);
                            }
                        }
                        // We can drop the combined marker for playback (structure only)
                        i++;
                        continue;
                    }

                    // Case 2: Inline repeat markers (old + colored): __REPEAT_4__ or __REPEAT_L1_3__
                    if (typeof token === 'string' && (token.startsWith('__REPEAT_') || token.match(/^__REPEAT_L\d+_\d+__$/))) {
                        let count;
                        if (token.match(/^__REPEAT_L\d+_(\d+)__$/)) {
                            const match = token.match(/^__REPEAT_L\d+_(\d+)__$/);
                            count = parseInt(match[1], 10);
                        } else {
                            count = parseInt(token.replace('__REPEAT_', '').replace('__', ''), 10);
                        }
                        console.log('🎵 Inline repeat marker:', token, 'count:', count);
                        // Repeat only the immediately preceding chord (ignore markers)
                        let k = expanded.length - 1; let prevChord = null;
                        while (k >= 0) {
                            if (isChord(expanded[k])) { prevChord = expanded[k]; break; }
                            k--;
                        }
                        if (prevChord) {
                            for (let rep = 1; rep < count; rep++) expanded.push(prevChord);
                        }
                        i++;
                        continue;
                    }

                    // Case 3: Structural bracket markers (kept temporarily for boundary detection)
                    if (typeof token === 'string' && token.match(/^__BRACKET_(START|END)_L\d+__$/)) {
                        expanded.push(token);
                        i++;
                        continue;
                    }

                    // Case 4: Regular chords
                    if (isChord(token)) {
                        expanded.push(token);
                        i++;
                        continue;
                    }

                    // Case 5: Other tokens like sections, drum maps, etc.
                    expanded.push(token);
                    i++;
                }

                // Remove bracket/repeat markers from final expanded sequence (keep only chords and sections)
                const finalExpanded = expanded.filter(t =>
                    typeof t === 'string' &&
                    !t.startsWith('__BRACKET_') &&
                    !t.startsWith('__REPEAT_')
                );

                console.log('🎵 Final expanded playback sequence:', finalExpanded);
                return finalExpanded;
            }

            // Parse a segment with bracket and repeat notation, keeping structure compact
            parseSegmentWithRepeats(segment) {
                // Use the new nested bracket parser
                return this.parseNestedBrackets(segment);
            }

            // Advanced bracket parser that handles nesting: [[Am F]x4 [C F G]x2]x4 Cx4
            parseNestedBrackets(text, nestLevel = 0) {
                const out = [];
                let i = 0;
                
                console.log('🎵 Parsing nested brackets:', text, 'at nest level', nestLevel);
                
                while (i < text.length) {
                    // Skip whitespace
                    while (i < text.length && /\s/.test(text[i])) i++;
                    if (i >= text.length) break;
                    
                    const char = text[i];
                    
                    if (char === '[') {
                        // Find matching closing bracket, handling nesting
                        const bracketContent = this.extractBracketContent(text, i);
                        if (bracketContent) {
                            const { content, endIndex, repeatCount } = bracketContent;
                            
                            console.log('🎵 Found bracket:', { content, repeatCount, nestLevel, fullMatch: text.slice(i, endIndex + 1) });
                            
                            // Add colored bracket start marker
                            out.push(`__BRACKET_START_L${nestLevel}__`);
                            
                            // Recursively parse bracket content (increment nest level)
                            const innerParsed = this.parseNestedBrackets(content, nestLevel + 1);
                            
                            // Add bracket content ONCE for visual display
                            out.push(...innerParsed);
                            
                            // Add combined bracket end and repeat marker
                            if (repeatCount > 1) {
                                out.push(`__BRACKET_END_REPEAT_L${nestLevel}_${repeatCount}__`);
                            } else {
                                out.push(`__BRACKET_END_L${nestLevel}__`);
                            }
                            
                            i = endIndex + 1; // Move past the entire bracket construct
                            continue;
                        } else {
                            console.warn('🎵 Malformed bracket at position', i, 'in text:', text);
                            i++; // Skip malformed bracket
                            continue;
                        }
                    }

                    // New: Curly-brace drum pattern mapping, e.g. {1x3}{2} or {1x3 2}
                    if (char === '{') {
                        const cmap = this.extractCurlyDrumMap(text, i);
                        if (cmap) {
                            const { patterns, endIndex } = cmap;
                            // Encode as a compact token for later assignment during column creation
                            const token = `__DRMAP_${patterns.join('_')}__`;
                            out.push(token);
                            i = endIndex + 1;
                            continue;
                        } else {
                            console.warn('🎵 Malformed curly directive at position', i, 'in text:', text);
                            i++;
                            continue;
                        }
                    }
                    
                    // Not a bracket - extract regular chords and inline repeats
                    const segment = this.extractNextSegment(text, i, nestLevel);
                    if (segment) {
                        const { chords, endIndex } = segment;
                        out.push(...chords);
                        i = endIndex + 1;
                    } else {
                        i++; // Skip unrecognized characters
                    }
                }
                
                console.log('🎵 Nested parsing result (compact for visual, level', nestLevel, '):', out);
                return out;
            }

            // Parse a curly-brace drum map directive starting at '{'
            extractCurlyDrumMap(text, startIndex) {
                if (text[startIndex] !== '{') return null;
                let i = startIndex + 1;
                let content = '';
                let foundClose = false;
                while (i < text.length) {
                    const ch = text[i];
                    if (ch === '}') { foundClose = true; break; }
                    content += ch;
                    i++;
                }
                if (!foundClose) return null;
                // content may be like "1x3 2" or "1 x 3, 2" etc.
                const tokens = content.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean);
                const patterns = [];
                for (const tok of tokens) {
                    const m = tok.match(/^(\d+)(?:[xX](\d+))?$/);
                    if (!m) continue;
                    const num = parseInt(m[1], 10);
                    const rep = Math.max(1, parseInt(m[2] || '1', 10));
                    for (let r = 0; r < rep; r++) patterns.push(num);
                }
                return { patterns, endIndex: i };
            }

            // Extract bracket content with proper nesting support
            extractBracketContent(text, startIndex) {
                if (text[startIndex] !== '[') return null;
                
                let depth = 0;
                let i = startIndex;
                
                // Find matching closing bracket
                while (i < text.length) {
                    if (text[i] === '[') depth++;
                    else if (text[i] === ']') depth--;
                    
                    if (depth === 0) break;
                    i++;
                }
                
                if (depth !== 0) return null; // Unmatched bracket
                
                const content = text.slice(startIndex + 1, i).trim();
                let endIndex = i;
                
                // Check for repeat notation after closing bracket: ]x4 or ] x4
                let j = i + 1;
                
                // Skip whitespace after closing bracket
                while (j < text.length && /\s/.test(text[j])) j++;
                
                // Look for 'x' or 'X' followed by digits
                let repeatCount = 1;
                if (j < text.length && /[xX]/.test(text[j])) {
                    j++; // Skip 'x'
                    
                    // Skip whitespace after 'x'
                    while (j < text.length && /\s/.test(text[j])) j++;
                    
                    // Extract number
                    let numStr = '';
                    while (j < text.length && /\d/.test(text[j])) {
                        numStr += text[j];
                        j++;
                    }
                    
                    if (numStr) {
                        repeatCount = parseInt(numStr, 10);
                        endIndex = j - 1; // Point to last digit
                    }
                }
                
                console.log('🎵 Extracted bracket:', { content, repeatCount, originalText: text.slice(startIndex, endIndex + 1) });
                return { content, endIndex, repeatCount };
            }

            // Extract next chord segment (handles inline repeats like Cx4, and standalone brackets)
            extractNextSegment(text, startIndex, nestLevel = 0) {
                // Skip whitespace
                while (startIndex < text.length && /\s/.test(text[startIndex])) {
                    startIndex++;
                }
                
                if (startIndex >= text.length) return null;
                
                // Check for standalone bracket symbols: [ or ]
                if (text[startIndex] === '[' && (startIndex === 0 || /\s/.test(text[startIndex - 1]))) {
                    // Check if this is a standalone [ (not part of bracket notation)
                    const nextChar = startIndex + 1 < text.length ? text[startIndex + 1] : '';
                    if (!nextChar || /\s/.test(nextChar)) {
                        // Standalone left bracket - create repeat marker
                        return { 
                            chords: ['__LEFT_BRACKET__'], 
                            endIndex: startIndex 
                        };
                    }
                }
                
                if (text[startIndex] === ']' && (startIndex === 0 || /\s/.test(text[startIndex - 1]))) {
                    // Check if this is a standalone ] (not part of bracket notation)
                    const nextChar = startIndex + 1 < text.length ? text[startIndex + 1] : '';
                    if (!nextChar || /\s/.test(nextChar)) {
                        // Standalone right bracket - create repeat marker
                        return { 
                            chords: ['__RIGHT_BRACKET__'], 
                            endIndex: startIndex 
                        };
                    }
                }
                
                // Extract token until next bracket or whitespace
                let endIndex = startIndex;
                while (endIndex < text.length && 
                       text[endIndex] !== '[' && 
                       text[endIndex] !== ']' && 
                       !/\s/.test(text[endIndex])) {
                    endIndex++;
                }
                
                const token = text.slice(startIndex, endIndex).trim();
                if (!token) return null;
                
                console.log('🎵 Extracting segment:', token);
                
                const chords = [];
                
                // Handle inline repeat: Cx4, Amx2, etc.
                const inlineMatch = token.match(/^(.+?)[xX](\d+)$/);
                if (inlineMatch) {
                    const chordName = inlineMatch[1];
                    const chord = this.normalizeChordToken(chordName);
                    if (chord) {
                        const count = parseInt(inlineMatch[2], 10);
                        console.log('🎵 Inline repeat found:', chordName, 'x', count);
                        
                        // For VISUAL DISPLAY: show chord ONCE followed by repeat marker
                        // This creates compact display like: C x4 (not C C C C x4)
                        chords.push(chord);
                        
                        // Add visual repeat marker with nest level color if count > 1
                        if (count > 1) {
                            chords.push(`__REPEAT_L${nestLevel}_${count}__`);
                        }
                    }
                } else {
                    // Regular chord - but make sure it's not a repeat marker like "x4"
                    if (!/^[xX]\d+$/.test(token)) {
                        const chord = this.normalizeChordToken(token);
                        if (chord) {
                            console.log('🎵 Regular chord:', chord);
                            chords.push(chord);
                        }
                    } else {
                        console.warn('🎵 Skipping standalone repeat marker:', token);
                    }
                }
                
                return { chords, endIndex: endIndex - 1 };
            }

            // Parse bracket content handling inner x patterns: "C F G Am x4"
            parseInnerBracketContent(content) {
                console.log('🎵 Parsing inner bracket content:', content);
                const out = [];
                const tokens = content.split(/\s+/);
                console.log('🎵 Tokens:', tokens);
                
                for (let i = 0; i < tokens.length; i++) {
                    const token = tokens[i];
                    console.log('🎵 Processing token:', token, 'at index', i);
                    
                    // Skip empty tokens
                    if (!token.trim()) continue;
                    
                    // Check for "chord x N" pattern
                    if (i < tokens.length - 2) {
                        const nextToken = tokens[i + 1];
                        const countToken = tokens[i + 2];
                        
                        if ((nextToken === 'x' || nextToken === 'X') && /^\d+$/.test(countToken)) {
                            console.log('🎵 Found spaced repeat pattern:', token, nextToken, countToken);
                            const chord = this.normalizeChordToken(token);
                            if (chord) {
                                out.push(chord);
                                const repeatCount = parseInt(countToken, 10);
                                if (repeatCount > 1) {
                                    out.push(`__REPEAT_${repeatCount}__`);
                                    console.log('🎵 Added inner repeat marker:', `__REPEAT_${repeatCount}__`);
                                }
                            }
                            i += 2; // Skip 'x' and count
                            continue;
                        }
                    }
                    
                    // Check for inline pattern: "Amx4"
                    const inlineMatch = token.match(/^(.+?)[xX](\d+)$/);
                    if (inlineMatch) {
                        console.log('🎵 Found inline repeat pattern:', token, '->', inlineMatch[1], 'x', inlineMatch[2]);
                        const chord = this.normalizeChordToken(inlineMatch[1]);
                        if (chord) {
                            out.push(chord);
                            const count = parseInt(inlineMatch[2], 10);
                            if (count > 1) {
                                out.push(`__REPEAT_${count}__`);
                                console.log('🎵 Added inline repeat marker:', `__REPEAT_${count}__`);
                            }
                        }
                        continue;
                    }
                    
                    // Regular chord
                    const chord = this.normalizeChordToken(token);
                    if (chord) {
                        console.log('🎵 Added regular chord:', chord);
                        out.push(chord);
                    } else {
                        console.log('🎵 Token not recognized as chord:', token);
                    }
                }
                
                console.log('🎵 Inner bracket result:', out);
                return out;
            }

            // Extract chords from simple text without repeat notation
            extractChordsFromSimpleText(text) {
                const out = [];
                const matches = this.scanChordMatches(text);
                for (const m of matches) {
                    const token = m.raw.trim();
                    
                    // Skip repeat notation that might have slipped through
                    if (/^[xX]\d+$/.test(token)) {
                        console.log('🎵 Skipping repeat token in chord extraction:', token);
                        continue;
                    }
                    
                    const norm = this.normalizeChordToken(token);
                    if (norm) out.push(norm);
                }
                return out;
            }

            // Expand chord sequence for PLAYBACK only (when actually playing music)
            expandChordSequenceForPlayback(compactChords) {
                const expanded = [];
                
                for (let i = 0; i < compactChords.length; i++) {
                    const item = compactChords[i];
                    
                    if (item === '__SECTION__') {
                        expanded.push(item);
                        continue;
                    }
                    
                    if (item.startsWith('__REPEAT_')) {
                        const count = parseInt(item.replace('__REPEAT_', '').replace('__', ''), 10);
                        const prevChord = expanded[expanded.length - 1];
                        if (prevChord && !prevChord.startsWith('__')) {
                            // Repeat the previous chord (count-1) more times
                            for (let r = 1; r < count; r++) {
                                expanded.push(prevChord);
                            }
                        }
                        continue;
                    }
                    
                    if (item.startsWith('__BRACKET_')) {
                        // Skip bracket markers in playback
                        continue;
                    }
                    
                    expanded.push(item);
                }
                
                return expanded;
            }

            // Presets management in localStorage
            getSequencePresets() {
                const keyNew = 'omni_seq_presets_v4';
                const keyOld = 'omni_seq_presets_v3';
                // Load new
                let listObj = [];
                try { listObj = JSON.parse(localStorage.getItem(keyNew)) || []; } catch(_) { listObj = []; }
                if (!Array.isArray(listObj) || !listObj.length) {
                    // Try migrate from v3 strings
                    let old = [];
                    try { old = JSON.parse(localStorage.getItem(keyOld)) || []; } catch(_) { old = []; }
                    if (Array.isArray(old) && old.length) {
                        const migrated = old.map(s => {
                            const nameMatch = String(s).match(/\(([^)]+)\)\s*$/);
                            const name = nameMatch ? nameMatch[1] : 'Preset';
                            const text = String(s).replace(/\s*\([^)]*\)\s*$/, '');
                            return { id: `S${Date.now()}_${Math.random().toString(36).slice(2,8)}`, name, text, edo: this.currentTuning || 24 };
                        });
                        listObj = migrated;
                        try { localStorage.setItem(keyNew, JSON.stringify(listObj)); } catch(_) {}
                    } else {
                        // Seed with defaults
            const defs = this.getDefaultSequencePresets();
            listObj = defs.map(s=>{ const nameMatch = String(s).match(/\(([^)]+)\)\s*$/); const name = nameMatch ? nameMatch[1] : 'Preset'; const text = String(s).replace(/\s*\([^)]*\)\s*$/, ''); return { id:`S${Date.now()}_${Math.random().toString(36).slice(2,8)}`, name, text, edo: this.currentTuning || 24, fx: null }; });
                        try { localStorage.setItem(keyNew, JSON.stringify(listObj)); } catch(_) {}
                    }
                }
                // Always merge in any new defaults added by the app author without removing user presets
                try {
                    const existing = Array.isArray(listObj) ? listObj.slice() : [];
                    const defs = this.getDefaultSequencePresets();
                    const toEntry = (s)=>{
                        const nm = String(s || '');
                        const nameMatch = nm.match(/\(([^)]+)\)\s*$/);
                        const name = nameMatch ? nameMatch[1] : 'Preset';
                        const text = nm.replace(/\s*\([^)]*\)\s*$/, '');
                        return { id: `DEF_${name.toLowerCase().replace(/[^a-z0-9]+/g,'-')}_${text.toLowerCase().replace(/[^a-z0-9]+/g,'-').slice(0,20)}`, name, text, edo: this.currentTuning || 24, fx: null, _isDefault: true };
                    };
                    const defaults = defs.map(toEntry);
                    const norm = (s)=> String(s || '').trim().toLowerCase().replace(/\s+/g,' ');
                    const haveName = new Set(existing.map(p=> norm(p.name)));
                    const haveText = new Set(existing.map(p=> norm(p.text)));
                    const merged = existing.slice();
                    for (const d of defaults){
                        const nameKey = norm(d.name);
                        const textKey = norm(d.text);
                        if (!haveName.has(nameKey) && !haveText.has(textKey)){
                            merged.push({ id: d.id, name: d.name, text: d.text, edo: d.edo, fx: d.fx || null });
                            haveName.add(nameKey); haveText.add(textKey);
                        }
                    }
                    // Persist back so future loads don't lose merged defaults
                    try { localStorage.setItem(keyNew, JSON.stringify(merged.slice(0, 200))); } catch(_) {}
                    return merged;
                } catch(_) {
                    return listObj;
                }
            }
            saveSequencePreset(preset) {
                const key = 'omni_seq_presets_v4';
                const list = this.getSequencePresets();
        const item = typeof preset === 'string' ? { text: preset.replace(/\s*\([^)]*\)\s*$/, ''), name: 'Saved', edo: this.currentTuning || 24 } : preset;
                if (!item || !item.text) return;
                const id = `S${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
        const entry = { 
            id, 
            name: item.name || 'Saved', 
            text: item.text, 
            edo: Math.max(5, Math.min(52, parseInt(item.edo||this.currentTuning||24))), 
            fx: item.fx || null,
            // Prefer explicit sequenceOrder; accept chordNames for backward compatibility
            sequenceOrder: (item.sequenceOrder && Array.isArray(item.sequenceOrder) && item.sequenceOrder.length)
                ? item.sequenceOrder
                : (Array.isArray(item.chordNames) && item.chordNames.length ? item.chordNames : null)
        };
                list.unshift(entry);
                try { localStorage.setItem(key, JSON.stringify(list.slice(0,100))); } catch(_) {}
            }
            populateSeqPresetDropdown(selectEl, list) {
                if (!selectEl) return;
                selectEl.innerHTML = '';
                // Default chooser option
                const def = document.createElement('option');
                def.value = '';
                def.textContent = 'Choose Preset';
                def.selected = true;
                def.disabled = false; // allow re-selecting empty to clear
                selectEl.appendChild(def);
                // Add presets with label = preset name
                list.forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p.id;
                    opt.textContent = (p.name || 'Preset').slice(0,80);
                    selectEl.appendChild(opt);
                });
            }
            getDefaultSequencePresets() {
                // A compact but comprehensive starter set
                return [
                    'C A^m E^m Ddim7 A^m Ebm  Bbm B^ E^m Abm6 Ebm Fsus4 F (Sunshine)',
                    'A^m D G^m E Am E G#vm D#v Fm C#vm Evm Bv (Headcase)',
                    'I–vi–IV–V (50s progression)',
                    'IV–V–I–vi (Doo-wop variant)',
                    'I–V–vi–IV (Pop progression)',
                    'I–IV–♭VII–IV (Mixolydian rock riff)',

                    'ii–V–I (251 cadence)',
                    'ii–♭II7–I (Tritone substitution cadence)',
                    'ii–♭III+–I (Augmented dominant substitute)',

                    'iv–III–♭II–I (Andalusian cadence)',
                    'ii–♭VII7–I (Backdoor progression)',

                    'I–viiø–III7–vi–II7–v–I7–IV7–iv–♭VII7–iii–VI7–♭iii–♭VI7–ii–V7–I–VI7–ii–V (Bird changes)',

                    'I–V–♭VII–IV (Chromatic 5–6 sequence)',
                    'vi–ii–V–I (Circle progression)',

                    'I–V–♭VI–V–III–V–I (Coltrane changes)',
                    'Bmaj7 D7 Gmaj7 Bb7 Ebmaj7 Am7 D7 Gmaj7 Bb7 Ebmaj7 F#7 Bmaj7 Fm7 Bb7 Ebmaj7 Am7 D7 Gmaj7 C#m7 F#7 Bmaj7 Fm7 Bb7 Ebmaj7 C#m7 F#7 (Giant Steps)',

                    'I–V–IV–IV–I–V–I–V (Eight-bar blues)',
                    'i–V–i–♭VII–♭III–♭VII–i–V–i–V–i–♭VII–♭III–♭VII–i–V–i (Folia)',
                    'V7–III7 (Irregular resolution)',
                    'I–IV–ii–V (Montgomery–Ward bridge)',
                    'I–V–vi–iii–IV–I–IV–V (Pachelbel’s Canon)',
                    'i–VII–i–V–III–VII–i–V–i (Passamezzo antico)',
                    'I–IV–I–V–I–IV–I–V–I (Passamezzo moderno)',
                    'III7–VI7–II7–V7 (Ragtime progression)',
                    'I–iv–ii–V | I–I7–iv–I–V–I | III7–VI7–II7–V7 (Rhythm changes)',

                    'I–IV–I–V–IV–I–V (Twelve-bar blues)',
                    'I–vi–ii–V (I–vi–ii–V progression)',
                    '♭VII–V7–I (♭VII cadence)',
                    'V–IV–I (V–IV–I turnaround)',
                    'I–♭VII–♭VI–♭VII (Aeolian rock cadence)',
                    'IV△7–V7–iii7–vi (IV–V–iii–vi progression)',
                    '♭VI–♭VII–I (Modal cadence)'
                ];
            }

            // Convert Roman numeral sequence to concrete chord names in current key
            convertRomanNumeralSequenceToChords(text) {
                const edo = this.currentTuning || 12;
                const keyStep = this.currentRoot || 0; // tonic
                const tokens = [];
                const lines = String(text).split(/\r?\n/);
                const pushLine = (s)=>{
                    // Turn any SectionLabel: into a separator. We accept letters/numbers/_ before colon
                    const normalized = s.replace(/(^|\s)[^\s|:]+\s*:\s*/g, ' | ');
                    // Preserve '|' as its own token; split other separators
                    const withPipes = normalized.replace(/\|/g, ' | ');
                    const parts = withPipes.split(/[\s]+|[–—-]/g).map(x=>x.trim()).filter(Boolean);
                    for (const p of parts) tokens.push(p);
                };
                lines.forEach(pushLine);
                const mapped = tokens.map(tok=> this.mapRomanTokenToChord(tok, keyStep, edo)).filter(t=>t!=null);
                return mapped.join(' ');
            }

            // Convert any Roman numerals inline while preserving other chord tokens and '|' separators
            convertRomanNumeralsInline(text){
                if (!text) return '';
                const edo = this.currentTuning || 12;
                const keyStep = this.currentRoot || 0;
                const outLines = [];
                const lines = String(text).split(/\r?\n/);
                for (const rawLine of lines){
                    // Normalize section headers to pipes and keep them as standalone tokens
                    let s = String(rawLine || '').replace(/(^|\s)[^\s|:]+\s*:\s*/g, ' | ');
                    s = s.replace(/\|/g, ' | ');
                    const parts = s.split(/[\s]+|[–—-]/g).map(x=>x.trim()).filter(Boolean);
                    const mapped = parts.map(p=>{
                        const m = this.mapRomanTokenToChord(p, keyStep, edo);
                        return m != null ? m : p;
                    });
                    outLines.push(mapped.join(' '));
                }
                return outLines.join('\n');
            }

            // Map one roman token (like bVII, ii, Vmaj7, iii7, bVI#11) to a chord name in current key
            mapRomanTokenToChord(tok, keyStep, edo) {
                // Normalize unicode flats/sharps
                if (tok === '|') return '|';
                let t = String(tok).replace(/♭/g,'b').replace(/♯/g,'#');
                // Extract accidental prefix for degree (b/# before the roman)
                const accMatch = t.match(/^(b+|#+)?/);
                const acc = (accMatch && accMatch[0]) || '';
                let rest = t.slice(acc.length);
                // Choose the longest matching roman token first to avoid splitting 'iv' into 'i'+'v'
                const romans = ['vii','vi','iv','iii','ii','v','i','VII','VI','IV','III','II','V','I'];
                let roman = null;
                for (const cand of romans) {
                    if (rest.startsWith(cand)) { roman = cand; break; }
                }
                if (!roman) return null;
                let tail = rest.slice(roman.length).trim();
                const isMinor = roman === roman.toLowerCase();
                // Map roman to diatonic degree in 12-TET steps (Ionian)
                const romanSteps = { i:0, ii:2, iii:4, iv:5, v:7, vi:9, vii:11 };
                const baseSemi = romanSteps[roman.toLowerCase()];
                if (baseSemi == null) return null;
                let semi = baseSemi;
                // Apply accidentals to degree
                for (const ch of acc) semi += (ch === 'b' ? -1 : 1);
                // Wrap
                semi = ((semi % 12) + 12) % 12;
                // Convert to EDO step offset from tonic for HEAD roman (relative to some reference key)
                const headDegreeStep = Math.round((semi * edo) / 12);
                let referenceKeyStep = keyStep; // may be replaced by target of "/"

                // Secondary functions e.g., V/ii, vii°7/V, iiø7/V
                // If tail contains "/<roman>" (optionally accidental), compute target key first
                let preSlash = tail; let postTail = '';
                let slashMatch = tail.match(/^(.*?)(?:\/(b+|#+)?(i{1,3}|iv|v|vi{0,3}|I{1,3}|IV|V|VI{0,3})([\^v]*))?(.*)$/);
                if (slashMatch) {
                    preSlash = (slashMatch[1] || '').trim();
                    const targetAcc = slashMatch[2] || '';
                    const targetRoman = slashMatch[3] || '';
                    const targetMicro = slashMatch[4] || '';
                    postTail = (slashMatch[5] || '').trim();
                    if (targetRoman) {
                        let targetSemi = romanSteps[targetRoman.toLowerCase()];
                        if (targetSemi != null) {
                            // apply accidentals to target degree
                            for (const ch of targetAcc) targetSemi += (ch === 'b' ? -1 : 1);
                            targetSemi = ((targetSemi % 12) + 12) % 12;
                            const targetDegreeStep = Math.round((targetSemi * edo) / 12);
                            let targetRoot = ((keyStep + targetDegreeStep) % edo + edo) % edo;
                            // optional micro on target
                            if (targetMicro) {
                                const ups2 = (targetMicro.match(/\^/g) || []).length;
                                const downs2 = (targetMicro.match(/v/g) || []).length;
                                targetRoot = (((targetRoot + ups2 - downs2) % edo) + edo) % edo;
                            }
                            referenceKeyStep = targetRoot; // Now interpret head roman relative to target key
                        }
                    }
                    // Keep the rest of the tail (quality/extensions) around the slash parts
                    tail = (preSlash + ' ' + (postTail || '')).trim();
                }

                // Now compute chord root relative to the chosen referenceKeyStep
                let rootStep = ((referenceKeyStep + headDegreeStep) % edo + edo) % edo;
                // Optional micro-step marks right after the numeral: e.g., ii^7, bVIIvv
                const microMatch = tail.match(/^([\^v]+)/);
                if (microMatch) {
                    const ups = (microMatch[1].match(/\^/g) || []).length;
                    const downs = (microMatch[1].match(/v/g) || []).length;
                    rootStep = (((rootStep + ups - downs) % edo) + edo) % edo;
                    tail = tail.slice(microMatch[1].length).trim();
                }
                // Preserve ^/v micro-steps in 24-EDO by using getRootNameForStep instead of getMicrotonalNoteName (which emits ↑/↓)
                const rootName = this.getRootNameForStep(rootStep, edo);
                // Determine basic quality from case unless tail already encodes explicit quality (maj/M/m/°/ø/+/sus)
                let canonicalTail = tail.replace(/△/g,'maj');
                const hasExplicitQuality = /^(?:maj|M|m|°|ø|\+|sus)/.test(canonicalTail);
                const quality = hasExplicitQuality ? '' : (isMinor ? 'm' : '');
                // Special-case: user expectation that 'VII7' denotes fully diminished seventh
                if (!isMinor && roman.toUpperCase() === 'VII' && /(?:^|\b)7(?![0-9])/.test(canonicalTail)) {
                    canonicalTail = canonicalTail.replace(/(?:^|\b)7(?![0-9])/, '°7');
                }
                const chord = `${rootName}${quality}${canonicalTail}`.trim();
                return this.normalizeChordToken(chord) || chord;
            }

            copyParsedChordsToClipboard() {
                const list = (this._lastParsedChordsList || []).join(', ');
                if (!navigator.clipboard) {
                    // Fallback
                    const ta = document.createElement('textarea');
                    ta.value = list; document.body.appendChild(ta); ta.select();
                    try { document.execCommand('copy'); } catch {}
                    ta.remove();
                    return;
                }
                navigator.clipboard.writeText(list).catch(()=>{});
            }

            // Create chord columns from a list of normalized chord strings, then lock each to its own root
            autoCreateColumnsFromText(chordList) {
                // Replace the current grid with this sequence
                this.chordExtensions = [];
                // Reset visibility and any prior locks so board truly clears
                this.hiddenColumns = [];
                this.lockedChords = new Map();
                this.pianoLockedChords = new Map();
                const beforeLen = 0;
                const created = [];
                const curEDO = this.currentTuning || 24;
                
                // Track repeat groups for visual representation
                let repeatGroupCount = 1;
                let insideBracket = false;
                
                // Buffer curly drum-map tokens encountered after a chord block (e.g., {1x3}{2})
                let drumMapBuffer = [];
                
                // Check if sequence already has loop markers
                let hasStartMarker = false;
                let hasEndMarker = false;
                for (let i = 0; i < chordList.length; i++) {
                    const item = chordList[i];
                    if (item === '__BRACKET_START__' || (typeof item === 'string' && item.trim() === '[')) {
                        hasStartMarker = true;
                    }
                    if (item === '__BRACKET_END__' || (typeof item === 'string' && item.trim().match(/^\](?:x\d+)?$/))) {
                        hasEndMarker = true;
                    }
                }
                
                // Auto-add loop markers if missing and sequence has content
                const hasActualChords = chordList.some(item => 
                    typeof item === 'string' && 
                    !item.startsWith('__') && 
                    !item.match(/^[\[\]x\d\s]*$/) &&
                    item.trim() !== ''
                );
                
                if (hasActualChords && !hasStartMarker) {
                    // Add opening bracket
                    this.chordExtensions.push({
                        name: '[',
                        isCustom: true,
                        isRepeatMarker: true,
                        nestLevel: 0,
                        id: 'auto_bracket_start_' + Date.now(),
                        position: this.chordExtensions.length
                    });
                    console.log('🎵 Auto-added opening loop marker');
                }

                for (let i = 0; i < chordList.length; i++) {
                    const chordStr = chordList[i];
                    
                    if (chordStr === '__SECTION__') {
                        const sep = {
                            name: '|',
                            isCustom: true,
                            isSeparator: true,
                            id: 'sep_' + (this.chordExtensions.length),
                            position: this.chordExtensions.length
                        };
                        this.chordExtensions.push(sep);
                        continue;
                    }
                    
                    if (chordStr === '__BRACKET_START__') {
                        insideBracket = true;
                        continue;
                    }
                    
                    if (chordStr === '__BRACKET_END__') {
                        insideBracket = false;
                        continue;
                    }
                    
                    // Handle colored repeat markers with nest levels
                    if (chordStr.match(/^__REPEAT_L\d+_\d+__$/)) {
                        const match = chordStr.match(/^__REPEAT_L(\d+)_(\d+)__$/);
                        const nestLevel = parseInt(match[1]);
                        const count = parseInt(match[2]);
                        
                        // Color scheme for nesting levels
                        const colors = [
                            { bg: 'linear-gradient(135deg, rgba(76,175,80,0.3) 0%, rgba(139,195,74,0.4) 100%)', border: 'rgba(76,175,80,0.8)', color: '#4CAF50' }, // Green (level 0)
                            { bg: 'linear-gradient(135deg, rgba(33,150,243,0.3) 0%, rgba(100,181,246,0.4) 100%)', border: 'rgba(33,150,243,0.8)', color: '#2196F3' }, // Blue (level 1)  
                            { bg: 'linear-gradient(135deg, rgba(244,67,54,0.3) 0%, rgba(239,154,154,0.4) 100%)', border: 'rgba(244,67,54,0.8)', color: '#F44336' }, // Red (level 2)
                            { bg: 'linear-gradient(135deg, rgba(156,39,176,0.3) 0%, rgba(186,104,200,0.4) 100%)', border: 'rgba(156,39,176,0.8)', color: '#9C27B0' }, // Purple (level 3)
                            { bg: 'linear-gradient(135deg, rgba(255,152,0,0.3) 0%, rgba(255,183,77,0.4) 100%)', border: 'rgba(255,152,0,0.8)', color: '#FF9800' } // Orange (level 4+)
                        ];
                        
                        const colorIndex = Math.min(nestLevel, colors.length - 1);
                        const colorTheme = colors[colorIndex];
                        
                        const repeatMarker = {
                            name: `x${count}`,
                            isCustom: true,
                            isRepeatMarker: true,
                            nestLevel: nestLevel,
                            id: 'repeat_L' + nestLevel + '_' + repeatGroupCount++,
                            position: this.chordExtensions.length,
                            colorTheme: colorTheme
                        };
                        this.chordExtensions.push(repeatMarker);
                        continue;
                    }
                    
                    // Handle colored bracket start markers
                    if (chordStr.match(/^__BRACKET_START_L\d+__$/)) {
                        const match = chordStr.match(/^__BRACKET_START_L(\d+)__$/);
                        const nestLevel = parseInt(match[1]);
                        
                        const colors = [
                            { bg: 'linear-gradient(135deg, rgba(76,175,80,0.2) 0%, rgba(139,195,74,0.3) 100%)', border: 'rgba(76,175,80,0.6)', color: '#4CAF50' },
                            { bg: 'linear-gradient(135deg, rgba(33,150,243,0.2) 0%, rgba(100,181,246,0.3) 100%)', border: 'rgba(33,150,243,0.6)', color: '#2196F3' },
                            { bg: 'linear-gradient(135deg, rgba(244,67,54,0.2) 0%, rgba(239,154,154,0.3) 100%)', border: 'rgba(244,67,54,0.6)', color: '#F44336' },
                            { bg: 'linear-gradient(135deg, rgba(156,39,176,0.2) 0%, rgba(186,104,200,0.3) 100%)', border: 'rgba(156,39,176,0.6)', color: '#9C27B0' },
                            { bg: 'linear-gradient(135deg, rgba(255,152,0,0.2) 0%, rgba(255,183,77,0.3) 100%)', border: 'rgba(255,152,0,0.6)', color: '#FF9800' }
                        ];
                        
                        const colorIndex = Math.min(nestLevel, colors.length - 1);
                        const colorTheme = colors[colorIndex];
                        
                        const leftBracket = {
                            name: '[',
                            isCustom: true,
                            isRepeatMarker: true,
                            nestLevel: nestLevel,
                            id: 'bracket_start_L' + nestLevel + '_' + repeatGroupCount++,
                            position: this.chordExtensions.length,
                            colorTheme: colorTheme
                        };
                        this.chordExtensions.push(leftBracket);
                        continue;
                    }
                    
                    // Handle colored bracket end markers
                    if (chordStr.match(/^__BRACKET_END_L\d+__$/)) {
                        const match = chordStr.match(/^__BRACKET_END_L(\d+)__$/);
                        const nestLevel = parseInt(match[1]);
                        
                        const colors = [
                            { bg: 'linear-gradient(135deg, rgba(76,175,80,0.2) 0%, rgba(139,195,74,0.3) 100%)', border: 'rgba(76,175,80,0.6)', color: '#4CAF50' },
                            { bg: 'linear-gradient(135deg, rgba(33,150,243,0.2) 0%, rgba(100,181,246,0.3) 100%)', border: 'rgba(33,150,243,0.6)', color: '#2196F3' },
                            { bg: 'linear-gradient(135deg, rgba(244,67,54,0.2) 0%, rgba(239,154,154,0.3) 100%)', border: 'rgba(244,67,54,0.6)', color: '#F44336' },
                            { bg: 'linear-gradient(135deg, rgba(156,39,176,0.2) 0%, rgba(186,104,200,0.3) 100%)', border: 'rgba(156,39,176,0.6)', color: '#9C27B0' },
                            { bg: 'linear-gradient(135deg, rgba(255,152,0,0.2) 0%, rgba(255,183,77,0.3) 100%)', border: 'rgba(255,152,0,0.6)', color: '#FF9800' }
                        ];
                        
                        const colorIndex = Math.min(nestLevel, colors.length - 1);
                        const colorTheme = colors[colorIndex];
                        
                        const rightBracket = {
                            name: ']',
                            isCustom: true,
                            isRepeatMarker: true,
                            nestLevel: nestLevel,
                            id: 'bracket_end_L' + nestLevel + '_' + repeatGroupCount++,
                            position: this.chordExtensions.length,
                            colorTheme: colorTheme
                        };
                        this.chordExtensions.push(rightBracket);
                        continue;
                    }
                    
                    // Handle combined bracket end + repeat markers
                    if (chordStr.match(/^__BRACKET_END_REPEAT_L\d+_\d+__$/)) {
                        const match = chordStr.match(/^__BRACKET_END_REPEAT_L(\d+)_(\d+)__$/);
                        const nestLevel = parseInt(match[1]);
                        const repeatCount = parseInt(match[2]);
                        
                        const colors = [
                            { bg: 'linear-gradient(135deg, rgba(76,175,80,0.2) 0%, rgba(139,195,74,0.3) 100%)', border: 'rgba(76,175,80,0.6)', color: '#4CAF50' },
                            { bg: 'linear-gradient(135deg, rgba(33,150,243,0.2) 0%, rgba(100,181,246,0.3) 100%)', border: 'rgba(33,150,243,0.6)', color: '#2196F3' },
                            { bg: 'linear-gradient(135deg, rgba(244,67,54,0.2) 0%, rgba(239,154,154,0.3) 100%)', border: 'rgba(244,67,54,0.6)', color: '#F44336' },
                            { bg: 'linear-gradient(135deg, rgba(156,39,176,0.2) 0%, rgba(186,104,200,0.3) 100%)', border: 'rgba(156,39,176,0.6)', color: '#9C27B0' },
                            { bg: 'linear-gradient(135deg, rgba(255,152,0,0.2) 0%, rgba(255,183,77,0.3) 100%)', border: 'rgba(255,152,0,0.6)', color: '#FF9800' }
                        ];
                        
                        const colorIndex = Math.min(nestLevel, colors.length - 1);
                        const colorTheme = colors[colorIndex];
                        
                        const combinedBracketRepeat = {
                            name: `]x${repeatCount}`,
                            isCustom: true,
                            isRepeatMarker: true,
                            nestLevel: nestLevel,
                            repeatCount: repeatCount,
                            id: 'bracket_end_repeat_L' + nestLevel + '_' + repeatGroupCount++,
                            position: this.chordExtensions.length,
                            colorTheme: colorTheme
                        };
                        this.chordExtensions.push(combinedBracketRepeat);
                        continue;
                    }
                    
                    // Handle colored repeat markers  
                    if (chordStr.match(/^__REPEAT_L\d+_\d+__$/)) {
                        const match = chordStr.match(/^__REPEAT_L(\d+)_(\d+)__$/);
                        const nestLevel = parseInt(match[1]);
                        const repeatCount = parseInt(match[2]);
                        
                        const colors = [
                            { bg: 'linear-gradient(135deg, rgba(76,175,80,0.2) 0%, rgba(139,195,74,0.3) 100%)', border: 'rgba(76,175,80,0.6)', color: '#4CAF50' },
                            { bg: 'linear-gradient(135deg, rgba(33,150,243,0.2) 0%, rgba(100,181,246,0.3) 100%)', border: 'rgba(33,150,243,0.6)', color: '#2196F3' },
                            { bg: 'linear-gradient(135deg, rgba(244,67,54,0.2) 0%, rgba(239,154,154,0.3) 100%)', border: 'rgba(244,67,54,0.6)', color: '#F44336' },
                            { bg: 'linear-gradient(135deg, rgba(156,39,176,0.2) 0%, rgba(186,104,200,0.3) 100%)', border: 'rgba(156,39,176,0.6)', color: '#9C27B0' },
                            { bg: 'linear-gradient(135deg, rgba(255,152,0,0.2) 0%, rgba(255,183,77,0.3) 100%)', border: 'rgba(255,152,0,0.6)', color: '#FF9800' }
                        ];
                        
                        const colorIndex = Math.min(nestLevel, colors.length - 1);
                        const colorTheme = colors[colorIndex];
                        
                        const coloredRepeat = {
                            name: `x${repeatCount}`,
                            isCustom: true,
                            isRepeatMarker: true,
                            nestLevel: nestLevel,
                            repeatCount: repeatCount,
                            id: 'repeat_L' + nestLevel + '_' + repeatGroupCount++,
                            position: this.chordExtensions.length,
                            colorTheme: colorTheme
                        };
                        this.chordExtensions.push(coloredRepeat);
                        continue;
                    }
                    
                    // Legacy repeat markers (keep for backward compatibility)
                    if (chordStr.startsWith('__REPEAT_')) {
                        const count = parseInt(chordStr.replace('__REPEAT_', '').replace('__', ''), 10);
                        const repeatMarker = {
                            name: `x${count}`,
                            isCustom: true,
                            isRepeatMarker: true,
                            id: 'repeat_' + repeatGroupCount++,
                            position: this.chordExtensions.length
                        };
                        this.chordExtensions.push(repeatMarker);
                        continue;
                    }
                    
                    if (chordStr === '__LEFT_BRACKET__') {
                        const leftBracket = {
                            name: '[',
                            isCustom: true,
                            isRepeatMarker: true,
                            id: 'left_bracket_' + repeatGroupCount++,
                            position: this.chordExtensions.length
                        };
                        this.chordExtensions.push(leftBracket);
                        continue;
                    }
                    
                    if (chordStr === '__RIGHT_BRACKET__') {
                        const rightBracket = {
                            name: ']',
                            isCustom: true,
                            isRepeatMarker: true,
                            id: 'right_bracket_' + repeatGroupCount++,
                            position: this.chordExtensions.length
                        };
                        this.chordExtensions.push(rightBracket);
                        continue;
                    }
                    
                    // Curly drum map token(s): accumulate, then apply to the most recent bars once the run ends
                    if (/^__DRMAP_(.+)__$/.test(chordStr)) {
                        const arr = chordStr.replace(/^__DRMAP_/, '').replace(/__$/, '').split('_').map(s=> parseInt(s,10)).filter(Number.isFinite);
                        if (arr.length) drumMapBuffer.push(...arr);
                        // If next token is also a DRMAP, keep buffering; otherwise apply now
                        const nextTok = chordList[i+1];
                        const nextIsMap = typeof nextTok === 'string' && /^__DRMAP_(.+)__$/.test(nextTok);
                        if (!nextIsMap && drumMapBuffer.length) {
                            const N = drumMapBuffer.length;
                            const slice = created.slice(-N);
                            // Apply in order: earliest of slice gets first pattern
                            for (let k = 0; k < slice.length; k++) {
                                const addedRef = slice[k];
                                const pat = drumMapBuffer[k];
                                if (addedRef && Number.isFinite(pat)) {
                                    try {
                                        const pos = addedRef.position;
                                        const model = this.chordExtensions[pos];
                                        if (model) model._drumPatternForBar = pat;
                                    } catch(_) {}
                                }
                            }
                            drumMapBuffer = [];
                        }
                        // Do not create a column for curly tokens
                        continue;
                    }

                    // Regular chord - add it normally
                    const added = this.addChordFromName(chordStr);
                    if (added) created.push(added);

                    // No-op: drum mapping is applied in-place when curly tokens are fully buffered
                }
                
                // Auto-add closing loop marker if we added an opening one
                if (hasActualChords && !hasStartMarker && !hasEndMarker) {
                    // Add closing bracket with repeat
                    this.chordExtensions.push({
                        name: ']',
                        isCustom: true,
                        isRepeatMarker: true,
                        nestLevel: 0,
                        id: 'auto_bracket_end_' + Date.now(),
                        position: this.chordExtensions.length,
                        repeatCount: 0 // Infinite loop
                    });
                    console.log('🎵 Auto-added closing loop marker');
                }
                
                // Render new chords
                this.normalizeChordPositions();
                if (typeof this.generateExactChordColumns === 'function') {
                    this.generateExactChordColumns();
                } else if (typeof this.generateExtensionColumns === 'function') {
                    this.generateExtensionColumns();
                }

                // Do NOT auto-lock new chords; keep everything editable and transposable per request
                const stepCents = Array.from({length: this.currentTuning}, (_,i)=> this.getCentValue(i, this.currentTuning));
                const container = document.getElementById('extensionColumns');
                const priorRoot = this.currentRoot;
                for (const data of created) {
                    const { chord, position, rootSemitone, rootStep } = data;
                    if (rootSemitone == null && rootStep == null) continue;
                    // Safety: if this chord's intervals look like raw 12-EDO values in a non-12 system, remap them now
                    try {
                        const model = chord;
                        if (model && model.isCustom && Array.isArray(model.intervals) && curEDO !== 12) {
                            const looks12 = model.intervals.some(iv => iv > 0 && iv <= 11);
                            const looks24 = model.intervals.some(iv => iv >= 12);
                            if (looks12 && !looks24) {
                                const remapped = model.intervals.map(semi => Math.round((semi * curEDO) / 12));
                                model.intervals = Array.from(new Set(remapped)).sort((a,b)=>a-b);
                                model.lastTuning = curEDO;
                                console.warn('[FIXUP] Remapped probable 12-EDO intervals to', curEDO, 'EDO for chord', model.name, '→', model.intervals);
                            }
                        }
                    } catch {}
                    const lockedRoot = (rootStep != null) ? rootStep : this.findNearestStepForSemitone(rootSemitone, stepCents);
                    const column = container.querySelector(`.extension-column[data-original-position="${position}"]`);
                    if (!column) continue;
                    try {
                        // Temporarily switch root for this chord
                        const prevRoot = this.currentRoot;
                        this.currentRoot = lockedRoot;
                        // If this bar has a mapped drum pattern, annotate it for runtime use and tooltip
                        try {
                            const model = this.chordExtensions[position];
                            const mapped = model && model._drumPatternForBar;
                            if (Number.isFinite(mapped)) {
                                column.dataset.drumPattern = String(mapped);
                                column.title = (column.title ? column.title + ' | ' : '') + `Drums: Pattern ${mapped}`;
                            }
                        } catch(_) {}
                        // Recompute this column's string frequencies at this root using interval tags (robust against stale edoStep)
                        const strings = column.querySelectorAll('.string');
                        strings.forEach(string => {
                            const octave = parseInt(string.dataset.octave);
                            const interval = parseInt(string.dataset.interval);
                            if (isNaN(octave) || isNaN(interval)) return;
                            const tuningSize = this.currentTuning;
                            // Absolute step in current tuning = lockedRoot + interval (intervals are EDO steps for custom chords)
                            const absStep = ((lockedRoot + interval) % tuningSize + tuningSize) % tuningSize;
                            const frequency = this.getFrequency(absStep, octave, tuningSize);
                            string.dataset.frequency = frequency;
                            // Also refresh relative step to be consistent with lockedRoot
                            const relStep = ((absStep - lockedRoot) % tuningSize + tuningSize) % tuningSize;
                            string.dataset.edoStep = String(relStep);
                            // Update tooltip/name and vibration period
                            const noteName = this.getNoteNames()[absStep] || this.getIntervalNoteName(interval);
                            string.title = `${noteName} (step ${absStep}, ${frequency.toFixed(1)}Hz)`;
                            const core = string.querySelector('.string-core');
                            if (core) {
                                const period = this.computeVibrationPeriod(frequency, absStep);
                                core.style.setProperty('--vib-period', period + 'ms');
                            }
                        });
                        // Restore global root for subsequent chords
                        this.currentRoot = prevRoot;
                    } catch (_) {}
                }
                this.currentRoot = priorRoot;
                
                // Make any new bracket markers draggable
                setTimeout(() => {
                    const newMarkers = document.querySelectorAll('.repeat-marker-column:not([data-draggable-wired])');
                    newMarkers.forEach(marker => {
                        if (typeof window.makeBracketDraggable === 'function') {
                            window.makeBracketDraggable(marker);
                            marker.dataset.draggableWired = 'true';
                        }
                    });
                    
                    // Initialize chord column drop zones for new sequences
                    if (typeof window.makeChordColumnsDroppable === 'function') {
                        window.makeChordColumnsDroppable();
                    }
                    
                    // Ensure all chords remain visible
                    if (typeof ensureChordVisibility === 'function') {
                        setTimeout(ensureChordVisibility, 50);
                    }
                }, 100);
            }

            // Map chord name to a chordExtensions entry with computed intervals. Returns {chord, position, rootSemitone, rootStep}
            addChordFromName(chordName) {
                // Safety check: don't process repeat markers as chords
                if (!chordName || typeof chordName !== 'string') return null;
                if (/^[xX]\d+$/.test(chordName.trim())) {
                    console.log('🎵 Skipping repeat marker in addChordFromName:', chordName);
                    return null;
                }
                
                const norm = this.normalizeChordToken(chordName);
                if (!norm) return null;
                const rootMatch = norm.match(/^([A-G])([#b]?)([\^v]*)/);
                const rootSemitone = rootMatch ? this.rootToSemitone(rootMatch[1], rootMatch[2]||'') : null;
                // Compute root step in current EDO including micro marks (^ up, v down). Multiple marks accumulate.
                let rootStep = null;
                if (rootSemitone != null) {
                    const baseStep = Math.round((rootSemitone * this.currentTuning) / 12);
                    const microMarks = (rootMatch && rootMatch[3]) ? rootMatch[3] : '';
                    const ups = (microMarks.match(/\^/g) || []).length;
                    const downs = (microMarks.match(/v/g) || []).length;
                    rootStep = ((baseStep + ups - downs) % this.currentTuning + this.currentTuning) % this.currentTuning;
                    // Only enforce 12-TET semitone back-mapping if there are NO micro marks
                    const hasMicro = (ups + downs) !== 0;
                    if (!hasMicro) {
                        try {
                            const semiBack = Math.round((rootStep * 12) / this.currentTuning) % 12;
                            if (semiBack !== ((rootSemitone % 12)+12)%12) {
                                console.warn('[ADD] Root mismatch, adjusting step. norm=', norm, 'rootSemi=', rootSemitone, 'computedStep=', rootStep, 'semiBack=', semiBack, 'EDO=', this.currentTuning);
                                // Find nearest step for this semitone in current EDO
                                const stepCents = Array.from({length: this.currentTuning}, (_,i)=> this.getCentValue(i, this.currentTuning));
                                const centsTarget = (rootSemitone * 1200) / 12;
                                let best = 0, bestDist = Infinity;
                                stepCents.forEach((c, i)=>{ const d = Math.abs(c - centsTarget); if (d < bestDist) { bestDist = d; best = i; }});
                                rootStep = best;
                            }
                        } catch {}
                    }
                }
                const quality = norm.replace(/^([A-G][#b]?[\^v]*)/, '');
                // Exclude slash bass from stacked-interval parsing; it will be added explicitly below
                const tailForIntervals = quality.replace(/\/[A-G](?:#|b)?/, '');
                let intervals = this.parseChordQualityToIntervals(tailForIntervals);
                try { console.log('[ADD] name=', norm, 'rootSemi=', rootSemitone, 'rootStep=', rootStep, 'intervals(steps)=', intervals, 'EDO=', this.currentTuning); } catch {}

                // Slash chord handling: if tail contains "/<bass>", add that bass pitch as an extra interval
                // Example: G/F -> add b7 (F relative to G)
                const slash = quality.match(/\/([A-G](?:#|b)?)/);
                if (slash && rootSemitone != null) {
                    const bassLetter = slash[1][0];
                    const bassAcc = slash[1].length > 1 ? slash[1][1] : '';
                    const bassSemi = this.rootToSemitone(bassLetter, bassAcc);
                    // Interval difference bass relative to root in 12-TET (0..11)
                    const diffSemi = ((bassSemi - rootSemitone) % 12 + 12) % 12;
                    // Map to current EDO
                    const mapped = Math.round((diffSemi * this.currentTuning) / 12);
                    if (!intervals.includes(mapped)) {
                        intervals = [...intervals, mapped].sort((a,b)=>a-b);
                    }
                }
                const newChord = {
                    name: norm,
                    intervals,
                    isCustom: true,
                    id: 'import_' + Date.now() + '_' + Math.floor(Math.random()*1e6),
                    createdAt: Date.now(),
                    position: this.chordExtensions.length,
                    // Preserve the chord's original root step so we don't force a C root
                    originalRoot: (rootStep != null ? rootStep : this.currentRoot),
                    originalTuning: this.currentTuning,
                    originalGamelanMode: this.gamelanMode,
                    lastTuning: this.currentTuning,
                    headerColor: this.getIntervalColor(0)?.color || '#14b8a6',
                    localTranspose: 0,
                    // Set a fixed absolute root so keyboard edits use the correct base
                    fixedRootStepAbs: (rootStep != null ? rootStep : (this.currentRoot || 0)),
                    fixedRootTuning: this.currentTuning,
                    // Also capture a baseline of the original relative intervals for EDO remaps
                    originalIntervals: intervals.slice()
                };
                this.chordExtensions.push(newChord);
                return { chord: newChord, position: newChord.position, rootSemitone, rootStep };
            }

            // Convert chord quality/extensions tail to interval steps in current EDO
            parseChordQualityToIntervals(tail) {
                // Defaults to major triad if unspecified
                const map = (semi)=> Math.round((semi * this.currentTuning) / 12);
                const add = (set, semi)=> set.add(map(semi));
                const set = new Set([0]);
                let third = 4; // major
                let fifth = 7;
                let hasThird = true;

                const t = (tail || '').trim();
                const has = (pat)=> new RegExp(pat).test(t);

                // quality
                const isMinorQuality = /^m(?!aj)/.test(t);
                if (isMinorQuality) third = 3; // 'm' but not 'maj'
                if (/^°/.test(t)) { third = 3; fifth = 6; }
                if (/^\+/.test(t)) { third = 4; fifth = 8; }
                if (/sus2/.test(t)) { hasThird = false; }
                if (/sus4/.test(t)) { hasThird = false; }

                // base triad
                if (hasThird) add(set, third);
                add(set, fifth);
                if (/sus2/.test(t)) add(set, 2);
                if (/sus4/.test(t)) add(set, 5);

                // seventh family
                const hasMaj7 = /maj7|Δ7|M7/.test(t);
                if (hasMaj7) add(set, 11);
                else if (/ø7/.test(t)) { add(set, 10); add(set, 6); third = 3; }
                else if (/°7/.test(t) || /dim7|diminished\s*7(?:th)?|o7/.test(t)) { add(set, 9); third = 3; fifth = 6; }
                else if (/m7/.test(t)) { add(set, 10); third = 3; }
                else if (/7(?![0-9])/.test(t)) { add(set, 10); }

                // 6th
                if (/(?:^|[^0-9])6(?![0-9])/.test(t)) add(set, 9);

                // Extensions with canonical stacking rules:
                // 9 implies 7; 11 implies 9+7; 13 implies 11+9+7.
                // Exception: m9 (minor ninth) skips the 7th unless explicitly present.
                // Plain '7' (dominant) only if not part of maj7/m7/°7/ø7 tokens
                const hasPlain7  = /(?:^|[^0-9])7(?![0-9])/.test(t) && !/(?:maj7|M7|Δ7|m7|°7|ø7)/.test(t);
                const hasAdd9    = /add9/.test(t);
                const hasAdd11   = /add11/.test(t);
                const hasAdd13   = /add13/.test(t);
                const hasSharp11 = /#11|♯11/.test(t);
                const hasSharp13 = /#13|♯13/.test(t);
                const isMaj9     = /maj9|M9|Δ9/.test(t);
                const isMinor9   = /^m9(?![0-9])/.test(t) || /\bm9(?![0-9])/.test(t);
                // Exclude 'add' forms with micro marks and bare micro-marked degrees from plain stacking detection
                const hasAdd9Micro  = /add[\^v]+9(?![0-9])/.test(t);
                const hasAdd11Micro = /add[\^v]+11(?![0-9])/.test(t);
                const hasAdd13Micro = /add[\^v]+13(?![0-9])/.test(t);
                const hasBareMicro9  = /(?:^|[^A-Za-z])[\^v]+9(?![0-9])/.test(t);
                const hasBareMicro11 = /(?:^|[^A-Za-z])[\^v]+11(?![0-9])/.test(t);
                const hasBareMicro13 = /(?:^|[^A-Za-z])[\^v]+13(?![0-9])/.test(t);
                const has9       = /(?:^|[^0-9])9(?![0-9])/.test(t) && !hasAdd9 && !isMaj9 && !isMinor9 && !hasAdd9Micro && !hasBareMicro9;
                // If #11 is present together with 13, we'll handle the sharped 11 inside the 13 stack below
                const has11      = /(?:^|[^0-9])11(?![0-9])/.test(t) && !hasAdd11 && !hasSharp11 && !hasAdd11Micro && !hasBareMicro11;
                const has13      = /(?:^|[^0-9])13(?![0-9])/.test(t) && !hasAdd13 && !hasSharp13 && !hasAdd13Micro && !hasBareMicro13;

                // maj9
                if (isMaj9) { add(set, 11); add(set, 14); }
                // m9 (no implied 7th)
                if (isMinor9) { add(set, 14); }
                // Plain stacked 9/11/13
                if (has9) { if (!hasMaj7) add(set, 10); add(set, 14); }
                if (has11) { if (!hasMaj7) add(set, 10); add(set, 14); add(set, 17); }
                if (hasSharp11 && !has13) { // standalone #11 (not tied to 13)
                    if (!hasMaj7) add(set, 10); add(set, 14); add(set, 18);
                }
                if (has13) {
                    // 13 implies 7+9+11; if #11 present, sharpen the 11 inside this stack
                    if (!hasMaj7) add(set, 10); // 7 (only if no maj7 present)
                    add(set, 14); // 9
                    if (hasSharp11) add(set, 18); else add(set, 17); // 11 or #11
                    add(set, 21); // 13
                }
                if (hasSharp13) { if (!hasMaj7) add(set, 10); add(set, 14); add(set, 17); add(set, 22); }
                // Explicit 7
                if (hasPlain7) { add(set, 10); }

                // add tones (plain)
                if (/add9(?![0-9])/.test(t)) add(set, 14);
                if (/add11(?![0-9])/.test(t)) add(set, 17);
                if (/add13(?![0-9])/.test(t)) add(set, 21);

                // alterations
                if (/♭5|b5|\-5/.test(t)) { set.delete(map(7)); add(set, 6); }
                if (/♯5|#5/.test(t)) { set.delete(map(7)); add(set, 8); }
                // Only add altered 9 if there isn't a micro-marked add9 or bare micro 9 already handling the nuance
                const hasAnyMicro9 = /add[\^v]+9(?![0-9])/.test(t) || /(?:^|[^A-Za-z])[\^v]+9(?![0-9])/.test(t);
                if (/♭9|b9|\-9/.test(t) && !hasAnyMicro9) add(set, 13);
                if (/♯9|#9/.test(t) && !hasAnyMicro9) add(set, 15);
                if (/♯11|#11/.test(t)) add(set, 18);

                // Microtonal '^' (raise) and 'v' (lower) modifiers on extensions
                // Helper: add a degree with optional microstep offset in current EDO
                const EDO = this.currentTuning;
                const degToSemi = {2:2,3:3,4:5,5:7,6:9,7:10,9:14,11:17,13:21};
                const addMicroDegree = (deg, microSteps=0)=>{
                    const semi = degToSemi[deg];
                    if (semi == null) return;
                    const base = map(semi);
                    let target = base + microSteps;
                    // wrap within EDO for safety
                    target = ((target % EDO) + EDO) % EDO;
                    set.add(target);
                };
                const microShiftOf = (s)=> ((s.match(/\^/g)||[]).length - (s.match(/v/g)||[]).length);

                // addv7/add^9/addv11/add^13 etc.
                const addMicroRe = /add([\^v]+)(2|3|4|5|6|7|9|11|13)/g;
                let mm;
                while ((mm = addMicroRe.exec(t)) !== null) {
                    const shift = microShiftOf(mm[1]);
                    const deg = parseInt(mm[2],10);
                    addMicroDegree(deg, shift);
                }

                // Bare micro-marked degrees like v7, ^9, v13
                const bareMicroRe = /(?:^|[^A-Za-z])([\^v]+)(2|3|4|5|6|7|9|11|13)(?![0-9])/g;
                while ((mm = bareMicroRe.exec(t)) !== null) {
                    const shift = microShiftOf(mm[1]);
                    const deg = parseInt(mm[2],10);
                    if (deg === 9) {
                        if (!hasMaj7) add(set, 10); // implied 7
                        addMicroDegree(9, shift);
                    } else if (deg === 11) {
                        if (!hasMaj7) add(set, 10);
                        add(set, 14); // implied 9
                        addMicroDegree(11, shift);
                    } else if (deg === 13) {
                        if (!hasMaj7) add(set, 10);
                        add(set, 14); // 9
                        add(set, hasSharp11 ? 18 : 17); // respect #11 if also present
                        addMicroDegree(13, shift);
                    } else {
                        addMicroDegree(deg, shift);
                    }
                }

                // Degree-suffix micro markers like 9^, 11v, 13^^
                const suffixMicroRe = /(?<![A-Za-z])\b(2|3|4|5|6|7|9|11|13)([\^v]+)\b/g;
                while ((mm = suffixMicroRe.exec(t)) !== null) {
                    const deg = parseInt(mm[1], 10);
                    const shift = microShiftOf(mm[2]);
                    if (deg === 9) {
                        if (!hasMaj7) add(set, 10);
                        addMicroDegree(9, shift);
                    } else if (deg === 11) {
                        if (!hasMaj7) add(set, 10);
                        add(set, 14);
                        addMicroDegree(11, shift);
                    } else if (deg === 13) {
                        if (!hasMaj7) add(set, 10);
                        add(set, 14);
                        add(set, hasSharp11 ? 18 : 17);
                        addMicroDegree(13, shift);
                    } else {
                        addMicroDegree(deg, shift);
                    }
                }

                // Return sorted unique
                const result = Array.from(set).sort((a,b)=>a-b);
                return result;
            }

            rootToSemitone(letter, acc) {
                const base = {C:0,D:2,E:4,F:5,G:7,A:9,B:11}[letter] ?? 0;
                if (acc === '#') return (base + 1) % 12;
                if (acc === 'b') return (base + 11) % 12;
                return base;
            }

            // Core parser: returns normalized chord strings including root (e.g., Bb7, Caug)
            extractUniqueChordsFromText(text) {
                if (!text) return [];
                const lines = String(text).split(/\r?\n/);
                const seen = new Set();
                const out = [];

                const pushNorm = (raw)=>{
                    const norm = this.normalizeChordToken(raw);
                    if (!norm) return;
                    const key = norm.toLowerCase();
                    if (!seen.has(key)) { seen.add(key); out.push(norm); }
                };

                for (const line of lines) {
                    const s = line.trim();
                    if (!s) continue;

                    // First, grab all chord-like matches with positions
                    const matches = this.scanChordMatches(s);
                    // Accept all matches; dedupe later
                    for (const m of matches) pushNorm(m.raw);
                }

                return out;
            }

            // Return array of { raw, start, end } chord-like matches within a string
            scanChordMatches(s) {
                // Normalize and strip section headings like "A:" "B:" before tokenizing
                const text = String(s)
                    .replace(/♭/g,'b')
                    .replace(/♯/g,'#')
                    .replace(/(^|\s)[^\s|:]+\s*:\s*/g, ' ');
                // Match a chord token up to the next whitespace or punctuation; do NOT consume spaces across tokens
                // Match compact slash chords like G/F but not spaced G / F (space breaks tokens)
                const re = /\b([A-G])(?:#|b|\-)?(?:[\^v]+)?(?:add|maj|min|dim|aug|mM|sus|m|M|\+|°|ø)?[A-Za-z0-9#bø°\+\-\^v]*(?:\/(?:[A-G](?:#|b)?))?/g;
                const found = [];
                let m;
                while ((m = re.exec(text)) !== null) {
                    const raw = m[0].trim();
                    // Keep single-letter roots (e.g., G) — treat as valid chords
                    found.push({ raw, start: m.index, end: m.index + m[0].length });
                }
                return found;
            }

            // Tokenize candidates allowing: flats as b or '-', sharps as #, unicode ♭/♯, letters A–G, and common quality tails
            tokenizePossibleChords(text) {
                return this.scanChordMatches(text).map(x=>x.raw);
            }

            // Normalize one token to a canonical chord string
            normalizeChordToken(rawToken) {
                if (!rawToken) return null;
                if (rawToken === '__SECTION__' || rawToken === '|') return '__SECTION__';
                
                // SAFETY: Reject repeat notation tokens like x4, X2 etc
                if (/^[xX]\d+$/.test(rawToken.trim())) {
                    console.log('🎵 normalizeChordToken: Rejecting repeat token:', rawToken);
                    return null;
                }
                
                let t = rawToken.trim();
                // Standardize unicode and spaces
                t = t.replace(/♭/g,'b').replace(/♯/g,'#');
                // Important: do NOT remove all spaces blindly; we must distinguish "G / F" (two chords) from "G/F" (slash chord)
                // We'll collapse spaces except when a slash is present with spaces around it; in that case, keep spaces so scanner splits tokens
                if (/\/[A-G]/.test(t)) {
                    // Already a compact slash chord like G/F – remove other spaces
                    t = t.replace(/\s+/g,'');
                } else {
                    // Keep spaces, they help tokenization stage treat G / F as separate tokens
                    t = t.replace(/\s{2,}/g,' ').trim();
                }

                // Root parse: letter + optional accidental (#, b, -) and optional micro marks (^ up, v down)
                const mRoot = t.match(/^([A-G])([#b\-]?)([\^v]*)(.*)$/);
                if (!mRoot) return null;
                const letter = mRoot[1];
                const acc = mRoot[2] === '-' ? 'b' : (mRoot[2] || '');
                const micro = mRoot[3] || '';
                let tail = mRoot[4] || '';
                // Normalize spacing before interpreting quality/extensions
                tail = tail.trim();
                // Normalize common spaced variants like "Maj 7", "Maj 9" → "maj7", "maj9"
                tail = tail.replace(/^maj\s*(?=(?:7|9|11|13)\b)/i, 'maj');
                tail = tail.replace(/^M\s*(7|9|11|13)/, 'M$1');

                // Guard: ignore bare two-letter words that look like lyrics (e.g., "Bu", "Ea")
                // Criteria: exactly two chars, second is a lowercase vowel, and no chord markers like m, M, digits, +, °, ø, #, b, or /
                if (!acc && !micro && /^[A-G][aeiou]$/.test(t) && !/[mM0-9+°ø#b/]/.test(t)) {
                    return null;
                }

                // Convert common synonyms/variants in the tail
                // min/maj shorthand
                tail = tail.replace(/^min/i,'m');
                tail = tail.replace(/^maj/i,'M');
                // diminished
                tail = tail.replace(/^dim/i,'°'); // use ° as canonical dim triad
                // half-diminished
                tail = tail.replace(/^ø/i,'ø');
                // augmented
                if (/^aug/i.test(tail) || /^\+/i.test(tail)) {
                    tail = tail.replace(/^aug/i,'+');
                    // Ensure + remains
                    if (!/^\+/.test(tail)) tail = '+' + tail;
                }
                // handle c+ etc: if tail starts with '+', keep as augmented triad unless specific tensions follow
                // sus synonyms already OK

                // Remove any remaining internal spaces in the tail to keep tokens intact (e.g., Maj 9 → M9)
                tail = tail.replace(/\s+/g, '');

                // Flats and sharps on extensions, allow b or -
                tail = tail.replace(/\-([0-9]+)/g,'b$1'); //  -7 -> b7
                tail = tail.replace(/b11/g,'♭11').replace(/b9/g,'♭9').replace(/b5/g,'♭5').replace(/b13/g,'♭13');
                tail = tail.replace(/#([0-9]+)/g,'♯$1');

                // Support simple slash chords bass note like /G or /Gb (compact only, no spaces)
                // Uppercase only the letter, keep accidental case
                tail = tail.replace(/\/([A-G])((?:#|b)?)$/g, (_, L, acc)=> '/' + L.toUpperCase() + acc);

                // Clean trailing punctuation or lyrics fragments after a closing bracket/paren or comma/semicolon
                tail = tail.replace(/[\],;:]+.*$/,'');
                // Keep valid tail characters, including A–G for slash bass notes (e.g., /G, /Bb)
                // Include Δ (major) so previously-normalized tokens like CΔ7/CΔ9 survive re-normalization
                tail = tail.replace(/[^A-GmM°øΔ+suad0-9♭♯/#^vb]+.*$/,'');

                // If tail empty, it's a bare triad: major by default -> ''
                // If tail equals 'min' was converted to 'm' above.

                // Special: 'dim' used with 7 -> °7; 'm7b5' normalize to ø7
                // m7b5 or m7-5 → ø7
                if (/^m7(?:♭|b|\-)?5$/i.test(tail)) tail = 'ø7';
                if (/^dim7$/i.test(tail)) tail = '°7';
                if (/^dim$/i.test(tail)) tail = '°';

                // Compose root + tail (allow bare single-letter chords e.g., G)
                const root = letter + acc + micro;
                let chord = root + tail;

                // Cosmetic: convert 'Bbb' accidents or double signs not handled here; keep simple
                // Display: prefer 'maj' wording over Δ or bare 'M'
                chord = chord.replace(/Δ(7|9|11|13)/g,'maj$1').replace(/M(7|9|11|13)/g,'maj$1');

                return chord;
            }
            
            // ============= CHORD BUILDER SETUP =============
            
            showSimpleChordBuilder() {
                // Create a simple modal for custom chord building
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                `;
                
                const tuningSize = this.getTuningStepsPerOctave();
                const noteNames = this.getNoteNames();
                
                // Create note selector grid
                let notesGrid = '';
                for (let i = 0; i < tuningSize; i++) {
                    const isDiatonic = this.isDiatonicNote(i);
                    const noteClass = isDiatonic ? 'note-btn diatonic' : 'note-btn';
                    notesGrid += `
                        <button class="${noteClass}" data-note="${i}" style="
                            background: ${isDiatonic ? '#1e40af' : '#374151'};
                            color: white;
                            border: 1px solid ${isDiatonic ? '#3b82f6' : '#6b7280'};
                            padding: 8px;
                            margin: 2px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 12px;
                            min-width: 40px;
                        ">${noteNames[i] || i}</button>
                    `;
                }
                
                modal.innerHTML = `
                    <div style="
                        background: #1f2937;
                        border-radius: 12px;
                        padding: 20px;
                        max-width: 600px;
                        width: 90%;
                        max-height: 80vh;
                        overflow-y: auto;
                        color: white;
                    ">
                        <h2 style="margin: 0 0 20px 0; color: #f3f4f6;">Create Custom Chord</h2>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Chord Name:</label>
                            <input type="text" id="simpleChordName" placeholder="Enter chord name" style="
                                width: 100%;
                                padding: 8px;
                                border: 1px solid #6b7280;
                                border-radius: 4px;
                                background: #374151;
                                color: white;
                                font-size: 14px;
                            ">
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">
                                Select Notes (Blue = Diatonic):
                            </label>
                            <div style="
                                display: grid;
                                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
                                gap: 4px;
                                max-height: 200px;
                                overflow-y: auto;
                                border: 1px solid #6b7280;
                                padding: 10px;
                                border-radius: 4px;
                                background: #2d3748;
                            " id="simpleNotesGrid">
                                ${notesGrid}
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <button id="previewSimpleChord" style="
                                background: #059669;
                                color: white;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 4px;
                                cursor: pointer;
                                margin-right: 10px;
                            ">?? Preview</button>
                            <button id="clearSimpleChord" style="
                                background: #dc2626;
                                color: white;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Clear</button>
                        </div>
                        
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button id="cancelSimpleChord" style="
                                background: #6b7280;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Cancel</button>
                            <button id="saveSimpleChord" style="
                                background: #1e40af;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Save Chord</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Add event listeners
                this.setupSimpleChordBuilderEvents(modal);
            }
            
            setupSimpleChordBuilderEvents(modal) {
                // Note selection
                modal.querySelectorAll('.note-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('selected');
                        if (btn.classList.contains('selected')) {
                            btn.style.background = btn.classList.contains('diatonic') ? '#3b82f6' : '#6b7280';
                            btn.style.boxShadow = '0 0 8px rgba(59, 130, 246, 0.5)';
                        } else {
                            btn.style.background = btn.classList.contains('diatonic') ? '#1e40af' : '#374151';
                            btn.style.boxShadow = 'none';
                        }
                    });
                });
                
                // Preview chord
                modal.querySelector('#previewSimpleChord').addEventListener('click', () => {
                    const selectedNotes = this.getSelectedNotesFromModal(modal);
                    if (selectedNotes.length === 0) {
                        alert('Please select at least one note!');
                        return;
                    }
                    this.previewCustomChord(selectedNotes);
                });
                
                // Clear selection
                modal.querySelector('#clearSimpleChord').addEventListener('click', () => {
                    modal.querySelectorAll('.note-btn.selected').forEach(btn => {
                        btn.classList.remove('selected');
                        btn.style.background = btn.classList.contains('diatonic') ? '#1e40af' : '#374151';
                        btn.style.boxShadow = 'none';
                    });
                });
                
                // Save chord
                modal.querySelector('#saveSimpleChord').addEventListener('click', () => {
                    const chordName = modal.querySelector('#simpleChordName').value.trim();
                    const selectedNotes = this.getSelectedNotesFromModal(modal);
                    
                    if (!chordName) {
                        alert('Please enter a chord name!');
                        return;
                    }
                    
                    if (selectedNotes.length === 0) {
                        alert('Please select at least one note!');
                        return;
                    }
                    
                    this.saveSimpleCustomChord(chordName, selectedNotes);
                    modal.remove();
                    if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
                });
                
                // Cancel
                modal.querySelector('#cancelSimpleChord').addEventListener('click', () => {
                    modal.remove();
                });
                
                // Close on ESC
                const closeOnEsc = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', closeOnEsc);
                    }
                };
                document.addEventListener('keydown', closeOnEsc);
            }
            
            isDiatonicNote(noteIndex) {
                // Check if note is diatonic (major scale intervals in current tuning)
                const tuningSize = this.getTuningStepsPerOctave();
                const diatonicIntervals = [0, 2, 4, 5, 7, 9, 11]; // Major scale in semitones
                
                // Map to current tuning
                const diatonicSteps = diatonicIntervals.map(interval => 
                    Math.round((interval * tuningSize) / 12)
                );
                
                return diatonicSteps.includes(noteIndex);
            }
            
            getSelectedNotesFromModal(modal) {
                const selectedButtons = modal.querySelectorAll('.note-btn.selected');
                return Array.from(selectedButtons).map(btn => parseInt(btn.dataset.note));
            }
            
            previewCustomChord(selectedNotes) {
                // Play the selected notes as a chord
                const baseOctave = 4;
                selectedNotes.forEach(noteStep => {
                    const freq = this.getFrequency(noteStep, baseOctave, this.currentTuning);
                    this.playFrequency(freq, null, 'chord');
                });
                
                // Stop after 1 second
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
            }
            
            saveSimpleCustomChord(chordName, selectedNotes) {
                // Create a single chord extension that will auto-generate all 3 qualities
                const chordExtension = {
                    name: chordName,
                    intervals: selectedNotes,
                    isCustom: true,
                    id: chordName.toLowerCase().replace(/\s+/g, '_')
                };
                
                // ADD to existing chords instead of replacing them
                this.chordExtensions.push(chordExtension);
                
                // Save and regenerate
                this.saveChordConfiguration();
                this.preserveLockedChordsAndRegenerate();
                
                console.log(`Added custom chord: ${chordName} with notes:`, selectedNotes);
            }

            getTuningDisplayName() {
                if (this.gamelanMode) return 'Gamelan';
                switch(this.currentTuning) {
                    case 5: return '5-EDO';
                    case 7: return '7-EDO';
                    case 11: return 'C.Gamma';
                    case 12: return '12-TET';
                    case 15: return '15-EDO';
                    case 17: return '17-EDO';
                    case 19: return '19-TET';
                    case 22: return '22-TET';
                    case 24: return '24-TET';
                    case 31: return '31-TET';
                    case 34: return '34-TET';
                    case 53: return '53-TET';
                    default: return `${this.currentTuning}-TET`;
                }
            }
            
            updateFavoritesDisplay() {
            }
            
            populateChordBuilderNoteSelector() {
                const selector = document.getElementById('chordBuilderNoteSelector');
                selector.innerHTML = '';
                
                const edoSize = this.gamelanMode ? 7 : this.currentTuning;
                
                for (let i = 0; i < edoSize; i++) {
                    const button = document.createElement('div');
                    button.className = 'note-btn';
                    button.dataset.note = i;
                    button.textContent = this.getMicrotonalNoteName(i);
                    
                    // Color coding for diatonic highlighting
                    button.style.cssText = `
                        padding: 8px 4px;
                        background: ${this.getDiatonicNoteColor(i)};
                        border: 2px solid ${this.getDiatonicNoteBorderColor(i)};
                        color: white;
                        cursor: pointer;
                        border-radius: 6px;
                        font-size: 11px;
                        font-weight: bold;
                        text-align: center;
                        transition: all 0.2s;
                        user-select: none;
                    `;
                    
                    button.addEventListener('click', () => {
                        button.classList.toggle('selected');
                        if (button.classList.contains('selected')) {
                            button.style.borderColor = '#f39c12';
                            button.style.boxShadow = '0 0 8px rgba(243, 156, 18, 0.6)';
                        } else {
                            button.style.borderColor = this.getDiatonicNoteBorderColor(i);
                            button.style.boxShadow = 'none';
                        }
                    });
                    
                    selector.appendChild(button);
                }
            }
            
            populateChordExtensions() {
                const checkboxContainer = document.getElementById('chordExtensionsCheckboxes');
                checkboxContainer.innerHTML = '';
                
                const extensions = [
                    { name: 'Major', intervals: [0, 4, 7], base: true },
                    { name: 'Minor', intervals: [0, 3, 7], base: true },
                    { name: 'Neutral', intervals: [0, 3.5, 7], base: true },
                    { name: 'Diminished', intervals: [0, 3, 6] },
                    { name: 'Augmented', intervals: [0, 4, 8] },
                    { name: 'sus2', intervals: [0, 2, 7] },
                    { name: 'sus4', intervals: [0, 5, 7] },
                    { name: 'maj7', intervals: [11] },
                    { name: '7th', intervals: [10] },
                    { name: '6th', intervals: [9] },
                    { name: '9th', intervals: [14] },
                    { name: 'add9', intervals: [2] },
                    { name: '11th', intervals: [17] },
                    { name: '13th', intervals: [21] },
                    { name: '?9', intervals: [13] },
                    { name: '?9', intervals: [15] },
                    { name: '?11', intervals: [18] },
                    { name: '?13', intervals: [20] },
                    { name: '?13', intervals: [22] }
                ];
                
                extensions.forEach((ext, index) => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.display = 'flex';
                    checkboxDiv.style.alignItems = 'center';
                    checkboxDiv.style.gap = '6px';
                    checkboxDiv.style.padding = '4px 8px';
                    checkboxDiv.style.borderRadius = '4px';
                    checkboxDiv.style.background = ext.base ? 'rgba(74, 144, 226, 0.2)' : 'rgba(255, 255, 255, 0.1)';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `ext_${index}`;
                    checkbox.dataset.intervals = JSON.stringify(ext.intervals);
                    checkbox.style.cursor = 'pointer';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `ext_${index}`;
                    label.textContent = ext.name;
                    label.style.fontSize = '12px';
                    label.style.cursor = 'pointer';
                    label.style.color = ext.base ? '#4a90e2' : '#8fb3d3';
                    label.style.fontWeight = ext.base ? 'bold' : 'normal';
                    
                    checkbox.addEventListener('change', () => {
                        this.updateChordPreview();
                    });
                    
                    // Add hover preview for extensions
                    checkboxDiv.addEventListener('mouseenter', () => {
                        this.previewIntervals(ext.intervals);
                    });
                    
                    checkboxDiv.addEventListener('mouseleave', () => {
                        this.stopPreview();
                    });
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    checkboxContainer.appendChild(checkboxDiv);
                });
            }
            
            populateMicrotonalIntervals() {
                const checkboxContainer = document.getElementById('microtonalCheckboxes');
                checkboxContainer.innerHTML = '';
                
                // Generate all intervals in the current EDO
                for (let step = 1; step < this.currentTuning; step++) {
                    const semitones = (step * 12) / this.currentTuning;
                    const cents = semitones * 100;
                    
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.display = 'flex';
                    checkboxDiv.style.alignItems = 'center';
                    checkboxDiv.style.gap = '4px';
                    checkboxDiv.style.padding = '3px 6px';
                    checkboxDiv.style.borderRadius = '3px';
                    checkboxDiv.style.fontSize = '11px';
                    
                    // Color coding based on interval type
                    const color = this.getDiatonicNoteColor(step);
                    checkboxDiv.style.background = color + '20'; // Add transparency
                    checkboxDiv.style.borderLeft = `3px solid ${color}`;
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `micro_${step}`;
                    checkbox.dataset.semitones = semitones.toString();
                    checkbox.dataset.step = step.toString();
                    checkbox.style.cursor = 'pointer';
                    checkbox.style.transform = 'scale(0.8)';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `micro_${step}`;
                    label.style.fontSize = '10px';
                    label.style.cursor = 'pointer';
                    label.style.color = '#fff';
                    label.style.fontFamily = 'monospace';
                    
                    // Create descriptive label
                    const noteName = this.getMicrotonalNoteName(step);
                    const centsStr = cents >= 0 ? `+${cents.toFixed(0)} ` : `${cents.toFixed(0)} `;
                    label.textContent = `${noteName} (${centsStr})`;
                    
                    checkbox.addEventListener('change', () => {
                        this.updateChordPreview();
                    });
                    
                    // Add hover preview for microtonal intervals
                    checkboxDiv.addEventListener('mouseenter', () => {
                        this.previewIntervals([semitones]);
                    });
                    
                    checkboxDiv.addEventListener('mouseleave', () => {
                        this.stopPreview();
                    });
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    checkboxContainer.appendChild(checkboxDiv);
                }
            }
            
            updateChordPreview() {
                const previewDisplay = document.getElementById('chordPreviewDisplay');
                if (!previewDisplay) return;
                
                const selectedIntervals = this.getSelectedChordIntervals();
                
                if (selectedIntervals.length === 0) {
                    previewDisplay.textContent = 'No intervals selected';
                    previewDisplay.style.color = '#8fb3d3';
                    return;
                }
                
                // Sort intervals
                selectedIntervals.sort((a, b) => a - b);
                
                // Create preview text
                let previewText = 'Selected intervals: ';
                previewText += selectedIntervals.map(interval => {
                    if (interval === 0) return 'Root';
                    const semitones = interval;
                    const cents = Math.round(semitones * 100);
                    return `${semitones.toFixed(1)}? (${cents} )`;
                }).join(', ');
                
                previewDisplay.textContent = previewText;
                previewDisplay.style.color = '#27ae60';
            }
            
            getSelectedChordIntervals() {
                const intervals = [0]; // Always include root
                
                // Get selected diatonic extensions
                const extensionCheckboxes = document.querySelectorAll('#chordExtensionsCheckboxes input[type="checkbox"]:checked');
                extensionCheckboxes.forEach(checkbox => {
                    const extIntervals = JSON.parse(checkbox.dataset.intervals);
                    intervals.push(...extIntervals);
                });
                
                // Get selected microtonal intervals
                const microCheckboxes = document.querySelectorAll('#microtonalCheckboxes input[type="checkbox"]:checked');
                microCheckboxes.forEach(checkbox => {
                    const semitones = parseFloat(checkbox.dataset.semitones);
                    intervals.push(semitones);
                });
                
                // Remove duplicates and sort
                return [...new Set(intervals)].sort((a, b) => a - b);
            }
            
            previewIntervals(intervals) {
                // Stop any existing preview
                this.stopPreview();
                
                // Start preview timeout to avoid too many rapid previews
                this.previewTimeout = setTimeout(() => {
                    if (!intervals || intervals.length === 0) return;
                    
                    // Play the intervals as a chord
                    const baseOctave = 4;
                    intervals.forEach((interval, index) => {
                        setTimeout(() => {
                            const step = this.semitoneToEDOStep(interval);
                            const frequency = this.getFrequency(step, baseOctave, this.currentTuning);
                            const mockElement = { classList: { add: () => {}, remove: () => {} } };
                            this.playFrequency(frequency, mockElement, 'chord');
                            
                            // Store the frequency for later cleanup
                            if (!this.previewFrequencies) this.previewFrequencies = [];
                            this.previewFrequencies.push(frequency);
                        }, index * 30); // Slight arpeggiation
                    });
                    
                    // Auto-stop preview after 800ms
                    this.previewStopTimeout = setTimeout(() => {
                        this.stopPreview();
                    }, 800);
                }, 100); // 100ms delay to avoid rapid firing
            }
            
            stopPreview() {
                // Clear timeouts
                if (this.previewTimeout) {
                    clearTimeout(this.previewTimeout);
                    this.previewTimeout = null;
                }
                if (this.previewStopTimeout) {
                    clearTimeout(this.previewStopTimeout);
                    this.previewStopTimeout = null;
                }
                
                // Stop all preview frequencies
                if (this.previewFrequencies) {
                    this.previewFrequencies.forEach(frequency => {
                        const mockElement = { classList: { add: () => {}, remove: () => {} } };
                        this.stopFrequency(frequency, mockElement);
                    });
                    this.previewFrequencies = [];
                }
            }
            
            updateChordBuilderFromExtensions() {
                // Get selected extensions
                const activeExtensions = Array.from(document.querySelectorAll('#chordExtensionsGrid .osc-btn.active'))
                    .map(btn => btn.textContent);
                
                // Convert extensions to intervals
                const intervals = this.convertExtensionsToIntervals(activeExtensions);
                
                // Update note selector to reflect these intervals
                this.loadChordPatternIntoBuilder(intervals);
            }
            
            convertExtensionsToIntervals(extensions) {
                const intervals = [0]; // Always include root
                const baseTriad = this.getBaseTriadForQuality();
                intervals.push(...baseTriad.slice(1)); // Add 3rd and 5th
                
                extensions.forEach(ext => {
                    switch(ext) {
                        case '6th': intervals.push(9); break;
                        case '7th': intervals.push(10); break;
                        case 'maj7': intervals.push(11); break;
                        case '9th': intervals.push(14); break;
                        case '?9': intervals.push(13); break;
                        case '?9': intervals.push(15); break;
                        case '11th': intervals.push(17); break;
                        case '?11': intervals.push(16); break;
                        case '?11': intervals.push(18); break;
                        case '13th': intervals.push(21); break;
                        case '?13': intervals.push(20); break;
                        case '?13': intervals.push(22); break;
                        case 'sus2': 
                            intervals.splice(intervals.indexOf(baseTriad[1]), 1); // Remove 3rd
                            intervals.push(2); 
                            break;
                        case 'sus4': 
                            intervals.splice(intervals.indexOf(baseTriad[1]), 1); // Remove 3rd
                            intervals.push(5); 
                            break;
                        case 'add9': intervals.push(14); break;
                        case 'dim': 
                            intervals[intervals.indexOf(baseTriad[1])] = 3; // ?3
                            intervals[intervals.indexOf(baseTriad[2])] = 6; // ?5
                            break;
                        case 'aug': 
                            intervals[intervals.indexOf(baseTriad[2])] = 8; // ?5
                            break;
                    }
                });
                
                return [...new Set(intervals)].sort((a, b) => a - b);
            }
            
            getBaseTriadForQuality() {
                switch(this.currentQuality) {
                    case 'major': return [0, 4, 7];
                    case 'minor': return [0, 3, 7];
                    case 'neutral': return [0, 3.5, 7];
                    default: return [0, 4, 7];
                }
            }
            
            loadChordPatternIntoBuilder(intervals) {
                // Clear all selections first
                document.querySelectorAll('#chordBuilderNoteSelector .note-btn').forEach(btn => {
                    btn.classList.remove('selected');
                    btn.style.borderColor = this.getDiatonicNoteBorderColor(parseInt(btn.dataset.note));
                    btn.style.boxShadow = 'none';
                });
                
                // Convert 12-TET intervals to current EDO
                intervals.forEach(interval => {
                    const edoStep = this.semitoneToEDOStep(interval);
                    const button = document.querySelector(`#chordBuilderNoteSelector .note-btn[data-note="${edoStep}"]`);
                    if (button) {
                        button.classList.add('selected');
                        button.style.borderColor = '#f39c12';
                        button.style.boxShadow = '0 0 8px rgba(243, 156, 18, 0.6)';
                    }
                });
            }
            
            semitoneToEDOStep(semitones) {
                // Convert 12-TET semitones to current EDO step
                const exactStep = (semitones / 12) * this.currentTuning;
                return Math.round(exactStep) % this.currentTuning;
            }
            
            getMicrotonalNoteName(step, opts = {}) {
                // FORCE ARROW NOTATION: Use ↑↓ for microtonal steps as specified
                const edo = this.currentTuning || 12;
                const stepsPerSemitone = edo / 12;
                
                // Base 12-tone note names
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                
                // Calculate which semitone this step is closest to
                const semiPosition = (step * 12) / edo;
                const baseSemi = Math.round(semiPosition) % 12;
                const baseName = noteNames[baseSemi];
                
                // Calculate microtonal deviation
                const exactSemi = Math.round(semiPosition);
                const deviation = step - (exactSemi * edo / 12);
                
                if (Math.abs(deviation) < 0.1) {
                    // Close enough to standard semitone
                    return baseName;
                } else if (deviation > 0) {
                    // Higher than standard semitone
                    return baseName + '↑';
                } else {
                    // Lower than standard semitone  
                    return baseName + '↓';
                }
            }

            // Return a concise root name for a given EDO step, using preferred labels for EDOs 5–24.
            // For EDOs not covered, fall back to microtonal arrow notation.
            getRootNameForStep(step, edo = (this.currentTuning || 12)) {
                const norm = (n, m) => ((n % m) + m) % m;
                const s = norm(step|0, edo|0 || 12);
                const namesByEDO = {
                    5:  ['C','D↑↑','F↓','G↑','B♭↓↓'],
                    6:  ['C','D','E','G♭','A♭','B♭'],
                    7:  ['C','D','E','F','G','A','B'],
                    8:  ['C','D𝄳','E♭','F𝄳','G♭','G𝄲','A','B𝄳'],
                    9:  ['C','D♭↑','E♭↓','E','F↑','G↓','A♭','A↑','B↓'],
                    10: ['C','D♭↑','D↑↑','E↓↓','F↓','G♭','G↑','A♭↑↑','B♭↓↓','B↓'],
                    11: ['C','D♭↑','D','E♭↑','E','F↑','G↓','G↑','A↓','A↑','B↓'],
                    12: ['C','D♭','D','E♭','E','F','G♭','G','A♭','A','B♭','B'],
                    13: ['C','D♭♭','D','E♭♭','E','F♭','F♯','G♭','G♯','A♭','A♯','B♭','B♯'],
                    14: ['C','C↑','D','E↓','E','E↑','F','F↑','G','A↓','A','B↓','B','B↑'],
                    15: ['C','D♭↓','D↓↓','D↑↑','E♭↑','E','F↓','G♭↓↓','G♭↑↑','G↑','A♭','A↓','B♭↓↓','B♭↑↑','B↑'],
                    16: ['C','D♭↓','D𝄳','D↑','E♭','E↓','F𝄳','F↑','G♭','G↓','G𝄲','A♭↑','A','B♭↓','B𝄳','B↑'],
                    17: ['C','D♭','D𝄳','D','E♭','E𝄳','E','F','G♭','G𝄳','G','A♭','A𝄳','A','B♭','B𝄳','B'],
                    18: ['C','D♭↓','D♭↑','D','E♭↓','E♭↑','E','F↓','F↑','G♭','G↓','G↑','A♭','A↓','A↑','B♭','B↓','B↑'],
                    19: ['C','C♯','D♭','D','D♯','E♭','E','F♭','F','F♯','G♭','G','G♯','A♭','A','A♯','B♭','B','C♭'],
                    20: ['C','D♭↓↓','D♭↑','D↓','D↑↑','E♭','E↓↓','E↑','F↓','F↑↑','G♭','G↓↓','G↑','A♭↓','A♭↑↑','A','B♭↓↓','B♭↑','B↓','B↑↑'],
                    21: ['C','C↑','D↓','D','D↑','E↓','E','E↑','F↓','F','F↑','G↓','G','G↑','A↓','A','A↑','B↓','B','B↑','C↓'],
                    22: ['C','C↑','D♭↑','D↓','D','D↑','E♭↑','E↓','E','F','F↑','G♭↑','G↓','G','G↑','A♭↑','A↓','A','A↑','B♭↑','B↓','B'],
                    23: ['C','D♭↓','D♭↑','D↓↓','D','E♭↓','E♭↑','E↓↓','E','F↓','F↑','F♯↓↓','G♭↑↑','G↓','G↑','A♭','A♭↑↑','A↓','A↑','B♭','B♭↑↑','B↓','B↑'],
                    24: ['C','C𝄲','D♭','D𝄳','D','D𝄲','E♭','E𝄳','E','F𝄳','F','F𝄲','G♭','G𝄳','G','G𝄲','A♭','A𝄳','A','A𝄲','B♭','B𝄳','B','C𝄳']
                };
                const table = namesByEDO[edo];
                if (table && table[s] != null) return table[s];
                // Fallback: basic 12-TET sharps for any other EDO
                const sharpNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
                if (edo === 12) return sharpNames[s%12];
                return this.getMicrotonalNoteName(s);
            }
            
            getDiatonicNoteColor(step) {
                // Color-code notes based on their relationship to diatonic scale
                const semitoneEquivalent = (step * 12) / this.currentTuning;
                const baseSemitone = Math.round(semitoneEquivalent) % 12;
                
                // Diatonic notes (C D E F G A B)
                if ([0, 2, 4, 5, 7, 9, 11].includes(baseSemitone)) {
                    return '#4a90e2'; // Blue for diatonic
                }
                // Neutral/microtonal
                if (Math.abs(semitoneEquivalent - Math.round(semitoneEquivalent)) > 0.3) {
                    return '#27ae60'; // Green for neutral
                }
                // Chromatic
                return '#e74c3c'; // Red for chromatic
            }
            
            getDiatonicNoteBorderColor(step) {
                const semitoneEquivalent = (step * 12) / this.currentTuning;
                const baseSemitone = Math.round(semitoneEquivalent) % 12;
                
                if ([0, 2, 4, 5, 7, 9, 11].includes(baseSemitone)) {
                    return '#6bb6ff'; // Lighter blue for diatonic
                }
                if (Math.abs(semitoneEquivalent - Math.round(semitoneEquivalent)) > 0.3) {
                    return '#2ecc71'; // Lighter green for neutral
                }
                return '#ff6b6b'; // Lighter red for chromatic
            }
            
            updateBuilderFavoritesDisplay() {
                const favoritesList = document.getElementById('chordBuilderFavoritesList');
                favoritesList.innerHTML = '';
                
                if (!this.favoriteChords || this.favoriteChords.length === 0) {
                    favoritesList.innerHTML = '<div style="color: #8fb3d3; font-style: italic; text-align: center; padding: 20px;">No favorite chords yet</div>';
                    return;
                }
                
                this.favoriteChords.forEach((chord, index) => {
                    const chordElement = document.createElement('div');
                    chordElement.className = 'favorite-chord-item';
                    chordElement.style.cssText = `
                        background: rgba(0, 30, 60, 0.6);
                        border: 1px solid #4a6870;
                        border-radius: 6px;
                        padding: 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                        text-align: center;
                    `;
                    
                    chordElement.innerHTML = `
                        <div style="font-weight: bold; color: #f39c12;">${chord.name}</div>
                        <div style="font-size: 10px; opacity: 0.8;">${chord.intervals ? chord.intervals.join(' ') : 'Custom'}</div>
                        <div style="font-size: 8px; opacity: 0.6; margin-top: 4px;">Click to load</div>
                    `;
                    
                    chordElement.addEventListener('click', () => {
                        this.loadFavoriteIntoBuilder(chord);
                    });
                    
                    chordElement.addEventListener('mouseenter', () => {
                        chordElement.style.borderColor = '#8fb3d3';
                        chordElement.style.background = 'rgba(0, 40, 80, 0.8)';
                    });
                    
                    chordElement.addEventListener('mouseleave', () => {
                        chordElement.style.borderColor = '#4a6870';
                        chordElement.style.background = 'rgba(0, 30, 60, 0.6)';
                    });
                    
                    favoritesList.appendChild(chordElement);
                });
            }
            
            loadFavoriteIntoBuilder(favoriteChord) {
                // Load name
                document.getElementById('chordBuilderName').value = favoriteChord.name;
                
                // Load pattern
                if (favoriteChord.intervals) {
                    this.loadChordPatternIntoBuilder(favoriteChord.intervals);
                }
            }
            
            saveChordFromBuilder() {
                const name = document.getElementById('chordBuilderName').value.trim();
                const selectedIntervals = this.getSelectedChordIntervals();
                
                if (!name || selectedIntervals.length <= 1) {
                    alert('Please enter a chord name and select at least one interval beyond the root.');
                    return;
                }
                
                // Use flavor-only name (no root injection)
                const newChord = {
                    name: name,
                    intervals: selectedIntervals,
                    isCustom: true,
                    id: Date.now(), // Unique ID
                    root: this.currentRoot || 0,
                    tuning: this.currentTuning || 12
                };
                
                if (this.currentEditingChord) {
                    // Update existing chord
                    this.updateExistingChord(newChord);
                } else {
                    // Use addChordColumn to automatically generate 3 chord qualities
                    this.addChordColumn(newChord);
                }
                
                // Custom chords are automatically added to extensions, no separate dropdown needed
                
                this.closeChordBuilder();
                
                console.log(`Saved custom chord: ${name} with auto-generated 3 qualities`);
            }
            
            getSelectedBuilderNotes() {
                // For backward compatibility, use the new checkbox system
                return this.getSelectedChordIntervals();
            }
            
            addBuilderChordToFavorites() {
                const name = document.getElementById('chordBuilderName').value.trim();
                const selectedNotes = this.getSelectedBuilderNotes();
                
                if (!name || selectedNotes.length === 0) {
                    alert('Please enter a chord name and select notes first.');
                    return;
                }
                
                const favoriteChord = {
                    name: name,
                    intervals: selectedNotes,
                    quality: this.currentQuality,
                    root: this.currentRoot,
                    tuning: this.currentTuning
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    JSON.stringify(fav.intervals) === JSON.stringify(favoriteChord.intervals)
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    this.updateBuilderFavoritesDisplay();
                    alert(`Added "${favoriteChord.name}" to favorites!`);
                } else {
                    alert('This chord is already in your favorites.');
                }
            }
            
            previewBuilderChord() {
                const selectedNotes = this.getSelectedBuilderNotes();
                if (selectedNotes.length === 0) {
                    alert('Please select some notes first.');
                    return;
                }
                
                // Play the chord
                selectedNotes.forEach((interval, index) => {
                    setTimeout(() => {
                        const frequency = this.getFrequency(this.semitoneToEDOStep(interval), 4);
                        const mockElement = { classList: { add: () => {}, remove: () => {} } };
                        this.playFrequency(frequency, mockElement, 'chord');
                        
                        // Stop after a short duration
                        setTimeout(() => {
                            this.stopFrequency(frequency, mockElement);
                        }, 1000);
                    }, index * 50); // Slight arpeggiation
                });
            }
            
            clearChordBuilder() {
                // Stop any active previews
                this.stopPreview();
                
                document.getElementById('chordBuilderName').value = '';
                
                // Uncheck all extension checkboxes
                document.querySelectorAll('#chordExtensionsCheckboxes input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Uncheck all microtonal checkboxes
                document.querySelectorAll('#microtonalCheckboxes input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Update preview
                this.updateChordPreview();
            }
            
            closeChordBuilder() {
                // Stop any active previews
                this.stopPreview();
                
                document.getElementById('chordBuilderModal').style.display = 'none';
                this.currentEditingChord = null;
                // Autosave on tap-out: if we were editing via selectedIntervals, commit in place
                if (this.isChordCreationMode && this.selectedIntervals && this.selectedIntervals.length > 1) {
                    const edo = this.currentTuning || 12;
                    const absSteps = this.selectedIntervals.map(iv => ((iv % edo) + edo) % edo);
                    const pendingName = this.computeFullChordNameFromAbsoluteSteps(absSteps, edo);
                    this.finalizePreviewChord(pendingName);
                }
                this.isChordCreationMode = false;
            }
            
            updateTuningSystem(divisions) {
                const previousTuning = this.currentTuning;
                this.currentTuning = divisions;
                this.gamelanMode = false;
                this.generateRootButtons();
                // Remap custom chords to nearest neighbors in new tuning
                try {
                    this.remapCustomChordsToNearestNeighbors(previousTuning, this.currentTuning);
                } catch (e) { console.warn('Remap skipped:', e); }
                // Update visible column headers to the new tuning preserving pitch/quality
                try {
                    this.relabelColumnsForNewTuning(previousTuning, this.currentTuning);
                } catch (e) { console.warn('Relabel skipped:', e); }
                this.preserveLockedChordsAndRegenerate();
                
                // Update note selector if chord builder is open
                if (document.getElementById('chordBuilderModal').style.display === 'block') {
                    this.populateChordBuilderNoteSelector();
                }
                
                // Auto-close the TUNING popup/panel after applying
                if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
            }

            // Remap custom-chord intervals using each chord's ORIGINAL EDO baseline to nearest neighbors in the new EDO.
            remapCustomChordsToNearestNeighbors(fromEdo, toEdo) {
                if (!Array.isArray(this.chordExtensions) || !toEdo) return;
                const clampEdo = (n)=> Math.max(5, Math.min(52, parseInt(n||0))) || 12;
                const mapStepFromTo = (step, srcEdo, dstEdo) => {
                    if (!srcEdo || srcEdo === dstEdo) return ((step % dstEdo) + dstEdo) % dstEdo;
                    const cents = (step / srcEdo) * 1200;
                    const mapped = Math.round((cents / 1200) * dstEdo);
                    return ((mapped % dstEdo) + dstEdo) % dstEdo;
                };
                this.chordExtensions = this.chordExtensions.map(ch => {
                    if (!ch || !ch.isCustom) return ch;
                    // Establish original baseline: source EDO and original relative intervals
                    const srcEdo = clampEdo(ch.originalTuning || ch.fixedRootTuning || fromEdo || this.currentTuning);
                    const sourceIntervals = (Array.isArray(ch.originalIntervals) && ch.originalIntervals.length)
                        ? ch.originalIntervals.slice()
                        : (Array.isArray(ch.intervals) ? ch.intervals.slice() : [0]);
                    // Ensure we remember the baseline for future remaps
                    const ensureOriginal = (!Array.isArray(ch.originalIntervals) || ch.originalIntervals.length === 0);
                    // Map each original interval to the destination EDO
                    let mappedIntervals = sourceIntervals.map(s => mapStepFromTo(((s % srcEdo)+srcEdo)%srcEdo, srcEdo, toEdo));
                    if (!mappedIntervals.includes(0)) mappedIntervals.unshift(0);
                    const uniqueSorted = [...new Set(mappedIntervals)].sort((a,b)=>a-b);
                    // Re-anchor the fixed root to the equivalent step in the destination EDO
                    let newFixedRoot = 0;
                    let hadFixed = false;
                    if (typeof ch.fixedRootStepAbs === 'number') {
                        const srcForRoot = clampEdo(ch.fixedRootTuning || srcEdo);
                        newFixedRoot = mapStepFromTo(((ch.fixedRootStepAbs % srcForRoot)+srcForRoot)%srcForRoot, srcForRoot, toEdo);
                        hadFixed = true;
                    }
                    const next = {
                        ...ch,
                        intervals: uniqueSorted,
                        lastTuning: toEdo,
                        ...(hadFixed ? { fixedRootStepAbs: newFixedRoot, fixedRootTuning: toEdo } : {})
                    };
                    if (ensureOriginal) {
                        next.originalIntervals = sourceIntervals.slice();
                        next.originalTuning = srcEdo;
                    }
                    return next;
                });
            }

            // After changing EDO, relabel each unlocked column to keep root at 0 semantics and preserve quality
            relabelColumnsForNewTuning(fromEdo, toEdo) {
                const edo = toEdo || this.currentTuning || 12;
                document.querySelectorAll('.extension-column').forEach(col => {
                    const nameEl = col.querySelector('.extension-header .chord-name');
                    if (!nameEl) return;
                    const isLocked = nameEl.dataset.isLocked === 'true';
                    if (isLocked) return; // leave locked headers as-is; pitch is preserved by snapshot

                    // Resolve chord model
                    let model = null;
                    try {
                        const id = col.dataset.chordId;
                        let idx = -1;
                        if (id) idx = (this.chordExtensions||[]).findIndex(c=> c && (String(c.id)===String(id)));
                        if (idx < 0 && col.dataset.originalPosition != null) {
                            const op = parseInt(col.dataset.originalPosition,10);
                            if (!isNaN(op) && op >= 0) idx = op;
                        }
                        if (idx >= 0) model = (this.chordExtensions||[])[idx];
                    } catch(_) {}

                    const label = (nameEl.dataset.lockedName || nameEl.textContent || '').trim();
                    // Parse root and any ^/v local transpose decorations
                    let baseStep = 0;
                    let arrowDelta = 0;
                    const m = label.match(/^([A-G])([#b]?)([\^v↑↓]*)/);
                    if (m) {
                        const semi = this.rootToSemitone(m[1], m[2]||'');
                        baseStep = this.semitoneToStep(semi, edo);
                        const ups = (m[3].match(/[\^↑]/g) || []).length;
                        const downs = (m[3].match(/[v↓]/g) || []).length;
                        arrowDelta = ups - downs;
                    }

                    // Build degree steps in new EDO
                    let degrees = [];
                    if (model && Array.isArray(model.intervals) && model.intervals.length) {
                        if (model.isCustom) {
                            // Custom intervals are already steps and were remapped above
                            degrees = model.intervals.slice();
                        } else {
                            // Map semitone intervals to new EDO steps
                            degrees = model.intervals.map(iv => this.mapIntervalToEDO(iv, edo));
                        }
                    } else {
                        // Fallback: try to infer a simple triad (Major by default)
                        degrees = [0, this.mapIntervalToEDO(4, edo), this.mapIntervalToEDO(7, edo)];
                    }
                    // Ensure root at 0 and dedupe/sort
                    degrees = Array.from(new Set([0, ...degrees.map(x=> ((x%edo)+edo)%edo)])).sort((a,b)=>a-b);

                    // Compose absolute steps with local arrows; global transpose is added inside naming
                    const rootStep = (((baseStep + arrowDelta) % edo) + edo) % edo;
                    const abs = [rootStep, ...degrees.filter(x=>x!==0).map(iv => (rootStep + iv) % edo)];
                    const labelNew = this.computeFullChordNameFromAbsoluteSteps(abs, edo) || label;

                    nameEl.textContent = labelNew;
                    nameEl.dataset.lockedName = labelNew;
                });
            }
            
            
            addChordColumn(chordData) {
                // When adding a new chord, automatically create ONE Major, ONE Minor, ONE Neutral
                if (chordData.intervals && chordData.intervals.length > 0) {
                    // Auto-generate 3 qualities for the new chord with color gradients
                    this.autoGenerateChordQualities(chordData);
                } else {
                    // For standard chord extensions without specific intervals
                    this.chordExtensions.push(chordData);
                    this.saveChordConfiguration(); // Use consistent save method
                }
                
                // Regenerate the columns to show the new chord variations
                this.preserveLockedChordsAndRegenerate();
                
                console.log(`Added chord column: ${chordData.name} with auto-generated qualities`);
            }
            
            autoGenerateChordQualities(chordData) {
                // Automatically create Major, Minor, and Neutral variants with color gradients
                const qualities = [
                    { 
                        name: 'major', 
                        suffix: 'Maj', 
                        color: { bg: '#1e40af', border: '#3b82f6' }, // Blue for Major
                        intervals: chordData.intervals 
                    },
                    { 
                        name: 'minor', 
                        suffix: 'Min', 
                        color: { bg: '#dc2626', border: '#ef4444' }, // Red for Minor
                        intervals: this.convertToMinorIntervals(chordData.intervals)
                    },
                    { 
                        name: 'neutral', 
                        suffix: 'Neu', 
                        color: { bg: '#059669', border: '#10b981' }, // Green for Neutral
                        intervals: this.convertToNeutralIntervals(chordData.intervals)
                    }
                ];
                
        qualities.forEach(quality => {
                    const qualityChord = {
            name: `${chordData.name}${quality.suffix}`,
                        originalName: chordData.name,
                        intervals: quality.intervals,
                        quality: quality.name,
                        isCustom: true,
                        color: quality.color,
            baseIntervals: chordData.intervals,
            root: chordData.root ?? this.currentRoot ?? 0,
            tuning: chordData.tuning ?? this.currentTuning ?? 12
                    };
                    
                    // Add to chord extensions for the 3-column layout
                    this.chordExtensions.push(qualityChord);
                });
                
                // Save the updated chord extensions
                this.saveChordConfiguration(); // Use consistent save method
                
                console.log(`Auto-generated 3 qualities for: ${chordData.name}`);
            }
            
            convertToMinorIntervals(intervals) {
                // Convert major intervals to minor by flattening the third
                return intervals.map(interval => {
                    if (interval === 4) return 3; // Major 3rd to minor 3rd
                    if (interval === 11) return 10; // Major 7th to minor 7th
                    return interval;
                });
            }
            
            convertToNeutralIntervals(intervals) {
                // Convert intervals to neutral by using quarter-tones
                return intervals.map(interval => {
                    if (interval === 4) return 3.5; // Major 3rd to neutral 3rd
                    if (interval === 3) return 3.5; // Minor 3rd to neutral 3rd
                    if (interval === 11) return 10.5; // Major 7th to neutral 7th
                    if (interval === 10) return 10.5; // Minor 7th to neutral 7th
                    return interval;
                });
            }
            
            updateExistingChord(newChordData) {
                if (this.currentEditingChord.isCustom) {
                    const index = this.customChords.findIndex(c => c.id === this.currentEditingChord.id);
                    if (index !== -1) {
                        const prev = this.customChords[index] || {};
                        this.customChords[index] = { ...prev, ...newChordData, id: this.currentEditingChord.id, root: prev.root ?? this.currentRoot, tuning: prev.tuning ?? this.currentTuning };
                    }
                } else {
                    const index = this.chordExtensions.findIndex(c => c.name === this.currentEditingChord.name);
                    if (index !== -1) {
                        const prev = this.chordExtensions[index] || {};
                        this.chordExtensions[index] = { ...prev, ...newChordData, root: prev.root ?? this.currentRoot, tuning: prev.tuning ?? this.currentTuning };
                        this.saveChordConfiguration(); // Use consistent save method
                    }
                }
                
                this.preserveLockedChordsAndRegenerate();
                console.log(`Updated chord: ${newChordData.name}`);
            }

        async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = this.volume * this.masterVolume; // Apply both volume and master volume at start
                    
                    // Create simple reverb
                    this.createReverb();
                    
            // Create wet gain for reverb send and a master-controlled dry output gain
        this.wetGainNode = this.audioContext.createGain();
        this.dryGainNode = this.audioContext.createGain();
        // Clamp wet to [0,1]
        const wet = Math.max(0, Math.min(1, Number.isFinite(this.reverb.wet) ? this.reverb.wet : 0.0));
        this.wetGainNode.gain.value = wet; // Amount sent into reverb
        // Dry path is governed by master volume, not (1-wet)
        this.dryGainNode.gain.value = this.masterVolume;
                    
                    // Create reverb filters: HP then LP after convolver
                    this.reverbHpNode = this.audioContext.createBiquadFilter();
                    this.reverbHpNode.type = 'highpass';
                    this.reverbHpNode.frequency.value = 20;
                    this.reverbHpNode.Q.value = 0.707;
                    this.reverbFilterNode = this.audioContext.createBiquadFilter();
                    this.reverbFilterNode.type = 'lowpass';
                    this.reverbFilterNode.frequency.value = Math.max(100, Math.min(20000, Number.isFinite(this.reverb.filterCutoff) ? this.reverb.filterCutoff : 8000));
                    this.reverbFilterNode.Q.value = 1;
                    
                    // Global Drive (first in chain after summing all notes)
                    this._drive = {
                        pre: this.audioContext.createGain(),
                        shaper: this.audioContext.createWaveShaper(),
                        // Per-effect tone for drive wet path: HP -> LP
                        hp: this.audioContext.createBiquadFilter(),
                        lp: this.audioContext.createBiquadFilter(),
                        post: this.audioContext.createGain(),
                        dry: this.audioContext.createGain(),
                        wet: this.audioContext.createGain(),
                        mix: this.audioContext.createGain()
                    };
                    this._drive.hp.type = 'highpass'; this._drive.hp.frequency.value = 20; this._drive.hp.Q.value = 0.707;
                    this._drive.lp.type = 'lowpass'; this._drive.lp.frequency.value = 20000; this._drive.lp.Q.value = 0.707;
                    // Default mix states
                    this._drive.dry.gain.value = 1;
                    this._drive.wet.gain.value = 0;
                    this._drive.mix.gain.value = 1;
                    // Build updateDrive helper for curve, mix, and output compensation
                    this.updateDrive = () => {
                        const amt = Math.max(0, Math.min(100, this.drive?.amount || 0)) / 100;
                        const mix = Math.max(0, Math.min(100, this.drive?.mix || 0)) / 100;
                        // Stronger curve range using arctangent shaper-like curve
                        const n = 2048; const curve = new Float32Array(n);
                        const k = 1 + amt * 24; // extend range
                        for (let i=0;i<n;i++){
                            const x = i/(n-1)*2-1; // -1..1
                            curve[i] = Math.tanh(k * x);
                        }
                        this._drive.shaper.curve = curve; this._drive.shaper.oversample = '4x';
                        // Perceived-loudness autogain: approximate inverse of RMS growth
                        const comp = 1 / Math.sqrt(1 + k*0.6);
                        this._drive.post.gain.value = comp;
                        // Mix
                        this._drive.dry.gain.value = 1 - mix;
                        this._drive.wet.gain.value = mix;
                    };
                    this.updateDrive();

                    // Master routing: sum → Drive (first) → Delay → PostDelayMix → HP → LP → Output
                    // Reverb taps after Delay (very last stage) and goes straight to output
                    // Drive split/mix
                    this.gainNode.connect(this._drive.pre);
                    this.gainNode.connect(this._drive.dry);
                    this._drive.pre.connect(this._drive.shaper);
                    // Drive wet tone: shaper -> hp -> lp -> post -> wet
                    this._drive.shaper.connect(this._drive.hp);
                    this._drive.hp.connect(this._drive.lp);
                    this._drive.lp.connect(this._drive.post);
                    this._drive.post.connect(this._drive.wet);
                    this._drive.dry.connect(this._drive.mix);
                    this._drive.wet.connect(this._drive.mix);

                    // Global Delay with filtered feedback and wet/dry mix
                    this._delay = {
                        node: this.audioContext.createDelay(120.0),
                        feedback: this.audioContext.createGain(),
                        // Feedback loop tone (LP) and wet-path tone (HP/LP)
                        filter: this.audioContext.createBiquadFilter(),
                        wetHp: this.audioContext.createBiquadFilter(),
                        wetLp: this.audioContext.createBiquadFilter(),
                        wet: this.audioContext.createGain(),
                        dry: this.audioContext.createGain(),
                        mix: this.audioContext.createGain()
                    };
                    this._delay.node.delayTime.value = 0.28; // 280ms
                    this._delay.feedback.gain.value = 0.25;
                    this._delay.filter.type = 'lowpass';
                    this._delay.filter.frequency.value = 6000;
                    // Delay wet path tone defaults
                    this._delay.wetHp.type = 'highpass'; this._delay.wetHp.frequency.value = 20; this._delay.wetHp.Q.value = 0.707;
                    this._delay.wetLp.type = 'lowpass'; this._delay.wetLp.frequency.value = 6000; this._delay.wetLp.Q.value = 0.707;
                    this._delay.wet.gain.value = 0.0; // start bypassed
                    this._delay.dry.gain.value = 1.0;
                    this._delay.mix.gain.value = 1.0;
                    // Wire delay split
                    this._drive.mix.connect(this._delay.dry);
                    this._drive.mix.connect(this._delay.node);
                    this._delay.node.connect(this._delay.filter);
                    this._delay.filter.connect(this._delay.feedback);
                    this._delay.feedback.connect(this._delay.node);
                    // Delay wet chain: node → wetHp → wetLp → wet
                    this._delay.node.connect(this._delay.wetHp);
                    this._delay.wetHp.connect(this._delay.wetLp);
                    this._delay.wetLp.connect(this._delay.wet);
                    // Sum delay wet/dry
                    this._postDelayMix = this.audioContext.createGain();
                    this._postDelayMix.gain.value = 1.0;
                    this._delay.dry.connect(this._postDelayMix);
                    this._delay.wet.connect(this._postDelayMix);

                    // Final filters at end of chain (HP then LP)
                    this._finalHP = this.audioContext.createBiquadFilter();
                    this._finalHP.type = 'highpass';
                    this._finalHP.frequency.value = 20;
                    this._finalLP = this.audioContext.createBiquadFilter();
                    this._finalLP.type = 'lowpass';
                    this._finalLP.frequency.value = 20000;
                    this._postDelayMix.connect(this._finalHP);
                    this._finalHP.connect(this._finalLP);
                    this._finalLP.connect(this.dryGainNode);

                    // Reverb taps after delay and is last to output
                    this._postDelayMix.connect(this.wetGainNode);
                    this.dryGainNode.connect(this.audioContext.destination);
                    this.wetGainNode.connect(this.reverbNode);
                    this.reverbNode.connect(this.reverbHpNode);
                    this.reverbHpNode.connect(this.reverbFilterNode);
                    // Add a dedicated reverb output gain so MASTER affects reverb too
                    this.reverbOutGain = this.audioContext.createGain();
                    this.reverbOutGain.gain.value = this.masterVolume;
                    this.reverbFilterNode.connect(this.reverbOutGain);
                    this.reverbOutGain.connect(this.audioContext.destination);

                    // Helper to bypass convolver when wet=0 to save CPU
                    this.updateReverbRouting = () => {
                        try {
                            const isWet = (this.reverb?.wet || 0) > 0.0001;
                            // Ensure base connections exist
                            if (!this.wetGainNode || !this.reverbNode || !this.reverbFilterNode || !this.reverbHpNode || !this.reverbOutGain) return;
                            // Disconnect all from wet chain first
                            try { this.wetGainNode.disconnect(); } catch {}
                            try { this.reverbNode.disconnect(); } catch {}
                            try { this.reverbHpNode.disconnect(); } catch {}
                            try { this.reverbFilterNode.disconnect(); } catch {}
                            if (isWet) {
                                // Enable wet path
                                this.wetGainNode.connect(this.reverbNode);
                                this.reverbNode.connect(this.reverbHpNode);
                                this.reverbHpNode.connect(this.reverbFilterNode);
                                this.reverbFilterNode.connect(this.reverbOutGain);
                            } else {
                                // Keep wetGainNode disconnected when wet=0
                                // Dry path already connected
                            }
                        } catch {}
                    };
                    // Apply initial routing state
                    this.updateReverbRouting();
                    
                    // Store the initial clean state for piano lock system
                    this.storeOriginalUIState();
                    console.log('🎹 Stored original UI state for piano lock system');
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                }
            }

            // Ensure AudioContext exists and is running before attempting playback
        async ensureAudioContext() {
                try {
                    if (!this.audioContext) await this.initAudio();
                    if (!this.audioContext) return false;
                    if (this.audioContext.state === 'suspended') {
                        try {
                            await this.audioContext.resume();
                            console.log('AudioContext resumed');
                        } catch (e) {
                            console.warn('Failed to resume AudioContext:', e);
                            return false;
                        }
                    }
                    return this.audioContext.state === 'running';
                } catch (e) {
                    console.warn('ensureAudioContext error:', e);
                    return false;
                }
            }

            createReverb() {
                const convolver = this.audioContext.createConvolver();
                // Ensure a non-zero impulse length to avoid AudioBuffer errors when decay is 0
                const decaySec = Math.max(0.01, Number.isFinite(this.reverb.decay) ? this.reverb.decay : 0.3);
                const length = Math.max(1, Math.floor(this.audioContext.sampleRate * decaySec));
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const n = length - i;
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, this.reverb.roomSize);
                    }
                }
                
                convolver.buffer = impulse;
                this.reverbNode = convolver;
            }

            createNoiseSource() {
                // Brown (Brownian) noise: integrate white noise with slight damping; looped buffer
                const seconds = 3; // longer to minimize loop artifacts
                const bufferSize = Math.max(1, Math.floor(this.audioContext.sampleRate * seconds));
                const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const out = noiseBuffer.getChannelData(0);
                let last = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1; // [-1, 1]
                    // Leaky integrator to avoid DC drift; tuning keeps spectrum ~1/f^2
                    last = (last + white) * 0.995; // slight damping
                    // Scale down to safe amplitude
                    out[i] = last * 0.1;
                }
                const brownNoise = this.audioContext.createBufferSource();
                brownNoise.buffer = noiseBuffer;
                brownNoise.loop = true;
                return brownNoise;
            }

            // Build or fetch a cached PeriodicWave for custom oscillator shapes.
            // type includes: 'sine','sawtooth','square','pulse','fullrect','halfrect','parabolic','stair'
            // pulseWidth: only applies to 'pulse' (0..1), default 0.5
            // width: used for sine/saw/square skewing (0..1), default 0.5
            getCustomPeriodicWave(type, pulseWidth = 0.5, width = 0.5) {
                if (!this.audioContext) return null;
                const key = `${type}:${type === 'pulse' ? Math.max(0.01, Math.min(0.99, pulseWidth || 0.5)).toFixed(3) : 'std'}:${Math.max(0.0, Math.min(1.0, width ?? 0.5)).toFixed(3)}`;
                if (this._customWaveCache.has(key)) return this._customWaveCache.get(key);

                let real = null, imag = null;
                const N = 64; // number of harmonics to include

                switch (type) {
                    case 'sine': {
                        const w = Math.max(0.0, Math.min(1.0, width ?? 0.5));
                        // Phase-skewed sine per hint
                        return this._buildSampledPeriodicWave(x => {
                            const phase = ((x / (2 * Math.PI)) % 1 + 1) % 1;
                            const skewed = (phase < w)
                                ? (phase / w) * 0.5
                                : 0.5 + ((phase - w) / (1 - w)) * 0.5;
                            return Math.sin(skewed * 2 * Math.PI);
                        }, key);
                    }
                    case 'sawtooth': {
                        const w = Math.max(0.0, Math.min(1.0, width ?? 0.5));
                        // Phase-skewed saw per hint
                        return this._buildSampledPeriodicWave(x => {
                            const phase = ((x / (2 * Math.PI)) % 1 + 1) % 1;
                            const skewed = (phase < w)
                                ? (phase / w) * 0.5
                                : 0.5 + ((phase - w) / (1 - w)) * 0.5;
                            return 2 * skewed - 1;
                        }, key);
                    }
                    case 'square': {
                        const w = Math.max(0.01, Math.min(0.99, width ?? 0.5));
                        // PWM-style duty comparator
                        return this._buildSampledPeriodicWave(x => {
                            const phase = ((x / (2 * Math.PI)) % 1 + 1) % 1;
                            return (phase < w) ? 1 : -1;
                        }, key);
                    }
                    case 'pulse': {
                        const d = Math.max(0.01, Math.min(0.99, pulseWidth));
                        real = new Float32Array(N + 1);
                        imag = new Float32Array(N + 1);
                        real[0] = 0;
                        for (let n = 1; n <= N; n++) {
                            // Duty-cycle pulse: sine-only series, scaled by sin(n*pi*d)
                            const bn = (4 / (n * Math.PI)) * Math.sin(n * Math.PI * d);
                            imag[n] = bn;
                            real[n] = 0;
                        }
                        break;
                    }
                    case 'fullrect': {
                        // |sin| -> even harmonics cosine series
                        real = new Float32Array(N + 1);
                        imag = new Float32Array(N + 1);
                        for (let k = 1; k <= N / 2; k++) {
                            const n = 2 * k;
                            const a = -4 / (Math.PI * (4 * k * k - 1));
                            real[n] = a;
                            imag[n] = 0;
                        }
                        break;
                    }
                    case 'parabolic': {
                        // Curved saw-like; cosine series decaying as 1/n^2 with alternating sign
                        real = new Float32Array(N + 1);
                        imag = new Float32Array(N + 1);
                        for (let n = 1; n <= N; n++) {
                            real[n] = (n % 2 === 0 ? 1 : -1) * (1 / (n * n));
                            imag[n] = 0;
                        }
                        break;
                    }
                    case 'halfrect': {
                        // Half-wave rectified sine: better built via sampling then DFT
                        return this._buildSampledPeriodicWave(x => Math.max(0, Math.sin(x)) * 2 - 1, key);
                    }
                    
                    case 'stair': {
                        const steps = 8;
                        return this._buildSampledPeriodicWave(x => {
                            const t = ((x / (2 * Math.PI)) % 1 + 1) % 1;
                            const s = Math.floor(t * steps) / (steps - 1);
                            return s * 2 - 1;
                        }, key);
                    }
                    default: {
                        // Fallback to a mild saw series
                        real = new Float32Array(N + 1);
                        imag = new Float32Array(N + 1);
                        real[0] = 0;
                        for (let n = 1; n <= N; n++) {
                            imag[n] = -1 / n;
                        }
                    }
                }

                let wave = null;
                if (real && imag) {
                    try {
                        wave = this.audioContext.createPeriodicWave(real, imag, { disableNormalization: false });
                    } catch(_) {
                        // Older browsers don't support the options arg
                        wave = this.audioContext.createPeriodicWave(real, imag);
                    }
                }
                if (wave) this._customWaveCache.set(key, wave);
                return wave;
            }

            // Build a PeriodicWave from a sampled function using a naive DFT for first N harmonics
            _buildSampledPeriodicWave(sampleFn, cacheKey) {
                const S = 1024; // samples per period
                const samples = new Float32Array(S);
                for (let i = 0; i < S; i++) {
                    const x = (i / S) * 2 * Math.PI;
                    samples[i] = sampleFn(x);
                }
                // Remove DC offset
                let dc = 0;
                for (let i = 0; i < S; i++) dc += samples[i];
                dc /= S;
                for (let i = 0; i < S; i++) samples[i] -= dc;

                const N = 64;
                const real = new Float32Array(N + 1);
                const imag = new Float32Array(N + 1);
                real[0] = 0; imag[0] = 0;
                for (let n = 1; n <= N; n++) {
                    let a = 0, b = 0;
                    for (let i = 0; i < S; i++) {
                        const x = (i / S) * 2 * Math.PI;
                        const y = samples[i];
                        a += y * Math.cos(n * x);
                        b += y * Math.sin(n * x);
                    }
                    a = (2 / S) * a;
                    b = (2 / S) * b;
                    real[n] = a;
                    imag[n] = b;
                }
                let wave;
                try {
                    wave = this.audioContext.createPeriodicWave(real, imag, { disableNormalization: false });
                } catch(_) {
                    wave = this.audioContext.createPeriodicWave(real, imag);
                }
                this._customWaveCache.set(cacheKey, wave);
                return wave;
            }

            initEventListeners() {
                // Tuning system selection
                document.querySelectorAll('[data-tuning]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-tuning]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        const tuningValue = btn.dataset.tuning;
                        if (tuningValue === 'gamelan') {
                            // Gamelan pelog scale (7 notes)
                            this.currentTuning = 7;
                            this.gamelanMode = true;
                        } else {
                            this.currentTuning = parseInt(tuningValue);
                            this.gamelanMode = false;
                        }
                        
                        this.generateRootButtons();
                        this.preserveLockedChordsAndRegenerate();
                        this.updateChordDisplay();
                    });
                });

                // Quality selection
                document.querySelectorAll('[data-quality]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-quality]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentQuality = btn.dataset.quality;
                        this.preserveLockedChordsAndRegenerate();
                        this.updateChordDisplay();
                    });
                });


                // ADSR controls with value displays and proper limits
                const attackSlider = document.getElementById('attackSlider');
                if (attackSlider) {
                    attackSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.instruments.strum1.env.attack = Math.max(0.003, e.target.value / 1000); // 3ms minimum
                        console.log('?? Attack changed to:', this.instruments.strum1.env.attack);
                        const attackValue = document.getElementById('attackValue');
                        if (attackValue) {
                            attackValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('attackSlider not found');
                }
                
                const decaySlider = document.getElementById('decaySlider');
                if (decaySlider) {
                    decaySlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        // 0–1000ms → 0–1s
                        const ms = Math.max(0, parseInt(e.target.value, 10) || 0);
                        this.instruments.strum1.env.decay = ms / 1000;
                        const decayValue = document.getElementById('decayValue');
                        if (decayValue) decayValue.textContent = `${ms}ms`;
                    });
                } else {
                    console.error('decaySlider not found');
                }
                
                const sustainSlider = document.getElementById('sustainSlider');
                if (sustainSlider) {
                    sustainSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        // 0–100% → 0.00–1.0 level
                        const pct = Math.min(100, Math.max(0, parseInt(e.target.value, 10) || 0));
                        this.instruments.strum1.env.sustain = pct / 100;
                        const sustainValue = document.getElementById('sustainValue');
                        if (sustainValue) sustainValue.textContent = `${pct}%`;
                    });
                } else {
                    console.error('sustainSlider not found');
                }
                
                const releaseSlider = document.getElementById('releaseSlider');
                if (releaseSlider) {
                    releaseSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        // Clamp to 0–1000ms => 0–1.0s
                        const ms = Math.max(0, Math.min(1000, parseInt(e.target.value, 10) || 0));
                        this.instruments.strum1.env.release = ms / 1000;
                        const releaseValue = document.getElementById('releaseValue');
                        if (releaseValue) {
                            releaseValue.textContent = `${ms}ms`;
                        }
                    });
                } else {
                    console.error('releaseSlider not found');
                }

                // Master Volume control with dB conversion
                const masterVolumeSlider = document.getElementById('masterVolume');
                if (masterVolumeSlider) {
                    masterVolumeSlider.addEventListener('input', (e) => {
                        // Convert 0-10 scale to 0dB to -3dB (linear from 0 to 0.9)
                        const sliderValue = e.target.value / 10; // 0-1
                        this.masterVolume = sliderValue * 0.9; // Max at -3dB (0.9 linear gain)
                        if (this.gainNode) {
                            this.gainNode.gain.value = this.volume * this.masterVolume;
                        }
                        // Also update dry gain node for FX-bypassed instruments
                        if (this.dryGainNode) {
                            this.dryGainNode.gain.value = this.masterVolume;
                        }
                        // Reverb output should follow master as well
                        if (this.reverbOutGain) {
                            this.reverbOutGain.gain.value = this.masterVolume;
                        }
                        const masterVolumeValue = document.getElementById('masterVolumeValue');
                        if (masterVolumeValue) {
                            masterVolumeValue.textContent = `${e.target.value * 10}%`;
                        }
                        // Sync transport volume
                        const transportVol = document.getElementById('transportMasterVolume');
                        if (transportVol && transportVol.value != e.target.value) {
                            transportVol.value = e.target.value;
                        }
                    });
                } else {
                    console.error('masterVolumeSlider not found');
                }

                // Initialize Transport Controls immediately after master volume
                setTimeout(() => {
                    const playBtn = document.getElementById('playStopTransportBtn');
                    const loopToggle = document.getElementById('loopToggle');
                    const prevBtn = document.getElementById('prevChordBtn');
                    const nextBtn = document.getElementById('nextChordBtn');
                    const bpmInput = document.getElementById('transportBpm');
                    const transportVolInput = document.getElementById('transportMasterVolume');
                    const legacyPlayToggle = document.getElementById('playStopToggleBtn');

                    // Master BPM setter that works with this instance
                    const setMasterBpm = (raw) => {
                        const bpm = Math.max(20, Math.min(300, parseInt(raw,10) || 120));
                        
                        // Update all transport objects
                        if (this._arpTransport) {
                            this._arpTransport.bpm = bpm;
                            this._arpTransport.tickMs = (60000 / bpm) / 16; // 16 ticks per beat
                            this._arpTransport.beatMs = 60000 / bpm;
                        }
                        if (this._arp) {
                            this._arp.bpm = bpm;
                        }
                        if (window._patternTransport) {
                            window._patternTransport.bpm = bpm;
                        }
                        
                        // Update transport BPM field only
                        if (bpmInput && bpmInput.value != bpm) bpmInput.value = bpm;
                        
                        // DISABLE other BPM inputs to prevent conflicts
                        const drumBpm = document.getElementById('drumBpmMini');
                        if (drumBpm) {
                            drumBpm.disabled = true;
                            drumBpm.value = bpm;
                            drumBpm.style.opacity = '0.5';
                            drumBpm.title = 'BPM controlled by transport';
                        }
                        const patternBpm = document.getElementById('patternBpm');
                        if (patternBpm) {
                            patternBpm.disabled = true;
                            patternBpm.value = bpm;
                            patternBpm.style.opacity = '0.5';
                            patternBpm.title = 'BPM controlled by transport';
                        }
                        const universalBpm = document.getElementById('universalBpm');
                        if (universalBpm) {
                            universalBpm.disabled = true;
                            universalBpm.value = bpm;
                            universalBpm.style.opacity = '0.5';
                            universalBpm.title = 'BPM controlled by transport';
                        }
                        
                        window.__MASTER_BPM = bpm;
                        console.log('🎵 Master BPM set to:', bpm, 'tickMs:', this._arpTransport?.tickMs);
                        return bpm;
                    };

                    // Initialize BPM sync
                    if (typeof window.__MASTER_BPM === 'undefined') {
                        const seed = (bpmInput && bpmInput.value) || 120;
                        setMasterBpm(seed);
                    }

                    // Wire transport play button
                    if (playBtn && !playBtn._transportWired) {
                        playBtn._transportWired = true;
                        playBtn.addEventListener('click', () => {
                            console.log('🎵 Transport PLAY clicked, delegating to legacy button');
                            if (legacyPlayToggle) {
                                legacyPlayToggle.click();
                                // Update transport button state
                                setTimeout(() => {
                                    const isSequencing = this._isSequencing;
                                    playBtn.textContent = isSequencing ? 'STOP' : 'PLAY';
                                    playBtn.style.background = isSequencing ? '#e74c3c' : '#27ae60';
                                    console.log('🎵 Transport button state updated:', isSequencing ? 'STOP' : 'PLAY');
                                }, 50);
                            }
                        });
                        
                        // Set up state monitoring
                        const updateTransportState = () => {
                            const isSequencing = this._isSequencing;
                            const newText = isSequencing ? 'STOP' : 'PLAY';
                            const newBg = isSequencing ? '#e74c3c' : '#27ae60';
                            if (playBtn.textContent !== newText) {
                                playBtn.textContent = newText;
                                playBtn.style.background = newBg;
                            }
                        };
                        setInterval(updateTransportState, 200);
                    }

                    // Wire BPM input
                    if (bpmInput && !bpmInput._transportWired) {
                        bpmInput._transportWired = true;
                        bpmInput.addEventListener('input', () => {
                            console.log('🎵 Transport BPM input changed to:', bpmInput.value);
                            setMasterBpm(bpmInput.value);
                        });
                    }

                    // Wire transport volume
                    if (transportVolInput && !transportVolInput._transportWired) {
                        transportVolInput._transportWired = true;
                        transportVolInput.addEventListener('input', (e) => {
                            const vol = parseFloat(e.target.value);
                            const sliderValue = vol / 10;
                            
                            // Only control oscillators if MIDI is not active (not muted)
                            if (this._preMidiMasterVolume === undefined) {
                                this.masterVolume = sliderValue * 0.9;
                                if (this.gainNode) this.gainNode.gain.value = this.volume * this.masterVolume;
                                if (this.dryGainNode) this.dryGainNode.gain.value = this.masterVolume;
                                if (this.reverbOutGain) this.reverbOutGain.gain.value = this.masterVolume;
                                console.log('🎵 Transport volume set oscillators to:', vol);
                            } else {
                                // MIDI is active - store new volume for when MIDI is disabled but don't apply yet
                                this._preMidiMasterVolume = sliderValue * 0.9;
                                console.log('🎵 Transport volume stored for post-MIDI:', vol);
                            }
                            
                            // Also affect MIDI output volume if enabled
                            if (window.midi && window.midi.enabled) {
                                // Apply volume scaling to MIDI velocity (stored for future note sends)
                                window.midi._masterVolumeScale = sliderValue;
                                console.log('🎵 Transport volume set MIDI scale to:', sliderValue);
                            }
                            
                            // Sync legacy volume slider
                            if (masterVolumeSlider && masterVolumeSlider.value != vol) {
                                masterVolumeSlider.value = vol;
                            }
                            const masterVolumeValue = document.getElementById('masterVolumeValue');
                            if (masterVolumeValue) {
                                masterVolumeValue.textContent = `${vol * 10}%`;
                            }
                        });
                    }

                    // Wire navigation
                    if (prevBtn && !prevBtn._transportWired) {
                        prevBtn._transportWired = true;
                        prevBtn.addEventListener('click', () => {
                            console.log('🎵 Transport PREV clicked');
                            if (typeof this.navigateChord === 'function') {
                                this.navigateChord(-1);
                            } else {
                                console.warn('navigateChord method not found');
                            }
                        });
                    }

                    if (nextBtn && !nextBtn._transportWired) {
                        nextBtn._transportWired = true;
                        nextBtn.addEventListener('click', () => {
                            console.log('🎵 Transport NEXT clicked');
                            if (typeof this.navigateChord === 'function') {
                                this.navigateChord(1);
                            } else {
                                console.warn('navigateChord method not found');
                            }
                        });
                    }

                    // Wire loop toggle
                    if (loopToggle && !loopToggle._transportWired) {
                        loopToggle._transportWired = true;
                        loopToggle.addEventListener('change', () => {
                            console.log('🎵 Transport LOOP toggled:', loopToggle.checked);
                            if (this._arpTransport) {
                                this._arpTransport.loopEnabled = loopToggle.checked;
                            }
                            // Sync with legacy loop checkbox
                            const legacyLoop = document.getElementById('playLoop');
                            if (legacyLoop && legacyLoop.checked !== loopToggle.checked) {
                                legacyLoop.checked = loopToggle.checked;
                                legacyLoop.dispatchEvent(new Event('change'));
                            }
                        });
                    }

                    console.log('🎵 Transport controls initialized and wired to omnichord instance');
                }, 100);

                // Transport Controls Integration
                this.initTransportControls = () => {
                    const playBtn = document.getElementById('playStopTransportBtn');
                    const loopToggle = document.getElementById('loopToggle');
                    const prevBtn = document.getElementById('prevChordBtn');
                    const nextBtn = document.getElementById('nextChordBtn');
                    const bpmInput = document.getElementById('transportBpm');
                    const transportVolInput = document.getElementById('transportMasterVolume');
                    const legacyPlayToggle = document.getElementById('playStopToggleBtn');

                    // Master BPM setter - single source of truth
                    const setMasterBpm = (raw) => {
                        const bpm = Math.max(20, Math.min(300, parseInt(raw,10) || 120));
                        if (this._arpTransport) this._arpTransport.bpm = bpm;
                        if (window._patternTransport) window._patternTransport.bpm = bpm;
                        if (bpmInput && bpmInput.value != bpm) bpmInput.value = bpm;
                        const drumBpm = document.getElementById('drumBpmMini');
                        if (drumBpm && drumBpm.value != bpm) drumBpm.value = bpm;
                        const patternBpm = document.getElementById('patternBpm');
                        if (patternBpm && patternBpm.value != bpm) patternBpm.value = bpm;
                        window.__MASTER_BPM = bpm;
                        return bpm;
                    };

                    // Initialize master BPM
                    if (typeof window.__MASTER_BPM === 'undefined') {
                        const seed = (bpmInput && bpmInput.value) || 120;
                        setMasterBpm(seed);
                    } else {
                        setMasterBpm(window.__MASTER_BPM);
                    }

                    // Wire transport play button
                    if (playBtn && !playBtn._wired) {
                        playBtn._wired = true;
                        playBtn.addEventListener('click', () => {
                            if (legacyPlayToggle) {
                                legacyPlayToggle.click(); // Use existing play/stop logic
                                setTimeout(() => {
                                    const isSequencing = this._isSequencing;
                                    playBtn.textContent = isSequencing ? 'STOP' : 'PLAY';
                                    playBtn.style.background = isSequencing ? '#e74c3c' : '#27ae60';
                                }, 10);
                            }
                        });
                    }

                    // Mirror play state changes
                    if (legacyPlayToggle && playBtn && !legacyPlayToggle._mirrorToTransport) {
                        legacyPlayToggle._mirrorToTransport = true;
                        const updateTransportBtn = () => {
                            const isSequencing = this._isSequencing;
                            playBtn.textContent = isSequencing ? 'STOP' : 'PLAY';
                            playBtn.style.background = isSequencing ? '#e74c3c' : '#27ae60';
                        };
                        const observer = new MutationObserver(updateTransportBtn);
                        observer.observe(legacyPlayToggle, { attributes: true, attributeFilter: ['class'] });
                        // Also listen for direct property changes
                        setInterval(updateTransportBtn, 500);
                    }

                    // Wire transport BPM
                    if (bpmInput && !bpmInput._wired) {
                        bpmInput._wired = true;
                        bpmInput.addEventListener('input', () => { setMasterBpm(bpmInput.value); });
                    }

                    // Wire transport volume
                    if (transportVolInput && !transportVolInput._wired) {
                        transportVolInput._wired = true;
                        transportVolInput.addEventListener('input', (e) => {
                            const vol = parseFloat(e.target.value);
                            const sliderValue = vol / 10;
                            this.masterVolume = sliderValue * 0.9;
                            if (this.gainNode) this.gainNode.gain.value = this.volume * this.masterVolume;
                            if (this.dryGainNode) this.dryGainNode.gain.value = this.masterVolume;
                            if (this.reverbOutGain) this.reverbOutGain.gain.value = this.masterVolume;
                            // Sync legacy volume
                            if (masterVolumeSlider && masterVolumeSlider.value != vol) {
                                masterVolumeSlider.value = vol;
                            }
                            const masterVolumeValue = document.getElementById('masterVolumeValue');
                            if (masterVolumeValue) {
                                masterVolumeValue.textContent = `${vol * 10}%`;
                            }
                        });
                    }

                    // Wire navigation buttons
                    if (prevBtn && !prevBtn._wired) {
                        prevBtn._wired = true;
                        prevBtn.addEventListener('click', () => {
                            if (typeof this.navigateChord === 'function') {
                                this.navigateChord(-1);
                            }
                        });
                    }

                    if (nextBtn && !nextBtn._wired) {
                        nextBtn._wired = true;
                        nextBtn.addEventListener('click', () => {
                            if (typeof this.navigateChord === 'function') {
                                this.navigateChord(1);
                            }
                        });
                    }

                    // Make existing bracket markers draggable
                    const existingMarkers = document.querySelectorAll('.repeat-marker-column');
                    existingMarkers.forEach(marker => {
                        if (!marker._draggableWired && typeof makeBracketDraggable === 'function') {
                            makeBracketDraggable(marker);
                            marker._draggableWired = true;
                        }
                    });
                    
                    // Initialize chord column drop zones
                    if (typeof makeChordColumnsDroppable === 'function') {
                        makeChordColumnsDroppable();
                    }
                    
                    // Initialize chord resize functionality
                    if (typeof initChordResize === 'function') {
                        initChordResize();
                    }
                    
                // Initialize universal EDO field synchronization
                if (typeof initUniversalEDOSync === 'function') {
                    initUniversalEDOSync();
                }                    // Monitor string compression
                    if (typeof updateStringCompression === 'function') {
                        updateStringCompression();
                        // Also monitor on window resize
                        window.addEventListener('resize', updateStringCompression);
                        
                        // Add automatic monitoring for when chords are created/updated
                        const observer = new MutationObserver(() => {
                            setTimeout(() => {
                                if (typeof updateStringCompression === 'function') {
                                    updateStringCompression();
                                }
                            }, 100); // Small delay to ensure layout is complete
                        });
                        
                        // Observe changes to the extension columns container
                        const extensionColumns = document.getElementById('extensionColumns');
                        if (extensionColumns) {
                            observer.observe(extensionColumns, {
                                childList: true,
                                subtree: true,
                                attributes: false
                            });
                        }
                    }
                    
                    // Initialize keyboard modal with keys visible
                    if (typeof bringModalToFront === 'function') {
                        bringModalToFront('keyboardModal');
                    }
                    if (typeof fixBracketMovement === 'function') {
                        // Fix bracket movement after short delay to ensure DOM is ready
                        setTimeout(fixBracketMovement, 500);
                    }
                    
                    // Fix oscillator routing - ensure oscillators work by default, MIDI only when enabled
                    const midiBtn = document.getElementById('midiBtn');
                    if (midiBtn && !midiBtn.classList.contains('active')) {
                        // MIDI is off, ensure oscillators are active
                        this.enableOscillators = true;
                        this.midiEnabled = false;
                    } else if (midiBtn && midiBtn.classList.contains('active')) {
                        // MIDI is on, prioritize MIDI
                        this.enableOscillators = false;
                        this.midiEnabled = true;
                    }
                    
                    // Ensure keyboard keys are visible by moving root grid to modal
                    setTimeout(() => {
                        const rootGrid = document.getElementById('rootGrid');
                        const modalRootGrid = document.getElementById('modalRootGrid');
                        if (rootGrid && modalRootGrid && !modalRootGrid.hasChildNodes()) {
                            // Move the root grid content into the modal
                            while (rootGrid.firstChild) {
                                modalRootGrid.appendChild(rootGrid.firstChild);
                            }
                        }
                        
                        // Ensure keyboard modal is visible and keys show
                        const keyboardModal = document.getElementById('keyboardModal');
                        if (keyboardModal && keyboardModal.style.display !== 'none') {
                            // Force regeneration of keyboard if empty
                            if (modalRootGrid && modalRootGrid.children.length === 0) {
                                // Trigger keyboard generation
                                if (typeof this.generateKeyboard === 'function') {
                                    this.generateKeyboard();
                                }
                            }
                        }
                    }, 1000);

                    // Wire loop toggle
                    if (loopToggle && !loopToggle._wired) {
                        loopToggle._wired = true;
                        loopToggle.addEventListener('change', () => {
                            if (this._arpTransport) {
                                this._arpTransport.loopEnabled = loopToggle.checked;
                            }
                            // Also sync with legacy loop checkbox
                            const legacyLoop = document.getElementById('playLoop');
                            if (legacyLoop && legacyLoop.checked !== loopToggle.checked) {
                                legacyLoop.checked = loopToggle.checked;
                            }
                        });
                    }
                };

                // Initialize transport controls
                this.initTransportControls();

                // Force compact one-octave voicing
                this.splitExtendedChordsAcrossOctaves = false;

        // Play modes via inline buttons
    this.playMode = this.playMode || 'high-low';
    // STRUM defaults to DOWN per latest directive; internal mapping uses high-low
    this.strumMode = this.strumMode || 'down'; // up | down | alt-centers | alt-ends
    // STRUM is always enabled; CHORD vs ARP is a single exclusive toggle
    this.strumEnabled = true;
    this.chordsEnabled = false;
    this.arpEnabled = true; // default to ARP on the toggle
    this.bassEnabled = true;
        this.setPlayMode = (mode) => {
            const strumModes = ['high-low','low-high','alt-ends','alt-center'];
            const chordArpModes = ['chords','arp'];
            if (strumModes.includes(mode)) {
                // Update strumMode mapping only; keep playMode (arp/chords) as-is
                switch(mode){
                    case 'low-high': this.strumMode = 'up'; break;
                    case 'high-low': this.strumMode = 'down'; break;
                    case 'alt-center': this.strumMode = 'alt-centers'; break;
                    case 'alt-ends': default: this.strumMode = 'alt-ends'; break;
                }
                if (typeof this.applyPlayModeToAllColumns === 'function') this.applyPlayModeToAllColumns();
                this.updateModeUI?.();
                return;
            }
            if (chordArpModes.includes(mode)) {
                this.playMode = mode;
                this.chordsEnabled = (mode === 'chords');
                this.arpEnabled = (mode === 'arp');
                this.strumEnabled = true;
                this.updateModeUI?.();
                return;
            }
            // Fallback: keep current playMode, update visuals
            if (typeof this.applyPlayModeToAllColumns === 'function') this.applyPlayModeToAllColumns();
            this.updateModeUI?.();
        };
        
        // Sync playMode with CHORD/ARP selection and STRUM order
        this.syncPlayMode = () => {
            if (this.chordsEnabled && !this.arpEnabled) {
                this.playMode = 'chords';
            } else if (this.arpEnabled && !this.chordsEnabled) {
                this.playMode = 'arp';
            } else {
                // Both off: STRUM-only
                this.playMode = (this.strumMode === 'up') ? 'low-high' : 'high-low';
            }
        };
        
        // Independent mode toggles
        this.toggleStrumMode = () => {
            // STRUM always stays on, just cycle through UP, DOWN, ALT-CENTERS, ALT-ENDS
            this.strumEnabled = true;
            this.cycleStrumMode();
            if (typeof this.applyPlayModeToAllColumns === 'function') this.applyPlayModeToAllColumns();
            this.updateModeUI();
        };

        // Single button cycles: OFF → CHORDS → ARP → ARP+CHORDS → OFF
        this.toggleChordArpMode = () => {
            const a = !!this.arpEnabled, c = !!this.chordsEnabled;
            
            // Check if playback is active - if so, defer ARP change to next cycle
            const isPlaying = this._arpTransport && this._arpTransport.isRunning;
            
            if (isPlaying) {
                // Defer ARP mode change by 2 beats during playback
                if (window.scheduleDeferred && typeof window.scheduleDeferred === 'function') {
                    let nextState = 'off';
                    if (!a && !c) nextState = 'chords';
                    else if (c && !a) nextState = 'arp';
                    else if (a && !c) nextState = 'both';
                    else nextState = 'off';
                    
                    window.scheduleDeferred({ arpMode: nextState });
                    return; // Don't apply immediately
                }
            }
            
            // Apply immediately if stopped or no defer system
            let nextState = 'off';
            if (!a && !c) nextState = 'chords';
            else if (c && !a) nextState = 'arp';
            else if (a && !c) nextState = 'both';
            else nextState = 'off';

            if (nextState === 'chords') { this.chordsEnabled = true; this.arpEnabled = false; }
            else if (nextState === 'arp') { this.chordsEnabled = false; this.arpEnabled = true; }
            else if (nextState === 'both') { this.chordsEnabled = true; this.arpEnabled = true; }
            else { this.chordsEnabled = false; this.arpEnabled = false; }

            this.syncPlayMode();
            this.updateModeUI();
            try { if (this.chordsEnabled || this.arpEnabled) this._startArpTransport(); } catch(_) {}
        };
        
        this.toggleBassMode = () => {
            this.bassEnabled = !this.bassEnabled;
            // If turning off bass but no other modes active, enable strum
            if (!this.bassEnabled && !this.strumEnabled && !this.chordsEnabled && !this.arpEnabled) {
                this.strumEnabled = true;
            }
            this.syncPlayMode();
            this.updateModeUI();
        };
        
        // Universal control synchronization
        this.syncUniversalControls = () => {
            // All controls are universal now; ensure values are sane and reflect engine state.
            const universalNpc = document.getElementById('universalNpc');
            if (universalNpc) universalNpc.value = String(Math.max(1, Math.min(64, parseInt(universalNpc.value)||3)));
            const universalHold = document.getElementById('universalHold');
            const chordHold = document.getElementById('chordHold');
            if (universalHold && chordHold) universalHold.value = chordHold.value;
        };
        
        // Apply universal settings to all individual controls
        this.applyUniversalSettings = () => {
            const universalBpm = document.getElementById('universalBpm');
            const universalQuant = document.getElementById('universalQuant');
            const universalNpc = document.getElementById('universalNpc');
            const universalHold = document.getElementById('universalHold');
            const universalPattern = document.getElementById('universalPattern');
            
            // Apply to engine from universal controls
            const chordHold = document.getElementById('chordHold');
            
            if (universalBpm) { this.bpm = parseInt(universalBpm.value) || 120; }
            // quant pattern is read at use sites from universal controls
            if (universalNpc) {
                const npcValue = parseInt(universalNpc.value) || 3;
                this.arpNotesPerCycle = npcValue;
                // Also sync to other NPC-related properties
                if (this._arp) {
                    this._arp.npc = npcValue;
                    this._arp.chordsNpc = npcValue;
                }
            }
            if (universalHold) {
                if (chordHold) chordHold.value = universalHold.value;
            }
            // No per-mode pattern element to mirror
            // Handle time signature changes
            const universalTimeSignature = document.getElementById('universalTimeSignature');
            if (universalTimeSignature) {
                // Only rebuild grid immediately if transport is not running; otherwise event handler defers it
                this._ensureArpTransport();
                if (!this._arpTransport.running) {
                    try { this._updateDrumGridForTimeSignature(); } catch(_) {}
                }
            }
        };

        // Rebuild drum lanes to match current time signature (steps per bar)
        this._updateDrumGridForTimeSignature = () => {
            try {
                const grid = document.getElementById('drumGrid'); if (!grid) return;
                // Compute new steps per bar
                let tsNum=4, tsDen=4; try {
                    const tsRaw = String(document.getElementById('universalTimeSignature')?.value||'4/4');
                    const parts = tsRaw.split('/');
                    const a=parseInt(parts[0],10); const b=parseInt(parts[1],10);
                    if(Number.isFinite(a)&&a>0) tsNum=a; if(Number.isFinite(b)&&b>0) tsDen=b;
                } catch(_) {}
                const beatsPerBar = (tsNum*4)/tsDen;
                const stepsPerBar = Math.max(4, Math.round(beatsPerBar * 4));
                // For each lane, snapshot current steps, then rebuild children
                const lanes = Array.from(grid.querySelectorAll('.drum-lane'));
                lanes.forEach(lane => {
                    const isBass = lane.closest('.drum-row')?.classList?.contains('bass-row');
                    const oldSteps = Array.from(lane.querySelectorAll('.drum-step'));
                    const snapshot = oldSteps.map(s => ({
                        active: s.classList.contains('active'),
                        npc: s.dataset.npc,
                        len: s.dataset.len,
                        tie: s.dataset.tie
                    }));
                    // Clear lane except label/controls are in row, so safe to nuke steps/dividers/playhead
                    oldSteps.forEach(el=> el.remove());
                    Array.from(lane.querySelectorAll('.beat-divider')).forEach(el=> el.remove());
                    const ph = lane.querySelector('.drum-playhead'); if (ph) try { ph.remove(); } catch{}
                    // Set CSS var
                    try { lane.style.setProperty('--steps-per-bar', String(stepsPerBar)); } catch(_){ }
                    // Beat dividers
                    const fullBeats = Math.max(0, Math.floor(beatsPerBar));
                    for (let b=1; b<fullBeats; b++){
                        const div = document.createElement('div');
                        div.className = 'beat-divider';
                        div.style.left = `${(b/beatsPerBar)*100}%`;
                        lane.appendChild(div);
                    }
                    // Steps
                    for (let i=0;i<stepsPerBar;i++){
                        const s = document.createElement('div');
                        s.className = 'drum-step' + ((i%4===0)?' beat-accent':'');
                        s.dataset.step = String(i);
                        s.title = `${(isBass?'BASS':(lane._controls?.name||'DRUM'))} • Step ${i+1}`;
                        if (isBass) s.dataset.npc = '';
                        // restore state when possible
                        const prev = snapshot[i];
                        if (prev){
                            if (!isBass) { if (prev.active) s.classList.add('active'); }
                            else {
                                if (prev.npc != null && prev.npc !== undefined) { s.dataset.npc = prev.npc; if (prev.npc && prev.npc.toLowerCase() !== 'x') s.classList.add('active'); }
                                if (prev.len) s.dataset.len = prev.len; if (prev.tie) s.dataset.tie = prev.tie;
                            }
                        }
                        // Reattach click/drag behavior minimal for bass; normal drums get same click toggling via event below
                        if (isBass){
                            s.addEventListener('mousedown', (e)=>{
                                if (e.button !== 0) return; e.preventDefault();
                                const startIdx = i;
                                const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                const applyLen = (toIdx)=>{
                                    const len = Math.max(1, (toIdx|0) - startIdx + 1);
                                    s.dataset.len = String(len);
                                    for (let k=0;k<steps.length;k++){
                                        if (k>startIdx && k<=startIdx+len-1) steps[k].dataset.tie='1';
                                        else if (k>startIdx) delete steps[k].dataset.tie;
                                    }
                                    try { this.rebuildBassTieOverlays(lane); } catch(_){ }
                                };
                                const onMove = (ev)=>{
                                    const rect = lane.getBoundingClientRect();
                                    const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
                                    const idx = Math.max(0, Math.min(stepsPerBar-1, Math.floor((x / rect.width) * stepsPerBar)));
                                    applyLen(idx);
                                };
                                const onUp = ()=>{
                                    document.removeEventListener('mousemove', onMove);
                                    document.removeEventListener('mouseup', onUp);
                                };
                                document.addEventListener('mousemove', onMove);
                                document.addEventListener('mouseup', onUp);
                                // Immediate visual on initial click-drag state
                                applyLen(startIdx);
                            });
                            s.addEventListener('click', (e)=>{ e.preventDefault(); /* Delegate to existing logic by simulating? Keep simple: toggle + prompt on second click */
                                const prev = (s.dataset.npc||'');
                                if (prev === '') { s.dataset.npc='1'; s.classList.add('active'); if (!s.dataset.len) s.dataset.len='1'; }
                                else if (prev && prev.toLowerCase() !== 'x') {
                                    s.classList.add('selected');
                                    const valIn = window.prompt('Bass NPC (1–9) or x for rest', String(prev).toLowerCase());
                                    s.classList.remove('selected');
                                    if (valIn == null) return;
                                    const val = String(valIn).trim();
                                    if (val === '') { s.dataset.npc=''; s.classList.remove('active'); delete s.dataset.len; return; }
                                    if (/^x$/i.test(val)) { s.dataset.npc='x'; s.classList.remove('active'); delete s.dataset.len; return; }
                                    if (/^[1-9]$/.test(val)) { s.dataset.npc=val; s.classList.add('active'); if (!s.dataset.len) s.dataset.len='1'; }
                                } else { s.dataset.npc='1'; s.classList.add('active'); if (!s.dataset.len) s.dataset.len='1'; }
                            });
                        } else {
                            s.addEventListener('click', (e)=>{
                                e.preventDefault();
                                const nowActive = !s.classList.contains('active');
                                if (nowActive) s.classList.add('active'); else s.classList.remove('active');
                                try {
                                    if (nowActive){
                                        const row = s.closest('.drum-row');
                                        const rowIdx = parseInt(lane.dataset.row||'0',10)|0;
                                        const volEl = row ? row.querySelector('.drum-volume') : null;
                                        const fxEl = row ? row.querySelector('.drum-fx input[type="checkbox"]') : null;
                                        const vol = volEl ? Math.max(0, Math.min(1, parseInt(volEl.value||'80',10)/100)) : 0.8;
                                        const sendToFX = fxEl ? !!fxEl.checked : false;
                                        this._triggerDrumSound(rowIdx, vol, sendToFX);
                                    }
                                } catch(_){ }
                            });
                        }
                        lane.appendChild(s);
                    }
                    // Playhead element
                    const ph2 = document.createElement('div'); ph2.className='drum-playhead'; ph2.style.left='0%'; lane.appendChild(ph2);
                });
            } catch(_){}
        };
        
        this.cycleStrumMode = () => {
            const order = ['up','down','alt-centers','alt-ends'];
            const i = order.indexOf(this.strumMode);
            this.strumMode = order[(i+1)%order.length];
            const lbl = document.getElementById('strumLabel');
            if (lbl) {
                if (this.strumMode === 'alt-centers') lbl.textContent = 'Alt-C';
                else if (this.strumMode === 'alt-ends') lbl.textContent = 'Alt-E';
                else lbl.textContent = this.strumMode.charAt(0).toUpperCase()+this.strumMode.slice(1);
            }
            // Map strum mode to internal playMode ordering
            if (this.strumMode === 'up') this.setPlayMode('low-high');
            else if (this.strumMode === 'down') this.setPlayMode('high-low');
            else if (this.strumMode === 'alt-centers') this.setPlayMode('alt-center');
            else this.setPlayMode('alt-ends');
        };
        this.updateModeUI = () => {
            const btnStrum = document.getElementById('modeStrum');
            const btnChordArp = document.getElementById('modeChordArp');
            const btnBass = document.getElementById('universalBass');
            
            // Update strum button text based on current strum mode
            if (btnStrum) {
                btnStrum.classList.toggle('active', this.strumEnabled);
                // Always show strum as active and update text based on mode
                btnStrum.classList.add('active');
                
                // Set STRUM button text based on actual strumMode (not ARP pattern)
                let strumText = 'STRUM UP';
                switch (this.strumMode) {
                    case 'up': strumText = 'STRUM UP'; break;
                    case 'down': strumText = 'STRUM DOWN'; break;
                    case 'alternating': strumText = 'STRUM ALT'; break;
                    case 'alt-centers': strumText = 'STRUM ALT'; break;
                    case 'alt-ends': strumText = 'STRUM ALT'; break;
                    default: strumText = 'STRUM UP'; break;
                }
                btnStrum.textContent = strumText;
            }
            
            // CHORD/ARP 4-state toggle (OFF / CHORDS / ARP / ARP+CHORDS)
            if (btnChordArp) {
                let label = 'OFF';
                let title = 'Currently OFF; click to enable CHORDS';
                if (this.chordsEnabled && this.arpEnabled) { label = 'ARP+CHORDS'; title = 'Both ON; click for OFF'; }
                else if (this.chordsEnabled) { label = 'CHORDS'; title = 'CHORDS ON; click for ARP'; }
                else if (this.arpEnabled) { label = 'ARP'; title = 'ARP ON; click for ARP+CHORDS'; }
                btnChordArp.textContent = label;
                btnChordArp.classList.toggle('active', true); // keep styled active
                btnChordArp.title = title;
            }
            if (btnBass) btnBass.classList.toggle('active', this.bassEnabled);
        };
        // Wire buttons when present
        setTimeout(()=>{
            const btnStrum = document.getElementById('modeStrum');
            const btnChordArp = document.getElementById('modeChordArp');
            const btnBass = document.getElementById('universalBass');
            const lbl = document.getElementById('strumLabel');
            if (lbl) lbl.textContent = this.strumMode==='alternating' ? 'Alt' : (this.strumMode.charAt(0).toUpperCase()+this.strumMode.slice(1));
            if (btnStrum && !btnStrum._wired){ btnStrum._wired=true; btnStrum.addEventListener('click', ()=> this.toggleStrumMode()); }
            if (btnChordArp && !btnChordArp._wired){ btnChordArp._wired=true; btnChordArp.addEventListener('click', ()=> this.toggleChordArpMode()); }
            if (btnBass && !btnBass._wired){ btnBass._wired=true; btnBass.addEventListener('click', ()=> this.toggleBassMode()); }
            this.syncPlayMode();
            this.updateModeUI();
        }, 0);

                // Fixed strum delay (no menu)
                this.strumDelayMs = 12;

                // Chords slide state
                this._chordSlideEnabled = !!document.getElementById('chordSlide')?.checked;
                this._chordSlideActive = false;
                this._chordSlideVoices = new Map(); // Map<stringRowEl, {freq,startLog2}>
                this._chordSlideGroupId = 0;
                this._chordSlideStartColumn = null;
                this._chordSlideHoverColumn = null;
                
                // Update PLAY/STOP button states based on initial SLIDE setting
                this._updatePlayStopButtonStates();
                this._chordSlideHoverSince = 0;
                this._chordSlideCommittedColumn = null;
                this._lastChordSlideTime = 0;
                this._chordSlideHoverCommitTimer = null;
                // Idle-stop for CHORD slide mode
                this._chordSlideIdleTimer = null;
                this._chordSlideIdleMs = 2000; // stop sustaining ~2s after last activity
                // Small dwell to avoid triggering intermediate boxes during fast slides (ms)
                this._chordSlideDwellMs = 50; // default 50ms, target: 40–60ms - improved touch responsiveness
                // Track last movement vector for direction-aware voice leading
                this._chordSlideLastDX = 0;
                this._chordSlideLastDY = 0;
                this._lastChordSlideDeltaT = 0;
                const chordSlideEl = document.getElementById('chordSlide');
                if (chordSlideEl) {
                    chordSlideEl.addEventListener('change', (e)=>{
                        this._chordSlideEnabled = !!e.target.checked;
                        if (!this._chordSlideEnabled) {
                            try { clearTimeout(this._chordSlideIdleTimer); } catch(_) {}
                            this._chordSlideIdleTimer = null;
                            this._chordSlideActive = false;
                        }
                        
                        // Update PLAY/STOP button states
                        this._updatePlayStopButtonStates();
                    });
                }

                // OSC 2 ADSR controls
                const osc2AttackSlider = document.getElementById('osc2AttackSlider');
                if (osc2AttackSlider) {
                    osc2AttackSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.instruments.strum2.env.attack = Math.max(0.003, e.target.value / 1000); // 3ms minimum
                        const osc2AttackValue = document.getElementById('osc2AttackValue');
                        if (osc2AttackValue) {
                            osc2AttackValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('osc2AttackSlider not found');
                }
                
                const osc2DecaySlider = document.getElementById('osc2DecaySlider');
                if (osc2DecaySlider) {
                    osc2DecaySlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        const ms = Math.max(0, parseInt(e.target.value, 10) || 0);
                        this.instruments.strum2.env.decay = ms / 1000;
                        const osc2DecayValue = document.getElementById('osc2DecayValue');
                        if (osc2DecayValue) osc2DecayValue.textContent = `${ms}ms`;
                    });
                } else {
                    console.error('osc2DecaySlider not found');
                }
                
                const osc2SustainSlider = document.getElementById('osc2SustainSlider');
                if (osc2SustainSlider) {
                    osc2SustainSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        const pct = Math.min(100, Math.max(0, parseInt(e.target.value, 10) || 0));
                        this.instruments.strum2.env.sustain = pct / 100;
                        const osc2SustainValue = document.getElementById('osc2SustainValue');
                        if (osc2SustainValue) osc2SustainValue.textContent = `${pct}%`;
                    });
                } else {
                    console.error('osc2SustainSlider not found');
                }
                
                const osc2ReleaseSlider = document.getElementById('osc2ReleaseSlider');
                if (osc2ReleaseSlider) {
                    osc2ReleaseSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        // Clamp to 0–1000ms => 0–1.0s
                        const ms = Math.max(0, Math.min(1000, parseInt(e.target.value, 10) || 0));
                        this.instruments.strum2.env.release = ms / 1000;
                        const osc2ReleaseValue = document.getElementById('osc2ReleaseValue');
                        if (osc2ReleaseValue) {
                            osc2ReleaseValue.textContent = `${ms}ms`;
                        }
                    });
                } else {
                    console.error('osc2ReleaseSlider not found');
                }

                // Tab switching for OSC modal
                const tabBtns = document.querySelectorAll('.osc-tab-btn');
                const tabStrum1 = document.getElementById('tab-strum1');
                const tabStrum2 = document.getElementById('tab-strum2');
                const tabChord = document.getElementById('tab-chord');
                const tabArp = document.getElementById('tab-arp');
                const tabBass = document.getElementById('tab-bass');
                const showTab = (key)=>{
                    if (!tabStrum1 || !tabStrum2 || !tabChord || !tabArp || !tabBass) return;
                    tabBtns.forEach(b=> b.classList.remove('active'));
                    const btn = Array.from(tabBtns).find(b=> b.dataset.tab===key);
                    if (btn) btn.classList.add('active');
                    tabStrum1.style.display = (key==='strum1') ? 'block' : 'none';
                    tabStrum2.style.display = (key==='strum2') ? 'block' : 'none';
                    tabChord.style.display = (key==='chord') ? 'block' : 'none';
                    tabArp.style.display = (key==='arp') ? 'block' : 'none';
                    tabBass.style.display = (key==='bass') ? 'block' : 'none';
                };
                tabBtns.forEach(b=>{
                    if (!b._wired){ b._wired=true; b.addEventListener('click', ()=> showTab(b.dataset.tab)); }
                });

                // Oscillator controls
                document.querySelectorAll('.osc-btn[data-wave]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        const wave = btn.dataset.wave;
                        // STRUM osc1/osc2 use existing buttons with data-osc
                        if (btn.dataset.osc) {
                            const osc = btn.dataset.osc;
                            document.querySelectorAll(`[data-osc="${osc}"]`).forEach(b => b.classList.remove('active'));
                            btn.classList.add('active');
                            this.oscillators[`osc${osc}`].type = wave;
                            const pwContainer = document.querySelector(`.pulse-width-container[data-osc="${osc}"]`);
                            if (pwContainer) pwContainer.style.display = (wave === 'pulse') ? 'block' : 'none';
                            // Mirror to per-instrument store
                            const target = (osc==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.type = wave;
                        } else if (btn.dataset.inst === 'chord') {
                            // CHORD instrument
                            document.querySelectorAll('.osc-btn[data-inst="chord"]').forEach(b => b.classList.remove('active'));
                            btn.classList.add('active');
                            this.instruments.chord.osc.type = wave;
                            const c = document.getElementById('chordPulseWidthContainer'); if (c) c.style.display = (wave==='pulse')?'block':'none';
                        } else if (btn.dataset.inst === 'arp') {
                            // ARP instrument
                            document.querySelectorAll('.osc-btn[data-inst="arp"]').forEach(b => b.classList.remove('active'));
                            btn.classList.add('active');
                            this.instruments.arp.osc.type = wave;
                            const c = document.getElementById('arpPulseWidthContainer'); if (c) c.style.display = (wave==='pulse')?'block':'none';
                        } else if (btn.dataset.inst === 'bass') {
                            // BASS instrument
                            document.querySelectorAll('.osc-btn[data-inst="bass"]').forEach(b => b.classList.remove('active'));
                            btn.classList.add('active');
                            this.instruments.bass.osc.type = wave;
                            const c = document.getElementById('bassPulseWidthContainer'); if (c) c.style.display = (wave==='pulse')?'block':'none';
                        }
                    });
                });

                // Oscillator detune and level controls
                ['1', '2'].forEach(num => {
                    // Shape width slider (DC proportion)
                    const swSlider = document.getElementById(`osc${num}ShapeWidth`);
                    if (swSlider) {
                        swSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            const pct = Math.min(100, Math.max(0, parseInt(e.target.value, 10) || 50));
                            this.oscillators[`osc${num}`].shapeWidth = pct / 100; // 0..1
                            const v = document.getElementById(`osc${num}ShapeWidthValue`);
                            if (v) v.textContent = `${pct}%`;
                            // Mirror to per-instrument
                            const target = (num==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.shapeWidth = pct/100;
                        });
                    }

                    // Pulse width slider
                    const pwSlider = document.getElementById(`osc${num}PulseWidth`);
                    if (pwSlider) {
                        pwSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            const pct = Math.min(95, Math.max(5, parseInt(e.target.value, 10) || 50));
                            this.oscillators[`osc${num}`].pulseWidth = pct / 100;
                            const v = document.getElementById(`osc${num}PulseWidthValue`);
                            if (v) v.textContent = `${pct}%`;
                            const target = (num==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.pulseWidth = pct/100;
                        });
                    }

                    const detuneSlider = document.getElementById(`osc${num}Detune`);
                    if (detuneSlider) {
                        detuneSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            this.oscillators[`osc${num}`].detune = parseInt(e.target.value);
                            const detuneValue = document.getElementById(`osc${num}DetuneValue`);
                            if (detuneValue) {
                                detuneValue.textContent = `${e.target.value}¢`;
                            }
                            const target = (num==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.detune = parseInt(e.target.value);
                        });
                    } else {
                        console.error(`osc${num}Detune not found`);
                    }
                    
                    const levelSlider = document.getElementById(`osc${num}Level`);
                    if (levelSlider) {
                        levelSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            // Convert 0-10 scale to -18dB to 0dB (linear from 0.125 to 1.0)
                            const sliderValue = e.target.value / 10; // 0-1
                            this.oscillators[`osc${num}`].level = sliderValue * 0.125; // Max at -18dB
                            const levelValue = document.getElementById(`osc${num}LevelValue`);
                            if (levelValue) {
                                levelValue.textContent = `${e.target.value * 10}%`;
                            }
                            const target = (num==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.level = sliderValue * 0.125;
                        });
                    } else {
                        console.error(`osc${num}Level not found`);
                    }
                });

                // Oscillator octave and coarse controls
                ['1', '2'].forEach(num => {
                    const octaveSlider = document.getElementById(`osc${num}Octave`);
                    if (octaveSlider) {
                        octaveSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            this.oscillators[`osc${num}`].octave = parseInt(e.target.value);
                            const octaveValue = document.getElementById(`osc${num}OctaveValue`);
                            if (octaveValue) {
                                octaveValue.textContent = e.target.value;
                            }
                            const target = (num==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.octave = parseInt(e.target.value);
                        });
                    } else {
                        console.error(`osc${num}Octave not found`);
                    }
                    
                    const coarseSlider = document.getElementById(`osc${num}Coarse`);
                    if (coarseSlider) {
                        coarseSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            this.oscillators[`osc${num}`].coarse = parseInt(e.target.value);
                            const coarseValue = document.getElementById(`osc${num}CoarseValue`);
                            if (coarseValue) {
                                coarseValue.textContent = `${e.target.value} steps`;
                            }
                            const target = (num==='1') ? this.instruments.strum1 : this.instruments.strum2;
                            target.osc.coarse = parseInt(e.target.value);
                        });
                    } else {
                        console.error(`osc${num}Coarse not found`);
                    }
                });

                // CHORD/BASS/ARP controls wiring (with piano lock protection)
                // Default values for all sliders (for double-tap reset)
                this.sliderDefaults = {
                    // OSC 1 (STRUM 1)
                    'osc1Level': 5, 'osc1Detune': 0, 'osc1Octave': 0, 'osc1Coarse': 0, 'osc1PulseWidth': 50, 'osc1ShapeWidth': 50,
                    'attackSlider': 0, 'decaySlider': 200, 'sustainSlider': 0, 'releaseSlider': 1000,
                    // OSC 2 (STRUM 2) 
                    'osc2Level': 5, 'osc2Detune': 0, 'osc2Octave': 0, 'osc2Coarse': 0, 'osc2PulseWidth': 50, 'osc2ShapeWidth': 50,
                    'attack2Slider': 0, 'decay2Slider': 200, 'sustain2Slider': 0, 'release2Slider': 1000,
                    // CHORD (OSC 3)
                    'chordLevel': 5, 'chordDetune': 0, 'chordOctave': 0, 'chordCoarse': 0, 'chordPulseWidth': 50, 'chordShapeWidth': 50,
                    'chordAttack': 10, 'chordDecay': 200, 'chordSustain': 90, 'chordRelease': 300,
                    // ARP (OSC 5)
                    'arpLevel': 5, 'arpDetune': 0, 'arpOctave': 0, 'arpCoarse': 0, 'arpPulseWidth': 50, 'arpShapeWidth': 50,
                    'arpAttack': 10, 'arpDecay': 200, 'arpSustain': 90, 'arpRelease': 300,
                    // BASS (OSC 4)
                    'bassLevel': 5, 'bassDetune': 0, 'bassOctave': 0, 'bassCoarse': 0, 'bassPulseWidth': 50, 'bassShapeWidth': 50,
                    'bassAttack': 5, 'bassDecay': 80, 'bassSustain': 90, 'bassRelease': 120,
                    // FX
                    'driveAmount': 0, 'driveMix': 0, 'driveHpCutoff': 0, 'driveLpCutoff': 100,
                    'delayTime': 280, 'delayFeedback': 25, 'delayLpCutoff': 73, 'delayHpCutoff': 0, 'delayMix': 0,
                    'filterLow': 0, 'filterHigh': 100, 'filterRes': 1,
                    'reverbWet': 1, 'reverbRoom': 5, 'reverbDecay': 20, 'reverbFilterCutoff': 70
                };

                const wireVal = (id, cb)=>{ 
                    const el=document.getElementById(id); 
                    if (el && !el._wired){ 
                        el._wired=true; 
                        
                        // Double-tap detection for sliders (not checkboxes)
                        if (el.type !== 'checkbox') {
                            let lastTapTime = 0;
                            const doubleTapDelay = 300; // ms
                            
                            // Double-tap handler
                            el.addEventListener('dblclick', (e) => {
                                e.preventDefault();
                                if (this.sliderDefaults.hasOwnProperty(id)) {
                                    el.value = this.sliderDefaults[id];
                                    // Trigger the change event to update the UI and internal state
                                    const changeEvent = new Event('input', { bubbles: true });
                                    el.dispatchEvent(changeEvent);
                                }
                            });
                        }
                        
                        // Use appropriate event based on element type
                        const eventType = el.type === 'checkbox' ? 'change' : 'input';
                        el.addEventListener(eventType, (e)=>{ 
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { 
                                this.flashPianoLockFeedback && this.flashPianoLockFeedback(); 
                                return; 
                            } 
                            cb(e); 
                        });
                    } 
                };
                wireVal('chordShapeWidth', (e)=>{ const pct=Math.max(0,Math.min(100,parseInt(e.target.value)||50)); this.instruments.chord.osc.shapeWidth=pct/100; const v=document.getElementById('chordShapeWidthValue'); if(v) v.textContent=`${pct}%`; });
                wireVal('chordPulseWidth', (e)=>{ const pct=Math.max(5,Math.min(95,parseInt(e.target.value)||50)); this.instruments.chord.osc.pulseWidth=pct/100; const v=document.getElementById('chordPulseWidthValue'); if(v) v.textContent=`${pct}%`; });
                wireVal('chordDetune', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.chord.osc.detune=v; const l=document.getElementById('chordDetuneValue'); if(l) l.textContent=`${v}¢`; });
                wireVal('chordLevel', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.chord.osc.level=(v/10)*0.125; const l=document.getElementById('chordLevelValue'); if(l) l.textContent=`${v*10}%`; });
                wireVal('chordOctave', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.chord.osc.octave=v; const l=document.getElementById('chordOctaveValue'); if(l) l.textContent=String(v); });
                wireVal('chordCoarse', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.chord.osc.coarse=v; const l=document.getElementById('chordCoarseValue'); if(l) l.textContent=`${v} steps`; });
                wireVal('chordAttackSlider', (e)=>{ const ms=Math.max(3,parseInt(e.target.value)||10); this.instruments.chord.env.attack=ms/1000; const l=document.getElementById('chordAttackValue'); if(l) l.textContent=`${ms}ms`; });
                wireVal('chordDecaySlider', (e)=>{ const ms=Math.max(0,parseInt(e.target.value)||200); this.instruments.chord.env.decay=ms/1000; const l=document.getElementById('chordDecayValue'); if(l) l.textContent=`${ms}ms`; });
                wireVal('chordSustainSlider', (e)=>{ const pct=Math.max(0,Math.min(100,parseInt(e.target.value)||70)); this.instruments.chord.env.sustain=pct/100; const l=document.getElementById('chordSustainValue'); if(l) l.textContent=`${pct}%`; });
                wireVal('chordReleaseSlider', (e)=>{ const ms=Math.max(0,parseInt(e.target.value)||500); this.instruments.chord.env.release=ms/1000; const l=document.getElementById('chordReleaseValue'); if(l) l.textContent=`${ms}ms`; });

                // ARP instrument controls
                wireVal('arpShapeWidth', (e)=>{ const pct=Math.max(0,Math.min(100,parseInt(e.target.value)||50)); this.instruments.arp.osc.shapeWidth=pct/100; const v=document.getElementById('arpShapeWidthValue'); if(v) v.textContent=`${pct}%`; });
                wireVal('arpPulseWidth', (e)=>{ const pct=Math.max(5,Math.min(95,parseInt(e.target.value)||50)); this.instruments.arp.osc.pulseWidth=pct/100; const v=document.getElementById('arpPulseWidthValue'); if(v) v.textContent=`${pct}%`; });
                wireVal('arpDetune', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.arp.osc.detune=v; const l=document.getElementById('arpDetuneValue'); if(l) l.textContent=`${v}¢`; });
                wireVal('arpLevel', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.arp.osc.level=(v/10)*0.125; const l=document.getElementById('arpLevelValue'); if(l) l.textContent=`${v*10}%`; });
                wireVal('arpOctave', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.arp.osc.octave=v; const l=document.getElementById('arpOctaveValue'); if(l) l.textContent=String(v); });
                wireVal('arpCoarse', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.arp.osc.coarse=v; const l=document.getElementById('arpCoarseValue'); if(l) l.textContent=`${v} steps`; });
                wireVal('arpAttackSlider', (e)=>{ const ms=Math.max(3,parseInt(e.target.value)||10); this.instruments.arp.env.attack=ms/1000; const l=document.getElementById('arpAttackValue'); if(l) l.textContent=`${ms}ms`; });
                wireVal('arpDecaySlider', (e)=>{ const ms=Math.max(0,parseInt(e.target.value)||200); this.instruments.arp.env.decay=ms/1000; const l=document.getElementById('arpDecayValue'); if(l) l.textContent=`${ms}ms`; });
                wireVal('arpSustainSlider', (e)=>{ const pct=Math.max(0,Math.min(100,parseInt(e.target.value)||70)); this.instruments.arp.env.sustain=pct/100; const l=document.getElementById('arpSustainValue'); if(l) l.textContent=`${pct}%`; });
                wireVal('arpReleaseSlider', (e)=>{ const ms=Math.max(0,parseInt(e.target.value)||500); this.instruments.arp.env.release=ms/1000; const l=document.getElementById('arpReleaseValue'); if(l) l.textContent=`${ms}ms`; });

                wireVal('bassShapeWidth', (e)=>{ const pct=Math.max(0,Math.min(100,parseInt(e.target.value)||50)); this.instruments.bass.osc.shapeWidth=pct/100; const l=document.getElementById('bassShapeWidthValue'); if(l) l.textContent=`${pct}%`; });
                wireVal('bassPulseWidth', (e)=>{ const pct=Math.max(5,Math.min(95,parseInt(e.target.value)||50)); this.instruments.bass.osc.pulseWidth=pct/100; const l=document.getElementById('bassPulseWidthValue'); if(l) l.textContent=`${pct}%`; });
                wireVal('bassDetune', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.bass.osc.detune=v; const l=document.getElementById('bassDetuneValue'); if(l) l.textContent=`${v}¢`; });
                wireVal('bassLevel', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.bass.osc.level=(v/10)*0.125; const l=document.getElementById('bassLevelValue'); if(l) l.textContent=`${v*10}%`; });
                wireVal('bassOctave', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.bass.osc.octave=v; const l=document.getElementById('bassOctaveValue'); if(l) l.textContent=String(v); });
                wireVal('bassCoarse', (e)=>{ const v=parseInt(e.target.value)||0; this.instruments.bass.osc.coarse=v; const l=document.getElementById('bassCoarseValue'); if(l) l.textContent=`${v} steps`; });
                wireVal('bassAttackSlider', (e)=>{ const ms=Math.max(3,parseInt(e.target.value)||5); this.instruments.bass.env.attack=ms/1000; const l=document.getElementById('bassAttackValue'); if(l) l.textContent=`${ms}ms`; });
                wireVal('bassDecaySlider', (e)=>{ const ms=Math.max(0,parseInt(e.target.value)||80); this.instruments.bass.env.decay=ms/1000; const l=document.getElementById('bassDecayValue'); if(l) l.textContent=`${ms}ms`; });
                wireVal('bassSustainSlider', (e)=>{ const pct=Math.max(0,Math.min(100,parseInt(e.target.value)||85)); this.instruments.bass.env.sustain=pct/100; const l=document.getElementById('bassSustainValue'); if(l) l.textContent=`${pct}%`; });
                wireVal('bassReleaseSlider', (e)=>{ const ms=Math.max(0,parseInt(e.target.value)||120); this.instruments.bass.env.release=ms/1000; const l=document.getElementById('bassReleaseValue'); if(l) l.textContent=`${ms}ms`; });

                // FX Send checkboxes
                wireVal('strum1FxSend', (e)=>{ this.instruments.strum1.fxSend = e.target.checked; });
                wireVal('strum2FxSend', (e)=>{ this.instruments.strum2.fxSend = e.target.checked; });
                wireVal('chordFxSend', (e)=>{ this.instruments.chord.fxSend = e.target.checked; });
                wireVal('arpFxSend', (e)=>{ this.instruments.arp.fxSend = e.target.checked; });
                wireVal('bassFxSend', (e)=>{ this.instruments.bass.fxSend = e.target.checked; });


                // Reverb controls
                // Drive controls
                const driveAmt = document.getElementById('driveAmount');
                if (driveAmt) {
                    driveAmt.addEventListener('input', (e)=>{
                        const v = Math.max(0, Math.min(100, parseInt(e.target.value)||0));
                        this.drive.amount = v;
                        const el = document.getElementById('driveAmountValue'); if (el) el.textContent = `${v}%`;
                        if (typeof this.updateDrive === 'function') this.updateDrive();
                    });
                }
                const driveMix = document.getElementById('driveMix');
                if (driveMix) {
                    driveMix.addEventListener('input', (e)=>{
                        const v = Math.max(0, Math.min(100, parseInt(e.target.value)||0));
                        this.drive.mix = v;
                        const el = document.getElementById('driveMixValue'); if (el) el.textContent = `${v}%`;
                        if (typeof this.updateDrive === 'function') this.updateDrive();
                    });
                }

                // Reverb controls
                // Delay controls
                const delayTime = document.getElementById('delayTime');
                if (delayTime) delayTime.addEventListener('input', (e)=>{
                    const ms = Math.max(20, Math.min(1000, parseInt(e.target.value)||280));
                    const el = document.getElementById('delayTimeValue'); if (el) el.textContent = `${ms}ms`;
                    if (this._delay && this._delay.node) this._delay.node.delayTime.value = ms/1000;
                });
                const delayFb = document.getElementById('delayFeedback');
                if (delayFb) delayFb.addEventListener('input', (e)=>{
                    const v = Math.max(0, Math.min(95, parseInt(e.target.value)||25))/100;
                    const el = document.getElementById('delayFeedbackValue'); if (el) el.textContent = `${Math.round(v*100)}%`;
                    if (this._delay && this._delay.feedback) this._delay.feedback.gain.value = v;
                });
                // Delay LP/HP per-effect tone (log scale)
                const delayLp = document.getElementById('delayLpCutoff');
                if (delayLp) delayLp.addEventListener('input', (e)=>{
                    const pct = Math.max(0, Math.min(100, parseInt(e.target.value)||73))/100;
                    const hz = Math.max(200, 200 * Math.pow(20000/200, pct));
                    const el = document.getElementById('delayLpCutoffValue'); if (el) el.textContent = `${hz>=20000? 'off' : (hz>=1000? (hz/1000).toFixed(1)+'kHz' : Math.round(hz)+'Hz')}`;
                    if (this._delay && this._delay.filter) this._delay.filter.frequency.value = hz; // feedback loop LP
                    if (this._delay && this._delay.wetLp) this._delay.wetLp.frequency.value = hz; // wet tone LP
                });
                const delayHp = document.getElementById('delayHpCutoff');
                if (delayHp) delayHp.addEventListener('input', (e)=>{
                    const pct = Math.max(0, Math.min(100, parseInt(e.target.value)||0))/100;
                    const hz = Math.max(20, 20 * Math.pow(2000/20, pct));
                    const el = document.getElementById('delayHpCutoffValue'); if (el) el.textContent = `${hz<=20? 'off' : Math.round(hz)+'Hz'}`;
                    if (this._delay && this._delay.wetHp) this._delay.wetHp.frequency.value = hz; // wet tone HP
                });
                const delayMix = document.getElementById('delayMix');
                if (delayMix) delayMix.addEventListener('input', (e)=>{
                    const v = Math.max(0, Math.min(100, parseInt(e.target.value)||0))/100;
                    const el = document.getElementById('delayMixValue'); if (el) el.textContent = `${Math.round(v*100)}%`;
                    if (this._delay && this._delay.wet && this._delay.dry) {
                        this._delay.wet.gain.value = v;
                        this._delay.dry.gain.value = 1;
                    }
                });

                // Dual-handle Filter controls (log scale)
                const low = document.getElementById('filterLow'); // 0..100 → 20..maxHz (HP edge)
                const high = document.getElementById('filterHigh'); // 0..100 → 20..maxHz (LP edge)
                const res = document.getElementById('filterRes');
                const lowLabel = document.getElementById('filterLowValue');
                const highLabel = document.getElementById('filterHighValue');
                const resLabel = document.getElementById('filterResValue');

                const getMaxHz = ()=>{
                    const nyq = (this.audioContext && this.audioContext.sampleRate) ? this.audioContext.sampleRate/2 : 22050;
                    return Math.min(20000, nyq);
                };
                const fromPercentLog = (p)=>{
                    // p in 0..100 → 20..maxHz exponentially
                    const maxHz = getMaxHz();
                    const t = Math.max(0, Math.min(1, (parseFloat(p)||0)/100));
                    return Math.max(20, 20 * Math.pow(maxHz/20, t));
                };
                const toLabel = (hz, prefix)=>{
                    return `${prefix} ${hz>=1000? (hz/1000).toFixed(1)+'kHz' : Math.round(hz)+'Hz'}`;
                };
                const clampHandles = ()=>{
                    if (!low || !high) return;
                    // Ensure low <= high in frequency space; if cross, snap the moved one back
                    const lowHz = fromPercentLog(low.value);
                    const highHz = fromPercentLog(high.value);
                    if (lowHz > highHz) {
                        // Decide based on last changed element; default clamp high to low
                        if (document.activeElement === low) {
                            high.value = low.value;
                        } else {
                            low.value = high.value;
                        }
                    }
                };
                const updateDualFilter = ()=>{
                    if (!this._finalHP || !this._finalLP) return;
                    clampHandles();
                    const hpHz = fromPercentLog(low ? low.value : 0);
                    const lpHz = fromPercentLog(high ? high.value : 100);
                    const q = res ? Math.max(0.1, Math.min(20, parseFloat(res.value)||1)) : 1;
                    this._finalHP.frequency.value = hpHz;
                    this._finalLP.frequency.value = lpHz;
                    this._finalHP.Q.value = q;
                    this._finalLP.Q.value = q;
                    if (lowLabel) lowLabel.textContent = toLabel(hpHz, 'HP');
                    if (highLabel) highLabel.textContent = toLabel(lpHz, 'LP');
                    if (resLabel) resLabel.textContent = `Q ${q.toFixed(1)}`;
                };
                if (low) low.addEventListener('input', updateDualFilter);
                if (high) high.addEventListener('input', updateDualFilter);
                if (res) res.addEventListener('input', updateDualFilter);
                updateDualFilter();
                const reverbWetSlider = document.getElementById('reverbWet');
                if (reverbWetSlider) {
                    reverbWetSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.reverb.wet = e.target.value / 10; // 0-10 scale to 0-1
                        if (this.wetGainNode && this.dryGainNode) {
                            this.wetGainNode.gain.value = this.reverb.wet;
                            this.dryGainNode.gain.value = this.masterVolume;
                        }
                        // Bypass reverb processing when wet=0%
                        if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                        const reverbWetValue = document.getElementById('reverbWetValue');
                        if (reverbWetValue) {
                            reverbWetValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('reverbWet slider not found');
                }

                const reverbRoomSlider = document.getElementById('reverbRoom');
                if (reverbRoomSlider) {
                    reverbRoomSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.reverb.roomSize = e.target.value / 10; // 0-10 scale to 0-1
                        const reverbRoomValue = document.getElementById('reverbRoomValue');
                        if (reverbRoomValue) {
                            reverbRoomValue.textContent = `${e.target.value * 10}%`;
                        }
                        // Recreate reverb with new room size
                        if (this.audioContext) {
                            this.createReverb();
                            // Properly reconnect the reverb chain
                            try { this.wetGainNode.disconnect(); } catch {}
                            try { this.reverbHpNode.disconnect(); } catch {}
                            try { this.reverbFilterNode.disconnect(); } catch {}
                            this.wetGainNode.connect(this.reverbNode);
                            this.reverbNode.connect(this.reverbHpNode);
                            this.reverbHpNode.connect(this.reverbFilterNode);
                            if (!this.reverbOutGain) this.reverbOutGain = this.audioContext.createGain();
                            this.reverbOutGain.gain.value = this.masterVolume;
                            this.reverbFilterNode.connect(this.reverbOutGain);
                            this.reverbOutGain.connect(this.audioContext.destination);
                            if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                        }
                    });
                } else {
                    console.error('reverbRoom slider not found');
                }
                
                const reverbDecaySlider = document.getElementById('reverbDecay');
                if (reverbDecaySlider) {
                    reverbDecaySlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.reverb.decay = (e.target.value / 100) * 10; // 0-10 seconds
                        const reverbDecayValue = document.getElementById('reverbDecayValue');
                        if (reverbDecayValue) {
                            reverbDecayValue.textContent = `${(this.reverb.decay).toFixed(1)}s`;
                        }
                        // Recreate reverb with new decay time
                        if (this.audioContext) {
                            this.createReverb();
                            // Properly reconnect the reverb chain
                            try { this.wetGainNode.disconnect(); } catch {}
                            try { this.reverbHpNode.disconnect(); } catch {}
                            try { this.reverbFilterNode.disconnect(); } catch {}
                            this.wetGainNode.connect(this.reverbNode);
                            this.reverbNode.connect(this.reverbHpNode);
                            this.reverbHpNode.connect(this.reverbFilterNode);
                            if (!this.reverbOutGain) this.reverbOutGain = this.audioContext.createGain();
                            this.reverbOutGain.gain.value = this.masterVolume;
                            this.reverbFilterNode.connect(this.reverbOutGain);
                            this.reverbOutGain.connect(this.audioContext.destination);
                            if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                        }
                    });
                } else {
                    console.error('reverbDecay slider not found');
                }
                
                const reverbFilterCutoffSlider = document.getElementById('reverbFilterCutoff');
                if (reverbFilterCutoffSlider) {
                    reverbFilterCutoffSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        const pct = Math.max(0, Math.min(100, parseInt(e.target.value)||70)) / 100;
                        // Map 0..1 to 200..20000 Hz log
                        const hz = Math.max(200, 200 * Math.pow(20000/200, pct));
                        this.reverb.filterCutoff = hz;
                        if (this.reverbFilterNode) {
                            this.reverbFilterNode.frequency.value = hz;
                        }
                        const reverbFilterCutoffValue = document.getElementById('reverbFilterCutoffValue');
                        if (reverbFilterCutoffValue) {
                            reverbFilterCutoffValue.textContent = hz>=20000? 'off': `${Math.round(hz)}Hz`;
                        }
                    });
                } else {
                    console.error('reverbFilterCutoff slider not found');
                }
                const reverbHpCutoffSlider = document.getElementById('reverbHpCutoff');
                if (reverbHpCutoffSlider) {
                    reverbHpCutoffSlider.addEventListener('input', (e) => {
                        const pct = Math.max(0, Math.min(100, parseInt(e.target.value)||0)) / 100;
                        // Map 0..1 to 20..2000 Hz log
                        const hz = Math.max(20, 20 * Math.pow(2000/20, pct));
                        if (this.reverbHpNode) this.reverbHpNode.frequency.value = hz;
                        const el = document.getElementById('reverbHpCutoffValue'); if (el) el.textContent = hz<=20? 'off': `${Math.round(hz)}Hz`;
                    });
                }

                // Drive HP/LP per-effect tone (log scale)
                const driveHp = document.getElementById('driveHpCutoff');
                if (driveHp) driveHp.addEventListener('input', (e)=>{
                    const pct = Math.max(0, Math.min(100, parseInt(e.target.value)||0))/100;
                    const hz = Math.max(20, 20 * Math.pow(2000/20, pct));
                    const el = document.getElementById('driveHpCutoffValue'); if (el) el.textContent = `${hz<=20? 'off' : Math.round(hz)+'Hz'}`;
                    if (this._drive && this._drive.hp) this._drive.hp.frequency.value = hz;
                });
                const driveLp = document.getElementById('driveLpCutoff');
                if (driveLp) driveLp.addEventListener('input', (e)=>{
                    const pct = Math.max(0, Math.min(100, parseInt(e.target.value)||100))/100;
                    const hz = Math.max(200, 200 * Math.pow(20000/200, pct));
                    const el = document.getElementById('driveLpCutoffValue'); if (el) el.textContent = `${hz>=20000? 'off' : (hz>=1000? (hz/1000).toFixed(1)+'kHz' : Math.round(hz)+'Hz')}`;
                    if (this._drive && this._drive.lp) this._drive.lp.frequency.value = hz;
                });

                const reverbFilterResSlider = document.getElementById('reverbFilterRes');
                if (reverbFilterResSlider) {
                    reverbFilterResSlider.addEventListener('input', (e) => {
                        if (this.reverbFilterNode) {
                            this.reverbFilterNode.Q.value = parseFloat(e.target.value);
                        }
                        const reverbFilterResValue = document.getElementById('reverbFilterResValue');
                        if (reverbFilterResValue) {
                            reverbFilterResValue.textContent = e.target.value;
                        }
                    });
                }
                // Note: reverbFilterRes slider not present in current UI

                // Panning controls
                const panningModeSelect = document.getElementById('panningMode');
                if (panningModeSelect) {
                    panningModeSelect.addEventListener('change', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.mode = e.target.value;
                            console.log('?? Panning mode changed to:', window.omnichord.panning.mode);
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningMode select not found');
                }

                const panningWidthSlider = document.getElementById('panningWidth');
                if (panningWidthSlider) {
                    panningWidthSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.width = e.target.value / 100; // 0-100% to 0-1
                            console.log('?? Panning width changed to:', window.omnichord.panning.width);
                            const panningWidthValue = document.getElementById('panningWidthValue');
                            if (panningWidthValue) {
                                panningWidthValue.textContent = `${e.target.value}%`;
                            }
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningWidth slider not found');
                }

                const panningSpeedSlider = document.getElementById('panningSpeed');
                if (panningSpeedSlider) {
                    panningSpeedSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.speed = parseInt(e.target.value);
                            console.log('?? Panning speed changed to:', window.omnichord.panning.speed);
                            const panningSpeedValue = document.getElementById('panningSpeedValue');
                            if (panningSpeedValue) {
                                panningSpeedValue.textContent = `${(e.target.value / 1000).toFixed(1)}s`;
                            }
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningSpeed slider not found');
                }

                const panningResetBtn = document.getElementById('panningReset');
                if (panningResetBtn) {
                    panningResetBtn.addEventListener('click', () => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.rotationAngle = 0;
                            window.omnichord.panning.alternateState = false;
                            console.log('?? Panning reset');
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningReset button not found');
                }

                // Enhanced string playing with ultra responsiveness (60 FPS optimized)
                const extensionColumns = document.getElementById('extensionColumns');
                
                // Mouse events for strings with optimized performance
                extensionColumns.addEventListener('mousedown', (e) => {
                    try { console.log('[INPUT] mousedown strings area mode=', (this.playMode||'high-low'), 'slide=', !!this._chordSlideEnabled); } catch(_){ }
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
            if (this.arpEnabled && !this.chordsEnabled) {
                        const hit = document.elementFromPoint(e.clientX, e.clientY);
                        const column = hit && hit.closest ? hit.closest('.extension-column') : null;
                        if (column) {
                            // Begin ARP gesture: enable lateral sliding while held - QUANTIZE ARP START TO BEAT
                            this._arpGestureActive = true;
                            this._arpLastColumn = column;
                            
                            // Check if we should quantize ARP start to the next beat
                            try {
                                const quantizedChange = this._shouldQuantizeChordChange();
                                if (quantizedChange.shouldQuantize) {
                                    this._scheduleQuantizedArpStart(column, e.clientY, quantizedChange.nextBeatMs);
                                } else {
                                    this._startArp(column, e.clientY);
                                }
                            } catch(_) { 
                                this._startArp(column, e.clientY); 
                            }
                        }
                    }
                    // In Chords mode, tapping the strings area should play or retune the whole chord for the tapped octave
            if (this.chordsEnabled) {
                        e.preventDefault();
                        const hit = document.elementFromPoint(e.clientX, e.clientY);
                        const column = hit && hit.closest ? hit.closest('.extension-column') : null;
                        if (column) {
                // Seed slide velocity tracking
                this._lastChordSlideX = e.clientX;
                this._lastChordSlideY = e.clientY;
                this._lastChordSlideTime = performance.now(); this._markChordSlideActivity();
                            // If slide is enabled and we're sustaining, retune to the tapped column; otherwise start and seed voices
                            if (this._chordSlideEnabled && (this._chordsGestureActive || this._sustainActive)){
                                if (this._chordSlideVoices && this._chordSlideVoices.size){
                                this._chordSlideHoverColumn = column; this._chordSlideCommittedColumn = column; this._chordSlideHoverSince = performance.now();
                                const targets = this._computeChordSlideTargets(column);
                                this._retuneActiveChordVoicesToTargets(targets);
                                // Also update held bass to match the committed/hovered column
                                try { this._updateHeldBassForColumn(column); } catch(_){ }
                                this._markChordSlideActivity();
                                this._markChordSlideActivity();
                                } else {
                                // No active slide voices yet: quantize initial chord start
                                try {
                                    const quantizedChange = this._shouldQuantizeChordChange();
                                    if (quantizedChange.shouldQuantize) {
                                        this._scheduleQuantizedChordChange(column, e.clientY, quantizedChange.nextBeatMs);
                                    } else {
                                        this._executeChordChange(column, e.clientY);
                                    }
                                } catch(_) { this._executeChordChange(column, e.clientY); }
                                }
                            }
                            else {
                                // Slide disabled: quantize simple tap to next QUANT tick
                                try {
                                    const quantizedChange = this._shouldQuantizeChordChange();
                                    if (quantizedChange.shouldQuantize) {
                                        this._scheduleQuantizedChordChange(column, e.clientY, quantizedChange.nextBeatMs);
                                    } else {
                                        this._executeChordChange(column, e.clientY);
                                    }
                                } catch(_) { this._executeChordChange(column, e.clientY); }
                            }
                        }
                        // Do not start per-string swipe processing
                        return;
                    }
                    this.isPlayingStrings = true;
                    this.triggeredStrings.clear();
                    // Start of a new mouse gesture: clear mouse pointer last-hit tracking
                    this._pointerLastStringKey.set('mouse', null);
                    // Disarm edit during active strum
                    this.editArmed = false;
                    clearTimeout(this._editArmTimer);
                    this.handleStringTrigger(e);
                });
                
                document.addEventListener('mousemove', (e) => {
                    // ARP mode: lateral slide across columns schedules quantized chord switches
                    if ((this.playMode||'high-low') === 'arp' && this._arpGestureActive) {
                        const hit = document.elementFromPoint(e.clientX, e.clientY);
                        const column = hit && hit.closest ? hit.closest('.extension-column') : null;
                        if (column && column !== this._arpLastColumn) {
                            this._arpLastColumn = column;
                            
                            // QUANTIZE ARP CHANGES TO BEAT during sliding
                            try {
                                const quantizedChange = this._shouldQuantizeChordChange();
                                if (quantizedChange.shouldQuantize) {
                                    this._scheduleQuantizedArpStart(column, e.clientY, quantizedChange.nextBeatMs);
                                } else {
                                    this._startArp(column, e.clientY);
                                }
                            } catch(_) { 
                                this._startArp(column, e.clientY); 
                            }
                        }
                        return;
                    }
                    if (this.isPlayingStrings) {
                        this.handleStringTrigger(e);
                    } else if (this.chordsEnabled && this._sustainActive) {
                        // In CHORDS mode while sustaining: if slide is enabled, trigger chords when entering a new box (enter-box behavior)
                        if (this._chordSlideActive) {
                            const hit = document.elementFromPoint(e.clientX, e.clientY);
                            const column = hit && hit.closest ? hit.closest('.extension-column') : null;
                            const now = performance.now();
                            // Track movement vector and dt
                            const dx = (typeof this._lastChordSlideX==='number') ? (e.clientX - this._lastChordSlideX) : 0;
                            const dy = (typeof this._lastChordSlideY==='number') ? (e.clientY - this._lastChordSlideY) : 0;
                            const dt = Math.max(1, now - (this._lastChordSlideTime||now)); this._markChordSlideActivity();
                            this._chordSlideLastDX = dx; this._chordSlideLastDY = dy; this._lastChordSlideDeltaT = dt;
                            if (column){
                                // Enter-box trigger: when the pointer moves into a different column, switch chords immediately
                                const cur = this.currentActiveColumnEl || this._chordSlideCommittedColumn || this._chordSlideStartColumn || null;
                                if (cur && column !== cur && this._chordsGestureActive) {
                                    try {
                                        // Check if quantization is enabled and calculate next beat timing
                                        const quantizedChange = this._shouldQuantizeChordChange();
                                        
                                        if (quantizedChange.shouldQuantize) {
                                            // Schedule quantized chord change
                                            this._scheduleQuantizedChordChange(column, e.clientY, quantizedChange.nextBeatMs);
                                        } else {
                                            // Immediate chord change (existing behavior)
                                            this._executeChordChange(column, e.clientY);
                                        }
                                    } catch(_){}
                                } else {
                                    // Continuous bend while staying within a column (throttled): retune bass immediately
                                    this._chordSlideHoverColumn = column; /* hoverSince updated only when pointer slows */
                                    try { this._updateChordSlideContinuously(column); } catch(_) { }
                                }
                            }
                            else { this._chordSlideHoverColumn = null; }
                            this._lastChordSlideX = e.clientX; this._lastChordSlideY = e.clientY; this._lastChordSlideTime = now;
                            // Debounce + dwell: when pointer slows or stops for dwellMs, retune once to hovered column
                            clearTimeout(this._chordSlideHoverCommitTimer);
                            const dwellMs = Math.max(30, Math.min(200, this._chordSlideDwellMs||50));
                            this._chordSlideHoverCommitTimer = setTimeout(()=>{
                                try{
                                    if (this.chordsEnabled && this._chordSlideActive && this._chordsGestureActive && this._chordSlideHoverColumn){
                                        this._chordSlideCommittedColumn = this._chordSlideHoverColumn; this._chordSlideHoverSince = performance.now();
                                        const targets = this._computeChordSlideTargets(this._chordSlideHoverColumn);
                                        this._retuneActiveChordVoicesToTargets(targets);
                                        console.log('[SLIDE][DWELL] commit to column', this._chordSlideHoverColumn?.dataset?.chordId || this._chordSlideHoverColumn?.dataset?.originalPosition);
                                        // Update held bass on dwell commit as well
                                        try { this._updateHeldBassForColumn(this._chordSlideHoverColumn); } catch(_){ }
                                        this._markChordSlideActivity();
                                    }
                                }catch(_){}
                            }, dwellMs);
                        } else {
                            // Allow strumming additional strings over a sustained chord when slide is off
                            this.handleStringTrigger(e);
                        }
                    }
                });
                
                document.addEventListener('mouseup', (e) => {
                    // Don't stop ARPs when just finishing string strumming - only stop if ARP gesture was active
                    if (this.arpEnabled && this._arpGestureActive) { 
                        this._stopArp(); 
                        this._arpGestureActive = false; 
                        this._arpLastColumn = null; 
                    }
                    clearTimeout(this._chordSlideHoverCommitTimer);
                    this.isPlayingStrings = false;
                    this.triggeredStrings.clear();
                    // End of mouse gesture: clear last-hit
                    this._pointerLastStringKey.delete('mouse');
                    // If in CHORDS slide, settle to final hovered/target column and KEEP SUSTAINING (taps will retune)
                    if (this.chordsEnabled && this._chordSlideActive && this._chordsGestureActive) {
                        const hit = e ? document.elementFromPoint(e.clientX, e.clientY) : null;
                        let column = hit && hit.closest ? hit.closest('.extension-column') : null;
                        // Prefer committed column (dwelled) to skip intermediates
                        column = this._chordSlideCommittedColumn || this._chordSlideHoverColumn || column || this.currentActiveColumnEl || null;
                        if (column) {
                            const targets = this._computeChordSlideTargets(column);
                            this._retuneActiveChordVoicesToTargets(targets);
                            console.log('[SLIDE][RELEASE] settle to column', column?.dataset?.chordId || column?.dataset?.originalPosition);
                            // Update held bass to final column on release commit
                            try { this._updateHeldBassForColumn(column); } catch(_){ }
                            this._markChordSlideActivity();
                        }
                        // Do not stop or clear; keep sustaining so next tap retunes smoothly
                    } else {
                        // Non-slide CHORD mode: let HOLD timers release notes/bass; just end the gesture flags
                        if (this.chordsEnabled) {
                            this._sustainActive = false;
                            this._chordsGestureActive = false;
                            this._slideOctaveLock = null;
                        } else {
                            // In other modes, keep legacy behavior
                            this.stopAllActiveNotes();
                            try{ this._resetAllStringFrequencies(); }catch(_){ }
                            if (this._chordsGestureActive) { this._sustainActive = false; this._chordsGestureActive = false; this._slideOctaveLock = null; }
                            // Safety: clear chord bass state so it doesn't persist after gesture ends
                            try { if (this._chordBassVoice && this._lastBassFreq){ this.stopFrequency(this._lastBassFreq, null, 'bass'); } } catch(_){ }
                            this._chordBassVoice = null; this._lastBassFreq = null;
                        }
                    }
                    // Re-arm editing 500ms after strum ends
                    this._scheduleEditArm();
                });

                // Touch events for strings
                extensionColumns.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    // Enhanced touch sensitivity: immediately mark all touch targets to prevent missed taps
                    this._enhanceTouchResponsiveness(e);
                    
                    // Strings are now purely for strumming - no ARP or CHORD triggering
                    // ARP and CHORD are triggered via dedicated footer buttons only
                    this.isPlayingStrings = true;
                    this.triggeredStrings.clear();
                    this.editArmed = false;
                    clearTimeout(this._editArmTimer);
                    
                    Array.from(e.changedTouches).forEach(touch => {
                        // Clear last-hit for this touch identifier at the beginning of a gesture
                        this._pointerLastStringKey.set(`t${touch.identifier}`, null);
                        this.activeTouches.set(touch.identifier, touch);
                        
                        // Always allow strumming in strings area - this is now purely for garnish
                        this.handleStringTrigger(touch);
                    });
                }, { passive: false });
                
                extensionColumns.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    // ARP mode: lateral slide across columns with quantized chord changes (preserves transport position)
                    if (this.arpEnabled && !this.chordsEnabled && this._arpGestureActive) {
                        const t = e.changedTouches[0] || (e.touches && e.touches[0]);
                        if (t){
                            const h = document.elementFromPoint(t.clientX, t.clientY);
                            const c = h && h.closest ? h.closest('.extension-column') : null;
                            if (c && c !== this._arpLastColumn) {
                                // Schedule quantized ARP chord change to preserve transport sync
                                this._scheduleQuantizedArpChordChange(c, t.clientY);
                                this._arpLastColumn = c;
                            }
                        }
                    }
                    if (this.isPlayingStrings || (this.chordsEnabled && this._sustainActive)) {
                        // CHORDS mode with slide enabled: trigger chords when entering a new box (enter-box behavior)
                        if (this.chordsEnabled && this._chordSlideActive) {
                            const t = e.changedTouches[0];
                            if (t){
                                const h = document.elementFromPoint(t.clientX, t.clientY);
                                const c = h && h.closest ? h.closest('.extension-column') : null;
                                const now = performance.now();
                                // Track movement vector and dt
                                const dx = (typeof this._lastChordSlideX==='number') ? (t.clientX - this._lastChordSlideX) : 0;
                                const dy = (typeof this._lastChordSlideY==='number') ? (t.clientY - this._lastChordSlideY) : 0;
                                const dt = Math.max(1, now - (this._lastChordSlideTime||now)); this._markChordSlideActivity();
                                this._chordSlideLastDX = dx; this._chordSlideLastDY = dy; this._lastChordSlideDeltaT = dt;
                                if (c){
                                    const cur = this.currentActiveColumnEl || this._chordSlideCommittedColumn || this._chordSlideStartColumn || null;
                                    if (cur && c !== cur && this._chordsGestureActive) {
                                        try {
                                            // Check if quantization is enabled and calculate next beat timing
                                            const quantizedChange = this._shouldQuantizeChordChange();
                                            
                                            if (quantizedChange.shouldQuantize) {
                                                // Schedule quantized chord change
                                                this._scheduleQuantizedChordChange(c, t.clientY, quantizedChange.nextBeatMs);
                                            } else {
                                                // Immediate chord change (existing behavior)
                                                this._executeChordChange(c, t.clientY);
                                            }
                                        } catch(_){}
                                    } else {
                                        // Continuous bend within the current column
                                        this._chordSlideHoverColumn = c; /* hoverSince updated only when finger slows */
                                        try { this._updateChordSlideContinuously(c); } catch(_) { }
                                    }
                                }
                                else { this._chordSlideHoverColumn = null; }
                                this._lastChordSlideX = t.clientX; this._lastChordSlideY = t.clientY; this._lastChordSlideTime = now;
                                // Debounce + dwell: when finger slows or stops for dwellMs, glide once to hovered column
                                clearTimeout(this._chordSlideHoverCommitTimer);
                                const dwellMs = Math.max(30, Math.min(200, this._chordSlideDwellMs||50));
                                this._chordSlideHoverCommitTimer = setTimeout(()=>{
                                    try{
                                        if (this.chordsEnabled && this._chordSlideActive && this._chordsGestureActive && this._chordSlideHoverColumn){
                                            this._chordSlideCommittedColumn = this._chordSlideHoverColumn; this._chordSlideHoverSince = performance.now();
                                            const targets = this._computeChordSlideTargets(this._chordSlideHoverColumn);
                                            this._retuneActiveChordVoicesToTargets(targets);
                                            console.log('[SLIDE][DWELL][touch] commit to column', this._chordSlideHoverColumn?.dataset?.chordId || this._chordSlideHoverColumn?.dataset?.originalPosition);
                                            try { this._updateHeldBassForColumn(this._chordSlideHoverColumn); } catch(_){ }
                                            this._markChordSlideActivity();
                                        }
                                    }catch(_){}
                                }, dwellMs);
                            }
                        } else {
                            Array.from(e.changedTouches).forEach(touch => {
                                this.activeTouches.set(touch.identifier, touch);
                                this.handleStringTrigger(touch);
                            });
                        }
                    }
                }, { passive: false });
                
    extensionColumns.addEventListener('touchend', (e) => {
                    e.preventDefault();
            // Don't stop ARPs when just finishing string strumming - only stop if ARP gesture was active
            if (this.arpEnabled && this._arpGestureActive) { 
                this._stopArp(); 
                this._arpGestureActive = false; 
                this._arpLastColumn = null; 
            }
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.delete(touch.identifier);
                        // Clear tracking for this touch pointer
                        this._pointerLastStringKey.delete(`t${touch.identifier}`);
                    });
                    
                    if (this.activeTouches.size === 0) {
                        this.isPlayingStrings = false;
                        this.triggeredStrings.clear();
            // CHORD slide settle on release: keep sustaining (do not stop/clear) so taps glide
            if (this.chordsEnabled && this._chordSlideActive && this._chordsGestureActive) {
                clearTimeout(this._chordSlideHoverCommitTimer);
                const t = e.changedTouches && e.changedTouches[0];
                const h = t ? document.elementFromPoint(t.clientX, t.clientY) : null;
                let c = h && h.closest ? h.closest('.extension-column') : null;
                // Prefer committed column (dwelled) to skip intermediates
                c = this._chordSlideCommittedColumn || this._chordSlideHoverColumn || c || this.currentActiveColumnEl || null;
                if (c){ const targets = this._computeChordSlideTargets(c); this._retuneActiveChordVoicesToTargets(targets); console.log('[SLIDE][RELEASE][touch] settle to column', c?.dataset?.chordId || c?.dataset?.originalPosition); try { this._updateHeldBassForColumn(c); } catch(_){ } this._markChordSlideActivity(); }
                // Keep sustaining; no stop/clear/reset here
            } else {
                if (this.chordsEnabled) {
                    // Let HOLD per-note/bass timers handle release; just end gesture flags
                    this._sustainActive = false;
                    this._chordsGestureActive = false;
                    this._slideOctaveLock = null;
                } else {
                    this.stopAllActiveNotes();
                    try{ this._resetAllStringFrequencies(); }catch(_){ }
                    if (this._chordsGestureActive) { this._sustainActive = false; this._chordsGestureActive = false; this._slideOctaveLock = null; }
                    // Safety: clear chord bass state after non-slide touch end
                    try { if (this._chordBassVoice && this._lastBassFreq){ this.stopFrequency(this._lastBassFreq, null, 'bass'); } } catch(_){ }
                    this._chordBassVoice = null; this._lastBassFreq = null;
                }
            }
        
            this._scheduleEditArm();
                    }
                }, { passive: false });
                
                extensionColumns.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.delete(touch.identifier);
                        this._pointerLastStringKey.delete(`t${touch.identifier}`);
                    });
                    
                    if (this.activeTouches.size === 0) {
                        this.isPlayingStrings = false;
                        this.triggeredStrings.clear();
                        this.stopAllActiveNotes();
                        // Clear ARP slide tracking
                        this._arpGestureActive = false; 
                        this._arpLastColumn = null;
                        this._scheduleEditArm();
                    }
                }, { passive: false });

                // Allow multitouch on control elements - prevent default only on strings
                document.addEventListener('touchstart', (e) => {
                    const target = e.target;
                    if (target.classList.contains('tuning-btn') || 
                        target.classList.contains('chord-btn') || 
                        target.classList.contains('quality-btn') || 
                        target.classList.contains('osc-btn')) {
                        // Don't prevent default on control buttons to allow multitouch
                        return;
                    }
                }, { passive: false });

                // Handle audio context resume on any interaction
                document.addEventListener('click', () => {
                    // Idle/HOLD transport reset: if not sequencing and idle > HOLD, reset transport so next tap starts on beat 1
                    try {
                        const now = (performance && performance.now) ? performance.now() : Date.now();
                        const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                        const hold = holdEl ? String(holdEl.value||'bar:1') : 'bar:1';
                        const [kind, valStr] = hold.split(':');
                        const n = Math.max(1, parseInt(valStr||'1',10));
                        const bpmEl = document.getElementById('universalBpm');
                        const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                        const beatMs = 60000 / Math.max(20, bpm);
                        const tsEl = document.getElementById('universalTimeSignature');
                        const tsRaw = tsEl ? String(tsEl.value||'4/4') : '4/4';
                        let tsNum=4, tsDen=4; try { const [n,d]=tsRaw.split('/').map(v=>parseInt(v,10)); if(Number.isFinite(n)&&n>0) tsNum=n; if(Number.isFinite(d)&&d>0) tsDen=d; } catch(_) {}
                        const beatsPerBar = (tsNum * 4) / tsDen;
                        const barMs = beatMs * beatsPerBar;
                        const holdMs = (kind==='beat') ? n*beatMs : n*barMs;
                        if (!this._isSequencing && now - (this._lastInteractionAt||0) > holdMs) {
                            try {
                                this._stopArpTransport();
                                this._ensureArpTransport();
                                const t = this._arpTransport; if (t) { t.tickCounter=0; t.absTickCounter=0; t.nextAt=now; t.running=false; t.inactivityStopScheduled=false; t.stopAtBarIndex=null; }
                                if (this._arp) { this._arp.pendingSwitch=null; this._arp.active=false; this._arp.seq=[]; this._arp.startTickAlign=0; this._arp.morph=null; }
                                this.stopAllActiveNotes();
                            } catch(_) {}
                        }
                        this._lastInteractionAt = now;
                    } catch(_) {}
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        console.log('Attempting to resume AudioContext on click...');
                        this.audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully');
                        });
                    }
                    try { this._startArpTransport(); } catch(_){ }
                });
                
                document.addEventListener('touchstart', () => {
                    // Idle/HOLD transport reset on touch
                    try {
                        const now = (performance && performance.now) ? performance.now() : Date.now();
                        const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                        const hold = holdEl ? String(holdEl.value||'bar:1') : 'bar:1';
                        const [kind, valStr] = hold.split(':');
                        const n = Math.max(1, parseInt(valStr||'1',10));
                        const bpmEl = document.getElementById('universalBpm');
                        const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                        const beatMs = 60000 / Math.max(20, bpm);
                        const tsEl = document.getElementById('universalTimeSignature');
                        const tsRaw = tsEl ? String(tsEl.value||'4/4') : '4/4';
                        let tsNum=4, tsDen=4; try { const [n,d]=tsRaw.split('/').map(v=>parseInt(v,10)); if(Number.isFinite(n)&&n>0) tsNum=n; if(Number.isFinite(d)&&d>0) tsDen=d; } catch(_) {}
                        const beatsPerBar = (tsNum * 4) / tsDen;
                        const barMs = beatMs * beatsPerBar;
                        const holdMs = (kind==='beat') ? n*beatMs : n*barMs;
                        if (!this._isSequencing && now - (this._lastInteractionAt||0) > holdMs) {
                            try {
                                this._stopArpTransport();
                                this._ensureArpTransport();
                                const t = this._arpTransport; if (t) { t.tickCounter=0; t.absTickCounter=0; t.nextAt=now; t.running=false; t.inactivityStopScheduled=false; t.stopAtBarIndex=null; }
                                if (this._arp) { this._arp.pendingSwitch=null; this._arp.active=false; this._arp.seq=[]; this._arp.startTickAlign=0; this._arp.morph=null; }
                                this.stopAllActiveNotes();
                            } catch(_) {}
                        }
                        this._lastInteractionAt = now;
                    } catch(_) {}
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        console.log('Attempting to resume AudioContext on touch...');
                        this.audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully');
                        });
                    }
                    try { this._startArpTransport(); } catch(_){ }
                });
                
                document.addEventListener('mousedown', () => {
                    // Idle/HOLD transport reset on mouse down
                    try {
                        const now = (performance && performance.now) ? performance.now() : Date.now();
                        const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                        const hold = holdEl ? String(holdEl.value||'bar:1') : 'bar:1';
                        const [kind, valStr] = hold.split(':');
                        const n = Math.max(1, parseInt(valStr||'1',10));
                        const bpmEl = document.getElementById('universalBpm');
                        const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                        const beatMs = 60000 / Math.max(20, bpm);
                        const tsEl = document.getElementById('universalTimeSignature');
                        const tsRaw = tsEl ? String(tsEl.value||'4/4') : '4/4';
                        let tsNum=4, tsDen=4; try { const [n,d]=tsRaw.split('/').map(v=>parseInt(v,10)); if(Number.isFinite(n)&&n>0) tsNum=n; if(Number.isFinite(d)&&d>0) tsDen=d; } catch(_) {}
                        const beatsPerBar = (tsNum * 4) / tsDen;
                        const barMs = beatMs * beatsPerBar;
                        const holdMs = (kind==='beat') ? n*beatMs : n*barMs;
                        if (!this._isSequencing && now - (this._lastInteractionAt||0) > holdMs) {
                            try {
                                this._stopArpTransport();
                                this._ensureArpTransport();
                                const t = this._arpTransport; if (t) { t.tickCounter=0; t.absTickCounter=0; t.nextAt=now; t.running=false; t.inactivityStopScheduled=false; t.stopAtBarIndex=null; }
                                if (this._arp) { this._arp.pendingSwitch=null; this._arp.active=false; this._arp.seq=[]; this._arp.startTickAlign=0; this._arp.morph=null; }
                                this.stopAllActiveNotes();
                            } catch(_) {}
                        }
                        this._lastInteractionAt = now;
                    } catch(_) {}
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        console.log('Attempting to resume AudioContext on mousedown...');
                        this.audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully');
                        });
                    }
                    try { this._startArpTransport(); } catch(_){ }
                });

                // Modal Event Listeners
                const closeColumnModalBtn = document.getElementById('closeColumnModal');
                const addCustomColumnBtn = document.getElementById('addCustomColumn');

                if (closeColumnModalBtn) {
                    closeColumnModalBtn.addEventListener('click', () => {
                        document.getElementById('columnModal').style.display = 'none';
                    });
                }

                if (addCustomColumnBtn) {
                    addCustomColumnBtn.addEventListener('click', () => {
                        document.getElementById('columnModal').style.display = 'none';
                        this.showChordBuilder();
                    });
                }

                // Add to favorites button
                const addToFavoritesBtn = document.getElementById('addToFavoritesBtn');
                if (addToFavoritesBtn) {
                    addToFavoritesBtn.addEventListener('click', () => {
                        this.addCurrentChordToFavorites();
                    });
                }

                // Initialize custom chords storage - no localStorage
                this.customChords = [];
                
                // Migrate old custom chords from 12-TET semitones to native tuning
                this.migrateCustomChords();
                
                this.hiddenColumns = [];
                this.favoriteChords = [];
                this.paletteChords = [];
                this.currentEditingColumn = null;
                
                // Set up context menu
                
                // Set up fretboard resize functionality
                this.setupFretboardResize();
                
                // Set up sonic chord functionality
                this.setupSonicChords();
                
                // Force initial generation
                console.log('Initializing omnichord with tuning:', this.currentTuning);
                setTimeout(() => {
                    this.generateRootButtons();
                    this.generateExtensionColumns();
                }, 100);
            }

            migrateCustomChords() {
                // Migrate old custom chords that used 12-TET semitones to native tuning
                let needsMigration = false;
                
                this.customChords.forEach(chord => {
                    // Check if this chord needs migration (has intervals property instead of notes)
                    if (chord.intervals && !chord.notes) {
                        // Convert from 12-TET semitones to native tuning
                        const originalTuning = this.currentTuning;
                        this.currentTuning = chord.tuning || 12;
                        
                        chord.notes = chord.intervals.map(semitone => {
                            // For chords saved in their original tuning, just use the intervals directly
                            return semitone;
                        });
                        
                        // Remove old intervals property
                        delete chord.intervals;
                        this.currentTuning = originalTuning;
                        needsMigration = true;
                        console.log(`Migrated custom chord: ${chord.name}`);
                    } else if (!chord.notes && chord.intervals) {
                        // Fallback: copy intervals to notes if notes missing
                        chord.notes = [...chord.intervals];
                        needsMigration = true;
                    }
                });
                
                if (needsMigration) {
                    console.log('Custom chords migrated to new format');
                }
            }

            setupContextMenu() {
                console.log('🎵 Context menus disabled for cleaner interface');
                
                // Setup keyboard input only
                this.setupKeyboardInput();
            }
            
            setupKeyboardInput() {
                if (this._keyboardListenerAttached) return;
                this._keyboardHandler = (e) => {
                    // Allow typing in inputs/textareas without hijacking
                    const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : '';
                    // Also allow typing in contenteditable chord name fields
                    const isEditable = (()=>{
                        try {
                            if (!e.target) return false;
                            if (e.target.isContentEditable) return true;
                            if (typeof e.target.closest === 'function') {
                                const el = e.target.closest('[contenteditable="true"]');
                                if (el) return true;
                            }
                        } catch(_) {}
                        return false;
                    })();
                    if (tag === 'INPUT' || tag === 'TEXTAREA' || isEditable || e.isComposing) return;

                    // Ctrl+1..Ctrl+0: queue drum pattern 1..10 for next bar; Ctrl+D duplicate current
                    if (e.ctrlKey && !e.shiftKey && !e.altKey && ((e.key >= '0' && e.key <= '9') || e.key.toLowerCase() === 'd')) {
                        e.preventDefault();
                        try {
                            if (e.key.toLowerCase() === 'd') {
                                // Duplicate current pattern
                                if (typeof this._duplicateCurrentDrumPattern === 'function') this._duplicateCurrentDrumPattern();
                                return;
                            }
                            // Ensure transport exists to compute bar edges
                            if (!this._arpTransport) this._ensureArpTransport();
                            // Map key to pattern number (1..10 where 0 maps to 10)
                            const targetPat = (e.key === '0') ? 10 : Math.max(1, Math.min(10, parseInt(e.key,10)));
                            this._drumPendingPattern = targetPat;
                            // Visual feedback: flash pattern input briefly
                            const patEl = document.getElementById('drumPatternNumber');
                            if (patEl) {
                                patEl.title = `Queued DRUM pattern ${targetPat} @ next bar`;
                                patEl.style.outline = '2px solid #00d1b2';
                                setTimeout(()=>{ try { patEl.style.outline = ''; } catch(_){} }, 240);
                            }
                        } catch(_) {}
                        return;
                    }

                    // In TOUCH (slide) mode, disable keyboard-triggered playback entirely
                    if (this._chordSlideEnabled) return;

                    const key = e.key;
                    let chordIndex = -1;
                    // Track held number keys to throttle OS key repeat
                    if (!this._heldNumberKeys) this._heldNumberKeys = new Set();

                    // Map number keys to chord indices (1-9, then 0 for 10th chord)
                    if (key >= '1' && key <= '9') chordIndex = parseInt(key,10) - 1;
                    else if (key === '0') chordIndex = 9;

                    if (chordIndex >= 0) {
                        // Ignore auto-repeat while key is held
                        if (this._heldNumberKeys.has(key) || e.repeat) return;
                        this._heldNumberKeys.add(key);
                        e.preventDefault();
                        this.playChordByIndex(chordIndex);
                        return;
                    }

                    // Global transpose shortcuts: support '+', '-', '=', and numpad add/subtract
                    // Do NOT trigger when ALT is held (ALT +/- is reserved for octave)
                    if (!e.altKey && (key === '+' || key === '=')) { e.preventDefault(); try { this.applyTransposeStep(1); } catch(_) {} return; }
                    if (!e.altKey && (key === '-' || key === '_')) { e.preventDefault(); try { this.applyTransposeStep(-1); } catch(_) {} return; }
                    if (!e.altKey && e.code === 'NumpadAdd') { e.preventDefault(); try { this.applyTransposeStep(1); } catch(_) {} return; }
                    if (!e.altKey && e.code === 'NumpadSubtract') { e.preventDefault(); try { this.applyTransposeStep(-1); } catch(_) {} return; }
                    
                    // SPACE key: PLAY/STOP toggle with audio panic on stop
                    if (key === ' ' || e.code === 'Space') {
                        e.preventDefault();
                        try {
                            const playStopToggle = document.getElementById('playStopToggleBtn');
                            if (playStopToggle) {
                                if (this._isSequencing) {
                                    // Currently playing - STOP with PANIC (kill all audio)
                                    console.log('🎵 SPACE pressed: STOPPING sequence with AUDIO PANIC');
                                    
                                    // AUDIO PANIC: Kill everything
                                    this.stopAllActiveNotes();
                                    this._sustainActive = false;
                                    this._chordsGestureActive = false;
                                    this._chordSlideActive = false;
                                    this._stopArp();
                                    
                                    // Stop all oscillators
                                    if (this.audioContext) {
                                        try {
                                            // Kill any remaining audio nodes
                                            Object.values(this.activeNotes || {}).forEach(noteGroup => {
                                                if (Array.isArray(noteGroup)) {
                                                    noteGroup.forEach(note => {
                                                        if (note && note.stop) note.stop(0);
                                                        if (note && note.disconnect) note.disconnect();
                                                    });
                                                }
                                            });
                                            this.activeNotes = {};
                                        } catch(_) {}
                                    }
                                    
                                    // Clear ARP state
                                    if (this._arp) {
                                        this._arp.pendingSwitch = null;
                                        this._arp.active = false;
                                    }
                                    
                                    // Clear sequence timer
                                    if (this._seqTimer) {
                                        clearTimeout(this._seqTimer);
                                        this._seqTimer = null;
                                    }
                                    
                                    this._isSequencing = false;
                                    this._stopPlayButtonFlashing();
                                    
                                    // Update button UI
                                    playStopToggle.textContent = 'PLAY';
                                    playStopToggle.style.background = '#27ae60';
                                    playStopToggle.style.borderColor = '#2ecc71';
                                    
                                    console.log('🎵 Audio PANIC complete - all sound stopped');
                                } else {
                                    // Currently stopped - START playing
                                    console.log('🎵 SPACE pressed: STARTING sequence');
                                    playStopToggle.click(); // Trigger the existing play logic
                                }
                            }
                        } catch (e) {
                            console.error('Error handling SPACE key:', e);
                        }
                        return;
                    }

                    // R key: Re-randomize arpeggiator pattern at next quant edge
                    if ((key === 'r' || key === 'R')) {
                        try {
                            // Only act when ARP is engaged or a sequence is active
                            const patEl = document.getElementById('universalPattern');
                            const pat = (patEl && patEl.value) ? patEl.value : (this._arp?.pattern||'up');
                            if (!this._arpTransport) this._ensureArpTransport();
                            if (!this._arp) this._ensureArpDefaults();
                            // If no column context, ignore
                            const col = this._arp?.column || this.currentActiveColumnEl || null;
                            if (!col) return;
                            // Build a fresh sequence using 'random' regardless of current pattern
                            const rowsAll = Array.from(col.querySelectorAll('.strings-column .string'));
                            const within = rowsAll.filter(r => {
                                const o = parseInt(r.dataset.octave||'0',10);
                                return o>=5 && o<=9;
                            });
                            const npc = Math.max(1, (this._getGlobalNpc ? this._getGlobalNpc() : (this._arp?.npc|0) || 3));
                            const seq = this._buildArpSequence(within, 'random', null).slice(0, npc);
                            // Queue for next tick to avoid phase break
                            const tpBar = this._arpTransport.ticksPerBar || 16;
                            const curTick = this._arpTransport.tickCounter|0;
                            const absTick = this._arpTransport.absTickCounter|0;
                            const targetAbsTick = absTick + 1;
                            this._arp.pendingSwitch = {
                                atAbsTick: targetAbsTick >>> 0,
                                alignPhaseToTickCounter: false,
                                seq,
                                bassFreq: this._arp.bassFreq,
                                column: col,
                                mapAsc: within.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0)-(parseFloat(b.dataset.frequency)||0)).slice(0, npc)
                            };
                            // Ensure transport
                            this._startArpTransport();
                        } catch(_) {}
                        return;
                    }
                };
                // Attach on window with capture so it fires even during bubbling-stopped handlers
                window.addEventListener('keydown', this._keyboardHandler, true);
                // Stop playback on number key release for ARP/Chords (press-to-start/release-to-stop parity with mouse/touch)
                this._keyboardKeyupHandler = (e) => {
                    // Global ESC panic (always active, cancels everything immediately)
                    if (e.key === 'Escape') {
                        try {
                            // Stop internal audio and sequencing
                            this.stopAllActiveNotes();
                            this._sustainActive = false;
                            this._chordsGestureActive = false;
                            this._chordSlideActive = false;
                            try { this._stopArp(); } catch(_) {}

                            // Kill any lingering audio nodes
                            if (this.audioContext) {
                                try {
                                    Object.values(this.activeNotes || {}).forEach(noteGroup => {
                                        if (Array.isArray(noteGroup)) {
                                            noteGroup.forEach(note => {
                                                if (note && note.stop) note.stop(0);
                                                if (note && note.disconnect) note.disconnect();
                                            });
                                        }
                                    });
                                    this.activeNotes = {};
                                } catch(_) {}
                            }

                            // Send MIDI All Notes Off across channels if available
                            try { if (window.midi && window.midi.enabled && typeof window.midi.allNotesOff === 'function') window.midi.allNotesOff(); } catch(_) {}
                        } catch(_) {}
                        return;
                    }
                    const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : '';
                    const isEditable = (()=>{
                        try {
                            if (!e.target) return false;
                            if (e.target.isContentEditable) return true;
                            if (typeof e.target.closest === 'function') {
                                const el = e.target.closest('[contenteditable="true"]');
                                if (el) return true;
                            }
                        } catch(_) {}
                        return false;
                    })();
                    if (tag === 'INPUT' || tag === 'TEXTAREA' || isEditable || e.isComposing) return;
                    // In TOUCH (slide) mode, ignore key releases as well
                    if (this._chordSlideEnabled) return;
                    const key = e.key;
                    const isNumberKey = (key >= '1' && key <= '9') || key === '0';
                    if (!isNumberKey) return;
                    if (this._heldNumberKeys) this._heldNumberKeys.delete(key);
                    const mode = (this.playMode||'high-low');
                    if (mode === 'arp') {
                        try { this._stopArp(); } catch(_) {}
                    } else if (mode === 'chords') {
                        try { this.stopAllActiveNotes(); } catch(_) {}
                        this._sustainActive = false;
                        this._chordsGestureActive = false;
                    }
                };
                window.addEventListener('keyup', this._keyboardKeyupHandler, true);
                this._keyboardListenerAttached = true;
            }
            
            playChordByIndex(index) {
                // Prefer playing from extension grid columns; fall back to palette when needed
                const columns = document.querySelectorAll('.extension-column');
                if (index < columns.length) {
                    const column = columns[index];
                    const header = column.querySelector('.extension-header');
                    if (header) {
                        console.log(`Playing extension chord ${index + 1}:`, header.textContent);
                        // For ARP mode, start the arpeggiator from the column on key press
                        const rect = column.getBoundingClientRect();
                        const centerY = rect.top + rect.height / 2;
                        if (this.arpEnabled) {
                            this._ensureArpDefaults();
                            // Keyboard start uses single-octave start (no span)
                            this._arp.span = { active:false, yMin:null, yMax:null, octMin:null, octMax:null };
                            
                            // Schedule quantized ARP chord change to preserve transport sync
                            this._scheduleQuantizedArpChordChange(column, centerY);
                        } else if (this.chordsEnabled) {
                            // Chords mode: if slide enabled, glide to this chord over 2 beats; else play immediately
                            if (this._chordSlideEnabled) {
                                // On first key press, if no active chord, start it immediately
                                if (!this._chordsGestureActive) {
                                    try {
                                        const quantizedChange = this._shouldQuantizeChordChange();
                                        if (quantizedChange.shouldQuantize) {
                                            this._scheduleQuantizedChordChange(column, centerY, quantizedChange.nextBeatMs);
                                        } else {
                                            this._executeChordChange(column, centerY);
                                        }
                                    } catch(_) { this._executeChordChange(column, centerY); }
                                } else {
                                    // Compute 2-beat duration from transport BPM (default 120)
                                    const bpm = (this._arp?.bpm) || 120;
                                    const beatMs = 60000 / bpm;
                                    const twoBeatsMs = 2 * beatMs;
                                    const targets = this._computeChordSlideTargets(column);
                                    // Use negative velocity hint to stretch to max
                                    this._retuneActiveChordVoicesToTargets(targets, 0);
                                    // Optionally, we could force a minimal gliss time by scheduling a follow-up exact settle after two beats
                                    setTimeout(()=>{ try{ this._retuneActiveChordVoicesToTargets(targets, 0); }catch(_){ } }, Math.max(50, twoBeatsMs));
                                }
                            } else {
                                try {
                                    const quantizedChange = this._shouldQuantizeChordChange();
                                    if (quantizedChange.shouldQuantize) {
                                        this._scheduleQuantizedChordChange(column, centerY, quantizedChange.nextBeatMs);
                                    } else {
                                        this._executeChordChange(column, centerY);
                                    }
                                } catch(_) { this._executeChordChange(column, centerY); }
                            }
                        } else {
                            // Other modes: simulate a short swipe strum across the center
                            this.playChordStrum(column, { name: header.textContent }, centerY - 10, centerY + 10);
                        }
                    }
                } else {
                    // Fall back to palette chords if available
                    if (this.paletteChords && index < this.paletteChords.length) {
                        const chord = this.paletteChords[index];
                        console.log(`Playing palette chord ${index + 1}:`, chord.name);
                        this.playPaletteChord(chord);
                    } else {
                        console.log(`No chord available at index ${index + 1}`);
                    }
                }
            }

            setupTouchGestures() {
                // Add touch gesture support to all chord elements
                this.addTouchGesturesToElements();
                
                // Re-apply gestures when DOM changes (for dynamically added elements)
                const observer = new MutationObserver(() => {
                    this.addTouchGesturesToElements();
                });
                
                observer.observe(document.getElementById('extensionColumns'), {
                    childList: true,
                    subtree: true
                });
            }
            
            addTouchGesturesToElements() {
                // Add gestures to chord string buttons
                document.querySelectorAll('.chord-btn').forEach(btn => {
                    this.addTouchGestureToElement(btn, 'chord');
                    this.addClickGestureToElement(btn, 'chord');
                });

                // Add gestures to extension headers (tap to play; long-press on name to edit)
                document.querySelectorAll('.extension-header').forEach(header => {
                    this.addTouchGestureToElement(header, 'chord');
                    this.addClickGestureToElement(header, 'chord');
                });

                // Add gestures to palette chords
                document.querySelectorAll('.palette-chord').forEach(chord => {
                    this.addTouchGestureToElement(chord, 'palette');
                    this.addClickGestureToElement(chord, 'palette');
                });

                // Add gestures to root chord buttons
                document.querySelectorAll('.root-btn').forEach(btn => {
                    this.addTouchGestureToElement(btn, 'root');
                    this.addClickGestureToElement(btn, 'root');
                });
            }
            
            addTouchGestureToElement(element, type) {
                // Prevent duplicate listeners
                if (element.dataset.touchGestureAdded) return;
                element.dataset.touchGestureAdded = 'true';
                
                let touchData = {
                    startTime: 0,
                    longPressTimer: null,
                    isLongPress: false
                };
                
                // Store the type for later reference
                element.dataset.touchGestureType = type;
                
                // Touch start
                element.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    touchData.startTime = Date.now();
                    touchData.isLongPress = false;
                    
                    // Add visual feedback for touch press
                    element.classList.add('touch-pressed');
                    
                    // Clear any existing timer
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                    }
                    
                    // Start long press timer - use shorter delay for chord name buttons
                    const delay = (type === 'chord' && element.classList.contains('extension-header')) ? 
                        this.touchGestures.chordNameLongPressDelay : this.touchGestures.longPressDelay;
                    
                    touchData.longPressTimer = setTimeout(() => {
                        touchData.isLongPress = true;
                        element.classList.remove('touch-pressed');
                        element.classList.add('touch-long-press');
                        this.handleLongPress(element, type, touch.clientX, touch.clientY);
                        
                        // Add haptic feedback if available
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                    }, delay);
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch move - cancel long press if moving too much
                element.addEventListener('touchmove', (e) => {
                    // Cancel long press on any significant movement
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                        element.classList.remove('touch-pressed');
                    }
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch end
                element.addEventListener('touchend', (e) => {
                    // Clear long press timer
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                    }
                    
                    // Remove all touch feedback classes
                    element.classList.remove('touch-pressed', 'touch-long-press');
                    
                    // Handle normal tap if not a long press
                    if (!touchData.isLongPress) {
                        const delay = (type === 'chord' && element.classList.contains('extension-header')) ? 
                            this.touchGestures.chordNameLongPressDelay : this.touchGestures.longPressDelay;
                        if (Date.now() - touchData.startTime < delay) {
                            this.handleNormalTap(element, type);
                        }
                    }
                    
                    touchData.isLongPress = false;
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch cancel
                element.addEventListener('touchcancel', (e) => {
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                    }
                    
                    // Remove all touch feedback classes
                    element.classList.remove('touch-pressed', 'touch-long-press');
                    
                    touchData.isLongPress = false;
                }, { passive: false });
            }
            
            addClickGestureToElement(element, type) {
                // Prevent duplicate listeners
                if (element.dataset.clickGestureAdded) return;
                element.dataset.clickGestureAdded = 'true';
                
                // Add click event listener for regular mouse clicks (using capture phase for higher priority)
                element.addEventListener('click', (e) => {
                    // For chord headers or columns, short click plays; do not open context menus
                    if (type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        // For CHORDS mode, clicking the chord should play the sustained chord, not a strum
                        const column = element.classList.contains('extension-column') ? element : element.closest('.extension-column');
                        if (column && (this.playMode||'high-low') === 'chords') {
                            const rect = column.getBoundingClientRect();
                            const midY = rect.top + rect.height * 0.5;
                            try {
                                const quantizedChange = this._shouldQuantizeChordChange();
                                if (quantizedChange.shouldQuantize) {
                                    this._scheduleQuantizedChordChange(column, midY, quantizedChange.nextBeatMs);
                                } else {
                                    this._executeChordChange(column, midY);
                                }
                            } catch(_) { this._executeChordChange(column, midY); }
                        } else {
                            this.handleClick(element, type, e.clientX, e.clientY);
                        }
                        return false; // Ensure event stops here
                    } else if (type === 'palette') {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        // Play palette chord on click
                        this.handleClick(element, type, e.clientX, e.clientY);
                        return false; // Ensure event stops here
                    }
                    // For root buttons (type === 'root'), let the normal click behavior happen
                }, true); // Use capture phase
                
                // Also add a mousedown listener for long-press support
                element.addEventListener('mousedown', (e) => {
                    // Only handle left click (button 0)
                    if (e.button === 0 && type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                        // For chord name buttons (extension-header), use shorter delay and enter edit only if on the text span
                        if (element.classList.contains('extension-header')) {
                            element.dataset.mouseDownTime = Date.now();
                            element.dataset.mouseDownX = e.clientX;
                            element.dataset.mouseDownY = e.clientY;
                            
                            // Start timer for long press on header; only edit if target is .chord-name
                            element.dataset.mouseLongPressTimer = setTimeout(() => {
                                element.dataset.isMouseLongPress = 'true';
                                // If the exact text span was pressed, enter inline edit
                                const target = e.target;
                                if (target && target.classList && target.classList.contains('chord-name')) {
                                    try {
                                        target.setAttribute('contenteditable','true');
                                        target.focus();
                                        const range = document.createRange();
                                        range.selectNodeContents(target);
                                        const sel = window.getSelection();
                                        sel.removeAllRanges();
                                        sel.addRange(range);
                                    } catch(_){ }
                                } else {
                                    // Otherwise treat as long-press hold (no context menu)
                                    this.handleLongPress(element, type, e.clientX, e.clientY);
                                }
                            }, this.touchGestures.chordNameLongPressDelay);
                        } else {
                            // Regular behavior for other chord elements
                            element.dataset.showContextMenuOnMouseup = 'true';
                        }
                    }
                }, true);
                
                // Add mousemove listener to cancel long press on movement
                element.addEventListener('mousemove', (e) => {
                    if (element.dataset.mouseLongPressTimer && element.dataset.mouseDownX && element.dataset.mouseDownY) {
                        const deltaX = Math.abs(e.clientX - parseInt(element.dataset.mouseDownX));
                        const deltaY = Math.abs(e.clientY - parseInt(element.dataset.mouseDownY));
                        
                        // Cancel long press if mouse moved too much (more than 10px)
                        if (deltaX > 10 || deltaY > 10) {
                            clearTimeout(parseInt(element.dataset.mouseLongPressTimer));
                            delete element.dataset.mouseLongPressTimer;
                            delete element.dataset.mouseDownTime;
                            delete element.dataset.mouseDownX;
                            delete element.dataset.mouseDownY;
                        }
                    }
                });
                
                // Add mouseup listener to complete the action
                element.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        // Handle chord name button mouseup
                        if (element.classList.contains('extension-header') && element.dataset.mouseDownTime) {
                            const holdTime = Date.now() - parseInt(element.dataset.mouseDownTime);
                            
                            // Clear the timer
                            if (element.dataset.mouseLongPressTimer) {
                                clearTimeout(parseInt(element.dataset.mouseLongPressTimer));
                                delete element.dataset.mouseLongPressTimer;
                            }
                            
                            // If it was a long press, don't do anything else (already handled)
                            if (element.dataset.isMouseLongPress === 'true') {
                                delete element.dataset.isMouseLongPress;
                            } else if (holdTime < this.touchGestures.chordNameLongPressDelay) {
                                // Short click - treat as normal tap to play
                                this.handleNormalTap(element, type);
                            }
                            
                            // Clean up
                            delete element.dataset.mouseDownTime;
                            delete element.dataset.mouseDownX;
                            delete element.dataset.mouseDownY;
                        } else if (element.dataset.showContextMenuOnMouseup === 'true') {
                            // Regular behavior for other chord elements
                            delete element.dataset.showContextMenuOnMouseup;
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            this.handleClick(element, type, e.clientX, e.clientY);
                            return false;
                        }
                    }
                }, true);
            }
            
            handleClick(element, type, x, y) {
                // For chords and palette items, trigger playback (strum or sustained chord)
                    if (type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                    const column = element.classList.contains('extension-column') ? element : element.closest('.extension-column');
                    if (!column) { console.error('Could not find parent column'); return; }
                    const rect = column.getBoundingClientRect();
                    if ((this.playMode||'high-low') === 'chords') {
                        const midY = rect.top + rect.height * 0.5;
                            try {
                                const quantizedChange = this._shouldQuantizeChordChange();
                                if (quantizedChange.shouldQuantize) {
                                    this._scheduleQuantizedChordChange(column, midY, quantizedChange.nextBeatMs);
                                } else {
                                    this._executeChordChange(column, midY);
                                }
                            } catch(_) { this._executeChordChange(column, midY); }
                    } else {
                        const header = column.querySelector('.extension-header');
                        const chordData = (this.getChordDataFromColumn(column, header)) || { name: header ? header.textContent : 'Chord' };
                        const startY = rect.top + Math.max(4, rect.height * 0.08);
                        const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                        this.playChordStrum(column, chordData, startY, endY);
                    }
                    return;
                }
                if (type === 'palette') {
                    const chordData = this.getPaletteChordDataFromElement(element);
                    const column = element.closest('.palette-chord') || element.closest('.extension-column') || element;
                    if (column && chordData) {
                        const rect = column.getBoundingClientRect();
                        if ((this.playMode || 'high-low') === 'chords') {
                            const midY = rect.top + rect.height * 0.5;
                            try {
                                const quantizedChange = this._shouldQuantizeChordChange();
                                if (quantizedChange.shouldQuantize) {
                                    this._scheduleQuantizedChordChange(column, midY, quantizedChange.nextBeatMs);
                                } else {
                                    this._executeChordChange(column, midY);
                                }
                            } catch(_) { this._executeChordChange(column, midY); }
                        } else {
                            const startY = rect.top + Math.max(4, rect.height * 0.08);
                            const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                            this.playChordStrum(column, chordData, startY, endY);
                        }
                    }
                    return;
                }
                // For other types (e.g., root), let normal behavior proceed
            }
            
            handleLongPress(element, type, x, y) {
                // Show appropriate context menu based on element type
                if (type === 'chord') {
                    // Check if this is an extension header (chord name button)
                    if (element.classList.contains('extension-header')) {
                        // Only enter edit mode if the long-press happened on the chord-name span
                        try {
                            const target = document.elementFromPoint(x, y);
                            const nameEl = element.querySelector('.chord-name');
                            if (target && nameEl && (target === nameEl || nameEl.contains(target))) {
                                nameEl.setAttribute('contenteditable','true');
                                nameEl.focus();
                                const range = document.createRange();
                                range.selectNodeContents(nameEl);
                                const sel = window.getSelection();
                                sel.removeAllRanges();
                                sel.addRange(range);
                            }
                        } catch(_) { /* no-op */ }
                    } else {
                        // Fallback to original logic for other chord elements
                        const columnData = this.getColumnDataFromElement(element);
                    }
                } else if (type === 'palette') {
                    const chordData = this.getPaletteChordDataFromElement(element);
                } else if (type === 'root') {
                    // Root chords could have their own context menu
                }
            }
            
            handleNormalTap(element, type) {
                // Play a strum on normal tap for chord headers and palette chords
                if (type === 'chord' && element.classList.contains('extension-header')) {
                    const column = element.closest('.extension-column');
                    if (column) {
                        const header = column.querySelector('.extension-header');
                        const chordData = (this.getChordDataFromColumn(column, header)) || { name: header ? header.textContent : 'Chord' };
                        const rect = column.getBoundingClientRect();
                        const startY = rect.top + Math.max(4, rect.height * 0.08);
                        const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                        this.playChordStrum(column, chordData, startY, endY);
                    }
                } else if (type === 'palette') {
                    const chordData = this.getPaletteChordDataFromElement(element);
                    const column = element.closest('.palette-chord') || element.closest('.extension-column') || element;
                    if (column && chordData) {
                        const rect = column.getBoundingClientRect();
                        const startY = rect.top + Math.max(4, rect.height * 0.08);
                        const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                        this.playChordStrum(column, chordData, startY, endY);
                    }
                } else if (type === 'root') {
                    // For root buttons, perform normal click behavior
                    const rootBtn = element.closest('.root-btn');
                    if (rootBtn) rootBtn.click();
                }
            }
            
            getColumnDataFromElement(element) {
                const column = element.closest('[data-chord-type]');
                if (!column) return null;
                
                return {
                    name: column.dataset.chordType,
                    extensions: column.dataset.extensions ? column.dataset.extensions.split(',') : [],
                    element: column
                };
            }
            
            getPaletteChordDataFromElement(element) {
                const chordElement = element.closest('.palette-chord');
                if (!chordElement) return null;
                
                const chordIndex = parseInt(chordElement.dataset.chordIndex);
                return this.paletteChords[chordIndex] || null;
            }
            
            showPaletteContextMenu(x, y, chordData) {
            }
            
            handlePaletteContextMenuAction(action) {
            }

            showColumnContextMenu(x, y, columnData) {
            }

            getChordDataFromColumn(column, header) {
                const chordType = column.dataset.chordType;
                let chordData = null;
                
                console.log('?? getChordDataFromColumn called with chordType:', chordType);
                
                // Check if it's a custom chord
                if (chordType && chordType.startsWith('custom_')) {
                    const customIndex = parseInt(chordType.replace('custom_', ''));
                    const customChord = this.customChords[customIndex];
                    if (customChord) {
                        chordData = {
                            name: customChord.name,
                            extensions: [],
                            quality: 'custom',
                            id: chordType,
                            isCustom: true,
                            originalName: customChord.name,
                            customIndex: customIndex,
                            intervals: customChord.notes,
                            root: this.currentRoot,
                            tuning: this.currentTuning
                        };
                    }
                } else {
                    // Regular extension chord - determine quality and extension
                    let quality = 'major'; // default
                    
                    // Try to find quality from parent quality section first
                    let qualitySection = null;
                    if (header && header.closest) {
                        qualitySection = header.closest('.quality-section');
                    }
                    
                    if (qualitySection) {
                        const allQualitySections = Array.from(document.querySelectorAll('.quality-section'));
                        const qualityIndex = allQualitySections.indexOf(qualitySection);
                        const qualities = ['major', 'neutral', 'minor'];
                        quality = qualities[qualityIndex] || 'major';
                    } else {
                        // For basic triads mode, determine quality from chord type or header text
                        const headerText = header && header.textContent ? header.textContent : '';
                        if (chordType === 'major' || headerText === 'Major') {
                            quality = 'major';
                        } else if (chordType === 'neutral' || headerText === 'Neutral') {
                            quality = 'neutral';
                        } else if (chordType === 'minor' || headerText === 'Minor') {
                            quality = 'minor';
                        }
                    }
                    
                    // Find the extension - in basic triads mode, find by name
                    let chordExt = null;
                    if (chordType === 'major' || chordType === 'neutral' || chordType === 'minor') {
                        // Basic triads mode - find by name
                        chordExt = this.chordExtensions.find(ext => 
                            ext.name.toLowerCase() === header.textContent.toLowerCase()
                        );
                    } else {
                        // Complex mode - find by index
                        const chordIndex = parseInt(chordType);
                        chordExt = this.chordExtensions[chordIndex];
                    }
                    
                    if (chordExt) {
                        chordData = {
                            name: header.textContent,
                            extensions: chordExt.extensions || [],
                            quality: quality,
                            id: chordType,
                            isCustom: false,
                            originalName: chordExt.name,
                            extensionIndex: chordExt.name, // Use name as identifier in basic mode
                            intervals: this.getBaseTriadForQuality(quality).concat(chordExt.extensions || []),
                            root: this.currentRoot,
                            tuning: this.currentTuning
                        };
                        console.log('?? Created chordData:', chordData);
                    } else {
                        console.log('?? Failed to find chordExt for chordType:', chordType);
                    }
                }
                
                return chordData;
            }

            showChordNameContextMenu(x, y, chordData) {
            }

            handleContextMenuAction(action) {
                console.log('Context menu action requested but disabled:', action);
            }
            
            // New unified methods for the refactored system
            duplicateAndEditColumn() {
                if (!this.currentEditingColumn) return;
                
                // Create a duplicate chord with new ID
                const duplicateChord = {
                    name: this.currentEditingColumn.name + ' Copy',
                    intervals: [...(this.currentEditingColumn.intervals || [])],
                    isCustom: true,
                    id: Date.now()
                };
                
                // Open chord builder with the duplicate
                this.showChordBuilder(duplicateChord);
            }
            
            editColumnInChordBuilder() {
                if (!this.currentEditingColumn) return;
                
                // Open chord builder with current column data for editing
                this.showChordBuilder(this.currentEditingColumn);
            }

            // Palette chord context menu actions
            editPaletteChordNotes(chordData) {
                // Open a modal to edit chord notes
                console.log('Editing palette chord notes:', chordData);
                // TODO: Implement chord note editor
            }
            
            copyPaletteChord(chordData) {
                // Create a copy of the chord and add it to the palette
                const copy = {
                    ...chordData,
                    name: chordData.name + ' Copy'
                };
                this.paletteChords.push(copy);
                this.savePaletteChords();
                console.log('Copied palette chord:', copy);
            }
            
            movePaletteChord(chordData, direction) {
                const currentIndex = this.paletteChords.findIndex(chord => 
                    chord.name === chordData.name && 
                    JSON.stringify(chord.notes) === JSON.stringify(chordData.notes)
                );
                
                if (currentIndex === -1) return;
                
                const newIndex = currentIndex + direction;
                if (newIndex < 0 || newIndex >= this.paletteChords.length) return;
                
                // Swap positions
                [this.paletteChords[currentIndex], this.paletteChords[newIndex]] = 
                [this.paletteChords[newIndex], this.paletteChords[currentIndex]];
                
                this.savePaletteChords();
                console.log('Moved palette chord:', direction > 0 ? 'right' : 'left');
            }
            
            removePaletteChord(chordData) {
                const index = this.paletteChords.findIndex(chord => 
                    chord.name === chordData.name && 
                    JSON.stringify(chord.notes) === JSON.stringify(chordData.notes)
                );
                
                if (index !== -1) {
                    this.paletteChords.splice(index, 1);
                    this.savePaletteChords();
                }
            }

            setupFretboardResize() {
                const resizeHandle = document.querySelector('.resize-handle');
                const extensionColumns = document.getElementById('extensionColumns');
                let isResizing = false;
                let startY = 0;
                let startHeight = 0;

                if (!resizeHandle || !extensionColumns) return;

                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startY = e.clientY;
                    startHeight = extensionColumns.offsetHeight;
                    document.body.style.cursor = 'ns-resize';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    
                    const deltaY = e.clientY - startY;
                    const newHeight = Math.max(200, Math.min(800, startHeight + deltaY));
                    
                    // Update container height
                    extensionColumns.style.height = `${newHeight}px`;
                    
                    // Update string spacing by keeping strings thin (1px) with tight margins for 8-octave support
                    const strings = document.querySelectorAll('.string');
                    const stringHeight = 1; // Always keep strings thin at 1px
                    const stringMargin = 0.2; // Consistent tight margin for 8-octave support
                    
                    strings.forEach(string => {
                        string.style.height = `${stringHeight}px`;
                        string.style.margin = `${stringMargin}px 0`;
                    });
                    
                    e.preventDefault();
                });

                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        document.body.style.cursor = '';
                    }
                });

                // Touch support for mobile
                resizeHandle.addEventListener('touchstart', (e) => {
                    isResizing = true;
                    startY = e.touches[0].clientY;
                    startHeight = extensionColumns.offsetHeight;
                    e.preventDefault();
                });

                document.addEventListener('touchmove', (e) => {
                    if (!isResizing) return;
                    
                    const deltaY = e.touches[0].clientY - startY;
                    const newHeight = Math.max(200, Math.min(800, startHeight + deltaY));
                    
                    extensionColumns.style.height = `${newHeight}px`;
                    
                    const strings = document.querySelectorAll('.string');
                    const stringHeight = 1; // Always keep strings thin at 1px
                    const stringMargin = 0.2; // Consistent tight margin for 8-octave support
                    
                    strings.forEach(string => {
                        string.style.height = `${stringHeight}px`;
                        string.style.margin = `${stringMargin}px 0`;
                    });
                    
                    e.preventDefault();
                });

                document.addEventListener('touchend', () => {
                    if (isResizing) {
                        isResizing = false;
                    }
                });
            }

            setupSonicChords() {
                // No longer rendering sonic chords - lock buttons work directly on main chord grid
                console.log('Sonic chord system disabled - using direct chord locking');
            }

            handleSonicStringTrigger(e) {
                if (!e.target.classList.contains('string')) return;
                
                const stringElement = e.target;
                const column = stringElement.closest('.sonic-column');
                if (!column) return;
                
                const index = parseInt(column.dataset.index);
                const sonicChord = this.lockedSonicChords[index];
                if (!sonicChord) return;
                
                const stringIndex = parseInt(stringElement.dataset.string);
                const stringKey = `${index}-${stringIndex}`;
                
                if (!this.sonicTriggeredStrings.has(stringKey)) {
                    this.sonicTriggeredStrings.add(stringKey);
                    
                    // Apply sonic settings temporarily and play the string
                    this.playSonicChord(sonicChord, () => {
                        this.playStringAtIndex(stringIndex);
                    });
                }
            }

            playSonicChordStrum(column, sonicChord, startY, endY) {
                // Apply sonic settings temporarily and play chord strum
                this.playSonicChord(sonicChord, () => {
                    this.playChordStrum(column, sonicChord.chordData, startY, endY);
                });
            }

            addToPalette(chordData) {
                // Always add chords to palette, even duplicates for chord progressions
                // Add a unique ID to track individual instances
                const chordWithId = {
                    ...chordData,
                    paletteId: Date.now() + Math.random() // Unique identifier for this instance
                };
                
                this.paletteChords.push(chordWithId);
                console.log(`Added "${chordData.fullName}" to palette (${this.paletteChords.length} total chords)`);
                this.renderPaletteChords();
            }

            removeFromPalette(index) {
                if (index >= 0 && index < this.paletteChords.length) {
                    const removedChord = this.paletteChords.splice(index, 1)[0];
                    this.renderPaletteChords();
                }
            }

            // =============================================================================
            // SONIC CHORD LOCKING SYSTEM - Complete snapshot of all settings
            // =============================================================================
            
            lockSonicChord(chordData, columnElement) {
                // Check if this chord is already locked
                if (!this.lockedChords) this.lockedChords = new Map();
                
                const isAlreadyLocked = this.lockedChords.has(columnElement);
                
                if (isAlreadyLocked) {
                    // UNLOCK the chord - make it editable but keep it visible
                    console.log('?? Unlocking chord but keeping it visible:', chordData.name);
                    
                    // Get the locked chord data before deleting
                    const lockedChordData = this.lockedChords.get(columnElement);
                    
                    this.lockedChords.delete(columnElement);
                    
                    // Update session data and saved locks
                    this.sessionData.lockedChords = Array.from(this.lockedChords.values());
                    this.savedLockedChords = Array.from(this.lockedChords.values());
                    
                    // Update UI - change lock button to unlocked state (buttons remain visible)
                    const lockButton = columnElement.querySelector('.lock-button');
                    if (lockButton) {
                        lockButton.innerHTML = '🔓';
                        lockButton.classList.remove('locked');
                        lockButton.title = 'Lock chord with current root & settings';
                    }
                    
                    // Keep action buttons visible when unlocked - they should always be available
                    
                    // Reset the column header color to indicate unlocked
                    const header = columnElement.querySelector('.extension-header');
                    const chordName = header.querySelector('.chord-name');
                    if (chordName) {
                        chordName.style.color = '#fff'; // Reset to default color
                        chordName.style.fontWeight = 'normal'; // Reset font weight
                        // Restore original chord name (remove lock icon and root prefix)
                        const originalName = chordData.name || (lockedChordData ? lockedChordData.chordName : 'Chord');
                        const qualityOnlyName = originalName.replace(/^🔒\s*/, '').replace(/^[A-G][#b]?\s*/, ''); // Remove lock icon and root
                        chordName.textContent = qualityOnlyName || originalName;
                        chordName.title = 'Unlocked - will follow current root'; // Update tooltip
                    }
                    
                    // Update the chord extension data to reflect unlocked state
                    if (lockedChordData) {
                        const chordExtension = this.chordExtensions.find(ext => 
                            ext.name === lockedChordData.chordName || 
                            (ext.lockedData && ext.lockedData.lockId === lockedChordData.lockId)
                        );
                        
                        if (chordExtension) {
                            // Convert back to unlocked state but keep the chord visible
                            chordExtension.isLocked = false;
                            chordExtension.lockedData = null;
                            // Keep the intervals so the chord structure remains
                            chordExtension.intervals = lockedChordData.intervals;
                            chordExtension.isCustom = true; // Mark as custom to preserve intervals
                            
                            console.log('?? Converted locked chord to unlocked custom chord:', chordExtension.name);
                        }
                    }
                    
                    // Update the strings in this column to use current root instead of locked root
                    const strings = columnElement.querySelectorAll('.string');
                    strings.forEach(string => {
                        const interval = parseInt(string.dataset.interval);
                        if (!isNaN(interval)) {
                            // Recalculate frequency with current root
                            const absStep3 = ((this.currentRoot + interval) % this.currentTuning + this.currentTuning) % this.currentTuning;
                            const frequency = this.getFrequency(absStep3, 4, this.currentTuning);
                            string.dataset.frequency = frequency;
                            
                            // Update note name and tooltip
                            const noteName = this.getIntervalNoteName(interval);
                            string.textContent = noteName;
                            string.title = `${noteName} (${interval} steps, ${frequency.toFixed(1)}Hz)`;
                        }
                    });
                    
                    console.log('?? Chord unlocked but remains visible as editable chord:', chordData.name);
                    return;
                }
                
                // LOCK the chord
                    console.log('?? Locking chord directly in main grid with current root and settings:', chordData);
                
                // Create a unique identifier for this specific chord + root combination
                const currentRoot = this.currentRoot || 0;
                const lockId = `${chordData.name}_${chordData.quality || 'major'}_${currentRoot}`;
                
                // Capture ALL current settings directly from UI controls
                const rootName = this.getNoteNames()[currentRoot] || currentRoot;
                // Avoid duplicating root if chordData.name already starts with a root (e.g., "C", "Bb7")
                const nameHasRoot = /^[A-G][#b]?/.test(chordData.name || '');
                const fullChordName = nameHasRoot ? (chordData.name || String(rootName)) : `${rootName}${chordData.name}`; // Full display name
                
                const lockedChordData = {
                    // Chord identification
                    lockId: lockId,
                    chordName: fullChordName, // Store full name (root + quality) when locked
                    quality: chordData.quality || this.currentQuality || 'major',
                    extensions: chordData.extensions || [],
                    lockedRoot: currentRoot, // THIS is the key - lock to current root
                    
                    // Position tracking - find current position in chordExtensions array
                    originalPosition: chordData.position !== undefined ? chordData.position : this.findChordPosition(chordData),
                    
                    // Store chord intervals for exact reconstruction
                    intervals: chordData.intervals || [],
                    isCustom: chordData.isCustom || false,
                    
                    // Tuning system (locked)
                    lockedTuning: this.currentTuning || 12,
                    lockedGamelanMode: this.gamelanMode || false,
                    
                    // Audio settings (locked)
                    lockedOsc1: {
                        type: document.getElementById('osc1Type')?.value || this.oscillators.osc1.type || 'sine',
                        level: parseFloat(document.getElementById('osc1Level')?.value || this.oscillators.osc1.level || 0.5),
                        octave: parseInt(document.getElementById('osc1Octave')?.value || this.oscillators.osc1.octave || 0),
                        coarse: parseInt(document.getElementById('osc1Coarse')?.value || this.oscillators.osc1.coarse || 0),
                        detune: parseFloat(document.getElementById('osc1Detune')?.value || this.oscillators.osc1.detune || 0)
                    },
                    
                    lockedOsc2: {
                        type: document.getElementById('osc2Type')?.value || this.oscillators.osc2.type || 'sine',
                        level: parseFloat(document.getElementById('osc2Level')?.value || this.oscillators.osc2.level || 0.5),
                        octave: parseInt(document.getElementById('osc2Octave')?.value || this.oscillators.osc2.octave || 0),
                        coarse: parseInt(document.getElementById('osc2Coarse')?.value || this.oscillators.osc2.coarse || 0),
                        detune: parseFloat(document.getElementById('osc2Detune')?.value || this.oscillators.osc2.detune || 0)
                    },
                    
                    lockedEnvelope: {
                        attack: parseFloat(document.getElementById('envAttack')?.value || this.envelope.attack || 0.01),
                        decay: parseFloat(document.getElementById('envDecay')?.value || this.envelope.decay || 0.3),
                        sustain: parseFloat(document.getElementById('envSustain')?.value || this.envelope.sustain || 0.5),
                        release: parseFloat(document.getElementById('envRelease')?.value || this.envelope.release || 1)
                    },
                    
                    lockedOsc2Envelope: {
                        attack: parseFloat(document.getElementById('osc2EnvAttack')?.value || this.osc2Envelope.attack || 0.01),
                        decay: parseFloat(document.getElementById('osc2EnvDecay')?.value || this.osc2Envelope.decay || 0.3),
                        sustain: parseFloat(document.getElementById('osc2EnvSustain')?.value || this.osc2Envelope.sustain || 0.5),
                        release: parseFloat(document.getElementById('osc2EnvRelease')?.value || this.osc2Envelope.release || 1)
                    },
                    
                    lockedEffects: {
                        reverbWet: parseFloat(document.getElementById('reverbWet')?.value || this.reverbWet || 0),
                        reverbDecay: parseFloat(document.getElementById('reverbDecay')?.value || (this.reverb ? this.reverb.decay : 1)),
                        reverbFilterCutoff: parseFloat(document.getElementById('reverbFilterCutoff')?.value || (this.reverbFilterNode ? this.reverbFilterNode.frequency.value : 20000)),
                        panningMode: document.getElementById('panningMode')?.value || this.panning.mode || 'center',
                        panningWidth: parseFloat(document.getElementById('panningWidth')?.value || this.panning.width || 1)
                    },
                    
                    lockedVolume: {
                        master: parseFloat(document.getElementById('masterVolume')?.value || this.masterVolume || 1),
                        main: parseFloat(document.getElementById('mainVolume')?.value || this.volume || 0.5)
                    },
                    
                    // CRITICAL: Capture exact string frequencies for perfect sound preservation
                    exactFrequencies: this.captureStringFrequencies(columnElement),
                    
                    // Timestamp
                    timestamp: Date.now()
                };
                
                // Store in lockedChords map using column element as key
                if (!this.lockedChords) this.lockedChords = new Map();
                this.lockedChords.set(columnElement, lockedChordData);
                
                // Store in session data and keep saved locks in sync
                this.sessionData.lockedChords = Array.from(this.lockedChords.values());
                this.savedLockedChords = Array.from(this.lockedChords.values());

                // Mark chord model as locked so regeneration uses snapshot
                if (chordData) {
                    chordData.isLocked = true;
                    chordData.lockedData = lockedChordData;
                }
                
                // Update UI - change lock button to locked state and show locked root
                const lockButton = columnElement.querySelector('.lock-button');
                if (lockButton) {
                    lockButton.innerHTML = '🔒';
                    lockButton.classList.add('locked');
                    lockButton.title = `Locked to ${this.getNoteNames()[currentRoot] || currentRoot} root with all settings`;
                }
                
                // Action buttons remain visible (they should always be available)
                // No edit/hide/duplicate header buttons anymore
                
                // Update the column header to show it's locked to a specific root
                const header = columnElement.querySelector('.extension-header');
                const chordName = header.querySelector('.chord-name');
                if (chordName) {
                    const rootName = this.getNoteNames()[currentRoot] || currentRoot;
                    chordName.style.color = '#4CAF50';
                    const alreadyHasRoot = /^[A-G][#b]?/.test(chordData.name || '');
                    const displayName = alreadyHasRoot ? chordData.name : `${rootName}${chordData.name}`;
                    chordName.textContent = `🔒 ${displayName}`;
                    chordName.title = `Locked to ${rootName} (oscillators & envelopes only)`;
                }
                
                console.log('?? Chord locked directly in main grid:', lockedChordData);
            }
            
            // ============= PIANO SETTINGS LOCK SYSTEM - Oscillator & Effect Settings Only =============
            
            // Store the original UI state to prevent contamination
            storeOriginalUIState() {
                if (!this.originalUIState) {
                    // Store the initial clean state when app starts
                    this.originalUIState = {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 },
                        envelope: { ...this.envelope },
                        osc2Envelope: { ...this.osc2Envelope },
                        reverb: { ...this.reverb },
                        panning: { ...this.panning },
                        volume: this.volume,
                        masterVolume: this.masterVolume
                    };
                }
                return this.originalUIState;
            }
            
            // Capture current synthesizer state for piano lock with unique preset ID
            captureCurrentSynthState() {
                // Defensive: initialize counter/map if missing
                if (typeof this.pianoLockPresetCounter !== 'number' || !isFinite(this.pianoLockPresetCounter)) {
                    this.pianoLockPresetCounter = 0;
                }
                if (!this.preloadedPresets) {
                    this.preloadedPresets = new Map();
                }
                // Generate unique preset ID
                this.pianoLockPresetCounter++;
                const presetId = `ID${String(this.pianoLockPresetCounter).padStart(3, '0')}`;
                
                const synthState = {
                    // Unique preset identifier
                    presetId: presetId,
                    
                    // Oscillator 1 settings (COMPLETE)
                    osc1: { ...this.oscillators.osc1 },
                    
                    // Oscillator 2 settings (COMPLETE)
                    osc2: { ...this.oscillators.osc2 },
                    
                    // Envelope settings (OSC 1 COMPLETE ADSR)
                    envelope: { ...this.envelope },
                    
                    // OSC 2 Envelope settings (COMPLETE ADSR)
                    osc2Envelope: { ...this.osc2Envelope },
                    
                    // Volume settings
                    volume: {
                        main: this.volume,
                        master: this.masterVolume
                    }
                };
                
                // Preload this preset for instant switching
                this.preloadedPresets.set(presetId, synthState);
                
                console.log(`🎹 Created new piano lock preset: ${presetId}`);
                console.log(`🎹 OSC1: ${synthState.osc1.type} wave, A:${Math.round(synthState.envelope.attack*1000)} D:${Math.round(synthState.envelope.decay*1000)} S:${Math.round(synthState.envelope.sustain*100)}% R:${Math.round(synthState.envelope.release*1000)}`);
                console.log(`🎹 OSC2: ${synthState.osc2.type} wave, A:${Math.round(synthState.osc2Envelope.attack*1000)} D:${Math.round(synthState.osc2Envelope.decay*1000)} S:${Math.round(synthState.osc2Envelope.sustain*100)}% R:${Math.round(synthState.osc2Envelope.release*1000)}`);
                
                return synthState;
            }
            
            // Migrate existing piano locks from old format (with root) to new format (without root)
            migratePianoLocksToNewFormat() {
                if (!this.pianoLockedChords || this.pianoLockedChords.size === 0) return;
                
                console.log('🎹 MIGRATING piano locks to new format (removing root dependency)');
                const oldEntries = Array.from(this.pianoLockedChords.entries());
                const newPianoLocks = new Map();
                const newPreloadedPresets = new Map();
                
                oldEntries.forEach(([oldKey, pianoData]) => {
                    // Check if this is an old-format key (contains root)
                    const keyParts = oldKey.split('_');
                    if (keyParts.length >= 4) {
                        // Old format: chordName_quality_root_extensions_intervals
                        const [chordName, quality, root, ...rest] = keyParts;
                        
                        // Create new key without root
                        const extensions = rest.length > 1 ? rest[0] : '';
                        const intervals = rest.length > 1 ? rest[1] : rest[0] || '';
                        const newKey = `${chordName}_${quality}_${extensions}_${intervals}`;
                        
                        console.log(`🎹 Migrating: ${oldKey} → ${newKey}`);
                        
                        // Store with new key format
                        newPianoLocks.set(newKey, pianoData);
                        
                        // Also migrate preloaded preset
                        if (pianoData.presetId && this.preloadedPresets.has(pianoData.presetId)) {
                            newPreloadedPresets.set(pianoData.presetId, this.preloadedPresets.get(pianoData.presetId));
                        }
                    } else {
                        // Already new format, keep as-is
                        newPianoLocks.set(oldKey, pianoData);
                        if (pianoData.presetId && this.preloadedPresets.has(pianoData.presetId)) {
                            newPreloadedPresets.set(pianoData.presetId, this.preloadedPresets.get(pianoData.presetId));
                        }
                    }
                });
                
                // Replace old maps with migrated data
                this.pianoLockedChords = newPianoLocks;
                this.preloadedPresets = newPreloadedPresets;
                
                console.log('🎹 Migration complete. Piano locks now work across all root notes!');
            }
            
            // Generate a stable key for piano lock identification that is independent of display names/quality
            generatePianoLockKey(chordData) {
                // Prefer the chord's SHAPE (sorted intervals) so the key is stable across renames, roots, and qualities
                let iv = Array.isArray(chordData?.intervals) ? [...chordData.intervals] : [];
                if ((!iv || iv.length === 0) && typeof this.getChordIntervals === 'function') {
                    // Derive from extensions if explicit intervals were not provided
                    iv = this.getChordIntervals(chordData?.extensions || []);
                }
                if (!Array.isArray(iv)) iv = [];
                // Normalize numeric and sort
                const ivNums = iv.map(n => {
                    const v = Number(n);
                    return Number.isFinite(v) ? v : 0;
                }).sort((a,b)=> a-b);
                const intervalsSig = ivNums.join('.');

                // Include whether it's custom to reduce accidental collisions across radically different modes
                const customTag = chordData?.isCustom ? 'custom' : 'builtIn';
                const key = `shape:${intervalsSig}|${customTag}`;

                // Debug
                console.log('🔑 generatePianoLockKey:', {intervalsSig, customTag, key, chordData});
                return key;
            }
            
            // Find piano lock data by stable key
            findPianoLockData(chordData) {
                if (!this.pianoLockedChords) return null;
                const key = this.generatePianoLockKey(chordData);
                const direct = this.pianoLockedChords.get(key);
                if (direct) return direct;

                // Fallback 1: match by intervals signature against existing entries (backward compatibility)
                let iv = Array.isArray(chordData?.intervals) ? [...chordData.intervals] : [];
                if ((!iv || iv.length === 0) && typeof this.getChordIntervals === 'function') {
                    iv = this.getChordIntervals(chordData?.extensions || []);
                }
                const sig = (Array.isArray(iv) ? iv.map(n=> Number(n)||0).sort((a,b)=>a-b).join('.') : '');
                if (sig) {
                    for (const [k, data] of this.pianoLockedChords.entries()) {
                        if (data && data.intervalsSig === sig) return data;
                        // Old-style key may end with "_intervals"; compare last token if present
                        const lastUnderscore = k.lastIndexOf('_');
                        if (lastUnderscore > -1) {
                            const tail = k.slice(lastUnderscore+1);
                            if (tail.replace(/,/g,'.') === sig.replace(/\./g,'.')) return data;
                        }
                    }
                }
                return null;
            }
            
            lockPianoSettings(chordData, columnElement) {
                console.log('🎹 lockPianoSettings function called with:', chordData, columnElement);
                
                // Check if this chord already has piano-locked settings using stable key
                if (!this.pianoLockedChords) this.pianoLockedChords = new Map();
                
                const lockKey = this.generatePianoLockKey(chordData);
                const isAlreadyPianoLocked = this.pianoLockedChords.has(lockKey);
                
                if (isAlreadyPianoLocked) {
                    console.log('🎹 Unlocking piano settings (backend) for:', chordData.name, 'key:', lockKey);
                    this.pianoLockedChords.delete(lockKey);
                    chordData.isPianoLocked = false;
                    chordData.pianoLockedData = null;
                    return;
                }
                
                // If a different column with the same shape is already locked, transfer ownership to this column
                const existingData = this.pianoLockedChords.get(lockKey);
                if (existingData) {
                    // Find currently locked column for this key
                    let currentOwnerCol = null;
                    try {
                        // Find an owner column by matching stored pianoLockKey on chord data
                        document.querySelectorAll('.extension-column').forEach(col => {
                            if (currentOwnerCol) return;
                            const headerEl = col.querySelector('.extension-header');
                            const cd = this.getChordDataFromColumn(col, headerEl);
                            if (!cd) return;
                            const k = this.generatePianoLockKey(cd);
                            if (k === lockKey && cd.isPianoLocked) {
                                currentOwnerCol = col;
                            }
                        });
                    } catch (_) {}
                    // If the same column, treat as unlock (handled above). If different, switch UI ownership.
                    if (currentOwnerCol && currentOwnerCol !== columnElement) {
                        // Unlock previous owner's UI and model flags
                        try {
                            const prevHeader = currentOwnerCol.querySelector('.extension-header');
                            const prevData = this.getChordDataFromColumn(currentOwnerCol, prevHeader);
                            if (prevData) { prevData.isPianoLocked = false; prevData.pianoLockedData = null; }
                        } catch (_) {}
                        // Transfer ownership (backend) and warm this column for instant play
                        chordData.isPianoLocked = true;
                        chordData.pianoLockedData = existingData;
                        chordData.pianoLockKey = lockKey;
                        // Warm this chord for instant play
                        try { this.preloadPianoLockedChord(columnElement); } catch (_) {}
                        console.log('🎹 Transferred piano-lock ownership to clicked column for key:', lockKey);
                        return;
                    }
                }

                // LOCK the piano settings (no existing owner)
                console.log('🎹 Locking piano settings for:', chordData.name, 'key:', lockKey);
                const currentSynthState = this.captureCurrentSynthState();
                const pianoLockedData = {
                    chordName: chordData.name,
                    lockKey: lockKey,
                    intervalsSig: (Array.isArray(chordData?.intervals) && chordData.intervals.length)
                        ? chordData.intervals.map(n=> Number(n)||0).sort((a,b)=>a-b).join('.')
                        : (typeof this.getChordIntervals === 'function' ? (this.getChordIntervals(chordData.extensions||[]).map(n=> Number(n)||0).sort((a,b)=>a-b).join('.')) : ''),
                    ...currentSynthState,
                    timestamp: Date.now()
                };
                this.pianoLockedChords.set(lockKey, pianoLockedData);
                chordData.isPianoLocked = true;
                chordData.pianoLockedData = pianoLockedData;
                chordData.pianoLockKey = lockKey;
                try { this.preloadPianoLockedChord(columnElement); } catch(_) {}
            }
            
            // Apply piano-locked settings when playing a chord (NEVER modifies base synthesizer state)
            applyPianoLockedSettings(pianoLockedData) {
                if (!pianoLockedData) return;
                
                const presetId = pianoLockedData.presetId;
                console.log(`🎹 Applying piano-locked preset: ${presetId} (${pianoLockedData.chordName})`);
                
                // Use preloaded preset if available for instant switching
                let settingsToApply = pianoLockedData;
                if (this.preloadedPresets.has(presetId)) {
                    settingsToApply = this.preloadedPresets.get(presetId);
                    console.log(`🎹 Using preloaded preset for instant switching: ${presetId}`);
                } else {
                    console.log(`🎹 Preset not preloaded, using stored data: ${presetId}`);
                }
                
                console.log(`🎹 OSC1: ${settingsToApply.osc1.type} wave, A:${Math.round(settingsToApply.envelope.attack*1000)} D:${Math.round(settingsToApply.envelope.decay*1000)} S:${Math.round(settingsToApply.envelope.sustain*100)}% R:${Math.round(settingsToApply.envelope.release*1000)}`);
                console.log(`🎹 OSC2: ${settingsToApply.osc2.type} wave, A:${Math.round(settingsToApply.osc2Envelope.attack*1000)} D:${Math.round(settingsToApply.osc2Envelope.decay*1000)} S:${Math.round(settingsToApply.osc2Envelope.sustain*100)}% R:${Math.round(settingsToApply.osc2Envelope.release*1000)}`);
                
                // IMPORTANT: We directly modify the synthesizer objects only temporarily
                // These will be immediately restored after playFrequency starts
                
                // Apply oscillator settings (complete objects)
                if (settingsToApply.osc1) {
                    Object.assign(this.oscillators.osc1, settingsToApply.osc1);
                }
                if (settingsToApply.osc2) {
                    Object.assign(this.oscillators.osc2, settingsToApply.osc2);
                }
                
                // Apply envelope settings (complete objects)
                if (settingsToApply.envelope) {
                    Object.assign(this.envelope, settingsToApply.envelope);
                    // Sync ADSR 1 UI
                    const a = document.getElementById('attackSlider');
                    const d = document.getElementById('decaySlider');
                    const s = document.getElementById('sustainSlider');
                    const r = document.getElementById('releaseSlider');
                    const av = document.getElementById('attackValue');
                    const dv = document.getElementById('decayValue');
                    const sv = document.getElementById('sustainValue');
                    const rv = document.getElementById('releaseValue');
                    if (a) { const ms = Math.round((this.envelope.attack||0)*1000); a.value = String(ms); if (av) av.textContent = `${ms}ms`; }
                    if (d) { const ms = Math.round((this.envelope.decay||0)*1000); d.value = String(ms); if (dv) dv.textContent = `${ms}ms`; }
                    if (s) { const pct = Math.round((this.envelope.sustain||0)*100); s.value = String(pct); if (sv) sv.textContent = `${pct}%`; }
                    if (r) { const ms = Math.round((this.envelope.release||0)*1000); r.value = String(ms); if (rv) rv.textContent = `${ms}ms`; }
                }
                if (settingsToApply.osc2Envelope) {
                    Object.assign(this.osc2Envelope, settingsToApply.osc2Envelope);
                    // Sync ADSR 2 UI
                    const a2 = document.getElementById('osc2AttackSlider');
                    const d2 = document.getElementById('osc2DecaySlider');
                    const s2 = document.getElementById('osc2SustainSlider');
                    const r2 = document.getElementById('osc2ReleaseSlider');
                    const a2v = document.getElementById('osc2AttackValue');
                    const d2v = document.getElementById('osc2DecayValue');
                    const s2v = document.getElementById('osc2SustainValue');
                    const r2v = document.getElementById('osc2ReleaseValue');
                    if (a2) { const ms = Math.round((this.osc2Envelope.attack||0)*1000); a2.value = String(ms); if (a2v) a2v.textContent = `${ms}ms`; }
                    if (d2) { const ms = Math.round((this.osc2Envelope.decay||0)*1000); d2.value = String(ms); if (d2v) d2v.textContent = `${ms}ms`; }
                    if (s2) { const pct = Math.round((this.osc2Envelope.sustain||0)*100); s2.value = String(pct); if (s2v) s2v.textContent = `${pct}%`; }
                    if (r2) { const ms = Math.round((this.osc2Envelope.release||0)*1000); r2.value = String(ms); if (r2v) r2v.textContent = `${ms}ms`; }
                }
                
                // NOTE: Do NOT apply reverb or panning from piano-lock. Those are global per-user mix choices.
                
                // Apply volume settings
                if (settingsToApply.volume) {
                    this.volume = settingsToApply.volume.main;
                    this.masterVolume = settingsToApply.volume.master;
                    if (this.gainNode) {
                        this.gainNode.gain.value = this.volume * this.masterVolume;
                    }
                }

                // If OSC panel is open, reflect the currently applied settings for clarity
                const oscPanel = document.querySelector('.panel-content[data-panel="osc"]');
                if (oscPanel && window.getComputedStyle(oscPanel).display !== 'none') {
                    const syncOscUi = (num, data) => {
                        try {
                            // Activate waveform button
                            document.querySelectorAll(`.osc-btn[data-osc="${num}"]`).forEach(b => b.classList.remove('active'));
                            const active = document.querySelector(`.osc-btn[data-osc="${num}"][data-wave="${data.type}"]`);
                            if (active) active.classList.add('active');
                            // Pulse width visibility/value
                            const pwContainer = document.querySelector(`.pulse-width-container[data-osc="${num}"]`);
                            if (pwContainer) pwContainer.style.display = (data.type === 'pulse') ? 'block' : 'none';
                            const pwSlider = document.getElementById(`osc${num}PulseWidth`);
                            const pwValue = document.getElementById(`osc${num}PulseWidthValue`);
                            if (pwSlider && typeof data.pulseWidth === 'number') {
                                const pct = Math.round((data.pulseWidth || 0.5) * 100);
                                pwSlider.value = String(pct);
                                if (pwValue) pwValue.textContent = `${pct}%`;
                            }
                            // Level
                            const lvl = document.getElementById(`osc${num}Level`);
                            const lvlV = document.getElementById(`osc${num}LevelValue`);
                            if (lvl) {
                                const slider = Math.round(((data.level || 0) / 0.125) * 10);
                                lvl.value = String(slider);
                                if (lvlV) lvlV.textContent = String(slider);
                            }
                            const det = document.getElementById(`osc${num}Detune`);
                            const detV = document.getElementById(`osc${num}DetuneValue`);
                            if (det) {
                                det.value = String(Math.round(data.detune || 0));
                                if (detV) detV.textContent = `${Math.round(data.detune || 0)}¢`;
                            }
                            // Octave/coarse
                            const oct = document.getElementById(`osc${num}Octave`);
                            const octV = document.getElementById(`osc${num}OctaveValue`);
                            if (oct) { oct.value = String(data.octave || 0); if (octV) octV.textContent = String(data.octave || 0); }
                            const crs = document.getElementById(`osc${num}Coarse`);
                            const crsV = document.getElementById(`osc${num}CoarseValue`);
                            if (crs) { crs.value = String(data.coarse || 0); if (crsV) crsV.textContent = `${data.coarse || 0} steps`; }
                        } catch(_) {}
                    };
                    syncOscUi(1, this.oscillators.osc1);
                    syncOscUi(2, this.oscillators.osc2);
                }
                
                console.log(`🎹 Applied piano-locked preset: ${presetId} for ${pianoLockedData.chordName}`);
            }
            
            // Helper to capture exact frequencies from a column's strings when locking
            captureStringFrequencies(columnElement) {
                console.log('?? Capturing exact string frequencies for locked chord');
                const stringElements = columnElement.querySelectorAll('.string');
                const frequencies = [];
                
                stringElements.forEach(stringElement => {
                    // Get exact frequency from the element dataset
                    // This will be the actual frequency value used in playback
                    const freq = parseFloat(stringElement.dataset.frequency);
                    if (!isNaN(freq)) {
                        frequencies.push(freq);
                        console.log(`?? Captured frequency: ${freq.toFixed(2)} Hz`);
                    }
                });
                
                console.log(`?? Total frequencies captured: ${frequencies.length}`);
                return frequencies.length > 0 ? frequencies : null;
            }
            
            // Create strings using exact captured frequencies - guaranteed perfect reproduction
            generateStringsWithExactFrequencies(column, lockedData) {
                console.log('?? Generating strings with EXACT frequencies for perfect reproduction');
                
                // Clear any existing strings
                const stringsContainer = document.createElement('div');
                stringsContainer.className = 'strings-column';
                // Apply subtle root tint gradient matching locked root
                try {
                    const semi = this.stepToSemitone(lockedData.lockedRoot || 0, lockedData.lockedTuning || (this.currentTuning||12));
                    const accent = this.getChromaticColorForSemitone(semi) || '#000000';
                    const tint = (hex => {
                        const m = /^#?([0-9a-f]{6})$/i.exec(hex || '');
                        if (!m) return 'rgba(0,0,0,0)';
                        const n = parseInt(m[1], 16);
                        let r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                        r = Math.max(6, Math.floor(r * 0.08));
                        g = Math.max(6, Math.floor(g * 0.08));
                        b = Math.max(6, Math.floor(b * 0.08));
                        return `linear-gradient(to bottom, rgba(${r},${g},${b},0.12), rgba(${r},${g},${b},0.08))`;
                    })(accent);
                    stringsContainer.style.setProperty('--root-tint-gradient', tint);
                    const headerEl = column.querySelector('.extension-header');
                    if (headerEl) headerEl.style.setProperty('--root-tint-gradient', tint);
                } catch (_) {}
                
                // Style the container like main columns
                // Use real header height to size strings correctly in two-row mode
                const headerEl = column.querySelector('.extension-header');
                const headerPx = Math.max(56, headerEl ? headerEl.offsetHeight : 56);
                stringsContainer.style.cssText = `
                    flex: 1;
                    overflow: hidden;
                    padding: 1px;
                    height: calc(100% - ${headerPx}px);
                    display: flex;
                    flex-direction: column;
                    justify-content: space-evenly;
                `;
                
                // Remove old strings container if exists
                const oldContainer = column.querySelector('.strings-column');
                if (oldContainer) {
                    column.removeChild(oldContainer);
                }
                
                // Create strings using exact frequencies
                lockedData.exactFrequencies.forEach((freq, index) => {
                    const stringElement = document.createElement('div');
                    stringElement.className = 'string';

                    // Store exact frequency for playback - CRITICAL
                    stringElement.dataset.frequency = freq;

                    // Estimate note and octave for display and color calculation
                    const noteInfo = this.estimateNoteFromFrequency(freq);
                    stringElement.dataset.note = noteInfo.note;
                    stringElement.dataset.octave = noteInfo.octave;
                    // Highlight mid octaves (3–4)
                    try {
                        const oct = parseInt(stringElement.dataset.octave, 10);
                        if (oct === 3 || oct === 4) stringElement.classList.add('mid-octave');
                    } catch(_) {}

                    // Universal pitch color by absolute step
                    const uni = this.getUniversalPitchColorForStep(noteInfo.note, lockedData.lockedTuning);
                    const baseColor = uni.color;
                    const glowColor = (baseColor && baseColor.toLowerCase() === '#000000') ? '#555555' : baseColor;
                    stringElement.dataset.glowColor = glowColor;

                    // Visible core
                    const core = document.createElement('div');
                    core.className = 'string-core';
                    core.style.background = baseColor;
                    core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;

                    // Tooltip with exact frequency
                    const noteDisplay = this.getNoteNames()[noteInfo.note] || noteInfo.note;
                    stringElement.title = `${noteDisplay}${noteInfo.octave} - LOCKED: ${freq.toFixed(2)}Hz`;

                    // Precompute vibration period
                    const period = this.computeVibrationPeriod(freq, noteInfo.note);
                    core.style.setProperty('--vib-period', period + 'ms');

                    // Click handlers for playback
                    this.addStringPlaybackHandlers(stringElement, freq);

                    // Attach
                    stringElement.appendChild(core);
                    stringsContainer.appendChild(stringElement);
                });
                
                column.appendChild(stringsContainer);
                
                // Add locked icon and visual indication this is using exact frequencies
                const header = column.querySelector('.extension-header');
                if (header) {
                    const chordName = header.querySelector('.chord-name');
                    if (chordName) {
                        chordName.style.color = '#ff9500'; // Bright orange to indicate exact frequency preservation
                        chordName.title = `LOCKED: Using exact frequencies (${lockedData.exactFrequencies.length}) for perfect reproduction`;
                    }
                }
                
                console.log(`?? Generated ${lockedData.exactFrequencies.length} strings with exact frequencies`);
            }
            
            // Helper to add click handlers to strings
            addStringPlaybackHandlers(stringElement, frequency) {
                // Add click handlers for immediate playback
                stringElement.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.playStringNote(frequency, 0); // Use exact frequency

                    // Visual feedback on core
                    const glow = stringElement.dataset.glowColor || '#FFFFFF';
                    const core = stringElement.querySelector('.string-core');
                    if (core) {
                        core.style.transform = 'scaleY(1.3)';
                        core.style.boxShadow = `0 0 6px ${glow}, 0 0 16px ${glow}B3, 0 0 24px ${glow}80`;
                        core.style.filter = 'brightness(1.15)';
                        const stepIndex = parseInt(stringElement.dataset.noteIndex||'0',10);
                        const period = this.computeVibrationPeriod(frequency, stepIndex);
                        core.style.setProperty('--vib-period', period + 'ms');
                        core.classList.add('vibrating');
                        setTimeout(() => core.classList.remove('vibrating'), 220);
                        setTimeout(() => {
                            core.style.transform = 'scaleY(1)';
                            core.style.boxShadow = `0 0 4px ${glow}, 0 0 10px ${glow}AA, 0 0 18px ${glow}66`;
                            core.style.filter = 'brightness(1)';
                        }, 200);
                    }
                });
                
                // Touch support
                stringElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.playStringNote(frequency, 0); // Use exact frequency
                });
            }
            
            // ============= PROPER CHORD NAMING SYSTEM =============
            
            // Template library for exact chord recognition, including micro (^/v) variants.
            // Each template defines a name suffix (to append after the root) and an interval list
            // expressed in 12-TET semitones with optional '^'/'v' to indicate +1/-1 EDO step.
            // Example: { name: '7^', intervals: ['0','4^','7','10'] }
            getChordTemplates() {
                // Helper to DRY strings
                const T = [];
                const add = (name, iv) => T.push({ name, intervals: iv });
                // Power/dyads/triads
                add('5', ['0','7']);
                add('b5', ['0','6']);
                add('+', ['0','4','8']);
                add('aug', ['0','4','8']);
                add('dim', ['0','3','6']);
                add('', ['0','4','7']); // major triad
                add('m', ['0','3','7']);
                add('sus2', ['0','2','7']);
                add('sus4', ['0','5','7']);
                // 6ths/7ths/maj7/etc
                add('6', ['0','4','7','9']);
                add('m6', ['0','3','7','9']);
                add('7', ['0','4','7','10']);
                add('m7', ['0','3','7','10']);
                add('maj7', ['0','4','7','11']);
                add('mMaj7', ['0','3','7','11']);
                add('dim7', ['0','3','6','9']);
                add('m7b5', ['0','3','6','10']);
                add('aug7', ['0','4','8','10']);
                // 9ths
                add('9', ['0','4','7','10','14']);
                add('m9', ['0','3','7','10','14']);
                add('maj9', ['0','4','7','11','14']);
                add('mMaj9', ['0','3','7','11','14']);
                add('6/9', ['0','4','7','9','14']);
                add('m6/9', ['0','3','7','9','14']);
                // sus with 7/9
                add('7sus4', ['0','5','7','10']);
                add('9sus4', ['0','5','7','10','14']);
                // altered dominants
                add('7b9', ['0','4','7','10','13']);
                add('7#9', ['0','4','7','10','15']);
                add('7b5', ['0','4','6','10']);
                add('7#5', ['0','4','8','10']);
                add('7alt', ['0','4','8','10','13','15']); // (#5, b9, #9)
                // 11ths / 13ths
                add('11', ['0','4','7','10','14','17']);
                add('m11', ['0','3','7','10','14','17']);
                add('maj11', ['0','4','7','11','14','17']);
                add('mMaj11', ['0','3','7','11','14','17']);
                add('11sus', ['0','5','7','10','14','17']);
                add('13', ['0','4','7','10','14','17','21']);
                add('m13', ['0','3','7','10','14','17','21']);
                add('maj13', ['0','4','7','11','14','17','21']);
                add('mMaj13', ['0','3','7','11','14','17','21']);
                // Micro-root triads (name becomes just root with micro, so empty suffix still OK)
                // We keep them implicit via root note name, no extra template needed.
                // Micro variants (caret up / v down) for common degrees
                add('7^', ['0','4^','7','10']);
                add('7v', ['0','3v','7','10']);
                add('9^', ['0','4','7','10','14^']);
                add('9v', ['0','4','7','10','14v']);
                add('maj9^', ['0','4^','7','11','14']);
                add('mMaj9v', ['0','3','7','11v','14']);
                add('6^', ['0','4^','7','9']);
                add('m6v', ['0','3','7','9v']);
                add('^sus2', ['0','2','7']); // root micro handled by root name; keep suffix distinct
                add('vsus4', ['0','5','7']);
                add('7#11^', ['0','4','7','10','18^']);
                add('7b13v', ['0','4','7','10','20v']);
                add('maj7#11^', ['0','4','7','11','18^']);
                add('m7b5v', ['0','3','6','10']); // symbol carries 'v' to indicate template request
                add('aug7^', ['0','4','8','10']);
                add('dim7v', ['0','3','6','9v']);
                // Add-chords
                add('add9', ['0','4','7','14']);
                add('madd9', ['0','3','7','14']);
                add('add4', ['0','4','7','5']);
                add('madd4', ['0','3','7','5']);
                return T;
            }

            // Convert a 12-TET semitone count (as string; may include '^'/'v') to an EDO step for matching
            _templateSemitoneToStep(semiStr, edo){
                const m = String(semiStr);
                const up = m.endsWith('^');
                const down = m.endsWith('v');
                const core = up || down ? m.slice(0, -1) : m;
                const semi = parseFloat(core) || 0;
                let step = Math.round((semi * edo) / 12);
                if (up) step += 1; else if (down) step -= 1;
                return ((step % edo) + edo) % edo;
            }

            // Attempt to recognize chord by template; returns best match with steps and type
            // { name, steps, matchType: 'exact' | 'subset' } or null
            tryMatchChordTemplate(relativeSteps, edo){
                const uniq = [...new Set(relativeSteps)].map(v=> ((v%edo)+edo)%edo).sort((a,b)=>a-b);
                const containsAll = (a,b)=> b.every(x=> a.includes(x));
                const eqSet = (a,b)=> a.length===b.length && a.every((v,i)=> v===b[i]);
                const templates = this.getChordTemplates();
                let bestSubset = null;
                for (const t of templates) {
                    const steps = t.intervals
                        .map(s=> this._templateSemitoneToStep(s, edo))
                        .map(v=> ((v%edo)+edo)%edo);
                    const uniqT = [...new Set(steps)].sort((a,b)=>a-b);
                    if (eqSet(uniq, uniqT)) return { name: t.name, steps: uniqT, matchType: 'exact' };
                    if (containsAll(uniq, uniqT)) {
                        if (!bestSubset || uniqT.length > bestSubset.steps.length) {
                            bestSubset = { name: t.name, steps: uniqT, matchType: 'subset' };
                        }
                    }
                }
                return bestSubset;
            }
            
            getProperChordSymbol(intervals) {
                if (!intervals || intervals.length === 0) return '';
                
                // Sort intervals and remove duplicates (EDO steps, relative to chosen root)
                const uniqueIntervals = [...new Set(intervals)].sort((a, b) => a - b);
                const numNotes = uniqueIntervals.length;
                const edo = this.currentTuning || 12;
                
                // Helper: map semitone target to EDO step and compute accidentals for deltas
                const stepForSemi = (semi)=> ((Math.round((semi*edo)/12))%edo+edo)%edo;
                const accidentalForDiff = (d)=> d===0?'':(d===1?'^':(d===-1?'v':(d===2?'#':(d===-2?'b':''))));
                const near = (x,y,tol=0.35)=> Math.abs(x-y) <= tol;
                const sFloat = (st)=> (st*12)/edo;
                // Allow calling hasNear(target[, tol]) by defaulting to uniqueIntervals when set not passed
                const hasNear = (maybeSet, target, tol=0.35)=> {
                    const arr = Array.isArray(maybeSet) ? maybeSet : uniqueIntervals;
                    const tgt = Array.isArray(maybeSet) ? target : maybeSet;
                    const tolVal = Array.isArray(maybeSet) ? tol : (typeof target === 'number' ? target : 0.35);
                    // If called as hasNear(target[, tol]) then tol comes in as second/third arg; normalize
                    const finalTol = Array.isArray(maybeSet)
                        ? tolVal
                        : (arguments.length >= 2 ? target : 0.35);
                    const finalTarget = Array.isArray(maybeSet) ? target : maybeSet;
                    return arr.some(i => near(sFloat(i), finalTarget, finalTol));
                };
                const removeSteps = (src,rm)=> src.filter(x=> !rm.includes(x));
                const uniqSteps = (arr)=> [...new Set(arr)].sort((a,b)=>a-b);

                // First: try template (exact or best subset)
                let baseName = '';
                let baseSteps = [];
                try {
                    const m = this.tryMatchChordTemplate(uniqueIntervals, edo);
                    if (m && m.matchType === 'exact') return m.name; // perfect match
                    if (m) { baseName = m.name; baseSteps = m.steps.slice(); }
                } catch(_) {}
                
                // Map to 12-TET pitch classes relative to the chosen root
                const pcs12 = [...new Set(uniqueIntervals.map(i => this.stepToSemitone(i, edo)))].sort((a,b)=>a-b);
                const has = (x)=> pcs12.includes(x);
                // Compare ignoring order by sorting the candidate array
                const setEq = (arr)=>{
                    const a = [...arr].sort((x,y)=> x-y);
                    return a.length===pcs12.length && a.every((v,i)=> v===pcs12[i]);
                };

                // Float semitone approximations for neutral detection
                const relSemi = uniqueIntervals.map(i => (i * 12) / edo);

                // 🎵 UNISON (single note) - only root note
                if (numNotes === 1 && uniqueIntervals[0] === 0) {
                    return 'Unison';
                }
                
                // 🎵 DYADS (2-note intervals) - adjusted for current tuning
                if (numNotes === 2 && uniqueIntervals[0] === 0) {
                    const interval12TET = pcs12[1] ?? 0;
                    
                    const intervalNames = {
                        1: 'Minor 2nd',
                        2: 'Major 2nd', 
                        3: 'Minor 3rd',
                        4: 'Major 3rd',
                        5: 'Perfect 4th',
                        6: 'Tritone',
                        7: 'Perfect 5th',
                        8: 'Minor 6th',
                        9: 'Major 6th',
                        10: 'Minor 7th',
                        11: 'Major 7th'
                    };
                    
                    return intervalNames[interval12TET] || `${interval12TET} semitones`;
                }
                
                // 🎵 TRIADS (3-note chords) - inversion-invariant
                if (pcs12.length === 3) {
                    // Neutral triad: ~3.5 and ~7 present
                    if (hasNear(0.0) && hasNear(3.5) && hasNear(7.0)) return 'n';
                    if (setEq([0,4,7])) return '';
                    if (setEq([0,3,7])) return 'm';
                    if (setEq([0,3,6])) return '°';
                    if (setEq([0,4,8])) return '+';
                    if (setEq([0,2,7])) return 'sus2';
                    if (setEq([0,5,7])) return 'sus4';
                }

                // 🎵 TETRADS (4-note chords) - favor simplest (triad + one extension)
                if (pcs12.length === 4) {
                    // Neutral 7 detection (~10.5)
                    if (hasNear(uniqueIntervals,0.0) && hasNear(uniqueIntervals,7.0) && hasNear(uniqueIntervals,10.5)) {
                        if (hasNear(3.0) || hasNear(3.5)) return 'm7v';
                        if (hasNear(4.0)) return '7v';
                    }
                    // Strict sets relative to chosen root (no inversion search)
                    if (setEq([0,4,7,9]))  return (hasNear(uniqueIntervals,10.0,0.5)? '7':'6');
                    if (setEq([0,3,7,9]))  return (hasNear(uniqueIntervals,10.0,0.5)? 'm7':'m6');
                    if (setEq([0,4,7,10])) return '7';
                    if (setEq([0,3,7,10])) return 'm7';
                    if (setEq([0,4,7,11])) return 'maj7';
                    if (setEq([0,3,7,11])) return 'mMaj7';
                    if (setEq([0,5,7,10])) return '7sus4';
                    if (setEq([0,3,6,10])) return 'ø7';
                    if (setEq([0,3,6,9]))  return '°7';
                    // Add chords (no 7 or 6)
                    if (setEq([0,2,4,7]))  return 'add9';
                    if (setEq([0,3,7,2]))  return 'madd9';
                    if (setEq([0,4,5,7]))  return 'add4';
                    if (setEq([0,3,5,7]))  return 'madd4';
                }
                
                // 🎵 5-NOTE CHORDS - keep minimal; prefer single extension naming
                if (numNotes === 5) {
                    const eq = (...arr)=> setEq(arr);
                    if (eq(0,3,7,10,2)) return 'm9';
                    if (eq(0,4,7,10,2)) return '9';
                    if (eq(0,3,7,5,2))  return 'm11';
                    if (eq(0,4,7,5,2))  return '11';
                    if (eq(0,3,7,2))    return 'madd9';
                    if (eq(0,4,7,2))    return 'add9';
                }
                
                // 🎵 6-NOTE CHORDS - cap at 11/13 families, still minimal
                if (numNotes === 6) {
                    const eq = (...a)=> setEq(a);
                    if (eq(0,3,7,10,2,5)) return 'm11';
                    if (eq(0,4,7,10,2,5)) return '11';
                    if (eq(0,3,7,10,2,9)) return 'm13';
                    if (eq(0,4,7,10,2,9)) return '13';
                }
                
                // Build a base symbol via minimal core if no template subset chosen
                if (!baseName) {
                    const core = this.findCoreChord(uniqueIntervals);
                    baseName = core.symbol;
                    baseSteps = core.intervals.map(semi=> stepForSemi(semi));
                }

                // Append add-extensions for any remaining tones not covered by base
                const extraSteps = removeSteps(uniqueIntervals, uniqSteps(baseSteps));
                if (!extraSteps.length) return baseName;

                // Context flags
                const hasMaj3 = hasNear(uniqueIntervals,4.0);
                const hasMin3 = hasNear(uniqueIntervals,3.0);
                const hasB7 = hasNear(uniqueIntervals,10.0);
                const hasMaj7 = hasNear(uniqueIntervals,11.0);

                const addParts = [];
                for (const st of extraSteps) {
                    const sf = sFloat(st);
                    // Special case: major triad plus ~3.0 -> #9
                    if (hasMaj3 && near(sf,3.0,0.5)) {
                        const base = stepForSemi(15);
                        let d = st - base; if (d>edo/2) d-=edo; if (d<-edo/2) d+=edo; d = Math.max(-2, Math.min(2, d));
                        const acc = accidentalForDiff(d);
                        addParts.push(`add${acc}#9`); // keep #9 label, include micro if any
                        continue;
                    }
                    // Map to 9 family
                    const base9 = stepForSemi(14);
                    const d9 = (()=>{ let d=st-base9; if(d>edo/2)d-=edo; if(d<-edo/2)d+=edo; return d; })();
                    if (Math.abs(d9) <= 2 && near(sf,2.0,1.0)) {
                        const acc = accidentalForDiff(Math.max(-2, Math.min(2, d9)));
                        const qual = acc==='#'?'#':(acc==='b'?'b':acc); // '^'/'v' retained
                        addParts.push(`add${acc?acc:''}9`);
                        continue;
                    }
                    // Map to 4 family (use 4 naming, not 11)
                    const base4 = stepForSemi(5);
                    const d4 = (()=>{ let d=st-base4; if(d>edo/2)d-=edo; if(d<-edo/2)d+=edo; return d; })();
                    if (Math.abs(d4) <= 2 && near(sf,5.0,1.0)) {
                        const acc = accidentalForDiff(Math.max(-2, Math.min(2, d4)));
                        addParts.push(`add${acc?acc:''}4`);
                        continue;
                    }
                    // Map to 13/6 family
                    const base13 = stepForSemi(21);
                    const d13 = (()=>{ let d=st-base13; if(d>edo/2)d-=edo; if(d<-edo/2)d+=edo; return d; })();
                    if (Math.abs(d13) <= 2 && near(sf,9.0,1.0)) {
                        const acc = accidentalForDiff(Math.max(-2, Math.min(2, d13)));
                        const deg = (hasB7||hasMaj7)? '13':'6';
                        addParts.push(`add${acc?acc:''}${deg}`);
                        continue;
                    }
                    // b9
                    if (near(sf,1.0,0.6)) { addParts.push('addb9'); continue; }
                    // #11 as fallback for tritone-ish
                    if (near(sf,6.0,0.6)) { addParts.push('add#4'); continue; }

                    // Generic fallback: produce add with degree and micro (^/v) when applicable
                    const s12 = ((Math.round((sf)) % 12) + 12) % 12; // nearest semitone
                    const baseForS = stepForSemi(s12);
                    let diff = st - baseForS; if (diff>edo/2) diff-=edo; if (diff<-edo/2) diff+=edo;
                    const micro = diff>0 ? '^' : (diff<0 ? 'v' : '');
                    // Degree label map by semitone
                    const degMap = ['1','b2','2','b3','3','4','#4','5','#5','6','b7','7'];
                    const degree = degMap[s12] || String(s12);
                    addParts.push(`add${micro}${degree}`);
                }
                return baseName + (addParts.length? addParts.join('') : '');
            }
            
            findNearestChordFit(intervals) {
                // Minimal nearest: triad + the single simplest added degree (9 or 11). Avoid piling on.
                const core = this.findCoreChord(intervals);
                const coreSet = new Set(core.intervals);
                // candidates in minimal order
        const order = [2,5,9,10,11]; // 9, 11, 13(=6/13 approx), b7, M7
                for (const iv of order) {
                    if (intervals.includes(iv) && !coreSet.has(iv)) {
            if (core.symbol === 'm' && iv === 5) return 'madd11';
            if (core.symbol === '' && iv === 5) return 'add11';
                        if (iv === 2) return (core.symbol === 'm') ? 'madd9' : 'add9';
                        if (iv === 10) return (core.symbol === 'm') ? 'm7' : '7';
                        if (iv === 11) return (core.symbol === 'm') ? 'mΔ7' : 'Δ7';
                    }
                }
                return core.symbol;
            }
            
            findCoreChord(intervals) {
                // Find the best matching triad or tetrad
                const intervalSet = new Set(intervals);
                
                // Check tetrads first (more specific)
                const tetrads = [
                    { intervals: [0, 3, 7, 5], symbol: 'madd11' },
                    { intervals: [0, 4, 7, 5], symbol: 'add11' },
                    { intervals: [0, 3, 7, 2], symbol: 'madd9' },
                    { intervals: [0, 4, 7, 2], symbol: 'add9' },
                    { intervals: [0, 3, 7, 10], symbol: 'm7' },
                    { intervals: [0, 4, 7, 10], symbol: '7' },
                    { intervals: [0, 4, 7, 9], symbol: '6' },
                    { intervals: [0, 3, 7, 9], symbol: 'm6' },
                    { intervals: [0, 3, 6, 10], symbol: 'ø7' },
                    { intervals: [0, 3, 6, 9], symbol: '°7' }
                ];
                
                for (const tetrad of tetrads) {
                    if (tetrad.intervals.every(interval => intervalSet.has(interval))) {
                        return tetrad;
                    }
                }
                
                // Check triads
                const triads = [
                    { intervals: [0, 4, 7], symbol: '' }, // Major = simplest, no suffix
                    { intervals: [0, 3, 7], symbol: 'm' },
                    { intervals: [0, 3, 6], symbol: '°' },
                    { intervals: [0, 4, 8], symbol: '+' },
                    { intervals: [0, 2, 7], symbol: 'sus2' },
                    { intervals: [0, 5, 7], symbol: 'sus4' }
                ];
                
                for (const triad of triads) {
                    if (triad.intervals.every(interval => intervalSet.has(interval))) {
                        return triad;
                    }
                }
                
                // Default to neutral minimal
                return { intervals: [0], symbol: '' };
            }
            
            findExtensions(intervals, coreIntervals) {
                const extensions = [];
                const coreSet = new Set(coreIntervals);
                
                for (const interval of intervals) {
                    if (!coreSet.has(interval) && interval !== 0) {
                        // Convert interval to extension name
                        const extName = this.intervalToExtensionName(interval);
                        if (extName) extensions.push(extName);
                    }
                }
                
                return extensions;
            }
            
            intervalToExtensionName(interval) {
                const extensionMap = {
                    1: '♭9', 2: '9', 3: '♯9', 4: '3', 5: '11', 6: '♯11',
                    7: '5', 8: '♭13', 9: '6/13', 10: '♭7', 11: '7'
                };
                return extensionMap[interval] || interval.toString();
            }
            
            // Estimate note and octave from frequency (for display only)
            estimateNoteFromFrequency(freq) {
                // A4 = 440 Hz is our reference
                const a4 = 440.0;
                const a4NoteNumber = 69; // MIDI note number for A4
                
                // Calculate MIDI note number from frequency
                const noteNumber = 12 * Math.log2(freq / a4) + a4NoteNumber;
                const roundedNoteNumber = Math.round(noteNumber);
                
                // Convert MIDI note number to note and octave
                const octave = Math.floor((roundedNoteNumber - 12) / 12);
                const note = roundedNoteNumber % 12;
                
                return { note, octave };
            }
            
            editLockedChord(chordData, columnElement) {
                // Get the locked chord data to extract the intervals
                const lockedChord = this.lockedChords.get(columnElement);
                if (!lockedChord) {
                    alert('This chord must be locked before it can be edited');
                    return;
                }
                
                console.log('? Editing locked chord:', chordData.name, 'with intervals:', lockedChord.intervals);
                
                // Enter chord creation mode with the locked chord's intervals
                this.enterChordCreationMode();
                
                // Set the intervals from the locked chord
                this.selectedIntervals = [...(lockedChord.intervals || [])];
                
                // Update the note selector to show these intervals
                // Refresh interval selection UI and preview column in builder
                this.updateIntervalButtons();
                this.updatePreviewChordColumn();
                
                // Show the chord name input with current name
                const modal = document.getElementById('chordBuilderModal');
                if (modal) {
                    modal.style.display = 'block';
                    const nameInput = document.getElementById('chordNameInput');
                    if (nameInput) {
                        nameInput.value = chordData.name;
                    }
                }
                
                console.log('? Chord edit mode activated with existing intervals');
            }
            
            hideLockedChord(chordData, columnElement) {
                if (!this.hiddenColumns) this.hiddenColumns = [];
                
                const chordId = chordData.id || chordData.name.toLowerCase().replace(/\s+/g, '_');
                
                if (confirm(`Hide the locked chord "${chordData.name}"? You can show it again from the settings.`)) {
                    // Add to hidden columns
                    if (!this.hiddenColumns.includes(chordId)) {
                        this.hiddenColumns.push(chordId);
                    }
                    
                    // Regenerate columns to hide this one
                    this.generateExtensionColumns();
                    
                    console.log('?? Hidden locked chord:', chordData.name);
                }
            }
            
            duplicateLockedChord(chordData, columnElement) {
                // Get the locked chord data
                const lockedChord = this.lockedChords.get(columnElement);
                if (!lockedChord) {
                    alert('This chord must be locked before it can be duplicated');
                    return;
                }
                
                console.log('? Duplicating locked chord:', chordData.name, 'with intervals:', lockedChord.intervals);
                
                // Create a new chord extension with a copy name
                const duplicateChord = {
                    name: chordData.name + ' Copy',
                    intervals: [...(lockedChord.intervals || [])],
                    extensions: [...(chordData.extensions || [])],
                    quality: chordData.quality || 'major',
                    isCustom: true,
                    id: 'duplicate_' + Date.now()
                };
                
                // Add to chord extensions
                this.chordExtensions.push(duplicateChord);
                this.saveChordConfiguration();
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log('? Duplicated chord:', duplicateChord.name);
            }
            
            // Generic functions that work for ALL chords (not just locked ones)
            editChordFromButton() { /* removed: live edit via keyboard */ }
            
            hideChordFromButton(chordData, columnElement) {
                // Repurpose as Delete Chord
                console.log('🗑️ DELETE for:', chordData?.name);
                if (!chordData || !chordData.name) {
                    alert('Error: Invalid chord data for delete');
                    return;
                }
                if (!confirm(`Delete the chord "${chordData.name}"? This cannot be undone.`)) return;
                const idx = this.getIndexFromColumn(columnElement, chordData);
                if (idx !== -1) {
                    this.chordExtensions.splice(idx, 1);
                    this.normalizeChordPositions();
                    this.generateExtensionColumns();
                    // Force rebuild to eliminate gaps
                    this._rebuildChordGridAfterDeletion();
                } else {
                    this.generateExtensionColumns();
                }
            }
            
            duplicateChordFromButton(chordData, columnElement) {
                console.log('📋 DUPLICATE for:', chordData?.name);
                if (!chordData || !chordData.name) {
                    alert('Error: Invalid chord data for duplication');
                    return;
                }
                // Find base chord and position
                const idx = this.getIndexFromColumn(columnElement, chordData);
                const base = (idx !== -1 && this.chordExtensions[idx]) ? this.chordExtensions[idx] : chordData;
                const intervals = (base.intervals && base.intervals.length)
                    ? [...base.intervals]
                    : (this.getBaseTriadForQuality(this.stripRootFromName(base.name).toLowerCase()) || [0,4,7]);

                const newChord = {
                    name: `${base.name} Copy`,
                    intervals: intervals,
                    extensions: Array.isArray(base.extensions) ? [...base.extensions] : [],
                    quality: base.quality || 'major',
                    isCustom: true,
                    id: `duplicate_${Date.now()}_${Math.floor(Math.random()*1e6)}`
                };
                const insertAt = (idx !== -1) ? (idx + 1) : this.chordExtensions.length;
                this.chordExtensions.splice(insertAt, 0, newChord);
                this.normalizeChordPositions?.();
                this.generateExtensionColumns();
            }

            // --- Helpers to robustly find the clicked chord in this.chordExtensions ---
            findChordIndex(chordData) {
                // Prefer exact id match
                if (chordData && chordData.id) {
                    const byId = this.chordExtensions.findIndex(ext => ext && ext.id === chordData.id);
                    if (byId !== -1) return byId;
                }
                // Fallback: name + intervals match
                const intervals = (chordData && (chordData.intervals || chordData.notes)) || [];
                const key = JSON.stringify(intervals);
                const byStruct = this.chordExtensions.findIndex(ext => {
                    if (!ext) return false;
                    if (ext.name !== chordData.name) return false;
                    const extIntervals = ext.intervals || [];
                    return JSON.stringify(extIntervals) === key;
                });
                if (byStruct !== -1) return byStruct;
                // Last resort: position if present
                if (typeof chordData.position === 'number') return chordData.position;
                return -1;
            }

            getIndexFromColumn(columnElement, chordData) {
                // First trust the dataset from the DOM column created with this chord
                const ds = columnElement && columnElement.dataset ? columnElement.dataset : {};
                if (ds && typeof ds.originalPosition !== 'undefined') {
                    const idx = parseInt(ds.originalPosition, 10);
                    if (!Number.isNaN(idx) && idx >= 0 && idx < this.chordExtensions.length) return idx;
                }
                // Then try to calculate from chordData
                const fallbackIdx = this.findChordIndex(chordData);
                if (fallbackIdx !== -1) return fallbackIdx;
                // Give up gracefully
                return -1;
            }
            
            findChordPosition(chordData) {
                // Find the position of this chord in the chordExtensions array
                for (let i = 0; i < this.chordExtensions.length; i++) {
                    const chord = this.chordExtensions[i];
                    if (chord.name === chordData.name && 
                        chord.id === chordData.id ||
                        (chord.isCustom === chordData.isCustom && chord.name === chordData.name)) {
                        return i;
                    }
                }
                return this.chordExtensions.length; // Default to end if not found
            }

            // Remove pitch-class prefix from chord names (e.g., "Csus4" -> "sus4")
            stripRootFromName(name) {
                if (!name) return '';
                return String(name).replace(/^[A-G][#b]?\s*/, '').trim();
            }
            
            applyLockedChordSettings(lockedChord) {
                console.log('?? Applying locked chord settings:', lockedChord);
                
                // Apply locked musical settings (MOST IMPORTANT - the locked root!)
                this.currentRoot = lockedChord.lockedRoot;
                this.currentQuality = lockedChord.quality;
                this.currentTuning = lockedChord.lockedTuning;
                this.gamelanMode = lockedChord.lockedGamelanMode;
                
                // Apply locked oscillator settings
                this.oscillators.osc1 = { ...lockedChord.lockedOsc1 };
                this.oscillators.osc2 = { ...lockedChord.lockedOsc2 };
                
                // Apply locked envelope settings
                this.envelope = { ...lockedChord.lockedEnvelope };
                this.osc2Envelope = { ...lockedChord.lockedOsc2Envelope };
                
                // Apply locked effects settings
                this.reverbWet = lockedChord.lockedEffects.reverbWet;
                if (this.reverb) this.reverb.decay = lockedChord.lockedEffects.reverbDecay;
                if (this.reverbFilterNode) this.reverbFilterNode.frequency.value = lockedChord.lockedEffects.reverbFilterCutoff;
                this.panning.mode = lockedChord.lockedEffects.panningMode;
                this.panning.width = lockedChord.lockedEffects.panningWidth;
                
                // Apply locked volume settings
                this.masterVolume = lockedChord.lockedVolume.master;
                this.volume = lockedChord.lockedVolume.main;
                
                console.log('?? Applied locked settings - root:', this.currentRoot, 'tuning:', this.currentTuning, 'quality:', this.currentQuality);
            }
            
            loadLockedChords() {
                // No localStorage - always return empty (start fresh each session)
                return null;
            }
            
            restoreLockedChordStates() {
                if (!this.savedLockedChords || this.savedLockedChords.length === 0) {
                    console.log('?? No saved locked chords to restore');
                    return;
                }
                
                // Ensure lockedChords Map is initialized
                if (!this.lockedChords) this.lockedChords = new Map();
                
                console.log('?? Restoring locked chord states for', this.savedLockedChords.length, 'locked chords');
                
                // After columns are generated, restore locked states using position-based matching
                this.savedLockedChords.forEach((lockedChord, index) => {
                    console.log('?? Restoring locked chord:', lockedChord.chordName, 'at position:', lockedChord.originalPosition);
                    
                    // Find the matching column element by position and chord data
                    const columns = Array.from(document.querySelectorAll('.extension-column'));
                    
                    // Method 1: Try position-based matching first (most reliable)
                    let targetColumn = null;
                    if (lockedChord.originalPosition !== undefined && columns[lockedChord.originalPosition]) {
                        targetColumn = columns[lockedChord.originalPosition];
                        console.log('?? Using position-based match at index', lockedChord.originalPosition);
                    }
                    
                    // Method 2: If position doesn't work, try finding by chord data
                    if (!targetColumn) {
                        targetColumn = columns.find(column => {
                            const chordType = column.dataset.chordType;
                            const header = column.querySelector('.extension-header');
                            const chordName = header?.querySelector('.chord-name');
                            
                            if (chordName) {
                                const currentText = chordName.textContent.trim();
                                console.log('?? Checking column with text:', currentText, 'against locked chord:', lockedChord.chordName);
                                return this.isChordMatch(currentText, lockedChord);
                            }
                            return false;
                        });
                        
                        if (targetColumn) {
                            console.log('?? Using name-based match');
                        }
                    }
                    
                    // Method 3: If still no match, try by original chord extension index
                    if (!targetColumn && lockedChord.originalPosition !== undefined) {
                        // Find chord extension that matches the locked chord
                        const matchingExtension = this.chordExtensions.find(ext => 
                            ext.name === lockedChord.chordName || 
                            (ext.isCustom && ext.id && lockedChord.lockId && lockedChord.lockId.includes(ext.id))
                        );
                        
                        if (matchingExtension) {
                            const extensionIndex = this.chordExtensions.indexOf(matchingExtension);
                            if (columns[extensionIndex]) {
                                targetColumn = columns[extensionIndex];
                                console.log('?? Using extension-based match at index', extensionIndex);
                            }
                        }
                    }
                    
                    if (targetColumn) {
                        console.log('?? Found matching column for:', lockedChord.chordName);
                        
                        // Restore the locked state
                        this.lockedChords.set(targetColumn, lockedChord);
                        
                        // No lock/duplicate/edit/hide buttons to update anymore
                        
                        // Update visual styling and show locked root in name (respect per-column local transpose)
                        const chordNameElement = targetColumn.querySelector('.chord-name');
                        if (chordNameElement) {
                            chordNameElement.style.color = '#4CAF50';
                            chordNameElement.style.fontWeight = 'bold';
                            const edo = lockedChord.lockedTuning || this.currentTuning || 12;
                            const localDelta = ((+targetColumn.dataset.localTranspose || 0) % edo + edo) % edo;
                            const effRoot = ((lockedChord.lockedRoot ?? 0) + localDelta + edo) % edo;
                            const rootName = this.getRootNameForStep(effRoot, edo);
                            
                            // ALWAYS show the locked root in the chord name
                            if (lockedChord.chordName.match(/^[A-G][#b]?/)) {
                                chordNameElement.textContent = lockedChord.chordName;
                            } else {
                                chordNameElement.textContent = `${rootName}${lockedChord.chordName}`;
                            }
                            
                            chordNameElement.title = `?? LOCKED: ${rootName} root, ${lockedChord.lockedTuning}TET, ${lockedChord.lockedOsc1.type}/${lockedChord.lockedOsc2.type} waves`;
                            
                            // Mark the effective locked label so future ops parse the correct root
                            chordNameElement.dataset.isLocked = 'true';
                            chordNameElement.dataset.lockedName = chordNameElement.textContent;
                        }
                        
                        console.log('?? Successfully restored locked chord:', lockedChord.chordName, 'at position', lockedChord.originalPosition);
                    } else {
                        console.warn('?? Could not find matching column for locked chord:', lockedChord.chordName, 'position:', lockedChord.originalPosition);
                        console.warn('?? Available columns:', columns.length, 'chord extensions:', this.chordExtensions.length);
                    }
                });
                
                console.log('?? Finished restoring locked chord states. Active locked chords:', this.lockedChords.size);
            }
            
            isChordMatch(currentText, lockedChord) {
                const chordBaseName = lockedChord.chordName;
                
                // Exact match (for custom chords like "CMaj6")
                if (currentText === chordBaseName) {
                    return true;
                }
                // Partial match (for complex chord names)
                if (currentText.includes(chordBaseName) || chordBaseName.includes(currentText)) {
                    return true;
                }
                // Quality-based match (for standard chords)
                if (lockedChord.quality && (
                    currentText.toLowerCase().includes(lockedChord.quality.toLowerCase()) ||
                    currentText.includes('Maj') && lockedChord.quality.includes('major') ||
                    currentText.includes('Min') && lockedChord.quality.includes('minor') ||
                    currentText.includes('Neu') && lockedChord.quality.includes('neutral')
                )) {
                    return true;
                }
                return false;
            }
            
            clearLockedChords() {
                if (confirm('Clear all locked chords?')) {
                    // Clear the locked chords map
                    this.lockedChords = new Map();
                    
                    // Clear localStorage
                    
                    // Reset all lock buttons to unlocked state
                    document.querySelectorAll('.lock-button').forEach(button => {
                        button.innerHTML = '🔓';
                        button.classList.remove('locked');
                        button.title = 'Lock chord with current root & settings';
                    });
                    
                    // Reset chord header colors to indicate unlocked
                    document.querySelectorAll('.extension-header .chord-name').forEach(chordName => {
                        chordName.style.color = '#fff'; // Reset to default color
                        chordName.title = ''; // Clear locked indicator
                    });
                    
                    console.log('?? All locked chords cleared from main grid');
                }
            }

            playPaletteChord(chord) {
                // Use locked settings from when the chord was dragged
                const originalRoot = this.currentRoot;
                const originalQuality = this.currentQuality;
                const originalTuning = this.currentTuning;
                const originalGamelanMode = this.gamelanMode;
                
                // Temporarily switch to the chord's locked settings
                this.currentRoot = chord.lockedRoot || chord.root;
                this.currentQuality = chord.quality;
                if (chord.lockedTuning !== undefined) {
                    this.currentTuning = chord.lockedTuning;
                }
                if (chord.lockedGamelanMode !== undefined) {
                    this.gamelanMode = chord.lockedGamelanMode;
                }
                
                // Generate intervals for this chord using locked settings
                let intervals;
                if (chord.intervals) {
                    // Custom chord with specific intervals (already in native tuning)
                    intervals = chord.intervals.map(interval => 
                        (this.currentRoot + interval) % this.currentTuning
                    );
                } else {
                    // Standard chord with extensions
                    const chordIntervals = this.getChordIntervals(chord.extensions);
                    intervals = chordIntervals.map(interval => 
                        (this.currentRoot + interval) % this.currentTuning
                    );
                }
                
                // Play the chord for 1 second with proper ADSR routing
                const baseOctave = 4;
                intervals.forEach(step => {
                    const freq = this.getFrequency(step, baseOctave, this.currentTuning);
                    // Create a dummy element for proper ADSR handling
                    const dummyElement = { classList: { add: () => {}, remove: () => {} } };
                    this.playFrequency(freq, dummyElement, 'chord');
                });
                
                // Stop all notes after 1 second
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
                
                // Restore original settings
                this.currentRoot = originalRoot;
                this.currentQuality = originalQuality;
                this.currentTuning = originalTuning;
                this.gamelanMode = originalGamelanMode;
                
                console.log(`Played chord: ${chord.fullName} (${chord.tuningName || 'current tuning'})`);
            }

            renameColumn() {
                const newName = prompt('Enter new column name:', this.currentEditingColumn.name);
                if (newName && newName.trim()) {
                    this.currentEditingColumn.name = newName.trim();
                    this.updateColumnInStorage();
                    this.generateExtensionColumns();
                }
            }

            copyColumn() {
                // Create a copy of the current column as a new chord extension (not custom chord)
                const baseName = this.currentEditingColumn.originalName || this.currentEditingColumn.name.replace(/^(Maj|Neu|Min)/, '');
                const columnCopy = {
                    name: `${baseName} Copy`,
                    extensions: [...(this.currentEditingColumn.extensions || [])],
                    intervals: this.currentEditingColumn.intervals || null
                };
                
                // Add to chord extensions so it gets all 3 flavors
                this.chordExtensions.push(columnCopy);
                this.saveChordConfiguration();
                this.generateExtensionColumns();
                
                console.log(`Copied column: ${columnCopy.name}`);
            }

            editColumnPattern() {
                const modal = document.getElementById('editPatternModal');
                const title = document.getElementById('editPatternTitle');
                const nameInput = document.getElementById('editPatternName');
                
                title.textContent = `Edit Pattern: ${this.currentEditingColumn.name}`;
                nameInput.value = this.currentEditingColumn.name;
                
                this.setupIntervalEditor();
                modal.style.display = 'block';
            }

            setupIntervalEditor() {
                const editor = document.getElementById('intervalEditor');
                editor.innerHTML = '';
                
                // Create interval input fields for common intervals
                const intervals = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
                
                intervals.forEach(interval => {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `interval_${interval}`;
                    checkbox.value = interval;
                    
                    const label = document.createElement('label');
                    label.htmlFor = `interval_${interval}`;
                    label.textContent = interval;
                    label.style.cssText = 'display: flex; align-items: center; gap: 5px; padding: 5px; background: #16213e; border-radius: 3px; cursor: pointer;';
                    
                    label.prepend(checkbox);
                    editor.appendChild(label);
                });
            }

            setQuickPattern(intervals) {
                // Convert 12TET intervals to current tuning system
                const currentTuning = this.getTuningStepsPerOctave();
                const convertedIntervals = intervals.map(interval => {
                    // Convert from 12TET to current tuning
                    return Math.round((interval / 12) * currentTuning);
                });
                
                console.log(`?? Converting intervals from 12TET ${intervals} to ${currentTuning}EDO: ${convertedIntervals}`);
                
                // Clear all checkboxes
                document.querySelectorAll('#intervalEditor input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                
                // Check the converted intervals
                convertedIntervals.forEach(interval => {
                    const checkbox = document.getElementById(`interval_${interval}`);
                    if (checkbox) {
                        checkbox.checked = true;
                        console.log(`? Checked interval ${interval} in ${currentTuning}EDO`);
                    }
                });
                
                // Also update the chord creation mode if active
                if (this.chordCreationMode) {
                    this.selectedIntervals = [...convertedIntervals];
                    this.updateIntervalButtons();
                    this.updatePreviewChordColumn();
                }
            }

            saveEditedPattern() {
                const nameInput = document.getElementById('editPatternName');
                const selectedIntervals = Array.from(document.querySelectorAll('#intervalEditor input[type="checkbox"]:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);

                if (selectedIntervals.length === 0) {
                    alert('Please select at least one interval.');
                    return;
                }

                // Update the column
                this.currentEditingColumn.name = nameInput.value;
                this.currentEditingColumn.intervals = selectedIntervals;
                
                this.updateColumnInStorage();
                document.getElementById('editPatternModal').style.display = 'none';
                this.generateExtensionColumns();
            }

            moveColumn(direction) {
                const currentId = this.currentEditingColumn.id || this.currentEditingColumn.name.toLowerCase();
                const currentIndex = this.chordExtensions.findIndex(ext => 
                    ext.name.toLowerCase() === currentId || ext.name === this.currentEditingColumn.name
                );
                
                if (currentIndex === -1) return;
                
                const newIndex = currentIndex + direction;
                if (newIndex < 0 || newIndex >= this.chordExtensions.length) return;
                
                // Swap the chord extensions
                [this.chordExtensions[currentIndex], this.chordExtensions[newIndex]] = 
                [this.chordExtensions[newIndex], this.chordExtensions[currentIndex]];
                
                // Save configuration
                this.saveChordConfiguration();
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log(`Moved column ${this.currentEditingColumn.name} ${direction > 0 ? 'right' : 'left'}`);
            }

            loadChordConfiguration() {
                // No localStorage - always return null (start fresh each session)
                return null;
            }

            saveChordConfiguration() {
                // No localStorage - update session data instead
                this.sessionData.chordExtensions = this.chordExtensions;
                console.log('?? Chord configuration updated in session data');
            }
            
            // ============= OMG FILE SYSTEM =============
            
            saveSessionToFile() {
                // Collect all session data
                const sessionData = {
                    version: "1.0",
                    timestamp: Date.now(),
                    customChords: this.customChords,
                    favoriteChords: this.favoriteChords,
                    paletteChords: this.paletteChords,
                    lockedSonicChords: this.lockedSonicChords,
                    hiddenColumns: this.hiddenColumns,
                    chordExtensions: this.chordExtensions,
                    lockedChords: this.lockedChords ? Array.from(this.lockedChords.values()) : [],
                    currentTuning: this.currentTuning || 12,
                    gamelanMode: this.gamelanMode || false,
                    currentRoot: this.currentRoot || 0,
                    volume: this.volume || 0.5,
                    masterVolume: this.masterVolume || 1,
                    oscillators: this.oscillators,
                    envelope: this.envelope,
                    osc2Envelope: this.osc2Envelope
                };
                
                const dataStr = JSON.stringify(sessionData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `omnichord-session-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.omg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                console.log('?? Session saved to OMG file');
            }
            
            loadSessionFromFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const sessionData = JSON.parse(e.target.result);
                            
                            // Restore all data
                            this.customChords = sessionData.customChords || [];
                            this.favoriteChords = sessionData.favoriteChords || [];
                            this.paletteChords = sessionData.paletteChords || [];
                            this.lockedSonicChords = sessionData.lockedSonicChords || [];
                            this.hiddenColumns = sessionData.hiddenColumns || [];
                            this.chordExtensions = sessionData.chordExtensions || [];
                            
                            // Restore locked chords if any
                            if (sessionData.lockedChords && sessionData.lockedChords.length > 0) {
                                // Convert back to Map structure
                                this.savedLockedChords = sessionData.lockedChords;
                            }
                            
                            // Restore settings
                            if (sessionData.currentTuning) {
                                this.currentTuning = sessionData.currentTuning;
                                const tuningSelect = document.getElementById('edoDivisions');
                                if (tuningSelect) tuningSelect.value = sessionData.currentTuning;
                            }
                            
                            if (sessionData.gamelanMode !== undefined) {
                                this.gamelanMode = sessionData.gamelanMode;
                            }
                            
                            if (sessionData.currentRoot !== undefined) {
                                this.currentRoot = sessionData.currentRoot;
                            }
                            
                            // Restore audio settings
                            if (sessionData.oscillators) {
                                this.oscillators = sessionData.oscillators;
                            }
                            if (sessionData.envelope) {
                                this.envelope = sessionData.envelope;
                            }
                            if (sessionData.osc2Envelope) {
                                this.osc2Envelope = sessionData.osc2Envelope;
                            }
                            
                            // Regenerate the interface
                            this.generateExtensionColumns();
                            this.generateRootButtons();
                            
                            console.log('?? Session loaded from OMG file:', sessionData);
                            resolve(sessionData);
                        } catch (error) {
                            console.error('Error loading session file:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
            
            promptSaveOnExit() {
                if (confirm('Save current session to OMG file before exiting?')) {
                    this.saveSessionToFile();
                }
            }
            
            clearUnlockedChords() {
                // Remove all unlocked chords, keeping only locked ones
                console.log('??? Clearing all unlocked chords...');
                console.log('?? Before clearing - chord extensions:', this.chordExtensions.length, 'chords:', this.chordExtensions.map(c => c.name));
                
                // Filter to keep only locked chords
                const lockedChords = this.chordExtensions.filter(chord => chord.isLocked && chord.lockedData);
                
                console.log('? Found locked chords:', lockedChords.length, 'chords:', lockedChords.map(c => c.name));
                
                // If no locked chords, start in chord creation mode
                if (lockedChords.length === 0) {
                    console.log('?? No chords available, starting in chord creation mode');
                    // Start empty - user must create chords from scratch
                    this.chordExtensions = [];
                } else {
                    console.log('?? Keeping only locked chords with preserved data');
                    // IMPORTANT: Keep the full locked chord data structure intact
                    this.chordExtensions = lockedChords.map(chord => ({
                        ...chord,
                        // Ensure intervals from locked data are preserved
                        intervals: chord.lockedData?.intervals || chord.intervals,
                        // Preserve all locked settings
                        lockedRoot: chord.lockedData?.lockedRoot,
                        lockedTuning: chord.lockedData?.lockedTuning,
                        lockedGamelanMode: chord.lockedData?.lockedGamelanMode,
                        // Keep the lock state
                        isLocked: true,
                        lockedData: chord.lockedData
                    }));
                }
                
                // Clear any old localStorage keys that might be confusing things
                
                // Save the cleaned configuration
                this.saveChordConfiguration();
                
                console.log('?? After clearing - chord extensions:', this.chordExtensions.length, 'chords:', this.chordExtensions.map(c => c.name));
                
                // Regenerate the display
                this.generateExtensionColumns();
            }

            addColumn() {
                // Show modal to select chord type
                this.showAddColumnModal();
            }

            showAddColumnModal() {
                // Create modal for adding new column
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px;">
                        <h3>Add New Chord Column</h3>
                        <div style="display: flex; gap: 20px;">
                            <div style="flex: 1;">
                                <h4>Preset Chords</h4>
                                <div class="add-column-grid">
                                    ${this.availableChordTypes.map(chord => `
                                        <button class="add-chord-btn" data-chord='${JSON.stringify(chord)}'>
                                            ${chord.name}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <h4>Create Custom Chord</h4>
                                <div style="margin-bottom: 15px;">
                                    <label>Chord Name:</label>
                                    <input type="text" id="customChordName" placeholder="My Chord" style="width: 100%; padding: 5px; margin-top: 5px;">
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <label>Select Notes (0-11 semitones):</label>
                                    <div id="noteSelector" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 10px;">
                                        ${Array.from({length: 12}, (_, i) => `
                                            <label style="display: flex; align-items: center; gap: 5px; padding: 8px; background: #333; border-radius: 4px; cursor: pointer;">
                                                <input type="checkbox" value="${i}" class="note-checkbox" style="cursor: pointer;">
                                                <span class="note-label">${this.getNoteNameFromSemitone(i)}</span>
                                                <button type="button" class="preview-btn" data-note="${i}" style="margin-left: auto; padding: 2px 6px; font-size: 10px; background: #555; border: none; color: white; border-radius: 3px; cursor: pointer;">?</button>
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <button type="button" id="previewChord" class="osc-btn" style="width: 100%;">?? Preview Full Chord</button>
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <button type="button" id="createCustomChord" class="osc-btn" style="width: 100%; background: #059669;">Create Custom Chord</button>
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                        </div>
                    </div>
                `;
                
                // Add event listeners for preset chord selection
                modal.querySelectorAll('.add-chord-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const chordData = JSON.parse(e.target.dataset.chord);
                        this.addChordColumn(chordData);
                        modal.remove();
                    });
                });
                
                // Add event listeners for custom chord creation
                const previewButtons = modal.querySelectorAll('.preview-btn');
                previewButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const note = parseInt(e.target.dataset.note);
                        this.previewNote(note);
                    });
                });
                
                const previewChordBtn = modal.querySelector('#previewChord');
                previewChordBtn.addEventListener('click', () => {
                    this.previewSelectedChord(modal);
                });
                
                const createCustomBtn = modal.querySelector('#createCustomChord');
                createCustomBtn.addEventListener('click', () => {
                    this.createCustomChordFromModal(modal);
                });
                
                document.body.appendChild(modal);
                
                // Close on ESC
                const closeOnEsc = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', closeOnEsc);
                    }
                };
                document.addEventListener('keydown', closeOnEsc);
            }

            getNoteNameFromSemitone(semitone) {
                const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                return notes[semitone];
            }

            previewNote(semitone) {
                // Calculate frequency for the note (using C4 as base)
                const baseFreq = 261.626; // C4
                const frequency = baseFreq * Math.pow(2, semitone / 12);
                
                // Play the note briefly
                this.playFrequency(frequency, 0.5, 'chord'); // 0.5 second duration
                
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 500);
            }

            previewSelectedChord(modal) {
                const selectedNotes = Array.from(modal.querySelectorAll('.note-checkbox:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);
                
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note to preview.');
                    return;
                }
                
                // Play all selected notes as a chord
                const baseFreq = 261.626; // C4
                selectedNotes.forEach(semitone => {
                    const frequency = baseFreq * Math.pow(2, semitone / 12);
                    this.playFrequency(frequency, 1.0, 'chord'); // 1 second duration
                });
                
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
            }

            createCustomChordFromModal(modal) {
                const chordName = modal.querySelector('#customChordName').value.trim();
                const selectedNotes = Array.from(modal.querySelectorAll('.note-checkbox:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);
                
                if (!chordName) {
                    alert('Please enter a chord name.');
                    return;
                }
                
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note.');
                    return;
                }
                
                // Create custom chord data
                const customChordData = {
                    name: chordName,
                    extensions: [], // Custom chords don't use extensions
                    intervals: selectedNotes,
                    isCustomPattern: true
                };
                
                this.addChordColumn(customChordData);
                modal.remove();
            }

            addChordColumn(chordData) {
                if (chordData.isCustomPattern) {
                    // Handle custom chord with specific intervals
                    if (!this.customChords) this.customChords = [];
                    
                    const customChord = {
                        name: chordData.name,
                        notes: chordData.intervals
                    };
                    
                    this.customChords.push(customChord);
                } else {
                    // Handle standard chord extension
                    this.chordExtensions.push({ ...chordData });
                    this.saveChordConfiguration();
                }
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log(`Added new chord column: ${chordData.name}`);
            }

            exportChordConfiguration() {
                const config = {
                    chordExtensions: this.chordExtensions,
                    customChords: this.customChords || [],
                    hiddenColumns: this.hiddenColumns || [],
                    exportDate: new Date().toISOString(),
                    version: '1.0'
                };
                
                const dataStr = JSON.stringify(config, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `xenon-config-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
            }
            
            /**
             * Export the COMPLETE application state as a versioned .xen file.
             * Schema (version 2.1):
             * {
             *   fileType: 'Xenmicord Session',
             *   schemaVersion: '2.1',       // explicit schema version (previous used 'version')
             *   appVersion: 'Xenmicord v2.0',
             *   savedDate: ISOString,
             *   chordExtensions: [...], customChords: [...], lockedChords: [...], paletteChords: [...],
             *   currentRoot, currentQuality, currentTuning, gamelanMode, transposeDelta,
             *   pianoLockedChords: [ [id, data], ... ], preloadedPresets: [ [id, synthState], ... ], pianoLockPresetCounter,
             *   hiddenColumns, splitExtendedChordsAcrossOctaves, playMode, strumEnabled, chordsEnabled, arpEnabled, bassEnabled,
             *   oscillators: { osc1, osc2 }, envelope, osc2Envelope,
             *   instruments: { strum1:{osc,env,fxSend}, strum2:{...}, chord:{...}, arp:{...}, bass:{...} },
             *   volume, masterVolume,
             *   bpm, quantize, timeSignature, pattern, loop, holdDuration, universalHold, npc,
             *   arpSettings: { npc, chordsNpc, chordQuant, chordsHold, pattern, gateMs, gatePct, glide, glideMs, active, seq, column },
             *   _isSequencing, _sustainActive, _chordsGestureActive,
             *   strumDelayMs, strumMode,
             *   chordSlideEnabled, _chordSlideEnabled, _chordGlideMs,
             *   heldBassEnabled, _heldBassEnabled,
             *   fx: { drive:{amount,mix,hp,lp}, delay:{timeMs,feedback,lp,hp,mix}, filters:{low,high,q}, reverb:{wet,room,decay,lp,hp}, panning:{mode,width,speedMs,alternateState,rotationAngle} },
             *   reverb, panning,
             *   textChordInput,
             *   drums: { active, patterns: { index: number[][] }, laneControls:[{vol,fx,midi,pPitch,pAtk,pDec}...], bass:[{npc,len,on}...] },
             *   midi: { outputPortMap, inputChannelMap, perSourceOctave, perSourceVelocity, defaultVelocity, octaveOffset, channelMap },
             *   sequencePresets, instrumentPresets, effectsPresets,
             *   currentActiveColumnEl: { chordName, index } | null,
             *   visualChordSequence: [ { name, intervals, position:{ index } } ],
             *   legacy: { version: '2.0' } // retained for backward compatibility
             * }
             *
             * Backward compatibility:
             *  - Older .omg or .xen with fileType 'OMG-nichord Session' or missing schemaVersion are translated.
             *  - Fields absent in legacy are defaulted.
             */
            exportXenState() {
                const sessionData = {
                    // ==== CHORD DATA ====
                    chordExtensions: this.chordExtensions,
                    customChords: this.customChords || [],
                    lockedChords: this.savedLockedChords || Array.from(this.lockedChords?.values() || []),
                    paletteChords: this.paletteChords || [],
                    currentRoot: this.currentRoot,
                    currentQuality: this.currentQuality,
                    currentTuning: this.currentTuning,
                    gamelanMode: this.gamelanMode,
                    // Global transpose state
                    transposeDelta: this.transposeDelta || 0,
                    
                    // ==== PIANO LOCK DATA - COMPLETE PRESERVATION ====
                    pianoLockedChords: this.pianoLockedChords ? Array.from(this.pianoLockedChords.entries()) : [],
                    preloadedPresets: this.preloadedPresets ? Array.from(this.preloadedPresets.entries()) : [],
                    pianoLockPresetCounter: this.pianoLockPresetCounter || 0,
                    
                    // ==== UI STATE - COMPLETE ====
                    hiddenColumns: this.hiddenColumns || [],
                    splitExtendedChordsAcrossOctaves: this.splitExtendedChordsAcrossOctaves,
                    playMode: this.playMode,
                    strumEnabled: this.strumEnabled,
                    chordsEnabled: this.chordsEnabled,
                    arpEnabled: this.arpEnabled,
                    bassEnabled: this.bassEnabled,
                    
                    // ==== OSCILLATOR SETTINGS - COMPLETE ====
                    oscillators: {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 }
                    },
                    envelope: { ...this.envelope },
                    osc2Envelope: { ...this.osc2Envelope },
                    
                    // ==== PER-INSTRUMENT SETTINGS - COMPLETE ====
                    instruments: {
                        strum1: {
                            osc: { ...this.instruments.strum1.osc },
                            env: { ...this.instruments.strum1.env },
                            fxSend: this.instruments.strum1.fxSend
                        },
                        strum2: {
                            osc: { ...this.instruments.strum2.osc },
                            env: { ...this.instruments.strum2.env },
                            fxSend: this.instruments.strum2.fxSend
                        },
                        chord: {
                            osc: { ...this.instruments.chord.osc },
                            env: { ...this.instruments.chord.env },
                            fxSend: this.instruments.chord.fxSend
                        },
                        arp: {
                            osc: { ...this.instruments.arp.osc },
                            env: { ...this.instruments.arp.env },
                            fxSend: this.instruments.arp.fxSend
                        },
                        bass: {
                            osc: { ...this.instruments.bass.osc },
                            env: { ...this.instruments.bass.env },
                            fxSend: this.instruments.bass.fxSend
                        }
                    },
                    
                    // ==== AUDIO ENGINE STATE ====
                    volume: this.volume,
                    masterVolume: this.masterVolume,
                    audioContext: {
                        sampleRate: this.audioContext ? this.audioContext.sampleRate : 44100,
                        state: this.audioContext ? this.audioContext.state : 'suspended'
                    },
                    
                    // ==== TRANSPORT AND TIMING - COMPLETE ====
                    bpm: parseInt(document.getElementById('universalBpm')?.value) || 120,
                    quantize: document.getElementById('universalQuant')?.value || 'beat:1',
                    timeSignature: document.getElementById('universalTimeSignature')?.value || '4/4',
                    pattern: document.getElementById('universalPattern')?.value || 'up',
                    // Persist custom typed pattern (if any) from companion text field
                    patternText: document.getElementById('universalPatternText')?.value || '',
                    loop: !!document.getElementById('playLoop')?.checked,
                    holdDuration: document.getElementById('chordHold')?.value || 'bar:1',
                    universalHold: document.getElementById('universalHold')?.value || 'bar:1',
                    npc: parseInt(document.getElementById('universalNpc')?.value) || 3,
                    
                    // ==== ARP/SEQUENCER STATE - COMPLETE ====
                    arpSettings: {
                        npc: this._arp?.npc || 3,
                        chordsNpc: this._arp?.chordsNpc || 3,
                        chordQuant: this._arp?.chordQuant || '1/4',
                        chordsHold: this._arp?.chordsHold || 'bar:1',
                        pattern: this._arp?.pattern || 'up',
                        gateMs: this._arp?.gateMs || 50,
                        gatePct: this._arp?.gatePct || 50,
                        glide: this._arp?.glide || false,
                        glideMs: this._arp?.glideMs || 0,
                        active: this._arp?.active || false,
                        seq: this._arp?.seq || [],
                        column: this._arp?.column || null
                    },
                    _isSequencing: this._isSequencing,
                    _sustainActive: this._sustainActive,
                    _chordsGestureActive: this._chordsGestureActive,
                    
                    // ==== STRUM SETTINGS ====
                    strumDelayMs: this.strumDelayMs,
                    strumMode: this.strumMode || 'up',
                    
                    // ==== SLIDE SETTINGS ====
                    chordSlideEnabled: !!document.getElementById('chordSlide')?.checked,
                    _chordSlideEnabled: this._chordSlideEnabled,
                    _chordGlideMs: this._chordGlideMs,
                    
                    // ==== BASS SETTINGS ====
                    heldBassEnabled: this._heldBassEnabled,
                    _heldBassEnabled: this._heldBassEnabled,
                    
                    // ==== EFFECTS SETTINGS - COMPLETE ====
                    fx: {
                        drive: {
                            amount: parseFloat(document.getElementById('driveAmount')?.value || 0),
                            mix: parseFloat(document.getElementById('driveMix')?.value || 0),
                            hp: parseFloat(document.getElementById('driveHpCutoff')?.value || 0),
                            lp: parseFloat(document.getElementById('driveLpCutoff')?.value || 100)
                        },
                        delay: {
                            timeMs: parseFloat(document.getElementById('delayTime')?.value || 280),
                            feedback: parseFloat(document.getElementById('delayFeedback')?.value || 0),
                            lp: parseFloat(document.getElementById('delayLpCutoff')?.value || 73),
                            hp: parseFloat(document.getElementById('delayHpCutoff')?.value || 0),
                            mix: parseFloat(document.getElementById('delayMix')?.value || 0)
                        },
                        filters: {
                            low: parseFloat(document.getElementById('filterLow')?.value || 0),
                            high: parseFloat(document.getElementById('filterHigh')?.value || 100),
                            q: parseFloat(document.getElementById('filterRes')?.value || 1)
                        },
                        reverb: {
                            wet: parseFloat(document.getElementById('reverbWet')?.value || 1),
                            room: parseFloat(document.getElementById('reverbRoom')?.value || 5),
                            decay: parseFloat(document.getElementById('reverbDecay')?.value || 20),
                            lp: parseFloat(document.getElementById('reverbFilterCutoff')?.value || 70),
                            hp: parseFloat(document.getElementById('reverbHpCutoff')?.value || 0)
                        },
                        panning: {
                            mode: document.getElementById('panningMode')?.value || 'center',
                            width: parseFloat(document.getElementById('panningWidth')?.value || 80),
                            speedMs: parseFloat(document.getElementById('panningSpeed')?.value || 2000),
                            alternateState: this.panning?.alternateState || false,
                            rotationAngle: this.panning?.rotationAngle || 0
                        }
                    },
                    
                    // ==== REVERB OBJECT STATE ====
                    reverb: this.reverb ? { ...this.reverb } : {},
                    panning: this.panning ? { ...this.panning } : {},
                    
                    // ==== TEXT INPUT STATE ====
                    textChordInput: document.getElementById('textChordInput')?.value || '',

                    // ==== DRUMS: PATTERNS + LANE CONTROLS ====
                    drums: (()=>{
                        try {
                            const active = Math.max(1, parseInt(document.getElementById('drumPatternNumber')?.value||'1',10));
                            // Serialize pattern bank map<number, number[][]>
                            let patterns = {};
                            try {
                                const mp = this._drumPatterns instanceof Map ? this._drumPatterns : null;
                                if (mp) {
                                    for (const [k,v] of mp.entries()) { patterns[String(k)] = Array.isArray(v) ? JSON.parse(JSON.stringify(v)) : v; }
                                } else {
                                    // Fallback: capture current grid into pattern 1
                                    const lanes = Array.from(document.querySelectorAll('.drum-row:not(.bass-row) .drum-lane'));
                                    patterns['1'] = lanes.map(lane=> Array.from(lane.querySelectorAll('.drum-step')).map(s=> s.classList.contains('active') ? 1 : 0));
                                }
                            } catch(_){ }
                            // Per-lane controls (non-bass rows only)
                            const lanes = Array.from(document.querySelectorAll('.drum-row:not(.bass-row)'));
                            const laneControls = lanes.map(row=>{
                                try {
                                    const vol = row.querySelector('.drum-volume');
                                    const fx  = row.querySelector('.drum-fx input[type="checkbox"]');
                                    const midi= row.querySelector('.drum-midi input[type="text"]');
                                    const pPitch = row.querySelector('.drum-params input[title$=" Pitch"]');
                                    const pAtk   = row.querySelector('.drum-params input[title$=" Attack"]');
                                    const pDec   = row.querySelector('.drum-params input[title$=" Decay"]');
                                    return {
                                        vol: vol? vol.value: '80',
                                        fx: !!(fx&&fx.checked),
                                        midi: midi? midi.value: '',
                                        pPitch: pPitch? pPitch.value : '0',
                                        pAtk: pAtk? pAtk.value : '2',
                                        pDec: pDec? pDec.value : '180'
                                    };
                                } catch(_){ return {vol:'80',fx:false,midi:'',pPitch:'0',pAtk:'2',pDec:'180'}; }
                            });
                            // Bass NPC/ties row
                            let bass = [];
                            try {
                                const bassLane = document.querySelector('.drum-row.bass-row .drum-lane');
                                if (bassLane) {
                                    const steps = Array.from(bassLane.querySelectorAll('.drum-step'));
                                    bass = steps.map(s=>{
                                        const npc=(s.dataset.npc||''); const len=(s.dataset.len||'');
                                        const on = s.classList.contains('active');
                                        return { npc, len, on };
                                    });
                                }
                            } catch(_){}
                            return { active, patterns, laneControls, bass };
                        } catch(_) { return { active:1, patterns:{}, laneControls:[], bass:[] }; }
                    })(),

                    // ==== WEB MIDI STATE (OUTPUT ROUTING + PER-SECTION) ====
                    midi: (()=>{
                        try {
                            const m = (window && window.midi) ? window.midi : null;
                            if (!m) return {};
                            return {
                                outputPortMap: { ...(m.outputPortMap||{}) },
                                inputChannelMap: { ...(m.inputChannelMap||{}) },
                                perSourceOctave: { ...(m.perSourceOctave||{}) },
                                perSourceVelocity: { ...(m.perSourceVelocity||{}) },
                                defaultVelocity: m.defaultVelocity||100,
                                octaveOffset: m.octaveOffset||0,
                                channelMap: { ...(m.channelMap||{}) }
                            };
                        } catch(_) { return {}; }
                    })(),
                    
                    // ==== PRESET DATA ====
                    sequencePresets: this.getSequencePresets ? this.getSequencePresets() : [],
                    instrumentPresets: this.getInstrumentPresets ? this.getInstrumentPresets() : [],
                    effectsPresets: this.getEffectsPresets ? this.getEffectsPresets() : [],
                    
                    // ==== VISUAL STATE ====
                    currentActiveColumnEl: this.currentActiveColumnEl ? {
                        chordName: this.currentActiveColumnEl.querySelector('.chord-name')?.textContent,
                        index: Array.from(document.querySelectorAll('.extension-column')).indexOf(this.currentActiveColumnEl)
                    } : null,
                    
                    // ==== CANVAS/VISUAL CHORD SEQUENCE ====
                    visualChordSequence: (() => {
                        try {
                            const columns = Array.from(document.querySelectorAll('#extensionColumns .extension-column'));
                            return columns.map(col => {
                                const header = col.querySelector('.extension-column-header .chord-name');
                                const chordName = header ? header.textContent.trim() : '';
                                if (!chordName) return null;
                                
                                try {
                                    const relSteps = this.getChordStepsForColumn ? this.getChordStepsForColumn(col) : [];
                                    return {
                                        name: chordName,
                                        intervals: relSteps,
                                        position: {
                                            rect: col.getBoundingClientRect(),
                                            index: Array.from(columns).indexOf(col)
                                        }
                                    };
                                } catch(e) {
                                    return { name: chordName, intervals: [], position: { index: Array.from(columns).indexOf(col) } };
                                }
                            }).filter(Boolean);
                        } catch(e) {
                            console.error('Error capturing visual chord sequence:', e);
                            return [];
                        }
                    })(),
                    
                    // ==== SESSION METADATA ====
                    savedDate: new Date().toISOString(),
                    fileType: 'Xenmicord Session',
                    appVersion: 'Xenmicord v2.0',
                    schemaVersion: '2.1',
                    legacy: { version: '2.0' }
                };
                
                const dataStr = JSON.stringify(sessionData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `Xenmicord-session-${new Date().toISOString().split('T')[0]}.xen`;
                link.click();
                
                URL.revokeObjectURL(url);
                
                console.log('🎵 Complete session saved as .XEN file');
            }
            // Legacy alias (kept for any external references still calling old method name)
            saveSessionAsOMG() { return this.exportXenState(); }
            
            importXenState(event) {
                const file = event?.target?.files ? event.target.files[0] : event;
                if (!file) return;
                const fileName = (file.name||'').toLowerCase();
                if (!fileName.endsWith('.xen') && !fileName.endsWith('.omg')) {
                    alert('Please select a .XEN session file (or .OMG for legacy support)');
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const sessionData = JSON.parse(e.target.result);
                        const isNewFormat = sessionData.fileType === 'Xenmicord Session';
                        const isLegacyFormat = sessionData.fileType === 'OMG-nichord Session';
                        if (!isNewFormat && !isLegacyFormat) {
                            alert('Invalid session file format');
                            return;
                        }
                        console.log('🎵 Loading session file:', sessionData);
                        // Stop transport/playback if active (safety)
                        try { if (this.stop) this.stop(); } catch(_) {}
                        // COMPLETE RESTORATION - EVERY VARIABLE
                        
                        // ==== CHORD DATA ====
                        if (sessionData.chordExtensions) this.chordExtensions = sessionData.chordExtensions;
                        if (sessionData.customChords) this.customChords = sessionData.customChords;
                        if (sessionData.paletteChords) this.paletteChords = sessionData.paletteChords;
                        if (sessionData.currentRoot !== undefined) this.currentRoot = sessionData.currentRoot;
                        if (sessionData.currentQuality !== undefined) this.currentQuality = sessionData.currentQuality;
                        if (sessionData.currentTuning !== undefined) this.currentTuning = sessionData.currentTuning;
                        if (sessionData.gamelanMode !== undefined) this.gamelanMode = sessionData.gamelanMode;
                        if (sessionData.transposeDelta !== undefined) this.transposeDelta = sessionData.transposeDelta;
                        
                        // ==== LOCKED CHORDS RESTORATION ====
                        if (sessionData.lockedChords && sessionData.lockedChords.length > 0) {
                            console.log('🎵 Restoring locked chords:', sessionData.lockedChords.length, 'chords');
                            this.lockedChords = new Map();
                            this.savedLockedChords = sessionData.lockedChords;
                            
                            // Convert locked chords to chord extensions that will appear as locked
                            this.chordExtensions = [...(this.chordExtensions || []), ...sessionData.lockedChords.map(locked => ({
                                name: locked.chordName,
                                intervals: locked.intervals,
                                extensions: locked.extensions || [],
                                quality: locked.quality || 'custom',
                                isCustom: true,
                                isLocked: true,
                                lockedData: locked,
                                position: locked.originalPosition || 0
                            }))];
                        }
                        
                        // ==== PIANO LOCK DATA RESTORATION ====
                        if (sessionData.pianoLockedChords) {
                            this.pianoLockedChords = new Map(sessionData.pianoLockedChords);
                        }
                        if (sessionData.preloadedPresets) {
                            this.preloadedPresets = new Map(sessionData.preloadedPresets);
                        }
                        if (sessionData.pianoLockPresetCounter !== undefined) {
                            this.pianoLockPresetCounter = sessionData.pianoLockPresetCounter;
                        }
                        
                        // ==== UI STATE RESTORATION ====
                        if (sessionData.hiddenColumns) this.hiddenColumns = sessionData.hiddenColumns;
                        if (sessionData.splitExtendedChordsAcrossOctaves !== undefined) {
                            this.splitExtendedChordsAcrossOctaves = sessionData.splitExtendedChordsAcrossOctaves;
                        }
                        if (sessionData.playMode !== undefined) this.playMode = sessionData.playMode;
                        if (sessionData.strumEnabled !== undefined) this.strumEnabled = sessionData.strumEnabled;
                        if (sessionData.chordsEnabled !== undefined) this.chordsEnabled = sessionData.chordsEnabled;
                        if (sessionData.arpEnabled !== undefined) this.arpEnabled = sessionData.arpEnabled;
                        if (sessionData.bassEnabled !== undefined) this.bassEnabled = sessionData.bassEnabled;
                        
                        // ==== OSCILLATOR SETTINGS RESTORATION ====
                        if (sessionData.oscillators) {
                            if (sessionData.oscillators.osc1) Object.assign(this.oscillators.osc1, sessionData.oscillators.osc1);
                            if (sessionData.oscillators.osc2) Object.assign(this.oscillators.osc2, sessionData.oscillators.osc2);
                        }
                        if (sessionData.envelope) Object.assign(this.envelope, sessionData.envelope);
                        if (sessionData.osc2Envelope) Object.assign(this.osc2Envelope, sessionData.osc2Envelope);
                        
                        // ==== PER-INSTRUMENT SETTINGS RESTORATION ====
                        if (sessionData.instruments) {
                            if (sessionData.instruments.strum1) {
                                if (sessionData.instruments.strum1.osc) Object.assign(this.instruments.strum1.osc, sessionData.instruments.strum1.osc);
                                if (sessionData.instruments.strum1.env) Object.assign(this.instruments.strum1.env, sessionData.instruments.strum1.env);
                                if (sessionData.instruments.strum1.fxSend !== undefined) this.instruments.strum1.fxSend = sessionData.instruments.strum1.fxSend;
                            }
                            if (sessionData.instruments.strum2) {
                                if (sessionData.instruments.strum2.osc) Object.assign(this.instruments.strum2.osc, sessionData.instruments.strum2.osc);
                                if (sessionData.instruments.strum2.env) Object.assign(this.instruments.strum2.env, sessionData.instruments.strum2.env);
                                if (sessionData.instruments.strum2.fxSend !== undefined) this.instruments.strum2.fxSend = sessionData.instruments.strum2.fxSend;
                            }
                            if (sessionData.instruments.chord) {
                                if (sessionData.instruments.chord.osc) Object.assign(this.instruments.chord.osc, sessionData.instruments.chord.osc);
                                if (sessionData.instruments.chord.env) Object.assign(this.instruments.chord.env, sessionData.instruments.chord.env);
                                if (sessionData.instruments.chord.fxSend !== undefined) this.instruments.chord.fxSend = sessionData.instruments.chord.fxSend;
                            }
                            if (sessionData.instruments.arp) {
                                if (sessionData.instruments.arp.osc) Object.assign(this.instruments.arp.osc, sessionData.instruments.arp.osc);
                                if (sessionData.instruments.arp.env) Object.assign(this.instruments.arp.env, sessionData.instruments.arp.env);
                                if (sessionData.instruments.arp.fxSend !== undefined) this.instruments.arp.fxSend = sessionData.instruments.arp.fxSend;
                            }
                            if (sessionData.instruments.bass) {
                                if (sessionData.instruments.bass.osc) Object.assign(this.instruments.bass.osc, sessionData.instruments.bass.osc);
                                if (sessionData.instruments.bass.env) Object.assign(this.instruments.bass.env, sessionData.instruments.bass.env);
                                if (sessionData.instruments.bass.fxSend !== undefined) this.instruments.bass.fxSend = sessionData.instruments.bass.fxSend;
                            }
                        }
                        
                        // ==== AUDIO ENGINE STATE ====
                        if (sessionData.volume !== undefined) this.volume = sessionData.volume;
                        if (sessionData.masterVolume !== undefined) this.masterVolume = sessionData.masterVolume;
                        
                        // ==== ARP/SEQUENCER STATE RESTORATION ====
                        if (sessionData.arpSettings) {
                            if (!this._arp) this._arp = {};
                            Object.assign(this._arp, sessionData.arpSettings);
                        }
                        if (sessionData._isSequencing !== undefined) this._isSequencing = sessionData._isSequencing;
                        if (sessionData._sustainActive !== undefined) this._sustainActive = sessionData._sustainActive;
                        if (sessionData._chordsGestureActive !== undefined) this._chordsGestureActive = sessionData._chordsGestureActive;
                        
                        // ==== STRUM SETTINGS ====
                        if (sessionData.strumDelayMs !== undefined) this.strumDelayMs = sessionData.strumDelayMs;
                        if (sessionData.strumMode !== undefined) this.strumMode = sessionData.strumMode;
                        
                        // ==== SLIDE SETTINGS ====
                        if (sessionData._chordSlideEnabled !== undefined) this._chordSlideEnabled = sessionData._chordSlideEnabled;
                        if (sessionData._chordGlideMs !== undefined) this._chordGlideMs = sessionData._chordGlideMs;
                        
                        // ==== BASS SETTINGS ====
                        if (sessionData._heldBassEnabled !== undefined) this._heldBassEnabled = sessionData._heldBassEnabled;
                        
                        // ==== REVERB/PANNING OBJECT STATE ====
                        if (sessionData.reverb) Object.assign(this.reverb || {}, sessionData.reverb);
                        if (sessionData.panning) Object.assign(this.panning || {}, sessionData.panning);
                        
                        // ==== UI SYNCHRONIZATION ====
                        // Transport and timing settings
                        const setVal = (id, val, formatter) => {
                            const el = document.getElementById(id);
                            if (el) {
                                el.value = String(val);
                                const vEl = document.getElementById(id + "Value");
                                if (vEl && formatter) vEl.textContent = formatter(val);
                                el.dispatchEvent(new Event('input'));
                            }
                        };
                        
                        if (sessionData.bpm !== undefined) setVal('universalBpm', sessionData.bpm);
                        if (sessionData.quantize !== undefined) {
                            const el = document.getElementById('universalQuant');
                            if (el) { el.value = sessionData.quantize; el.dispatchEvent(new Event('change')); }
                        }
                        if (sessionData.timeSignature !== undefined) {
                            const el = document.getElementById('universalTimeSignature');
                            if (el) { el.value = sessionData.timeSignature; el.dispatchEvent(new Event('change')); }
                        }
                        if (sessionData.pattern !== undefined) {
                            const el = document.getElementById('universalPattern');
                            if (el) { el.value = sessionData.pattern; el.dispatchEvent(new Event('change')); }
                        }
                        // Restore custom pattern text BEFORE NPC/other dependent recalcs, then trigger handler
                        if (sessionData.patternText !== undefined) {
                            const txt = document.getElementById('universalPatternText');
                            if (txt) { txt.value = sessionData.patternText; txt.dispatchEvent(new Event('change')); }
                        }
                        if (sessionData.loop !== undefined) {
                            const el = document.getElementById('playLoop');
                            if (el) { el.checked = !!sessionData.loop; el.dispatchEvent(new Event('change')); }
                        }
                        if (sessionData.holdDuration !== undefined) {
                            const el = document.getElementById('chordHold');
                            if (el) { el.value = sessionData.holdDuration; el.dispatchEvent(new Event('change')); }
                        }
                        if (sessionData.universalHold !== undefined) {
                            const el = document.getElementById('universalHold');
                            if (el) { el.value = sessionData.universalHold; el.dispatchEvent(new Event('change')); }
                        }
                        if (sessionData.npc !== undefined) setVal('universalNpc', sessionData.npc);
                        
                        // Effects restoration
                        if (sessionData.fx) {
                            const fx = sessionData.fx;
                            if (fx.drive) {
                                setVal('driveAmount', fx.drive.amount, v => `${Math.round(v)}%`);
                                setVal('driveMix', fx.drive.mix, v => `${Math.round(v)}%`);
                                setVal('driveHpCutoff', fx.drive.hp);
                                setVal('driveLpCutoff', fx.drive.lp);
                            }
                            if (fx.delay) {
                                setVal('delayTime', fx.delay.timeMs, v => `${Math.round(v)}ms`);
                                setVal('delayFeedback', fx.delay.feedback, v => `${Math.round(v)}%`);
                                setVal('delayLpCutoff', fx.delay.lp);
                                setVal('delayHpCutoff', fx.delay.hp);
                                setVal('delayMix', fx.delay.mix, v => `${Math.round(v)}%`);
                            }
                            if (fx.filters) {
                                setVal('filterLow', fx.filters.low);
                                setVal('filterHigh', fx.filters.high);
                                setVal('filterRes', fx.filters.q, v => `Q ${Number(v).toFixed(1)}`);
                            }
                            if (fx.reverb) {
                                setVal('reverbWet', fx.reverb.wet, v => `${Math.round(v*10)}%`);
                                setVal('reverbRoom', fx.reverb.room, v => `${Math.round((v||0)*10)}%`);
                                setVal('reverbDecay', fx.reverb.decay, v => `${(Number(v)/10).toFixed(1)}s`);
                                setVal('reverbFilterCutoff', fx.reverb.lp);
                                setVal('reverbHpCutoff', fx.reverb.hp);
                            }
                            if (fx.panning) {
                                const pm = document.getElementById('panningMode');
                                if (pm) {
                                    pm.value = fx.panning.mode || 'center';
                                    pm.dispatchEvent(new Event('change'));
                                }
                                setVal('panningWidth', fx.panning.width, v => `${Math.round(v)}%`);
                                setVal('panningSpeed', fx.panning.speedMs, v => `${(Number(v)/1000).toFixed(1)}s`);
                            }
                        }
                        
                        // Update transpose UI label if present
                        try {
                            const deltaEl = document.getElementById('transposeDelta');
                            if (deltaEl && typeof this.transposeDelta === 'number') {
                                deltaEl.textContent = String(this.transposeDelta);
                            }
                        } catch(_) {}

                        // Checkboxes
                        if (sessionData.chordSlideEnabled !== undefined) {
                            const el = document.getElementById('chordSlide');
                            if (el) el.checked = sessionData.chordSlideEnabled;
                        }
                        
                        // FX Send checkboxes
                        if (sessionData.instruments) {
                            const checkboxes = [
                                ['strum1FxSend', sessionData.instruments.strum1?.fxSend],
                                ['strum2FxSend', sessionData.instruments.strum2?.fxSend],
                                ['chordFxSend', sessionData.instruments.chord?.fxSend],
                                ['arpFxSend', sessionData.instruments.arp?.fxSend],
                                ['bassFxSend', sessionData.instruments.bass?.fxSend]
                            ];
                            checkboxes.forEach(([id, value]) => {
                                if (value !== undefined) {
                                    const el = document.getElementById(id);
                                    if (el) el.checked = value;
                                }
                            });
                        }
                        
                        // Text input restoration
                        if (sessionData.textChordInput !== undefined) {
                            const el = document.getElementById('textChordInput');
                            if (el) el.value = sessionData.textChordInput;
                        }

                        // ==== DRUMS: RESTORE PATTERNS, ACTIVE SLOT, LANE CONTROLS, BASS ====
                        try {
                            const d = sessionData.drums || {};
                            // Restore pattern map then apply active pattern grid
                            if (d.patterns && typeof d.patterns === 'object') {
                                this._drumPatterns = new Map();
                                for (const k of Object.keys(d.patterns)) {
                                    const num = parseInt(k,10); if (!Number.isFinite(num) || num<1) continue;
                                    this._drumPatterns.set(num, d.patterns[k]);
                                }
                            }
                            const patEl = document.getElementById('drumPatternNumber');
                            if (patEl) {
                                const act = Math.max(1, parseInt((d.active!=null? d.active: patEl.value)||'1',10));
                                patEl.value = String(act);
                                // Apply grid for this pattern
                                const patt = this._drumPatterns ? this._drumPatterns.get(act) : null;
                                if (patt && Array.isArray(patt)) {
                                    const lanes = Array.from(document.querySelectorAll('.drum-row:not(.bass-row) .drum-lane'));
                                    lanes.forEach((lane, i)=>{
                                        const row = patt[i] || [];
                                        const steps = Array.from(lane.querySelectorAll('.drum-step'));
                                        steps.forEach((s, j)=>{ if (row[j]) s.classList.add('active'); else s.classList.remove('active'); });
                                    });
                                    this._lastDrumPatternNumber = act;
                                }
                            }
                            // Per-lane controls
                            if (Array.isArray(d.laneControls)) {
                                const rows = Array.from(document.querySelectorAll('.drum-row:not(.bass-row)'));
                                d.laneControls.forEach((cfg, idx)=>{
                                    const row = rows[idx]; if (!row || !cfg) return;
                                    try {
                                        const vol = row.querySelector('.drum-volume'); if (vol && cfg.vol!=null) vol.value = String(cfg.vol);
                                        const fx  = row.querySelector('.drum-fx input[type="checkbox"]'); if (fx && typeof cfg.fx==='boolean') fx.checked = cfg.fx;
                                        const midi= row.querySelector('.drum-midi input[type="text"]'); if (midi && cfg.midi!=null) midi.value = String(cfg.midi);
                                        const pPitch = row.querySelector('.drum-params input[title$=" Pitch"]'); if (pPitch && cfg.pPitch!=null) pPitch.value = String(cfg.pPitch);
                                        const pAtk   = row.querySelector('.drum-params input[title$=" Attack"]'); if (pAtk && cfg.pAtk!=null) pAtk.value = String(cfg.pAtk);
                                        const pDec   = row.querySelector('.drum-params input[title$=" Decay"]'); if (pDec && cfg.pDec!=null) pDec.value = String(cfg.pDec);
                                    } catch(_){}
                                });
                            }
                            // Bass NPC/ties
                            if (Array.isArray(d.bass)) {
                                const bassLane = document.querySelector('.drum-row.bass-row .drum-lane');
                                if (bassLane) {
                                    const steps = Array.from(bassLane.querySelectorAll('.drum-step'));
                                    steps.forEach((s, i)=>{
                                        const cfg = d.bass[i]; if (!cfg) { s.classList.remove('active'); s.dataset.npc=''; delete s.dataset.len; return; }
                                        s.dataset.npc = cfg.npc || '';
                                        if (cfg.len!=null && cfg.len!=='') s.dataset.len = String(cfg.len); else delete s.dataset.len;
                                        if (cfg.on || (cfg.npc && cfg.npc.toLowerCase()!=='x')) s.classList.add('active'); else s.classList.remove('active');
                                    });
                                    try { this.rebuildBassTieOverlays(bassLane); } catch(_){ }
                                }
                            }
                        } catch(_){ }

                        // ==== MIDI ROUTING RESTORATION (per-section OUT selections etc.) ====
                        try {
                            const m = sessionData.midi || {};
                            if (m && window.midi) {
                                if (m.outputPortMap) window.midi.outputPortMap = { ...(window.midi.outputPortMap||{}), ...m.outputPortMap };
                                if (m.inputChannelMap) window.midi.inputChannelMap = { ...(window.midi.inputChannelMap||{}), ...m.inputChannelMap };
                                if (m.perSourceOctave) window.midi.perSourceOctave = { ...(window.midi.perSourceOctave||{}), ...m.perSourceOctave };
                                if (m.perSourceVelocity) window.midi.perSourceVelocity = { ...(window.midi.perSourceVelocity||{}), ...m.perSourceVelocity };
                                if (Number.isFinite(m.defaultVelocity)) window.midi.defaultVelocity = m.defaultVelocity|0;
                                if (Number.isFinite(m.octaveOffset)) window.midi.octaveOffset = m.octaveOffset|0;
                                if (m.channelMap) window.midi.channelMap = { ...(window.midi.channelMap||{}), ...m.channelMap };
                                // Try to reflect OUT selects in UI immediately
                                try {
                                    ['strum1','strum2','chord','arp','bass','drum'].forEach(sec=>{
                                        const el = document.getElementById(`midiOut-${sec}`);
                                        if (el && el.tagName==='SELECT') {
                                            const id = window.midi.outputPortMap?.[sec] || '';
                                            el.value = id || '';
                                        }
                                    });
                                } catch(_){}
                            }
                        } catch(_){ }
                        
                        // ==== REGENERATE UI ====
                        this.regenerateChordGrid();
                        this.syncOscillatorUI();

                        // ---- SILENCE AFTER LOAD (prevent auto drum/arp start) ----
                        try {
                            // Stop any lingering voices
                            this.stopAll && this.stopAll();
                        } catch(_) {}
                        try { this.stopAllDrums && this.stopAllDrums(); } catch(_) {}
                        try { this._stopArpTransport && this._stopArpTransport(); } catch(_) {}
                        try { this._isSequencing = false; } catch(_) {}
                        try { this.isPlaying = false; } catch(_) {}
                        try { this.playMode = this.playMode; } catch(_) {}
                        // Clear any queued next chord / bass state
                        try { this._pendingArpChord = null; } catch(_){ }
                        try { this._heldBassVoice = null; } catch(_){ }
                        // Reflect play button UI if present
                        try {
                            const playBtn = document.getElementById('playButton');
                            if (playBtn) {
                                playBtn.classList.remove('active');
                                playBtn.textContent = 'PLAY';
                            }
                        } catch(_) {}
                        // Ensure drum transport indicator off
                        try {
                            const drumPlay = document.getElementById('drumPlayButton');
                            if (drumPlay) {
                                drumPlay.classList.remove('active');
                                drumPlay.textContent = 'DRUMS';
                            }
                        } catch(_) {}
                        // ---- END SILENCE AFTER LOAD ----

                        // ==== VISUAL CHORD SEQUENCE RESTORATION (if available) ====
                        if (sessionData.visualChordSequence && sessionData.visualChordSequence.length > 0) {
                            console.log('🎵 Restoring visual chord sequence:', sessionData.visualChordSequence.length, 'chords');
                            // The regenerateChordGrid() above should handle this through the restored chordExtensions
                        }
                        
                        console.log('✅ Session restoration completed (silent)');
                        // Optionally restart playback in a safe state (left stopped for user to decide)
                        
                    } catch (error) {
                        console.error('Error loading session file:', error);
                        alert('Error loading session: ' + error.message);
                    }
                };
                
                reader.readAsText(file);
            }
            // Legacy alias
            loadSessionFromOMG(event){ return this.importXenState(event); }
            
            syncOscillatorUI() {
                // Sync all oscillator and envelope UI elements with current state
                const syncOscUi = (num, data) => {
                    if (!data) return;
                    try {
                        // Wave type buttons
                        const waveButtons = document.querySelectorAll(`[data-osc="${num}"]`);
                        waveButtons.forEach(btn => btn.classList.remove('active'));
                        const activeWaveBtn = document.querySelector(`[data-osc="${num}"][data-wave="${data.type}"]`);
                        if (activeWaveBtn) activeWaveBtn.classList.add('active');
                        
                        // Level, Detune, Octave, Coarse sliders
                        const setSliderAndLabel = (sliderId, labelId, value, formatter) => {
                            const slider = document.getElementById(sliderId);
                            const label = document.getElementById(labelId);
                            if (slider) slider.value = String(value);
                            if (label && formatter) label.textContent = formatter(value);
                        };
                        
                        setSliderAndLabel(`osc${num}Level`, `osc${num}LevelValue`, Math.round(data.level * 10), v => `${v}`);
                        setSliderAndLabel(`osc${num}Detune`, `osc${num}DetuneValue`, data.detune, v => `${v}¢`);
                        setSliderAndLabel(`osc${num}Octave`, `osc${num}OctaveValue`, data.octave, v => `${v >= 0 ? '+' : ''}${v}`);
                        setSliderAndLabel(`osc${num}Coarse`, `osc${num}CoarseValue`, data.coarse, v => `${v >= 0 ? '+' : ''}${v}`);
                        setSliderAndLabel(`osc${num}PulseWidth`, `osc${num}PulseWidthValue`, Math.round(data.pulseWidth * 100), v => `${v}%`);
                        setSliderAndLabel(`osc${num}ShapeWidth`, `osc${num}ShapeWidthValue`, Math.round(data.shapeWidth * 100), v => `${v}%`);
                        
                        // Show/hide pulse width controls
                        const pulseWidthContainer = document.querySelector(`.pulse-width-container[data-osc="${num}"]`);
                        if (pulseWidthContainer) {
                            pulseWidthContainer.style.display = (data.type === 'pulse') ? 'block' : 'none';
                        }
                    } catch(e) {
                        console.error(`Error syncing osc${num} UI:`, e);
                    }
                };
                
                // Sync ADSR displays
                const syncADSR = (attackId, decayId, sustainId, releaseId, attackValId, decayValId, sustainValId, releaseValId, envData) => {
                    if (!envData) return;
                    try {
                        const setADSR = (id, valId, value, formatter) => {
                            const el = document.getElementById(id);
                            const valEl = document.getElementById(valId);
                            if (el) el.value = String(formatter ? formatter(value) : value);
                            if (valEl) valEl.textContent = formatter ? formatter(value) : String(value);
                        };
                        
                        setADSR(attackId, attackValId, envData.attack, v => Math.round(v * 1000));
                        setADSR(decayId, decayValId, envData.decay, v => Math.round(v * 1000));
                        setADSR(sustainId, sustainValId, envData.sustain, v => Math.round(v * 100));
                        setADSR(releaseId, releaseValId, envData.release, v => Math.round(v * 1000));
                    } catch(e) {
                        console.error('Error syncing ADSR UI:', e);
                    }
                };
                
                // Sync oscillators
                syncOscUi(1, this.oscillators.osc1);
                syncOscUi(2, this.oscillators.osc2);
                
                // Sync ADSR envelopes
                syncADSR('attackSlider', 'decaySlider', 'sustainSlider', 'releaseSlider',
                        'attackValue', 'decayValue', 'sustainValue', 'releaseValue', 
                        this.instruments.strum1.env);
                        
                syncADSR('osc2AttackSlider', 'osc2DecaySlider', 'osc2SustainSlider', 'osc2ReleaseSlider',
                        'osc2AttackValue', 'osc2DecayValue', 'osc2SustainValue', 'osc2ReleaseValue', 
                        this.instruments.strum2.env);
                        
                // Sync per-instrument ADSR
                if (this.instruments.chord) {
                    syncADSR('chordAttackSlider', 'chordDecaySlider', 'chordSustainSlider', 'chordReleaseSlider',
                            'chordAttackValue', 'chordDecayValue', 'chordSustainValue', 'chordReleaseValue', 
                            this.instruments.chord.env);
                }
                if (this.instruments.arp) {
                    syncADSR('arpAttackSlider', 'arpDecaySlider', 'arpSustainSlider', 'arpReleaseSlider',
                            'arpAttackValue', 'arpDecayValue', 'arpSustainValue', 'arpReleaseValue', 
                            this.instruments.arp.env);
                }
                if (this.instruments.bass) {
                    syncADSR('bassAttackSlider', 'bassDecaySlider', 'bassSustainSlider', 'bassReleaseSlider',
                            'bassAttackValue', 'bassDecayValue', 'bassSustainValue', 'bassReleaseValue', 
                            this.instruments.bass.env);
                }
                
                console.log('🎵 Oscillator and envelope UI synchronized');
            }

            importChordConfiguration(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);
                        
                        if (config.chordExtensions) {
                            this.chordExtensions = config.chordExtensions;
                        }
                        if (config.customChords) {
                            this.customChords = config.customChords;
                        }
                        if (config.hiddenColumns) {
                            this.hiddenColumns = config.hiddenColumns;
                        }
                        
                        this.saveChordConfiguration();
                        this.generateExtensionColumns();
                        
                        alert('Configuration imported successfully!');
                    } catch (error) {
                        alert('Error importing configuration: Invalid file format');
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = '';
            }

            resetToDefaults() {
                if (confirm('Reset completely? This will remove ALL chords and start fresh.')) {
                    // Clear all storage
                    
                    // Reset to completely empty state
                    this.chordExtensions = [];
                    this.customChords = [];
                    this.hiddenColumns = [];
                    this.lockedChords = new Map();
                    this.savedLockedChords = [];
                    this.currentEditingColumn = null;
                    
                    // Start in chord creation mode since no chords exist
                    this.enterChordCreationMode();
                    
                    alert('Reset complete - you can now create chords from scratch');
                }
            }

            hideColumn() {
                if (!this.hiddenColumns) this.hiddenColumns = [];
                const columnId = this.currentEditingColumn.id || this.currentEditingColumn.name.toLowerCase();
                
                if (!this.hiddenColumns.includes(columnId)) {
                    this.hiddenColumns.push(columnId);
                    this.generateExtensionColumns();
                }
            }

            addToFavorites() {
                if (!this.favoriteChords) this.favoriteChords = [];
                
                const favoriteChord = {
                    name: this.currentEditingColumn.name,
                    originalName: this.currentEditingColumn.originalName || this.currentEditingColumn.name,
                    extensions: this.currentEditingColumn.extensions || [],
                    quality: this.currentEditingColumn.quality,
                    intervals: this.currentEditingColumn.intervals,
                    root: this.currentRoot, // Store current root note
                    isCustom: this.currentEditingColumn.isCustom || false,
                    addedAt: Date.now()
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    fav.quality === favoriteChord.quality &&
                    fav.root === favoriteChord.root
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    this.generateExtensionColumns();
                    console.log(`Added "${favoriteChord.name}" to favorites with root ${this.getNoteNames()[favoriteChord.root]}`);
                } else {
                    alert('This chord with this root is already in favorites!');
                }
            }

            addCurrentChordToFavorites() {
                const chordName = document.getElementById('customChordName').value.trim();
                if (!chordName) {
                    alert('Please enter a chord name first!');
                    return;
                }
                
                const selectedNotes = this.getSelectedNotes();
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note!');
                    return;
                }
                
                if (!this.favoriteChords) this.favoriteChords = [];
                
                const favoriteChord = {
                    name: chordName,
                    originalName: chordName,
                    extensions: [],
                    quality: this.currentQuality,
                    intervals: selectedNotes,
                    notes: selectedNotes,
                    root: this.currentRoot,
                    isCustom: true,
                    addedAt: Date.now(),
                    tuning: this.currentTuning
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    fav.quality === favoriteChord.quality &&
                    fav.root === favoriteChord.root
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    this.updateFavoritesDisplay();
                    console.log(`Added "${favoriteChord.name}" to favorites`);
                    alert(`Added "${favoriteChord.name}" to favorites!`);
                } else {
                    alert('This chord is already in favorites!');
                }
            }
            
            updateFavoritesDisplay() {
                const favoritesList = document.getElementById('favoriteChordsList');
                if (!favoritesList) return;
                
                favoritesList.innerHTML = '';
                
                if (!this.favoriteChords || this.favoriteChords.length === 0) {
                    favoritesList.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #8fb3d3; font-style: italic; padding: 20px;">No favorite chords yet</div>';
                    return;
                }
                
                this.favoriteChords.forEach((chord, index) => {
                    const chordElement = document.createElement('div');
                    chordElement.style.cssText = `
                        background: linear-gradient(135deg, #f39c12, #e67e22);
                        border: 1px solid #d68910;
                        border-radius: 6px;
                        padding: 8px;
                        text-align: center;
                        cursor: pointer;
                        font-size: 12px;
                        color: #fff;
                        position: relative;
                        transition: all 0.2s ease;
                        user-select: none;
                    `;
                    
                    chordElement.innerHTML = `
                        <div style="font-weight: bold;">${chord.name}</div>
                        <div style="font-size: 10px; opacity: 0.8;">${this.getNoteNames()[chord.root] || 'C'} ${chord.quality}</div>
                        <div style="position: absolute; top: 2px; right: 2px; background: rgba(0,0,0,0.3); border-radius: 50%; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; font-size: 10px; cursor: pointer;" class="remove-favorite" data-index="${index}"> </div>
                    `;
                    
                    // Play chord on click
                    chordElement.addEventListener('click', (e) => {
                        if (e.target.classList.contains('remove-favorite')) return;
                        this.playChord(chord.intervals || chord.notes, chord.root);
                    });
                    
                    // Hover effects
                    chordElement.addEventListener('mouseenter', () => {
                        chordElement.style.transform = 'scale(1.05)';
                        chordElement.style.boxShadow = '0 4px 12px rgba(243, 156, 18, 0.4)';
                    });
                    
                    chordElement.addEventListener('mouseleave', () => {
                        chordElement.style.transform = 'scale(1)';
                        chordElement.style.boxShadow = 'none';
                    });
                    
                    favoritesList.appendChild(chordElement);
                });
                
                // Add remove functionality
                favoritesList.addEventListener('click', (e) => {
                    if (e.target.classList.contains('remove-favorite')) {
                        const index = parseInt(e.target.dataset.index);
                        this.removeFavoriteChord(index);
                    }
                });
            }
            
            removeFavoriteChord(index) {
                if (confirm('Remove this chord from favorites?')) {
                    this.favoriteChords.splice(index, 1);
                    this.updateFavoritesDisplay();
                }
            }
            
            getSelectedNotes() {
                const selector = document.getElementById('edoNoteSelector');
                if (!selector) return [];
                
                const selectedButtons = selector.querySelectorAll('.note-btn.selected');
                return Array.from(selectedButtons).map(btn => parseInt(btn.dataset.note));
            }

            removeFromFavorites() {
                if (this.currentEditingColumn.favoriteIndex !== undefined) {
                    const favoriteName = this.favoriteChords[this.currentEditingColumn.favoriteIndex].name;
                    this.favoriteChords.splice(this.currentEditingColumn.favoriteIndex, 1);
                    this.generateExtensionColumns();
                }
            }

            addToPalette() {
                if (!this.paletteChords) this.paletteChords = [];
                
                const noteNames = this.getNoteNames();
                const rootName = noteNames[this.currentRoot] || this.currentRoot;
                
                // Generate the actual chord intervals for this column
                let chordIntervals = [];
                if (this.currentEditingColumn.intervals && this.currentEditingColumn.intervals.length > 0) {
                    // Use stored intervals (for custom chords)
                    chordIntervals = this.currentEditingColumn.intervals;
                } else {
                    // Generate intervals from extensions and quality (for standard chords)
                    const originalQuality = this.currentQuality;
                    this.currentQuality = this.currentEditingColumn.quality || 'major';
                    chordIntervals = this.getChordIntervals(this.currentEditingColumn.extensions || []);
                    // Convert EDO steps back to semitones for storage
                    chordIntervals = chordIntervals.map(step => (step * 12) / this.currentTuning);
                    this.currentQuality = originalQuality;
                }
                
                const paletteChord = {
                    name: this.currentEditingColumn.name,
                    fullName: `${rootName}${this.currentEditingColumn.name}`,
                    extensions: this.currentEditingColumn.extensions || [],
                    quality: this.currentEditingColumn.quality || 'major',
                    rootNote: this.currentRoot,
                    originalName: this.currentEditingColumn.originalName || this.currentEditingColumn.name,
                    isCustom: this.currentEditingColumn.isCustom || false,
                    intervals: chordIntervals,
                    root: this.currentRoot,
                    lockedTuning: this.currentTuning,
                    lockedGamelanMode: this.gamelanMode
                };
                
                // Always allow adding chords to create sequences
                this.paletteChords.push(paletteChord);
                this.renderPaletteChords();
                console.log(`Added "${paletteChord.fullName}" to palette with intervals:`, chordIntervals);
            }

            deleteColumn() {
                console.log('?? deleteColumn called, currentEditingColumn:', this.currentEditingColumn);
                
                if (!this.currentEditingColumn) {
                    console.error('?? No currentEditingColumn set for deleteColumn');
                    alert('Error: No column selected for deletion');
                    return;
                }
                
                if (this.currentEditingColumn.isCustom) {
                    console.log('?? Deleting custom chord:', this.currentEditingColumn.name);
                    if (confirm(`Delete custom column "${this.currentEditingColumn.name}"?`)) {
                        const index = this.customChords.findIndex(chord => chord.name === this.currentEditingColumn.name);
                        console.log('?? Found custom chord at index:', index);
                        if (index !== -1) {
                            this.customChords.splice(index, 1);
                            console.log('?? Custom chord deleted, regenerating columns');
                            this.generateExtensionColumns();
                            // Custom chords automatically appear in extensions
                        } else {
                            console.error('?? Custom chord not found for deletion');
                            alert('Error: Custom chord not found for deletion');
                        }
                    }
                } else {
                    console.log('?? Deleting standard chord:', this.currentEditingColumn.originalName || this.currentEditingColumn.name);
                    // Allow deleting standard chord columns too
                    if (confirm(`Delete column "${this.currentEditingColumn.originalName || this.currentEditingColumn.name}"? This will remove all 3 flavors (Maj/Neu/Min) permanently.`)) {
                        // Use extension index if available, otherwise find by name
                        let index = -1;
                        if (this.currentEditingColumn.extensionIndex !== undefined) {
                            index = this.currentEditingColumn.extensionIndex;
                            console.log('?? Using extensionIndex:', index);
                        } else {
                            const searchName = this.currentEditingColumn.originalName || this.currentEditingColumn.name;
                            index = this.chordExtensions.findIndex(ext => 
                                ext.name === searchName || ext.name.toLowerCase() === searchName.toLowerCase()
                            );
                            console.log('?? Found extension by name at index:', index);
                        }
                        
                        if (index !== -1 && index < this.chordExtensions.length) {
                            console.log('?? Deleting chord extension at index:', index);
                            this.chordExtensions.splice(index, 1);
                            this.saveChordConfiguration();
                            this.generateExtensionColumns();
                            // Force rebuild of chord grid to eliminate gaps
                            this._rebuildChordGridAfterDeletion();
                            console.log(`?? Deleted chord extension at index ${index}`);
                        } else {
                            console.error('?? Could not find chord extension to delete:', this.currentEditingColumn);
                            alert('Error: Could not find chord extension to delete');
                        }
                    }
                }
            }

            // Enhanced method to rebuild chord grid and eliminate gaps after deletion
            _rebuildChordGridAfterDeletion() {
                try {
                    const container = document.getElementById('extensionColumns');
                    if (!container) return;
                    
                    console.log('🎵 Rebuilding chord grid after deletion');
                    
                    // Remove any empty columns or placeholders
                    const allElements = Array.from(container.children);
                    allElements.forEach(element => {
                        // Remove empty extension columns
                        if (element.classList.contains('extension-column')) {
                            const header = element.querySelector('.extension-header');
                            const strings = element.querySelector('.strings-column');
                            if (!header || !strings || !header.textContent.trim()) {
                                console.log('🎵 Removing empty chord column');
                                element.remove();
                            }
                        }
                    });
                    
                    // Regenerate the layout to ensure proper spacing and bracket positioning
                    setTimeout(() => {
                        this.generateExtensionColumns();
                        // Re-enable chord column drop zones
                        if (typeof makeChordColumnsDroppable === 'function') {
                            makeChordColumnsDroppable();
                        }
                        // Ensure chord visibility after rebuild
                        if (typeof ensureChordVisibility === 'function') {
                            ensureChordVisibility();
                        }
                    }, 50);
                } catch (e) {
                    console.error('Error rebuilding chord grid:', e);
                }
            }
            
            // Update bracket positions in data model after drag and drop
            _updateBracketPositions() {
                try {
                    const container = document.getElementById('extensionColumns');
                    if (!container) return;
                    
                    // Get current order of all elements
                    const elements = Array.from(container.children);
                    const newExtensions = [];
                    
                    elements.forEach((element, index) => {
                        if (element.classList.contains('extension-column')) {
                            // Find corresponding chord in data model
                            const header = element.querySelector('.extension-header');
                            if (header) {
                                const chordName = header.textContent.trim();
                                const existingChord = this.chordExtensions.find(ext => 
                                    ext.name === chordName && !ext.isRepeatMarker
                                );
                                if (existingChord) {
                                    newExtensions.push({...existingChord, position: newExtensions.length});
                                }
                            }
                        } else if (element.classList.contains('repeat-marker-column')) {
                            // Add bracket marker to data model
                            const markerText = element.textContent.trim();
                            const nestLevel = parseInt(element.dataset.nestLevel || '0');
                            const repeatCount = parseInt(element.dataset.repeatCount || '0');
                            
                            newExtensions.push({
                                name: markerText,
                                isCustom: true,
                                isRepeatMarker: true,
                                nestLevel: nestLevel,
                                repeatCount: repeatCount,
                                position: newExtensions.length
                            });
                        }
                    });
                    
                    // Update the data model
                    this.chordExtensions = newExtensions;
                    this.saveChordConfiguration();
                    
                    console.log('🎵 Updated bracket positions in data model');
                } catch (e) {
                    console.error('Error updating bracket positions:', e);
                }
            }

            // Bracket-aware navigation functionality for transport controls
            navigateChord(direction) {
                try {
                    const container = document.getElementById('extensionColumns');
                    if (!container) return;
                    
                    // Get all columns including bracket markers
                    const allElements = Array.from(container.querySelectorAll('.extension-column, .repeat-marker-column'));
                    const chordColumns = allElements.filter(el => el.classList.contains('extension-column'));
                    if (chordColumns.length === 0) return;
                    
                    // Find bracket sections - sections start after '[' markers
                    const bracketSections = [];
                    let currentSection = [];
                    
                    for (let i = 0; i < allElements.length; i++) {
                        const element = allElements[i];
                        
                        if (element.classList.contains('repeat-marker-column')) {
                            const text = element.textContent?.trim();
                            if (text === '[') {
                                // Start new section
                                if (currentSection.length > 0) {
                                    bracketSections.push(currentSection);
                                }
                                currentSection = [];
                            } else if (text === ']' || /^\]x\d+$/.test(text)) {
                                // End current section
                                if (currentSection.length > 0) {
                                    bracketSections.push(currentSection);
                                    currentSection = [];
                                }
                            }
                        } else if (element.classList.contains('extension-column')) {
                            // Add chord to current section
                            currentSection.push(element);
                        }
                    }
                    
                    // Add any remaining chords as final section
                    if (currentSection.length > 0) {
                        bracketSections.push(currentSection);
                    }
                    
                    // If no bracket sections found, fall back to all chords as one section
                    if (bracketSections.length === 0) {
                        bracketSections.push(chordColumns);
                    }
                    
                    // Find current section
                    let currentSectionIndex = -1;
                    const activeColumn = chordColumns.find(col => 
                        col.classList.contains('active') || col.classList.contains('playing')
                    );
                    
                    if (activeColumn) {
                        for (let i = 0; i < bracketSections.length; i++) {
                            if (bracketSections[i].includes(activeColumn)) {
                                currentSectionIndex = i;
                                break;
                            }
                        }
                    }
                    
                    // Calculate target section
                    let targetSectionIndex = currentSectionIndex + direction;
                    
                    // Handle looping
                    const loopEnabled = document.getElementById('playLoop')?.checked ?? true;
                    if (loopEnabled) {
                        if (targetSectionIndex >= bracketSections.length) {
                            targetSectionIndex = 0;
                        } else if (targetSectionIndex < 0) {
                            targetSectionIndex = bracketSections.length - 1;
                        }
                    } else {
                        if (targetSectionIndex >= bracketSections.length || targetSectionIndex < 0) {
                            return;
                        }
                    }
                    
                    // Clear previous active state
                    chordColumns.forEach(col => {
                        col.classList.remove('active', 'playing');
                    });
                    
                    // Activate first chord of target section
                    const targetSection = bracketSections[targetSectionIndex];
                    if (targetSection && targetSection.length > 0) {
                        const firstChord = targetSection[0];
                        firstChord.classList.add('active', 'playing');
                        
                        // Trigger chord sound if playing
                        if (this._arpTransport?.isRunning) {
                            firstChord.click();
                        }
                        
                        // Update visual feedback
                        firstChord.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'nearest',
                            inline: 'center'
                        });
                    }
                } catch (e) {
                    console.error('Error navigating chords:', e);
                }
            }

            // Override loop behavior to respect the loop toggle
            _checkLoopBehavior() {
                const loopToggle = document.getElementById('loopToggle');
                if (loopToggle && this._arpTransport) {
                    this._arpTransport.loopEnabled = loopToggle.checked;
                }
            }

            updateColumnInStorage() {
                if (this.currentEditingColumn.isCustom) {
                    const index = this.customChords.findIndex(chord => chord.name === this.currentEditingColumn.originalName || this.currentEditingColumn.name);
                    if (index !== -1) {
                        this.customChords[index].name = this.currentEditingColumn.name;
                        if (this.currentEditingColumn.intervals) {
                            this.customChords[index].notes = this.currentEditingColumn.intervals;
                        }
                    }
                }
            }

            // Chord Name Context Menu Methods
            hideChord() {
                this.pushState();
                console.log('?? hideChord called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for hideChord');
                    alert('Error: No chord selected for hiding');
                    return;
                }
                
                const chordId = this.currentEditingChord.id;
                if (!this.hiddenColumns.includes(chordId)) {
                    this.hiddenColumns.push(chordId);
                    this.generateExtensionColumns();
                    console.log(`?? Hidden chord: ${this.currentEditingChord.name}`);
                }
            }

            duplicateChord() {
                this.pushState();
                console.log('?? duplicateChord called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for duplicateChord');
                    alert('Error: No chord selected for duplication');
                    return;
                }
                
                // Create a duplicate chord
                const duplicateChord = {
                    name: this.currentEditingChord.name + ' Copy',
                    intervals: [...(this.currentEditingChord.intervals || [])],
                    isCustom: true,
                    id: 'custom_' + Date.now()
                };
                
                // Open chord builder with the duplicate
                this.showChordBuilder(duplicateChord);
            }

            editChord() {
                console.log('?? editChord called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for editChord');
                    alert('Error: No chord selected for editing');
                    return;
                }
                
                // Open chord builder with the current chord
                this.showChordBuilder(this.currentEditingChord);
            }

            copyToCustomChords() {
                console.log('?? copyToCustomChords called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for copyToCustomChords');
                    alert('Error: No chord selected for copying');
                    return;
                }
                
                // Get safe root note name
                const noteNames = this.getNoteNames();
                const rootIndex = this.currentEditingChord.root || this.currentRoot || 0;
                const rootName = noteNames[rootIndex] || `Note${rootIndex}`;
                
                console.log('?? Root details - index:', rootIndex, 'name:', rootName, 'noteNames:', noteNames);
                
                // Create a custom chord copy with root and tuning system
                const customChord = {
                    name: this.currentEditingChord.name + ` (${rootName})`,
                    notes: [...(this.currentEditingChord.intervals || [])],
                    id: Date.now()
                };
                
                console.log('?? Created customChord:', customChord);
                
                // Add to custom chords storage
                if (!this.customChords) this.customChords = [];
                this.customChords.push(customChord);
                
                // Add to palette for immediate use
                const paletteChord = {
                    name: customChord.name,
                    fullName: customChord.name,
                    extensions: [],
                    quality: 'custom',
                    id: 'custom_' + customChord.id,
                    isCustom: true,
                    originalName: customChord.name,
                    intervals: customChord.notes,
                    root: this.currentEditingChord.root || this.currentRoot || 0,
                    lockedTuning: this.currentEditingChord.tuning || this.currentTuning,
                    lockedGamelanMode: this.gamelanMode
                };
                
                console.log('?? Created paletteChord:', paletteChord);
                
                if (!this.paletteChords) this.paletteChords = [];
                this.paletteChords.push(paletteChord);
                
                // Regenerate everything
                this.generateExtensionColumns();
                this.renderPaletteChords();
                
                // Show success message
                alert(`Successfully copied "${customChord.name}" to custom palette!`);
                
                console.log(`?? Copied chord "${customChord.name}" to custom chords and palette`);
            }

            getNotesFromExtensions(extensions) {
                // Convert chord extensions to note intervals
                const intervals = this.getChordIntervals(extensions);
                return intervals;
            }

            // =============================================================================
            // =============================================================================
            
            // OLD: showColumnModal(), showCustomChordModal(), saveCustomChord()
            // NEW: All functionality moved to unified ChordBuilder module above
            
            toggleColumnVisibility(columnId, visible) {
                if (visible) {
                    this.hiddenColumns = this.hiddenColumns.filter(id => id !== columnId);
                } else {
                    if (!this.hiddenColumns.includes(columnId)) {
                        this.hiddenColumns.push(columnId);
                    }
                }
                this.generateExtensionColumns();
            }

            deleteCustomChord(index) {
                if (confirm('Delete this custom chord?')) {
                    this.customChords.splice(index, 1);
                    this.generateExtensionColumns();
                }
            }

            updateChordDisplay() {
            }

            translateSemitoneToTuning(semitone) {
                // Translate 12-TET semitone to nearest step in current tuning
                // This ensures custom chords sound close in different tunings
                const exactStep = (semitone / 12) * this.currentTuning;
                return Math.round(exactStep) % this.currentTuning;
            }

            generateRootButtons() {
                const rootGrid = document.getElementById('rootGrid');
                if (!rootGrid) return;
                // Create or reuse a keyboard row containing left transpose controls + keyboard
                let row = rootGrid.querySelector('.keyboard-row');
                if (!row) {
                    row = document.createElement('div');
                    row.className = 'keyboard-row';
                    rootGrid.appendChild(row);
                }
                
                // Reuse existing keyboard element to avoid layout shift flicker
                let keyboard = row.querySelector('.piano-keyboard');
                if (!keyboard) {
                    // First-time creation
                    keyboard = document.createElement('div');
                    keyboard.className = 'piano-keyboard';
                    // Drag hint
                    const hint = document.createElement('div');
                    hint.className = 'drag-hint';
                    hint.textContent = 'drag ← →';
                    keyboard.appendChild(hint);
                    row.appendChild(keyboard);
                } else {
                    // Clear dynamic children (keys + dots) only
                    keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn, .edo-dot').forEach(el=> el.remove());
                    if (!keyboard.querySelector('.drag-hint')) {
                        const hint = document.createElement('div');
                        hint.className = 'drag-hint';
                        hint.textContent = 'drag ← →';
                        keyboard.appendChild(hint);
                    }
                }

                // Attach drag-to-rotate across all EDOs (cyclic modulo currentTuning)
                if (!keyboard.dataset.rotateBound) {
                    keyboard.dataset.rotateBound = '1';
                    let dragging = false; let startX = 0; let startRot = 0;
                    const applyDrag = (dx)=>{
                        const stepPx = Math.max(12, (keyboard.clientWidth || 600) / 12);
                        // Keep discrete steps but compute continuously, then round once
                        const delta = -Math.round(dx / stepPx);
                        const edo = this.currentTuning || 12;
                        let next = ((startRot + delta) % edo + edo) % edo;
                        if (next !== this.keyboardRotation) {
                            this.keyboardRotation = next;
                            this.generateRootButtons();
                            if (this.chordCreationMode) { this.setupIntervalSelection(); this.updatePreviewChordColumn(); }
                            if (this.currentActiveColumnEl) this.highlightKeyboardForColumn(this.currentActiveColumnEl);
                        }
                    };
                    keyboard.addEventListener('mousedown', (e)=>{ dragging=true; keyboard.classList.add('is-dragging'); startX=e.clientX; startRot=this.keyboardRotation|0; });
                    window.addEventListener('mousemove', (e)=>{ if(!dragging) return; applyDrag(e.clientX - startX); });
                    window.addEventListener('mouseup', ()=>{ dragging=false; keyboard.classList.remove('is-dragging'); });
                    keyboard.addEventListener('touchstart', (e)=>{ dragging=true; keyboard.classList.add('is-dragging'); startX=e.touches[0].clientX; startRot=this.keyboardRotation|0; }, {passive:false});
                    window.addEventListener('touchmove', (e)=>{ if(!dragging) return; applyDrag(e.touches[0].clientX - startX); }, {passive:false});
                    window.addEventListener('touchend', ()=>{ dragging=false; keyboard.classList.remove('is-dragging'); }, {passive:false});
                }

                if (this.gamelanMode) {
                    const noteNames = this.getNoteNames();
                    for (let i = 0; i < this.currentTuning; i++) {
                        const b = document.createElement('div');
                        b.className = 'root-btn';
                        b.textContent = noteNames[i] || i;
                        b.addEventListener('click', async ()=>{
                            const ok = await this.ensureAudioContext();
                            if (ok) {
                                const f = this.getFrequency(i % this.currentTuning, 4, this.currentTuning);
                                
                                // Route to MIDI or oscillators based on midiEnabled flag
                                if (this.midiEnabled && this.midi) {
                                    // Send to MIDI output
                                    const midiNote = Math.round(12 * Math.log2(f / 440) + 69); // A4=440Hz=MIDI 69
                                    this.midi.sendNoteOn(midiNote, 100, 1); // velocity 100, channel 1
                                    console.log('MIDI routing: sent note', midiNote, 'for frequency', f, 'Hz');
                                } else {
                                    // Send to oscillators (default behavior)
                                    this.playFrequency(f, null, 'chord');
                                    console.log('Oscillator routing: playing frequency', f, 'Hz');
                                }
                            }
                            const activeCol = this.getActiveColumnElement?.();
                            if (activeCol && this.editArmed) {
                                // Use the effective step for chord editing
                                this.toggleNoteInActiveChord(i % this.currentTuning);
                                this._scheduleEditSave(activeCol);
                            }
                            this._scheduleEditArm();
                        });
                        rootGrid.appendChild(b);
                    }
                    return;
                }

                // Piano layout definitions
                const whiteOrder = [0,2,4,5,7,9,11]; // semitone numbers for C D E F G A B
                const whiteLabels = ['C','D','E','F','G','A','B'];
                const blackMap = { 1:'C#',3:'D#',6:'F#',8:'G#',10:'A#' };
                const blackPositionsRelativeToWhite = {1:0,3:1,6:3,8:4,10:5}; // index of white to left

                // Precompute cent positions of all current tuning steps (0..currentTuning-1)
                const stepCents = Array.from({length:this.currentTuning},(_,i)=> this.getCentValue(i));

                // Map each tuning step to nearest 12TET semitone (0..11)
                const semitoneCenters = Array.from({length:12},(_,i)=> i*100);
                const stepToSemitone = stepCents.map(c=>{
                    let best=0; let mind=Infinity;
                    for (let s=0;s<12;s++){const d=Math.abs(c-semitoneCenters[s]); if(d<mind){mind=d;best=s;}}
                    return {cent:c, step: c/ (1200/ this.currentTuning), idx:best, dist:mind};
                });

                // For deciding which standard keys (white/black) are represented by an EDO step
                const threshold = 35; // cents tolerance to claim a semitone
                const semitoneHasStep = new Array(12).fill(false);
                stepToSemitone.forEach(o=>{ if(o.dist<=threshold) semitoneHasStep[o.idx]=true; });

                // keyboard already prepared above
                // Dynamic width scaling for higher EDO counts
                this.adjustKeyboardWidth(keyboard);


                // Pick representative step for each claimed semitone (closest)
                const semitoneToStep = new Array(12).fill(null);
                for (let s=0;s<12;s++){
                    let best=null; let mind=Infinity;
                    stepToSemitone.forEach(o=>{ if(o.idx===s && o.dist < mind){ mind=o.dist; best=o; }});
                    semitoneToStep[s]=best; // may be null
                }

                // Horizontal positions for 7 white circles equally spaced across width
                const whiteCenters = whiteOrder.map((_,i)=> ( (i+0.5)/7 )*100 );
                let centersUsed = whiteCenters.slice();

                // Uniform-slot keyboard for all EDOs: 12 visual slots that rotate, keys map to nearest EDO steps
                const edo = this.currentTuning || 12;
                const rotBase = (this.keyboardRotation||0) % 12; // visual rotation in 12 slots
                const slotCenters = Array.from({length:12},(_,i)=> ((i+0.5)/12)*100);
                centersUsed = slotCenters.slice();
                // Track which EFFECTIVE steps are already used to avoid duplicates across keys/dots
                const usedEffSteps = new Set();
                for (let i = 0; i < 12; i++) {
                    const semi = (rotBase + i) % 12; // visual semitone
                    // find nearest step for this semitone in current EDO
                    let stepIndex;
                    if (edo === 12) stepIndex = semi;
                    else stepIndex = this.findNearestStepForSemitone(semi, stepCents);
                    const isWhite = whiteOrder.includes(semi);
                    const el = document.createElement('div');
                    el.className = (isWhite? 'white-key' : 'black-key') + ' root-btn';
            // Store the EFFECTIVE step (what you hear) so selection and glow match labels
                    el.dataset.semitone = semi;
                    // no persistent 'active' highlight for root; only chord-tone glow handled elsewhere
                    el.style.left = slotCenters[i] + '%';
                    // Label reflects global transpose so keys show what you hear
                    const effStep = ((stepIndex + (this.transposeDelta||0)) % edo + edo) % edo;
                    // Record the key's effective step to prevent duplicate dots, but never alter the key mapping
                    usedEffSteps.add(effStep);
        el.dataset.step = effStep;
        el.dataset.originalStep = stepIndex; // Store original step for chord editing
            // Use EDO naming tables so keyboard labels match chord enharmonics
            el.textContent = this.getRootNameForStep(effStep, edo);
                    // Prevent multiple event listeners
                    if (!el.dataset.clickHandlerAttached) {
                        el.dataset.clickHandlerAttached = 'true';
                    el.addEventListener('click', async (ev)=>{
                        console.log('KEYBOARD CLICK HANDLER: Using effective step for chord editing');
                        console.log('CLICK DEBUG: el.dataset.step =', el.dataset.step, 'el.dataset.originalStep =', el.dataset.originalStep);
                        console.log('CLICK DEBUG: this.transposeDelta =', this.transposeDelta);
                        try { ev.stopPropagation(); ev.stopImmediatePropagation && ev.stopImmediatePropagation(); } catch(_){ }
                        // mark interaction and ensure audio; keep editArmed state
                        this.userInteracted = true;
                        // Clear preview highlight if any immediately
                        this.previewInterval = null;
                        try { document.querySelectorAll('#rootGrid [data-step].preview').forEach(x=> x.classList.remove('preview')); } catch {}
                        try { this.updateIntervalButtons(); } catch {}
                        let activeCol = this.getActiveColumnElement?.();
                        if (!activeCol) { activeCol = document.querySelector('.extension-column'); if (activeCol) this.currentActiveColumnEl = activeCol; }
                        const ok = await this.ensureAudioContext();
                        if (ok) {
                const eff = parseInt(el.dataset.step,10);
                const f = this.getFrequency(eff, 4, edo);
                            
                            // Route to MIDI or oscillators based on midiEnabled flag
                            if (this.midiEnabled && this.midi) {
                                // Send to MIDI output
                                const midiNote = Math.round(12 * Math.log2(f / 440) + 69); // A4=440Hz=MIDI 69
                                this.midi.sendNoteOn(midiNote, 100, 1); // velocity 100, channel 1
                                console.log('Piano MIDI routing: sent note', midiNote, 'for frequency', f, 'Hz');
                            } else {
                                // Send to oscillators (default behavior)
                                this.playFrequency(f, null, 'chord');
                                console.log('Piano oscillator routing: playing frequency', f, 'Hz');
                            }
                        }
                        // Use effective step so clicks match what you hear (accounts for transpose)
                        const effectiveStep = parseInt(el.dataset.step,10);
                        console.log('CHORD EDIT: effectiveStep =', effectiveStep);
                        if (activeCol) {
                            this.toggleNoteInActiveChord(effectiveStep);
                            this._scheduleEditSave(activeCol);
                        } else {
                            // No active column, just arm editing for soon
                            this._scheduleEditArm();
                        }
                    });
                    }
                    keyboard.appendChild(el);
                }

                // For non-12 EDO, place micro dots between the current rotated semitone slots
                if (this.currentTuning !== 12) {
                    // Build a mapping from semitone -> slot center based on current rotation
                    const centersBySemitone = {};
                    for (let i = 0; i < 12; i++) {
                        const semi = (rotBase + i) % 12;
                        centersBySemitone[semi] = slotCenters[i];
                    }

            // Helper to add a micro dot at a fractional position between two adjacent slots
            // stepIndex is the exact EDO step we want this dot to represent (no nearest rounding)
        const addMicroDot = (s, frac01, color, stepIndex) => {
                        // j is the slot index for semitone s in the rotated view
                        const j = ((s - rotBase) % 12 + 12) % 12;
                        const jNext = (j + 1) % 12;
                        let leftPct = slotCenters[j];
                        let rightPct = slotCenters[jNext];
                        // Handle wrap-around across 100% -> 0%
                        if (rightPct < leftPct) rightPct += 100;
            let pct = leftPct + (rightPct - leftPct) * frac01;
                        if (pct >= 100) pct -= 100;

                        // Create the dot element and map it to the nearest EDO step inside this gap
                        const d = document.createElement('div');
            d.className = `edo-dot ${color}`; // inline style will set vertical position precisely
                        d.style.left = pct + '%';
            // Vertically position dot based on cents offset: 0c at topBound, 50c centered, 100c at bottomBound
            const topBound = 36;   // percent from top of keyboard
            const bottomBound = 64; // percent from top
            const topPct = topBound + (bottomBound - topBound) * Math.min(Math.max(frac01, 0), 1);
            d.style.top = topPct + '%';
        let effStep = ((stepIndex + (this.transposeDelta||0)) % this.currentTuning + this.currentTuning)%this.currentTuning;
        // Skip creating a dot if its effective step is already represented (avoid duplicates like E^ and Ev coupling)
        if (usedEffSteps.has(effStep)) return;
        usedEffSteps.add(effStep);
            // Store effective step so click and highlight align with label
            d.dataset.step = effStep;
            d.dataset.originalStep = stepIndex; // Store original step for chord editing
            // Use EDO naming tables for micro-step dots as well
            d.textContent = this.getRootNameForStep(effStep, edo);
                        d.title = `${d.textContent}`;
                        // Prevent multiple event listeners
                        if (!d.dataset.clickHandlerAttached) {
                            d.dataset.clickHandlerAttached = 'true';
                        d.addEventListener('click', async (ev)=>{
                            try { ev.stopPropagation(); ev.stopImmediatePropagation && ev.stopImmediatePropagation(); } catch(_){ }
                            let activeCol = this.getActiveColumnElement?.();
                            if (!activeCol) { activeCol = document.querySelector('.extension-column'); if (activeCol) this.currentActiveColumnEl = activeCol; }
                            // Clear preview highlight if any immediately
                            this.previewInterval = null;
                            try { document.querySelectorAll('#rootGrid [data-step].preview').forEach(x=> x.classList.remove('preview')); } catch {}
                            try { this.updateIntervalButtons(); } catch {}
                            const ok = await this.ensureAudioContext();
                            if (ok) {
                const eff = parseInt(d.dataset.step,10);
                const f = this.getFrequency(eff, 4, this.currentTuning);
                                this.playFrequency(f, null, 'chord');
                            }
                            // Use effective step so clicks match what you hear (accounts for transpose)
                            const effectiveStep = parseInt(d.dataset.step,10);
                            console.log('MICRO DOT EDIT: effectiveStep =', effectiveStep);
                            if (activeCol) {
                                this.toggleNoteInActiveChord(effectiveStep);
                                this._scheduleEditSave(activeCol);
                            } else {
                                this._scheduleEditArm();
                            }
                        });
                        }
                        keyboard.appendChild(d);
                    };

                    // Determine which EDO steps already claimed a main 12-slot key
                    const claimedSteps = new Set();
                    semitoneToStep.forEach(rep=>{ if(rep) claimedSteps.add(Math.round(rep.step)); });

                    // Iterate each 12-TET gap in cents space and drop dots between its rotated slots
                    const whiteSemis = new Set([0,2,4,5,7,9,11]);
                    const blackSemis = new Set([1,3,6,8,10]);
                    for (let s = 0; s < 12; s++) {
                        const nextSemi = (s + 1) % 12;
                        const gapStartCent = s * 100;
                        const gapEndCent = ((s + 1) % 12) * 100;
                        // Collect EDO steps whose cents fall strictly inside this 12-TET gap
                        const candidates = [];
                        stepCents.forEach((c,i)=>{
                            const cent = c % 1200;
                            // Handle wrap for 11->0 gap by treating end at 1200
                            if (s === 11) {
                                if (cent > 1100 && cent < 1200 && !claimedSteps.has(i)) {
                                    candidates.push({cent, offset: cent - 1100, step: i});
                                }
                            } else {
                                if (cent > gapStartCent && cent < gapEndCent && !claimedSteps.has(i)) {
                                    candidates.push({cent, offset: cent - gapStartCent, step: i});
                                }
                            }
                        });
                        if (!candidates.length) continue;
                        candidates.sort((a,b)=> a.offset - b.offset);

                        // Map each candidate to a fraction within the 0-100c gap
                        const fracs = candidates.map(c => ({...c, frac: c.offset/100}));
                        // Find the one nearest 50c (0.5) to be the neutral green
                        let greenIdx = 0; let minDist = Infinity;
                        fracs.forEach((c,idx)=>{ const d = Math.abs(c.frac - 0.5); if (d < minDist){ minDist = d; greenIdx = idx; } });
                        // Add the green neutral dot first, centered vertically (handled in addMicroDot)
                        const g = fracs[greenIdx];
                        if (g) addMicroDot(s, Math.min(Math.max(g.frac, 0.02), 0.98), 'green', g.step);
                        // Dots below 50c are blue, above are red
                        fracs.forEach((c,idx)=>{
                            if (idx === greenIdx) return;
                            const color = (c.frac < 0.5) ? 'blue' : 'red';
                            addMicroDot(s, Math.min(Math.max(c.frac, 0.02), 0.98), color, c.step);
                        });
                    }
                }
                // After constructing all keys, resize to fit; skip dot overlap fixes in 12EDO
                this.resizeKeyboardKeys(keyboard, centersUsed);
                if (this.currentTuning !== 12) {
                    this.adjustForDotOverlap(keyboard);
                    this.resizeDotsToKeySize(keyboard);
                }
                // Edge fade and dot/link exclusions
                this.applyDotEdgeFadeAndExclusions(keyboard);
                // Reapply highlight if a chord is currently active
                try {
                    const activeCol = this.getActiveColumnElement?.();
                    if (activeCol) this.highlightKeyboardForColumn(activeCol);
                } catch(_){}

                // If in creation mode, re-bind interval selection to include new UI and reflect state
                if (this.chordCreationMode) {
                    this.setupIntervalSelection();
                    this.updatePreviewChordColumn();
                }
            }

            getNoteNames() {
                if (this.gamelanMode) {
                    // Gamelan pelog note names
                    return ['Bem', 'Gulu', 'Dada', 'Pelog', 'Lima', 'Nem', 'Barang'];
                }
                
                // Use EDO-specific naming tables for 5–24; fallback to arrow notation otherwise
                const names = [];
                for (let i = 0; i < this.currentTuning; i++) {
                    names.push(this.getRootNameForStep(i, this.currentTuning));
                }
                return names;
            }

            getCentValue(step, tuning = null) {
                const currentTuning = tuning || this.currentTuning;
                console.log('getCentValue called with step:', step, 'tuning:', tuning, 'gamelanMode:', this.gamelanMode, 'currentTuning:', currentTuning);
                
                if (this.gamelanMode) {
                    // Gamelan pelog scale approximation in cents from root
                    const gamelanCents = [0, 136, 348, 560, 704, 840, 1056]; // 7-note pelog scale
                    const result = gamelanCents[step % 7] + (Math.floor(step / 7) * 1200);
                    console.log('gamelan cents result:', result);
                    return result;
                }
                const result = (step * 1200) / currentTuning;
                console.log('equal temperament cents result:', result);
                return result;
            }

            // Find nearest EDO step (index) whose cent value is closest to a given 12-TET semitone center
            findNearestStepForSemitone(semitone, stepCents){
                const targetCent = semitone * 100;
                let bestIdx = 0; let bestDist = Infinity;
                stepCents.forEach((c,i)=>{
                    const dist = Math.abs((c%1200) - targetCent);
                    if(dist < bestDist){ bestDist = dist; bestIdx = i; }
                });
                return bestIdx;
            }

            // Dynamically resize circular keys to avoid overflow and keep everything after first C
            resizeKeyboardKeys(keyboard, whiteCenters){
                if(!keyboard || !whiteCenters || whiteCenters.length < 2) return;
                const kbWidth = (keyboard.clientWidth || 1000);
                const edo = this.currentTuning || 12;
                const densityFactor = edo/12;
                let diameter = 70 / densityFactor;
                const spacingPct = whiteCenters[1]-whiteCenters[0];
                const spacingPx = (spacingPct/100) * kbWidth;
                diameter = Math.min(diameter, spacingPx * 0.85);
                const minReadable = edo >= 72 ? 12 : 16;
                if (diameter < minReadable) diameter = minReadable;
                this.currentKeyDiameter = diameter;
                const renderD = diameter;
                keyboard.querySelectorAll('.white-key.root-btn').forEach(el=>{
                    el.style.width = renderD + 'px';
                    el.style.height = renderD + 'px';
                });
                keyboard.querySelectorAll('.black-key.root-btn').forEach(el=>{
                    el.style.width = renderD + 'px';
                    el.style.height = renderD + 'px';
                });
                keyboard.querySelectorAll('.edo-dot').forEach(el=>{
                    const dotD = renderD * 0.55;
                    el.style.width = dotD + 'px';
                    el.style.height = dotD + 'px';
                });
            }

            // Widen keyboard proportionally with EDO so higher divisions have more horizontal space
            adjustKeyboardWidth(keyboard){
                if(!keyboard) return;
            }

            // Detect dot/key overlaps; shrink keys globally until all dots clear or min size reached
            adjustForDotOverlap(keyboard){
                if(!keyboard) return;
                const kbWidth = keyboard.clientWidth || 1000;
                const percentPerPx = 100 / kbWidth;
                const padPx = 2;
                const dotRadiusPx = 10; // 20px diameter per CSS
                let diameter = this.currentKeyDiameter || 70;
                const minDiameter = 34;
                const dots = Array.from(keyboard.querySelectorAll('.edo-dot'));
                if(!dots.length) return;
                const getOverlapExists = ()=>{
                    const keyCenters = [];
                    keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn').forEach(k=>{
                        const leftPct = parseFloat(k.style.left);
                        keyCenters.push(leftPct);
                    });
                    const keyRadiusPct = (diameter/2) * percentPerPx;
                    const dotRadiusPct = dotRadiusPx * percentPerPx;
                    const padPct = padPx * percentPerPx;
                    for(const d of dots){
                        const dPct = parseFloat(d.style.left);
                        for(const kc of keyCenters){
                            if (Math.abs(dPct - kc) < (keyRadiusPct + dotRadiusPct + padPct)){
                                return true;
                            }
                        }
                    }
                    return false;
                };
                let guard=0;
                while(getOverlapExists() && diameter>minDiameter && guard<20){
                    guard++;
                    diameter -= 3; // shrink step
                    this.currentKeyDiameter = diameter;
                    // Use the same scale logic as in resizeKeyboardKeys
                    const renderD = diameter;
                    keyboard.querySelectorAll('.white-key.root-btn').forEach(el=>{
                        el.style.width = renderD + 'px';
                        el.style.height = renderD + 'px';
                    });
                    keyboard.querySelectorAll('.black-key.root-btn').forEach(el=>{
                        el.style.width = renderD + 'px';
                        el.style.height = renderD + 'px';
                    });
                }
             }

            // Fade out dots near left/right edges
            applyDotEdgeFadeAndExclusions(keyboard) {
                if (!keyboard) return;
                const dots = Array.from(keyboard.querySelectorAll('.edo-dot'));
                if (!dots.length) return;
                // Compute fade based on percent from edges
                const edgeWidthPct = 6; // within 6% from either edge start fading
                dots.forEach(d => {
                    const left = parseFloat(d.style.left || '0');
                    const distToEdge = Math.min(left, 100 - left);
                    let alpha = 1.0;
                    if (distToEdge < edgeWidthPct) {
                        alpha = Math.max(0, distToEdge / edgeWidthPct);
                    }
                    d.style.opacity = String(alpha);
                });
                // no brand exclusion
            }

            // Reposition all key & dot centers to be perfectly equidistant while preserving ordering
            enforceEquidistantCenters(keyboard){
                if(!keyboard) return;
                const all = Array.from(keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn, .edo-dot'));
                if(all.length < 2) return;
                // Sort by current left
                all.sort((a,b)=> parseFloat(a.style.left) - parseFloat(b.style.left));
                // Determine first C (white key with label starting C) to lock at current position
                const firstCEl = all.find(el=> el.classList.contains('white-key') && /C/.test(el.textContent));
                const firstLeft = firstCEl ? parseFloat(firstCEl.style.left) : parseFloat(all[0].style.left);
                const lastEl = all[all.length-1];
                const lastLeft = parseFloat(lastEl.style.left);
                if (lastLeft <= firstLeft) return;
                // If any element already exceeds 100%, abort normalization (shouldn't happen after earlier clamps)
                if (all.some(el=> parseFloat(el.style.left) > 100)) return;
                const span = lastLeft - firstLeft;
                const uniformGap = span / (all.length - 1);
                all.forEach((el,idx)=>{
                    if (el===firstCEl || el===lastEl) return; // lock ends
                    const newLeft = firstLeft + idx*uniformGap;
                    // Safety clamp
                    el.style.left = Math.min(99.5, Math.max(firstLeft, newLeft)) + '%';
                });
            }

            // Make colored micro dots same diameter as (reduced) black/white keys for easier tapping
            resizeDotsToKeySize(keyboard){
                if(!keyboard) return;
                const diameter = (this.currentKeyDiameter || 70) * 0.97; // match black key size
                keyboard.querySelectorAll('.edo-dot').forEach(dot=>{
                    dot.style.width = diameter + 'px';
                    dot.style.height = diameter + 'px';
                    dot.style.lineHeight = diameter + 'px';
                    // Adjust font size relative to diameter
                    const fs = Math.max(10, Math.min(14, diameter * 0.22));
                    dot.style.fontSize = fs + 'px';
                });
            }

            getFrequency(step, octave = 4, tuning = null) {
                
                const cents = this.getCentValue(step, tuning);
                console.log('cents calculated:', cents);
                
                // Use C4 as base frequency (261.626 Hz) since step 0 = C
                const baseFreq = 261.626 * Math.pow(2, (octave - 4)); // C4 = 261.626Hz
                console.log('baseFreq calculated:', baseFreq);
                
                const finalFreq = baseFreq * Math.pow(2, cents / 1200);
                console.log('finalFreq calculated:', finalFreq);
                
                if (isNaN(finalFreq)) {
                    console.error('NaN frequency detected! step:', step, 'octave:', octave, 'cents:', cents, 'baseFreq:', baseFreq);
                }
                
                return finalFreq;
            }

            generateChordPattern(extensions) {
                // Generate a pattern of chord intervals
                const intervals = this.getChordIntervals(extensions);
                return intervals;
            }

            getTuningDivisions() {
                return this.currentTuning;
            }

            getNoteName(noteIndex) {
                if (noteIndex === undefined || noteIndex === null) {
                    return 'C'; // Default to C if undefined
                }
                const noteNames = this.getNoteNames();
                return noteNames[noteIndex] || noteIndex.toString();
            }

            getChordIntervals(extensions = []) {
                let intervals = [0]; // Root
                
                // Base triad
                switch (this.currentQuality) {
                    case 'major':
                        intervals.push(Math.round(4 * this.currentTuning / 12)); // Major third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                    case 'minor':
                        intervals.push(Math.round(3 * this.currentTuning / 12)); // Minor third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                    case 'neutral':
                        intervals.push(Math.round(3.5 * this.currentTuning / 12)); // Neutral third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                }
                
                // Apply extensions
                extensions.forEach(ext => {
                    switch (ext) {
                        case '6':
                            intervals.push(Math.round(9 * this.currentTuning / 12));
                            break;
                        case '7':
                            intervals.push(Math.round(10 * this.currentTuning / 12));
                            break;
                        case 'maj7':
                            intervals.push(Math.round(11 * this.currentTuning / 12));
                            break;
                        case '9':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // Add 7th first
                            intervals.push(Math.round(14 * this.currentTuning / 12)); // Then 9th
                            break;
                        case 'sus2':
                            intervals = intervals.filter(i => i !== Math.round(4 * this.currentTuning / 12) && i !== Math.round(3 * this.currentTuning / 12) && i !== Math.round(3.5 * this.currentTuning / 12));
                            intervals.push(Math.round(2 * this.currentTuning / 12));
                            break;
                        case 'sus4':
                            intervals = intervals.filter(i => i !== Math.round(4 * this.currentTuning / 12) && i !== Math.round(3 * this.currentTuning / 12) && i !== Math.round(3.5 * this.currentTuning / 12));
                            intervals.push(Math.round(5 * this.currentTuning / 12));
                            break;
                        case 'add9':
                            intervals.push(Math.round(14 * this.currentTuning / 12));
                            break;
                        case '13':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // Add 7th
                            intervals.push(Math.round(21 * this.currentTuning / 12)); // Add 13th
                            break;
                        case '#11':
                            intervals.push(Math.round(18 * this.currentTuning / 12)); // #11
                            break;
                        case '7#9':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // 7th
                            intervals.push(Math.round(15 * this.currentTuning / 12)); // #9 (raised 9th)
                            break;
                        case '#9':
                            intervals.push(Math.round(15 * this.currentTuning / 12)); // #9 (raised 9th)
                            break;
                        case 'n7':
                            intervals.push(Math.round(10.5 * this.currentTuning / 12)); // neutral 7th
                            break;
                        case 'n11':
                            intervals.push(Math.round(16.5 * this.currentTuning / 12)); // neutral 11th
                            break;
                    }
                });
                
                return [...new Set(intervals)].sort((a, b) => a - b);
            }

            // Build the visible sequence string from current columns, preserving sections "|"
            buildCurrentSequenceString(includeSections = true) {
                const cols = Array.from(document.querySelectorAll('#extensionColumns .extension-column'));
                const parts = [];
                cols.forEach(col => {
                    const nameEl = col.querySelector('.extension-header .chord-name');
                    if (!nameEl) return;
                    const t = (nameEl.dataset.lockedName || nameEl.textContent || '').trim();
                    if (!t) return;
                    if (t === '|' || col.dataset.chordId === '__SECTION__') {
                        if (includeSections) parts.push('|');
                    } else {
                        parts.push(t);
                    }
                });
                return parts.join(' ');
            }
            
            regenerateAllColumnsPreservingLocks() {
                console.log('?? Regenerating all columns while preserving locked chord settings');
                
                // Get all current columns
                const container = document.getElementById('extensionColumns');
                const allColumns = Array.from(container.querySelectorAll('.extension-column'));
                
                // For each column, regenerate its strings using appropriate settings
                allColumns.forEach(column => {
                    const isLocked = this.lockedChords && this.lockedChords.has(column);
                    
                    if (isLocked) {
                        // This column is locked - regenerate using its locked settings
                        const lockedChord = this.lockedChords.get(column);
                        console.log('?? Regenerating locked column:', lockedChord.chordName, 'with locked root:', lockedChord.lockedRoot);
                        
                        // Resolve the backing chord model by stable id/position if possible
                        let chordExt = null;
                        try {
                            if (column.dataset.chordId) {
                                chordExt = (this.chordExtensions || []).find(c => String(c.id) === String(column.dataset.chordId));
                            }
                            if (!chordExt && column.dataset.originalPosition != null) {
                                const op = parseInt(column.dataset.originalPosition, 10);
                                if (!isNaN(op) && op >= 0 && this.chordExtensions && this.chordExtensions[op]) {
                                    chordExt = this.chordExtensions[op];
                                }
                            }
                        } catch(_) {}
                        // Fallback to name match only if id/position not found
                        if (!chordExt) {
                            chordExt = this.chordExtensions.find(ext => 
                                ext.name === lockedChord.chordName || 
                                ext.name === lockedChord.originalChordName ||
                                (ext.symbol && lockedChord.chordName && lockedChord.chordName.includes(ext.symbol))
                            );
                        }
                        
                        if (chordExt) {
                            // Clear existing strings and regenerate with locked settings
                            const stringsContainer = column.querySelector('.strings-column');
                            if (stringsContainer) {
                                stringsContainer.remove();
                            }
                            
                            // Generate strings using locked settings
                            this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals, lockedChord);
                        }
                    } else {
                        // This column is unlocked - regenerate using current global settings
                        // Resolve the backing chord model by stable id/position; do not depend on header text
                        let chordExt = null;
                        try {
                            if (column.dataset.chordId) {
                                chordExt = (this.chordExtensions || []).find(c => String(c.id) === String(column.dataset.chordId));
                            }
                            if (!chordExt && column.dataset.originalPosition != null) {
                                const op = parseInt(column.dataset.originalPosition, 10);
                                if (!isNaN(op) && op >= 0 && this.chordExtensions && this.chordExtensions[op]) {
                                    chordExt = this.chordExtensions[op];
                                }
                            }
                        } catch(_) {}
                        console.log('?? Regenerating unlocked column using model:', chordExt?.name, 'with current root:', this.currentRoot, 'transposeDelta:', this.transposeDelta);
                        
                        if (chordExt) {
                            // Clear existing strings and regenerate with current settings
                            const stringsContainer = column.querySelector('.strings-column');
                            if (stringsContainer) {
                                stringsContainer.remove();
                            }
                            
                            // Generate strings using current global settings
                            this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom);
                        }
                    }
                });
                
                console.log('?? Completed regeneration preserving', this.lockedChords ? this.lockedChords.size : 0, 'locked chords');
            }

            regenerateUnlockedChordsOnly() {
                console.log('?? Regenerating only unlocked chords, preserving locked ones exactly as they are');
                
                if (!this.lockedChords || this.lockedChords.size === 0) {
                    // No locked chords, just regenerate everything normally
                    console.log('?? No locked chords found, regenerating all chords normally');
                    this.preserveLockedChordsAndRegenerate();
                    return;
                }
                
                // Get all columns currently in the DOM
                const container = document.getElementById('extensionColumns');
                const existingColumns = Array.from(container.querySelectorAll('.extension-column'));
                
                console.log('?? Found', existingColumns.length, 'existing columns,', this.lockedChords.size, 'are locked');
                
                // Separate locked and unlocked columns
                const lockedColumns = [];
                const unlockedColumns = [];
                
                existingColumns.forEach(column => {
                    if (this.lockedChords.has(column)) {
                        lockedColumns.push(column);
                        console.log('?? Preserving locked column:', column.querySelector('.chord-name')?.textContent);
                    } else {
                        unlockedColumns.push(column);
                        console.log('?? Will regenerate unlocked column:', column.querySelector('.chord-name')?.textContent);
                    }
                });
                
                // Remove only the unlocked columns from DOM (keep locked ones in place)
                unlockedColumns.forEach(column => {
                    column.remove();
                });
                
                // Update chord names in locked columns to ensure they display correctly
                // but preserve their locked root information
                lockedColumns.forEach(column => {
                    const lockedChord = this.lockedChords.get(column);
                    if (lockedChord) {
                        const chordNameElement = column.querySelector('.chord-name');
                        if (chordNameElement) {
                            // Keep the locked chord name exactly as it was locked
                            // This prevents it from being rewritten with the new root
                            const lockedName = lockedChord.chordName;
                            chordNameElement.textContent = `🔒 ${lockedName}`;
                            chordNameElement.style.color = '#4CAF50';
                            chordNameElement.style.fontWeight = 'bold';
                            
                            const rootName = this.getNoteNames()[lockedChord.lockedRoot] || lockedChord.lockedRoot;
                            chordNameElement.title = `LOCKED: ${rootName} root, ${lockedChord.lockedTuning}TET, ${lockedChord.lockedOsc1.type}/${lockedChord.lockedOsc2.type} waves`;
                            
                            console.log('?? Preserved locked chord display:', lockedName, 'locked to root:', lockedChord.lockedRoot);
                        }
                    }
                });
                
                // Now regenerate only the chord extensions that correspond to unlocked columns
                // Find which chord extensions were unlocked
                const unlockedExtensions = this.chordExtensions.filter(ext => {
                    // Check if this extension had a locked column
                    const wasLocked = lockedColumns.some(column => {
                        const lockedChord = this.lockedChords.get(column);
                        return lockedChord && (
                            ext.name === lockedChord.chordName ||
                            (ext.isCustom && lockedChord.lockId && lockedChord.lockId.includes(ext.id || ext.name))
                        );
                    });
                    return !wasLocked;
                });
                
                // unlocked extensions to regenerate: count logged disabled
                
                // Generate new columns for unlocked extensions with the new root
                unlockedExtensions.forEach(ext => {
                    // regenerating column for unlocked extension
                    this.generateSingleChordColumn(ext, container);
                });
                
                // regeneration complete; logs suppressed
            }
            
            generateSingleChordColumn(chordExt, container) {
                // This function generates a single chord column for the given chord extension
                // This is extracted from the main generateExtensionColumns function
                const noteNames = this.getNoteNames();
                
                const column = document.createElement('div');
                column.className = 'extension-column';
                // Provide stable identifiers so delete/reorder logic can map back to data
                try {
                    const absoluteIndex = (typeof chordExt.position === 'number')
                        ? chordExt.position
                        : (this.findChordIndex ? this.findChordIndex(chordExt) : (this.chordExtensions ? this.chordExtensions.indexOf(chordExt) : -1));
                    if (absoluteIndex !== -1) column.dataset.originalPosition = String(absoluteIndex);
                    const slug = (chordExt.id || (chordExt.name || '').toLowerCase().replace(/\s+/g, '_'));
                    column.dataset.chordId = slug;
                    column.dataset.chordType = slug;
                } catch (_) { /* non-fatal */ }
                column.style.flex = '1';
                column.style.height = '100%';
                column.style.border = 'none';
                column.style.borderRadius = '0';
                column.style.margin = '0';
                column.style.padding = '0';
                
                // Create header with chord name and action buttons
                const header = document.createElement('div');
                header.className = 'extension-header';
                
                // Create chord name span
                const chordName = document.createElement('span');
                chordName.className = 'chord-name';
                chordName.textContent = chordExt.name;
                
                // Create buttons container
                const buttonsContainer = document.createElement('div');
                buttonsContainer.className = 'header-buttons';
                
                
                // (buttonsContainer kept for other action buttons)
                // Per-column transpose controls (single-column path)
                const downBtn = document.createElement('button');
                downBtn.className = 'chord-action-button transpose-down';
                downBtn.title = 'Transpose this chord down one step';
                downBtn.textContent = '▼';
                const upBtn = document.createElement('button');
                upBtn.className = 'chord-action-button transpose-up';
                upBtn.title = 'Transpose this chord up one step';
                upBtn.textContent = '▲';
                let _pressGuard = false;
                const norm = (v, m)=> ((v % m) + m) % m;
                const applyLocalTranspose = (delta)=>{
                    if (_pressGuard) return;
                    _pressGuard = true;
                    const edoNow = chordExt.fixedRootTuning || this.currentTuning || 24;
                    const prevLocal = parseInt(column.dataset.localTranspose || '0', 10) || 0;
                    const nextLocal = norm(prevLocal + delta, edoNow);
                    column.dataset.localTranspose = String(nextLocal);
                    chordExt.localTranspose = nextLocal; // persist
                    // Relabel: for custom (“+”) chords, recompute from absolute steps (matches SEQ semantics);
                    // for others, keep the lightweight root-respell.
                    try {
                        const baseRoot = typeof chordExt.fixedRootStepAbs === 'number' ? chordExt.fixedRootStepAbs : 0;
                        const effRoot = norm((baseRoot % edoNow) + nextLocal, edoNow);
                        if (chordExt.isCustom && Array.isArray(chordExt.intervals) && chordExt.intervals.length > 0) {
                            // Build absolute steps: transposed root + each interval from the transposed root
                            const absNow = [effRoot, ...chordExt.intervals.map(iv => norm(effRoot + iv, edoNow))];
                            const recomputed = this.computeFullChordNameFromAbsoluteSteps(absNow, edoNow) || chordExt.name;
                            chordName.textContent = recomputed;
                            chordName.dataset.lockedName = recomputed;
                            chordExt.name = recomputed;
                        } else {
                            const mRoot = (chordExt.name || '').match(/^([A-G])([#b]?)([\^v↑↓]*)(.*)$/);
                            const tail = mRoot ? (mRoot[4] || '') : '';
                            const newRootName = this.getRootNameForStep(effRoot, edoNow) || String(effRoot);
                            const newName = `${newRootName}${tail}`.trim();
                            chordName.textContent = newName;
                            chordName.dataset.lockedName = newName;
                            chordExt.name = newName;
                        }
                    } catch(_) {}
                    // Re-render strings with offset applied at playback time
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                        // IMPORTANT: For custom (“+”) chords, always use the stored custom intervals
                        // to avoid wiping strings due to empty extension-derived intervals
                        console.log('🔧 DEBUG: About to call generateStringsForColumn with intervals:', chordExt.intervals, 'isCustom:', chordExt.isCustom);
                        this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom || false);
                    Promise.resolve().then(()=>{ _pressGuard = false; });
                };
                const onPointer = (delta)=> (e)=>{ e.preventDefault(); e.stopPropagation(); applyLocalTranspose(delta); };
                upBtn.addEventListener('pointerdown', onPointer(+1));
                downBtn.addEventListener('pointerdown', onPointer(-1));
                buttonsContainer.appendChild(downBtn);
                buttonsContainer.appendChild(upBtn);

                header.appendChild(chordName);
                header.appendChild(buttonsContainer);
                
                // Color coding by type
                let qualityColor;
                if (chordExt.name === 'Major') qualityColor = { bg: '#1e40af', border: '#3b82f6' };
                else if (chordExt.name === 'Neutral') qualityColor = { bg: '#059669', border: '#10b981' };
                else if (chordExt.name === 'Minor') qualityColor = { bg: '#dc2626', border: '#ef4444' };
                else qualityColor = { bg: '#4a5568', border: '#718096' }; // Default for custom
                
                header.style.backgroundColor = qualityColor.bg;
                header.style.borderColor = qualityColor.border;
                header.style.color = 'white';
                header.style.border = `1px solid ${qualityColor.border}`;
                
                // Short click on header handled by generic gesture routing elsewhere
                
                column.appendChild(header);
                
                // Generate strings for this chord using the shared renderer
                const intervals = this.getChordIntervals(chordExt.extensions || []);
                this.generateStringsForColumn(column, intervals, chordExt.isCustom || false);
                // Initialize per-column local transpose from model, defaulting to 0
                if (!column.dataset.localTranspose) column.dataset.localTranspose = String(chordExt.localTranspose || 0);
                
                // Add to container
                container.appendChild(column);
                
                // Ensure new single-generated columns are draggable like others
                if (this.attachColumnDragHandlers) {
                    this.attachColumnDragHandlers(column);
                }
                
                return column;
            }
            
            preserveLockedChordsAndRegenerate() {
                
                // Store current locked chords before regeneration
                if (this.lockedChords && this.lockedChords.size > 0) {
                    this.savedLockedChords = Array.from(this.lockedChords.values());
                    
                    // Store the original root before any changes occur
                    const originalRoot = this.currentRoot;
                    
                    // CRITICAL: Preserve the chord extensions that are locked
                    // Don't let them get overwritten during regeneration
                    this.savedLockedChords.forEach(lockedChord => {
                        // preserve locked chord extension
                        
                        // Find the corresponding chord extension and mark it as locked
                        const chordExtension = this.chordExtensions.find(ext => {
                            // Try exact match first
                            if (ext.name === lockedChord.chordName) return true;
                            
                            const nameWithoutRoot = lockedChord.chordName.replace(/^[A-G][#b]?/, '');
                            if (ext.name === nameWithoutRoot) return true;
                            
                            // Try custom chord match
                            if (ext.isCustom && lockedChord.lockId && lockedChord.lockId.includes(ext.id || ext.name)) return true;
                            
                            return false;
                        });
                        
                        if (chordExtension) {
                            // Mark this extension as locked so it won't be modified
                            chordExtension.isLocked = true;
                            chordExtension.lockedData = lockedChord;
                            // marked as locked
                        } else {
                            // could not find chord extension for locked chord
                        }
                    });
                }
                
                // Store current piano locked chords before regeneration
                if (this.pianoLockedChords && this.pianoLockedChords.size > 0) {
                    this.savedPianoLockedChords = Array.from(this.pianoLockedChords.values());
                    
                    // Mark chord extensions as piano locked
                    this.savedPianoLockedChords.forEach(pianoLockedData => {
                        const chordExtension = this.chordExtensions.find(ext => ext.name === pianoLockedData.chordName);
                        if (chordExtension) {
                            chordExtension.isPianoLocked = true;
                            chordExtension.pianoLockedData = pianoLockedData;
                        }
                    });
                }
                
                // Clear the Maps since DOM elements will be destroyed
                this.lockedChords = new Map();
                this.pianoLockedChords = new Map();
                
                // Check if we have custom chords - if so, use exact regeneration
                const hasCustomChords = this.chordExtensions.some(chord => chord.isCustom);
                
                if (hasCustomChords) {
                    console.log('?? Has custom chords - using exact regeneration');
                    this.generateExactChordColumns();
                } else {
                    console.log('?? No custom chords - using standard regeneration');
                    this.generateExtensionColumns();
                }
            }

            generateExtensionColumns() {
                // Generating extension columns for current tuning
                const container = document.getElementById('extensionColumns');
                
                // Clear container completely to remove any leftover columns
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.gap = '0px';
                container.style.width = '100%';
                container.style.height = '100%';
                // Always reset to one-row layout by default; we may switch to two rows below
                container.style.flexDirection = 'row';
                
                const noteNames = this.getNoteNames();
                
                // Initialize hiddenColumns if not exists
                if (!this.hiddenColumns) {
                    this.hiddenColumns = [];
                }
                
                // Map chord extensions to identifiers for hiding (per-instance)
                const chordIds = this.chordExtensions.map((chord, index) => {
                    const id = (chord.id || (chord.name + '_' + index)).toLowerCase().replace(/\s+/g, '_');
                    return id;
                });
                
                // Filter visible chord extensions
                const visibleExtensions = this.chordExtensions.filter((chordExt, index) => {
                    const chordId = chordIds[index];
                    const isVisible = !this.hiddenColumns.includes(chordId);
                    return isVisible;
                });
                
                // console debug removed
                
                // If no visible extensions, show empty interface (only locked chords should be loaded)
                if (visibleExtensions.length === 0) {
                    // No visible extensions - showing empty interface
                    // Show message for empty state
                    container.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; color: #8fb3d3; font-size: 16px; text-align: center; flex-direction: column;">
                            <div style="margin-bottom: 10px;">No chords loaded</div>
                            <div style="font-size: 12px; opacity: 0.7;">Lock chords to save them, or use the chord builder to create new ones</div>
                        </div>
                    `;
                    
                    // Still restore locked chord states if they exist
                    this.restoreLockedChordStates();
                    return;
                }
                
                // Layout: split into two rows if many columns
                const useTwoRows = visibleExtensions.length > 16;
                let rowTop, rowBottom;
                if (useTwoRows) {
                    container.style.flexDirection = 'column';
                    rowTop = document.createElement('div');
                    rowBottom = document.createElement('div');
                    // Use flex growth instead of fixed 50% height, and allow shrinking (minHeight:0) to avoid clipping
                    Object.assign(rowTop.style, { display:'flex', gap:'0px', width:'100%', flex:'1 1 0', minHeight:'0' });
                    Object.assign(rowBottom.style, { display:'flex', gap:'0px', width:'100%', flex:'1 1 0', minHeight:'0' });
                    container.appendChild(rowTop);
                    container.appendChild(rowBottom);
                }

                // Always use simple layout - one column per chord type (no more variants)
                // Creating modern chord layout - each chord gets its own column
                visibleExtensions.forEach((chordExt, extensionIndex) => {
                    // Render repeat marker as a special thin column
                    if (chordExt.isRepeatMarker) {
                        const repeatCol = document.createElement('div');
                        repeatCol.className = 'repeat-marker-column';
                        repeatCol.style.width = '50px';
                        repeatCol.style.minWidth = '50px';
                        repeatCol.style.maxWidth = '50px';
                        repeatCol.style.height = '100%';
                        repeatCol.style.flex = '0 0 50px';
                        repeatCol.style.background = 'linear-gradient(135deg, rgba(255,215,0,0.3) 0%, rgba(255,140,0,0.4) 100%)';
                        repeatCol.style.border = '2px solid rgba(255,215,0,0.6)';
                        repeatCol.style.borderRadius = '8px';
                        repeatCol.style.display = 'flex';
                        repeatCol.style.alignItems = 'center';
                        repeatCol.style.justifyContent = 'center';
                        repeatCol.style.fontSize = '16px';
                        repeatCol.style.fontWeight = 'bold';
                        repeatCol.style.color = '#FFD700';
                        repeatCol.style.textShadow = '0 0 6px rgba(0,0,0,0.8)';
                        repeatCol.style.cursor = 'default';
                        repeatCol.textContent = chordExt.name; // e.g., "x4"
                        repeatCol.title = `Repeat marker: ${chordExt.name} - NO chord strings, just visual indicator`;
                        
                        // Mark as repeat marker so it gets filtered out during playback
                        repeatCol.dataset.isRepeatMarker = 'true';
                        
                        if (useTwoRows) {
                            const half = Math.ceil(visibleExtensions.length / 2);
                            const targetRow = extensionIndex < half ? rowTop : rowBottom;
                            targetRow.appendChild(repeatCol);
                        } else {
                            container.appendChild(repeatCol);
                        }
                        return; // IMPORTANT: Return early - no chord processing!
                    }
                    
                    // Render section separator as a thin dummy column
                    if (chordExt.isSeparator || chordExt.name === '|') {
                        const sepCol = document.createElement('div');
                        sepCol.className = 'extension-separator';
                        sepCol.style.width = '30px';
                        sepCol.style.minWidth = '30px';
                        sepCol.style.maxWidth = '30px';
                        sepCol.style.height = '100%';
                        sepCol.style.flex = '0 0 30px';
                        sepCol.style.background = 'transparent';
                        sepCol.style.borderLeft = '2px solid rgba(255,255,255,0.15)';
                        sepCol.style.boxShadow = 'inset 0 0 12px rgba(255,255,255,0.08)';
                        if (useTwoRows) {
                            const half = Math.ceil(visibleExtensions.length / 2);
                            const targetRow = extensionIndex < half ? rowTop : rowBottom;
                            targetRow.appendChild(sepCol);
                        } else {
                            container.appendChild(sepCol);
                        }
                        return; // go to next item
                    }
                    const column = document.createElement('div');
                    column.className = 'extension-column';
                    column.dataset.chordType = chordIds[this.chordExtensions.indexOf(chordExt)];
                    // Persist absolute index to support precise mapping for delete/reorder without DOM recreation
                    try {
                        const absoluteIndex = (typeof chordExt.position === 'number') ? chordExt.position : (this.findChordIndex ? this.findChordIndex(chordExt) : this.chordExtensions.indexOf(chordExt));
                        column.dataset.originalPosition = String(absoluteIndex);
                        column.dataset.chordId = chordExt.id || column.dataset.chordType;
                        if (!column.dataset.instanceId) {
                            column.dataset.instanceId = `${column.dataset.chordId}__${Date.now()}_${Math.floor(Math.random()*1e6)}`;
                        }
                    } catch (_) { /* non-fatal */ }
                    column.style.flex = '1'; // Each column takes equal width
                    column.style.height = '100%';
                    column.style.border = 'none';
                    column.style.borderRadius = '0';
                    column.style.margin = '0';
                    column.style.padding = '0';
                    
                    // Create header with chord name and action buttons
                    const header = document.createElement('div');
                    header.className = 'extension-header';
                    
                    // Create chord name span (inline-editable)
                    const chordName = document.createElement('span');
                    chordName.className = 'chord-name';
                    chordName.setAttribute('contenteditable', 'true');
                    chordName.setAttribute('spellcheck', 'false');
                    
                    // Check if this chord extension is locked and preserve its locked name
                    if (chordExt.isLocked && chordExt.lockedData) {
                        const lockedData = chordExt.lockedData;
                        const rootName = this.getNoteNames()[lockedData.lockedRoot] || lockedData.lockedRoot;
                        
                        // Use the locked name exactly as it was when locked
                        if (lockedData.chordName.match(/^[A-G][#b]?/)) {
                            chordName.textContent = lockedData.chordName;
                        } else {
                            chordName.textContent = `${rootName}${lockedData.chordName}`;
                        }
                        
                        chordName.style.color = '#4CAF50';
                        chordName.style.fontWeight = 'bold';
                        chordName.dataset.isLocked = 'true';
                        chordName.dataset.lockedName = chordName.textContent;
                        chordName.title = `🔒 LOCKED: ${rootName} root, ${lockedData.lockedTuning}TET, ${lockedData.lockedOsc1.type}/${lockedData.lockedOsc2.type} waves`;
                    } else {
                        // Regular unlocked chord - use current name
                        chordName.textContent = chordExt.name;
                    }
                    
                    // Create buttons container
                    const buttonsContainer = document.createElement('div');
                    buttonsContainer.className = 'header-buttons';
                    
                    // Create hide button (ALWAYS VISIBLE)
                    

                    // Per-column transpose controls
                    const downBtn = document.createElement('button');
                    downBtn.className = 'chord-action-button transpose-down';
                    downBtn.title = 'Transpose this chord down one step';
                    downBtn.textContent = '▼';
                    const upBtn = document.createElement('button');
                    upBtn.className = 'chord-action-button transpose-up';
                    upBtn.title = 'Transpose this chord up one step';
                    upBtn.textContent = '▲';
                    // Prevent double-fire on touch; normalize modulo
                    let _pressGuard = false;
                    const norm = (v, m)=> ((v % m) + m) % m;
                    const applyLocalTranspose = (delta)=>{
                        if (_pressGuard) return; // avoid accidental double-fire on first tap
                        _pressGuard = true;
                        const edoNow = chordExt.fixedRootTuning || this.currentTuning || 24; // use column/root tuning
                        
                        console.log('=== LOCAL TRANSPOSE RESPELLING (v2) ===');
                        console.log('Transposing chord by', delta, 'steps in', edoNow, 'EDO');
                        console.log('this.currentTuning =', this.currentTuning);
                        console.log('Current intervals:', chordExt.intervals);
                        console.log('Current chord should be CEG in 24EDO: [0, 8, 14]');
                        console.log('Current fixedRootStepAbs:', chordExt.fixedRootStepAbs);
                        console.log('Current fixedRootStepAbs:', chordExt.fixedRootStepAbs);
                        
                        // Non-baking: adjust local transpose offset only
                        const prevLocal = parseInt(column.dataset.localTranspose || '0', 10) || 0;
                        const nextLocal = norm(prevLocal + delta, edoNow);
                        column.dataset.localTranspose = String(nextLocal);
                        chordExt.localTranspose = nextLocal; // persist to model

                        // Relabel using full chord computation like global transpose
                        const baseRoot = typeof chordExt.fixedRootStepAbs === 'number' ? chordExt.fixedRootStepAbs : 0;
                        const effRoot = norm((baseRoot % edoNow) + nextLocal, edoNow);
                        try {
                            if (chordExt.isCustom && Array.isArray(chordExt.intervals) && chordExt.intervals.length > 0) {
                                // Build absolute steps: transposed root + each interval from the transposed root
                                const absNow = [effRoot, ...chordExt.intervals.map(iv => norm(effRoot + iv, edoNow))];
                                const recomputed = this.computeFullChordNameFromAbsoluteSteps(absNow, edoNow) || chordExt.name;
                                chordName.textContent = recomputed;
                                chordName.dataset.lockedName = recomputed;
                                chordExt.name = recomputed;
                            } else {
                                const mRoot = (chordExt.name || '').match(/^([A-G])([#b]?)([\^v↑↓]*)(.*)$/);
                                const tail = mRoot ? (mRoot[4] || '') : '';
                                const newRootName = this.getRootNameForStep(effRoot, edoNow) || String(effRoot);
                                const newName = `${newRootName}${tail}`.trim();
                                chordName.textContent = newName;
                                chordName.dataset.lockedName = newName;
                                chordExt.name = newName;
                            }
                        } catch(_) {}

                        // Re-render strings: trigger proper regeneration like global transpose does
                        const oldContainer = column.querySelector('.strings-column');
                        if (oldContainer) oldContainer.remove();
                        
                        // Regenerate this column using the same logic as regenerateAllColumnsPreservingLocks
                        const isLocked = this.lockedChords && this.lockedChords.has(column);
                        if (isLocked) {
                            const lockedChord = this.lockedChords.get(column);
                            this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals, lockedChord);
                        } else {
                            // For unlocked columns, regenerate using current global settings and the chord model
                            this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom || false);
                        }
                        try { this.currentActiveColumnEl = column; this.highlightKeyboardForColumn(column); } catch {}
                        Promise.resolve().then(()=>{ _pressGuard = false; });
                    };
                    const onPointer = (delta)=> (e)=>{ e.preventDefault(); e.stopPropagation(); applyLocalTranspose(delta); };
                    upBtn.addEventListener('pointerdown', onPointer(+1));
                    downBtn.addEventListener('pointerdown', onPointer(-1));

                    // Ensure per-column local transpose is initialized from model (default 0)
                    if (!column.dataset.localTranspose) column.dataset.localTranspose = String(chordExt.localTranspose || 0);

                    

                    // pointerdown covers mouse/touch/pen without double fires
                    
                    // Add buttons to container
                    // Keep only local transpose and piano lock
                    buttonsContainer.appendChild(downBtn);
                    buttonsContainer.appendChild(upBtn);
                    
                    header.appendChild(chordName);
                    header.appendChild(buttonsContainer);
                    
                    // Color coding by type
                    let qualityColor;
                    if (chordExt.name === 'Major') qualityColor = { bg: '#1e40af', border: '#3b82f6' };
                    else if (chordExt.name === 'Neutral') qualityColor = { bg: '#059669', border: '#10b981' };
                    else if (chordExt.name === 'Minor') qualityColor = { bg: '#dc2626', border: '#ef4444' };
                    else qualityColor = { bg: '#4a5568', border: '#718096' }; // Default for custom
                    
                    header.style.backgroundColor = qualityColor.bg;
                    header.style.borderColor = qualityColor.border;
                    header.style.color = 'white';
                    header.style.border = `1px solid ${qualityColor.border}`;
                    
                    // Inline editing: Enter to apply, ESC to cancel
                    const applyTypedName = () => {
                        try {
                            const raw = (chordName.textContent || '').trim();
                            if (!raw) return;
                            const added = (typeof this.addChordFromName === 'function') ? this.addChordFromName(raw) : null;
                            if (!added || !added.chord) {
                                const prevOutline = chordName.style.outline;
                                chordName.style.outline = '2px solid #e74c3c';
                                setTimeout(()=> { chordName.style.outline = prevOutline; }, 600);
                                return;
                            }
                            let idx = (typeof column.dataset.originalPosition !== 'undefined') ? parseInt(column.dataset.originalPosition,10) : -1;
                            if (isNaN(idx) || idx < 0) idx = (this.chordExtensions||[]).indexOf(chordExt);
                            if (idx >= 0) {
                                const parsed = added.chord;
                                try { if (this.chordExtensions[this.chordExtensions.length-1] === parsed) this.chordExtensions.pop(); } catch(_){ }
                                parsed.position = chordExt.position;
                                parsed.localTranspose = chordExt.localTranspose || 0;
                                this.chordExtensions.splice(idx, 1, parsed);
                                column.dataset.chordId = parsed.id || column.dataset.chordId;
                                column.dataset.originalPosition = String(idx);
                                chordName.textContent = parsed.name;
                                const old = column.querySelector('.strings-column');
                                if (old) old.remove();
                                this.generateStringsForColumn(column, parsed.intervals, parsed.isCustom || false);
                                try { this.saveChordConfiguration?.(); } catch(_){}
                            }
                        } catch (err) { console.error('applyTypedName error:', err); }
                    };
                    chordName.addEventListener('keydown', (ev)=>{
                        if (ev.key === 'Enter') { ev.preventDefault(); applyTypedName(); chordName.blur(); }
                        else if (ev.key === 'Escape') { ev.preventDefault(); chordName.blur(); }
                    });
                    chordName.addEventListener('click', (e)=>{ e.stopPropagation(); });
                    chordName.addEventListener('mousedown', (e)=>{ e.stopPropagation(); });
                    chordName.addEventListener('touchstart', (e)=>{ e.stopPropagation(); }, {passive:true});

                    // Header short click: play chord/arp (handled by generic gesture router)
                    header.addEventListener('click', (e) => {
                        if (
                            e.target.classList.contains('lock-button') ||
                            e.target.classList.contains('chord-action-button') ||
                            e.target.tagName === 'BUTTON'
                        ) return;
                        this.handleClick(header, 'chord', e.clientX, e.clientY);
                    });
                    
                    column.appendChild(header);
                    
                    // Add elements to header
                    header.appendChild(chordName);
                    header.appendChild(buttonsContainer);
                    
                    // Remove duplicate simplified handler; playback handled above
                    
                    column.appendChild(header);
                    
                    // Persist the last intervals and ensure a default voicing variant for revoice
                    try { column.dataset.lastIntervals = JSON.stringify(chordExt.intervals || []); } catch(_){}
                    if (!column.dataset.voicingVariant) { column.dataset.voicingVariant = '0'; }

                    // Generate strings for this chord; prefer locked snapshot
                    if (chordExt.isLocked && chordExt.lockedData) {
                        this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals, chordExt.lockedData);
                    } else {
                        this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom || false);
                    }
                    
                    // Enable long-press drag reordering
                    this.attachColumnDragHandlers(column);
                    if (useTwoRows) {
                        const half = Math.ceil(visibleExtensions.length / 2);
                        const targetRow = extensionIndex < half ? rowTop : rowBottom;
                        targetRow.appendChild(column);
                        const sc = column.querySelector('.strings-column');
                        if (sc) {
                            const headerEl = column.querySelector('.extension-header');
                            const headerPx = Math.max(56, headerEl ? headerEl.offsetHeight : 56);
                            sc.style.height = `calc(100% - ${headerPx}px)`;
                        }
                    } else {
                        container.appendChild(column);
                    }
                });
                
                // Establish deterministic play order (left→right; top row before bottom row)
                try {
                    const containerEl = document.getElementById('extensionColumns');
                    let ordered = [];
                    if (useTwoRows) {
                        const topCols = Array.from(rowTop.querySelectorAll('.extension-column'));
                        const bottomCols = Array.from(rowBottom.querySelectorAll('.extension-column'));
                        ordered = [...topCols, ...bottomCols];
                    } else {
                        ordered = Array.from(containerEl.querySelectorAll('.extension-column'));
                    }
                    this._orderedColumns = ordered;
                    ordered.forEach((col, idx)=>{ col.dataset.playIndex = String(idx); });
                    // If nothing is active or a previous active column is not in DOM, choose the first visible
                    if (!this.currentActiveColumnEl || !document.body.contains(this.currentActiveColumnEl)) {
                        this.currentActiveColumnEl = ordered[0] || null;
                    }
                } catch(_) {}

                // Add click handlers after rendering
                setTimeout(() => {
                    this.addSimpleClickHandlers();
                    this.restoreLockedChordStates(); // Restore locked chord states
                    this.restorePianoLockStates(); // Restore piano lock states
                }, 100);
            }

            /**
             * regenerateChordGrid
             * Compatibility shim expected by newer persistence import path.
             * Attempts to regenerate the chord columns while preserving any
             * locked chord / piano lock state. Falls back progressively.
             */
            regenerateChordGrid() {
                try {
                    if (typeof this.preserveLockedChordsAndRegenerate === 'function') {
                        return this.preserveLockedChordsAndRegenerate();
                    }
                    if (typeof this.generateExtensionColumns === 'function') {
                        return this.generateExtensionColumns();
                    }
                    console.warn('regenerateChordGrid(): no chord generation function available');
                } catch (e) {
                    console.error('regenerateChordGrid() failed:', e);
                }
            }
            
            // Restore piano lock button states after column regeneration
            restorePianoLockStates() {
                if (!this.pianoLockedChords) return;

                // restoring piano lock states

                const columns = Array.from(document.querySelectorAll('.extension-column'));
                // Clear previous visual markers
                columns.forEach(c => c.classList.remove('piano-locked-col'));

                for (const [lockKey, data] of this.pianoLockedChords.entries()) {
                    const targetSig = (data && data.intervalsSig) ? String(data.intervalsSig) : '';
                    // Find first matching column by intervals signature and mark it as owner
                    const match = columns.find(col => {
                        try {
                            const rel = this.getChordStepsForColumn(col) || [];
                            const sig = Array.isArray(rel) ? rel.slice().map(n=>Number(n)||0).sort((a,b)=>a-b).join('.') : '';
                            return sig === targetSig;
                        } catch(_) { return false; }
                    });
                    if (match) {
                        try {
                            // Persist minimal flags on the column's chord data for other routines to read
                            const header = match.querySelector('.extension-header');
                            const cd = this.getChordDataFromColumn(match, header);
                            if (cd) {
                                cd.isPianoLocked = true;
                                cd.pianoLockedData = data;
                                cd.pianoLockKey = lockKey;
                            }
                        } catch(_) {}
                        match.classList.add('piano-locked-col');
                    }
                }
            }

            // Helper: is the currently active column piano-locked (osc/effects)?
            isActiveChordPianoLocked() {
                try {
                    const col = this.currentActiveColumnEl;
                    if (!col || !document.body.contains(col)) return false;
                    let chordData = null;
                    try {
                        const header = col.querySelector('.extension-header .chord-name');
                        if (typeof this.getChordDataFromColumn === 'function') {
                            chordData = this.getChordDataFromColumn(col, header);
                        }
                    } catch (_) {}
                    if (!chordData) {
                        chordData = {
                            name: col.dataset.chordType,
                            quality: this.currentQuality,
                            extensions: col.dataset.extensions ? col.dataset.extensions.split(',') : [],
                            intervals: []
                        };
                    }
                    const data = (typeof this.findPianoLockData === 'function') ? this.findPianoLockData(chordData) : null;
                    return !!data;
                } catch (_) {
                    return false;
                }
            }

            // Brief visual nudge on the piano-lock button when edits are blocked
            flashPianoLockFeedback() {
                try {
                    const col = this.currentActiveColumnEl;
                    if (!col) return;
                    const prevShadow = col.style.boxShadow;
                    const prevTransform = col.style.transform;
                    col.style.boxShadow = '0 0 16px rgba(139, 92, 246, 0.6)';
                    col.style.transform = 'scale(1.01)';
                    setTimeout(() => { col.style.boxShadow = prevShadow; col.style.transform = prevTransform; }, 200);
                } catch (_) {}
            }
            
            getIntervalColor(interval) {
                // Neon color coding for musical intervals with microtonal gradient support
                const normalizedInterval = ((interval % 12) + 12) % 12;

                // Requested palette mapping (0-11):
                // 0 White, 1 Deep Violet, 2 Bright Orange, 3 Blue, 4 Red,
                // 5 Cyan, 6 Black, 7 Green, 8 Magenta, 9 Bright Yellow,
                // 10 Dark Blue, 11 Lime Green
                const chromaticColors = [
                    { interval: 0, color: '#EEEEEE', name: 'Root' },           // White
                    { interval: 1, color: '#5A0D5D', name: 'm2/♭9' },          // Deep Violet
                    { interval: 2, color: '#99A500', name: 'M2/9' },           // Bright Orange
                    { interval: 3, color: '#0000CC', name: 'm3' },             // Blue
                    { interval: 4, color: '#CC0000', name: 'M3' },             // Red
                    { interval: 5, color: '#00CCCC', name: 'P4/11' },          // Cyan
                    { interval: 6, color: '#C0C0C0', name: 'TT' },             // Silver (tritone)
                    { interval: 7, color: '#00CC00', name: 'P5' },             // Green
                    { interval: 8, color: '#CC00CC', name: 'm6/♯5' },          // Magenta
                    { interval: 9, color: '#EEEE00', name: 'M6/13' },          // Bright Yellow
                    { interval: 10, color: '#00008B', name: 'm7' },            // Dark Blue
                    { interval: 11, color: '#229D22', name: 'M7' },            // Lime Green
                ];

                // Exact chromatic matches
                for (let i = 0; i < chromaticColors.length; i++) {
                    const chromatic = chromaticColors[i];
                    if (Math.abs(normalizedInterval - chromatic.interval) < 0.05) {
                        return { color: chromatic.color, name: chromatic.name };
                    }
                }

                // Microtonal interpolation between adjacent chromatic steps
                for (let i = 0; i < chromaticColors.length; i++) {
                    const current = chromaticColors[i];
                    const next = chromaticColors[(i + 1) % chromaticColors.length];

                    let lowerBound = current.interval;
                    let upperBound = next.interval;
                    if (next.interval < current.interval) upperBound = next.interval + 12; // wrap

                    let testInterval = normalizedInterval;
                    if (upperBound > 12 && normalizedInterval < 6) testInterval = normalizedInterval + 12;

                    if (testInterval > lowerBound + 0.05 && testInterval < upperBound - 0.05) {
                        const position = (testInterval - lowerBound) / (upperBound - lowerBound);
                        const gradientColor = this.interpolateColors(current.color, next.color, position);
                        const cents = Math.round((normalizedInterval - Math.floor(normalizedInterval)) * 100);
                        const baseName = current.name.split('/')[0];
                        const gradientName = `${baseName}+${cents}¢`;
                        return { color: gradientColor, name: gradientName };
                    }
                }

                return { color: '#CCCCCC', name: 'Unknown' };
            }

            // Map an EDO step to nearest 12-TET semitone index (0..11)
            stepToSemitone(step, edo) {
                if (edo <= 0) return 0;
                const semi = Math.round((step * 12) / edo) % 12;
                return ((semi % 12) + 12) % 12;
            }
            // Map a 12-TET semitone (0..11) to the nearest step in a given EDO
            semitoneToStep(semi, edo) {
                if (!edo || edo <= 0) return 0;
                const s = Math.round(((semi % 12 + 12) % 12) * edo / 12);
                return ((s % edo) + edo) % edo;
            }
            
            // Root selection: leftmost (lowest) note unless a clear major/minor triad exists on another pitch;
            // slash only when bass is the (flat/neutral) seventh
            computeFullChordNameFromAbsoluteSteps(absSteps, edo = (this.currentTuning || 12), preferredBassAbs = null){
                if (!Array.isArray(absSteps) || absSteps.length < 1) return '';
                // Apply global transpose to reflect what you hear
                const t = (this.transposeDelta || 0) % edo;
                const norm = absSteps.map(s => (((s + t) % edo) + edo) % edo);
                const steps = Array.from(new Set(norm));
                if (steps.length < 2) {
                    const rootOnly = steps[0] ?? 0;
                    return this.getRootNameForStep(rootOnly, edo);
                }

                // Bass candidate: prefer provided; else lowest by 12-TET approximation (leftmost)
                const bassAbs = (preferredBassAbs != null)
                    ? (((preferredBassAbs + t) % edo) + edo) % edo
                    : steps.slice().sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo))[0];

                // Override rule: choose the pitch that yields the clearest quality.
                // Priority: major/minor triad > half-diminished 7 (ø7) > diminished 7 (°7) > diminished triad (°)
                let rootAbs = bassAbs;
                const triadFound = (()=>{
                    const targetMaj = new Set([0,4,7]);
                    const targetMin = new Set([0,3,7]);
                    const targetDimTriad = new Set([0,3,6]);
                    const targetDim7 = new Set([0,3,6,9]);
                    const targetHalfDim7 = new Set([0,3,6,10]);
                    const to12 = (step)=> this.stepToSemitone(step, edo);
                    const scoreForRel = (rel12Arr)=>{
                        const rel = new Set(rel12Arr);
                        const hasAll = (set)=> [...set].every(x=> rel.has(x));
                        // exact-set helpers
                        const eq = (arr)=> arr.length===rel12Arr.length && arr.every((v,i)=> v===rel12Arr[i]);
                        if (hasAll(targetMaj) || hasAll(targetMin)) return 100; // strong triads
                        if (eq([0,3,6,10])) return 90; // ø7
                        if (eq([0,3,6,9]))  return 85; // °7
                        if (hasAll(targetDimTriad)) return 80; // diminished triad subset
                        return -1;
                    };
                    let best = {cand: rootAbs, score: -1};
                    for (const cand of steps) {
                        const rSemi = to12(cand);
                        const rel12 = [...new Set(steps.map(s=> ((to12(s) - rSemi + 12) % 12)))].sort((a,b)=>a-b);
                        const s = scoreForRel(rel12);
                        if (s > best.score) best = {cand, score: s};
                    }
                    if (best.score >= 0 && best.cand !== rootAbs) {
                        rootAbs = best.cand;
                        return true;
                    }
                    return best.score >= 0;
                })();
                const rels = steps.map(s => ((s - rootAbs) % edo + edo) % edo);
                const rootName = this.getRootNameForStep(rootAbs, edo);
                const symbol = this.getProperChordSymbol(rels);

                // Slash policy: only when bass is the seventh (flat or neutral 7), otherwise omit
                let slash = '';
                if (rootAbs !== bassAbs) {
                    const semiRoot = this.stepToSemitone(rootAbs, edo);
                    const semiBass = this.stepToSemitone(bassAbs, edo);
                    const d = ((semiBass - semiRoot) % 12 + 12) % 12;
                    const near = (x,y,tol=0.35)=> Math.abs(x-y) <= tol;
                    if (near(d, 10.0) || near(d, 10.5)) {
                        const bassName = this.getRootNameForStep(bassAbs, edo);
                        slash = `/${bassName}`;
                    }
                }
                const rawLabel = `${rootName}${symbol}${slash}`;
                return rawLabel;
            }

            

            // Internal: choose the root within absSteps that yields the clearest 12-TET quality
            _chooseBestRootByQuality(absSteps, edo){
                const uniq = Array.from(new Set(absSteps.map(s => ((s % edo) + edo) % edo)));
                // Known quality targets in semitones (12-TET)
                const targets = [
                    {name:'maj', ints:[0,4,7], score:10},
                    {name:'min', ints:[0,3,7], score:10},
                    {name:'dim', ints:[0,3,6], score:8},
                    {name:'aug', ints:[0,4,8], score:8},
                    {name:'sus2',ints:[0,2,7], score:7},
                    {name:'sus4',ints:[0,5,7], score:7},
                ];
                let best = {root: uniq[0], score: -Infinity, rels12: null};
                // Precompute semitones for each abs step
                const semiMap = new Map();
                uniq.forEach(s => semiMap.set(s, this.stepToSemitone(s, edo)));
                uniq.forEach(root => {
                    const rootSemi = semiMap.get(root);
                    const rels12 = uniq.map(s => ((semiMap.get(s) - rootSemi + 12) % 12)).sort((a,b)=>a-b);
                    // Score against targets: exact subset/superset gets high score
                    let sMax = -1;
                    for (const t of targets) {
                        const tSet = new Set(t.ints);
                        const relSet = new Set(rels12);
                        const hitAll = t.ints.every(x => relSet.has(x));
                        if (hitAll) sMax = Math.max(sMax, t.score);
                    }
                    // Minor preference: if both maj/min ambiguous, keep the one whose lowest spelled triad is exact
                    if (sMax > best.score) best = {root, score: sMax, rels12};
                });
                // Fallback: pick by minimal semitone (previous behavior) if no quality matched
                if (best.score < 0) {
                    const r = uniq.slice().sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo))[0];
                    const rootSemi = this.stepToSemitone(r, edo);
                    const rels12 = uniq.map(s => ((this.stepToSemitone(s, edo) - rootSemi + 12) % 12)).sort((a,b)=>a-b);
                    return {root: r, score: 0, rels12};
                }
                return best;
            }

            // Universal pitch colors: C=RED, D=ORANGE, E=YELLOW, F=GREEN, G=BLUE, A=INDIGO, B=VIOLET
            _universalColorAnchors() {
                return [
                    { semi: 0,  name: 'C', color: '#FF0000' }, // Red
                    { semi: 2,  name: 'D', color: '#FFA500' }, // Orange
                    { semi: 4,  name: 'E', color: '#FFFF00' }, // Yellow
                    { semi: 5,  name: 'F', color: '#00FF00' }, // Green
                    { semi: 7,  name: 'G', color: '#0000FF' }, // Blue
                    { semi: 9,  name: 'A', color: '#4B0082' }, // Indigo
                    { semi: 11, name: 'B', color: '#8F00FF' }, // Violet
                    { semi: 12, name: 'C', color: '#FF0000' }, // wrap C for interpolation
                ];
            }
            _getUniversalColorForSemitoneFloat(semiFloat) {
                let x = semiFloat;
                while (x < 0) x += 12;
                while (x > 12) x -= 12;
                const anchors = this._universalColorAnchors();
                // exact anchor
                for (let i = 0; i < anchors.length - 1; i++) {
                    if (Math.abs(x - anchors[i].semi) < 1e-6) return { color: anchors[i].color, name: anchors[i].name };
                }
                // find segment
                let lo = anchors[0], hi = anchors[anchors.length - 1];
                for (let i = 0; i < anchors.length - 1; i++) {
                    const a = anchors[i], b = anchors[i+1];
                    if (x >= a.semi && x <= b.semi) { lo = a; hi = b; break; }
                }
                const span = Math.max(1e-6, hi.semi - lo.semi);
                const t = Math.min(1, Math.max(0, (x - lo.semi) / span));
                return { color: this.interpolateColors(lo.color, hi.color, t), name: t < 0.5 ? lo.name : hi.name };
            }
            getUniversalPitchColorForStep(step, edo) {
                if (!edo || edo <= 0) return { color: '#CCCCCC', name: '' };
                const semiFloat = (step * 12) / edo;
                return this._getUniversalColorForSemitoneFloat(((semiFloat % 12) + 12) % 12);
            }
            // Map semitone (integer) to universal color
            getChromaticColorForSemitone(semi) {
                const s = ((semi % 12) + 12) % 12;
                return this._getUniversalColorForSemitoneFloat(s).color;
            }

            // Simple contrast helper for header text
            pickTextColor(bgHex, light = '#FFFFFF', dark = '#000000') {
                const h = (bgHex || '#000000').replace('#','');
                const r = parseInt(h.substring(0,2),16) || 0;
                const g = parseInt(h.substring(2,4),16) || 0;
                const b = parseInt(h.substring(4,6),16) || 0;
                const brightness = (r*299 + g*587 + b*114) / 1000;
                return brightness > 150 ? dark : light;
            }
            
            interpolateColors(color1, color2, factor) {
                // Convert hex colors to RGB, interpolate, and convert back
                const hex1 = color1.replace('#', '');
                const hex2 = color2.replace('#', '');
                
                const r1 = parseInt(hex1.substr(0, 2), 16);
                const g1 = parseInt(hex1.substr(2, 2), 16);
                const b1 = parseInt(hex1.substr(4, 2), 16);
                
                const r2 = parseInt(hex2.substr(0, 2), 16);
                const g2 = parseInt(hex2.substr(2, 2), 16);
                const b2 = parseInt(hex2.substr(4, 2), 16);
                
                const r = Math.round(r1 + (r2 - r1) * factor);
                const g = Math.round(g1 + (g2 - g1) * factor);
                const b = Math.round(b1 + (b2 - b1) * factor);
                
                return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
            }

            generateStringsForColumn(column, intervals, isCustomChord = false) {
                // Resolve lock/model first so we can recover intervals if caller passed empty
                const lockedChord = this.lockedChords?.get(column);
                let model = null;
                try {
                    // Prefer stable ID mapping first
                    const id = column.dataset.chordId;
                    let idx = -1;
                    if (id) idx = (this.chordExtensions||[]).findIndex(c=> c && (String(c.id)===String(id)));
                    if (idx < 0 && column.dataset.originalPosition != null) {
                        const op = parseInt(column.dataset.originalPosition,10);
                        if (!isNaN(op) && op >= 0) idx = op;
                    }
                    if (idx >= 0) model = (this.chordExtensions||[])[idx];
                } catch(_) {}
                // Fallback: if no intervals were provided, recover them from the model
                if (!intervals || !Array.isArray(intervals) || intervals.length === 0) {
                    const recovered = model && Array.isArray(model.intervals) ? model.intervals : null;
                    if (recovered && recovered.length > 0) {
                        intervals = recovered;
                    }
                }
                // If still empty, render an empty strings container and exit
                if (!intervals || !Array.isArray(intervals) || intervals.length === 0) {
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                    const stringsContainer = document.createElement('div');
                    stringsContainer.className = 'strings-column';
                    // Compute dynamic header height for robust layout in two-row mode
                    const headerEl = column.querySelector('.extension-header');
                    const headerPx = Math.max(56, headerEl ? headerEl.offsetHeight : 56);
                    stringsContainer.style.cssText = `flex:1; overflow:hidden; padding:1px; height: calc(100% - ${headerPx}px); display:flex; flex-direction:column; justify-content:center; align-items:center; color:#8fb3d3; font-size:12px; opacity:0.8;`;
                    // Respect global invert-strings preference
                    try { if (document.documentElement.classList.contains('invert-strings')) stringsContainer.style.flexDirection = 'column-reverse'; } catch(_) {}
                    const hint = document.createElement('div');
                    hint.textContent = 'Tap keys to add notes';
                    stringsContainer.appendChild(hint);
                    column.appendChild(stringsContainer);
                    // Footer removed; ensure fit after insertion
                    this.ensureStringsFullyVisible(stringsContainer);
                    return;
                }

                // If exact frequencies were captured for this column, render snapshot and exit
                // But skip snapshot if a local per-column transpose is active, so arrows take effect
                const hasLocalTranspose = ((+column.dataset.localTranspose || 0) !== 0);
                if (lockedChord && Array.isArray(lockedChord.exactFrequencies) && lockedChord.exactFrequencies.length > 0 && !this._transposing && !hasLocalTranspose) {
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                    this.generateStringsWithExactFrequencies(column, lockedChord);
                    return;
                }
                
                // Use locked settings if available, otherwise use current settings
                let currentRoot, currentTuning;
                if (lockedChord) {
                    const edo = lockedChord.lockedTuning || this.currentTuning || 12;
                    const globalDelta = (this.transposeDelta || 0) % edo;
                    const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                    // Locked chords preserve exact pitch by default; do not apply globalDelta here
                    currentRoot = ((lockedChord.lockedRoot ?? 0) + localDelta + edo) % edo;
                    currentTuning = lockedChord.lockedTuning;
                } else {
                    // Prefer per-chord fixed root if present; apply deltas so audio follows arrows and global transpose
                    if (model && typeof model.fixedRootStepAbs === 'number' && model.fixedRootTuning) {
                        currentTuning = model.fixedRootTuning;
                        const edo = currentTuning || this.getTuningStepsPerOctave();
                        const globalDelta = (this.transposeDelta || 0) % edo;
                        const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                        console.log('AUDIO GENERATION DEBUG: fixedRootStepAbs =', model.fixedRootStepAbs, 'globalDelta =', globalDelta, 'localDelta =', localDelta, 'edo =', edo);
                        currentRoot = (((model.fixedRootStepAbs % edo) + globalDelta + localDelta) % edo + edo) % edo;
                        console.log('AUDIO GENERATION DEBUG: calculated currentRoot =', currentRoot);
                    } else {
                        // Start from current global context; header label parsing below may override
                        currentRoot = this.currentRoot;
                        currentTuning = this.currentTuning;
                    }
                }
                
                
                
                const noteNames = this.getNoteNames();
                const tuningSize = currentTuning || this.getTuningStepsPerOctave();

                // Ensure header label matches actual notes after local transpose (no global baked into label)
                // Skip locked chords (they preserve exact label)
                try {
                    if (!lockedChord) {
                        const nameEl = column.querySelector('.extension-header .chord-name');
                        if (nameEl && model && Array.isArray(model.intervals) && model.intervals.length > 0) {
                            const edoNow = this.currentTuning || tuningSize || 12;
                            const modelEdo = model.fixedRootTuning || edoNow;
                            const mapStep = (step, srcEdo, dstEdo) => {
                                const cents = ((step % srcEdo + srcEdo) % srcEdo) * (1200 / srcEdo);
                                const dst = Math.round(cents / (1200 / dstEdo));
                                return ((dst % dstEdo) + dstEdo) % dstEdo;
                            };
                            const localDeltaNow = ((+column.dataset.localTranspose || 0) % edoNow + edoNow) % edoNow;
                            const localDeltaModel = (modelEdo === edoNow) ? localDeltaNow : mapStep(localDeltaNow, edoNow, modelEdo);
                            const baseRootModel = (typeof model.fixedRootStepAbs === 'number') ? ((model.fixedRootStepAbs % modelEdo) + modelEdo) % modelEdo : 0;
                            const effRootModel = (((baseRootModel) + localDeltaModel) % modelEdo + modelEdo) % modelEdo;
                            // Build degree steps in model's EDO
                            const degreeStepsModel = model.isCustom
                                ? model.intervals.map(iv => ((iv % modelEdo) + modelEdo) % modelEdo)
                                : model.intervals.map(iv => this.mapIntervalToEDO(iv, modelEdo));
                            const absModel = [effRootModel, ...degreeStepsModel.map(d => (effRootModel + d) % modelEdo)];
                            const absNow = (modelEdo === edoNow) ? absModel.map(s => ((s%edoNow)+edoNow)%edoNow)
                                                                : absModel.map(s => mapStep(s, modelEdo, edoNow));
                            const recomputedLabel = this.computeFullChordNameFromAbsoluteSteps(absNow, edoNow);
                            if (recomputedLabel) {
                                nameEl.textContent = recomputedLabel;
                                nameEl.dataset.lockedName = recomputedLabel;
                                try { model.name = recomputedLabel; } catch(_) {}
                            }
                        }
                    }
                } catch(_) {}

                // For unlocked, non-fixed-root chords: derive pitch from base currentRoot plus global/local transpose deltas
                // This guarantees audio shifts by exact EDO steps on global transpose, independent of header text parsing.
                if (!lockedChord && !(model && typeof model.fixedRootStepAbs === 'number')) {
                    const edo = tuningSize;
                    const globalDelta = (this.transposeDelta || 0) % edo;
                    const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                    currentRoot = (((currentRoot ?? 0) + globalDelta + localDelta) % edo + edo) % edo;
                }

                try {
                    const headerNameEl = column.querySelector('.extension-header .chord-name');
                    const headerName = headerNameEl ? headerNameEl.textContent.trim() : '';
                    console.log('[AUDIO] header=', headerName, 'currentRoot=', currentRoot, 'currentTuning=', currentTuning, 'fixedRoot=', model?.fixedRootStepAbs, 'isCustomChord=', isCustomChord, 'intervals(steps)=', intervals);
                } catch {}

                // Ascending, octave-consistent voicing:
                // 1) Map intervals to EDO steps (or use directly for custom chords)
                // 2) Sort degrees within an octave by pitch (root -> third -> fifth -> ...)
                // 3) Repeat this ordered set across consecutive octaves to fill the column
                const degreeSteps = intervals.map(iv => isCustomChord ? ((iv % tuningSize)+tuningSize)%tuningSize : this.mapIntervalToEDO(iv, currentTuning));
                // Unique and sort by 12-TET semitone equivalence for consistent ordering
                const uniqueSteps = Array.from(new Set(degreeSteps));
                uniqueSteps.sort((a, b) => {
                    const sa = this.stepToSemitone(a, tuningSize);
                    const sb = this.stepToSemitone(b, tuningSize);
                    return sa - sb;
                });

                // Choose a mid register for clarity
                const baseOctave = 1; // C1 as lowest default anchor
                const stringFreqs = [];

                // Detect slash-chord bass to place as the very bottom voice (one octave below base)
                let slashBassStep = null;
                try {
                    const headerNameEl = column.querySelector('.extension-header .chord-name');
                    const headerName = headerNameEl ? headerNameEl.textContent.trim() : '';
                    const m = headerName.match(/^([A-G])([#b]?)[\^v]*.*\/(?:\s*)?([A-G])([#b]?)/);
                    if (m) {
                        const rootSemi = this.rootToSemitone(m[1], m[2]||'');
                        const bassSemi = this.rootToSemitone(m[3], m[4]||'');
                        const diffSemi = ((bassSemi - rootSemi) % 12 + 12) % 12;
                        slashBassStep = Math.round((diffSemi * tuningSize) / 12);
                    }
                } catch { /* ignore */ }

                // Prepare ordered steps (semitone ascending within octave)
                // We'll compute a special order for the FIRST group only so core tones
                // (root/3rd/5th/7th or their altered equivalents) appear before lifted extensions (≥9).
                const orderedSteps = uniqueSteps.slice();

                // If enabled, split extended chords (≥9) across two octaves in the first group
                // Strategy: keep root/3rd/5th/7th in baseOctave; push 9/11/13 (+alterations) up one octave
                let firstGroupOctaveOffsetMap = new Map();
                // Build mapping from EDO step -> original interval value (in semitones above root),
                // so we can classify core (<12) vs extensions (>=12). For custom chords, keep order as-is.
                let firstGroupOrderSteps = orderedSteps;
                if (this.splitExtendedChordsAcrossOctaves && !isCustomChord) {
                    const mapIvToStep = (iv) => this.mapIntervalToEDO(iv, currentTuning);
                    const stepInfoList = orderedSteps.map(edoStep => {
                        // find a representative original interval that maps to this step
                        let origin = intervals.find(iv => mapIvToStep(iv) === edoStep);
                        if (origin == null) {
                            // Fallback: estimate extended by semitone class (rare path)
                            const semi = this.stepToSemitone(edoStep, tuningSize);
                            origin = [1,2,3,5,6,8,9].includes(semi) ? 14 : 0; // treat as 9 or root-ish
                        }
                        // Treat #13 (22) specially: it collides with b7 in 12-TET; don't lift it.
                        const isExtended = (origin >= 12) && origin !== 22;
                        return { step: edoStep, semi: this.stepToSemitone(edoStep, tuningSize), origin, isExtended };
                    });

                    // Build first-group order: slash bass (if any) → core → extended
                    const coreList = stepInfoList
                        .filter(si => !si.isExtended && (slashBassStep == null || si.step !== slashBassStep))
                        .sort((a,b)=> a.semi - b.semi);
                    const extList = stepInfoList
                        .filter(si => si.isExtended && (slashBassStep == null || si.step !== slashBassStep))
                        .sort((a,b)=> a.semi - b.semi);
                    firstGroupOrderSteps = (slashBassStep != null ? [slashBassStep] : [])
                        .concat(coreList.map(si=>si.step))
                        .concat(extList.map(si=>si.step));

                    // Mark only the extended tones for the +1 octave lift in the first group
                    stepInfoList.forEach(si => { if (si.isExtended) firstGroupOctaveOffsetMap.set(si.step, 1); });
                }

                // Replicate the voicing across octaves C1..C8
                const replicateStride = this.splitExtendedChordsAcrossOctaves ? 2 : 1; // 2-oct stride for split voicing
                const totalReplicas = Math.floor(8 / replicateStride); // 8 octaves total span
                for (let r = 0; r < totalReplicas; r++) {
                    const replicateBaseOct = baseOctave + r * replicateStride;
                    const seq = firstGroupOrderSteps; // always apply core→extensions ordering per replica
                    for (let i = 0; i < seq.length; i++) {
                        const edoStep = seq[i];
                        // Normalize degree within an octave and track extra octaves for large extensions (e.g., 9/11/13)
                        const normStep = ((edoStep % tuningSize) + tuningSize) % tuningSize;
                        const extraFromDegree = Math.floor((edoStep - normStep) / tuningSize);

                        // Compute wrap relative to the column root
                        const total = currentRoot + normStep;
                        const wrapOctaves = Math.floor(total / tuningSize);
                        const step = ((total % tuningSize) + tuningSize) % tuningSize;

                        // For the first degree in this replica, if it's a slash bass, drop it one octave
                        const firstGroupBass = (slashBassStep != null && i === 0);
                        let octave = replicateBaseOct + extraFromDegree + wrapOctaves - (firstGroupBass ? 1 : 0);
                        // Apply split lift per replica for extensions (≥9)
                        if (this.splitExtendedChordsAcrossOctaves && firstGroupOctaveOffsetMap.has(edoStep)) {
                            octave += firstGroupOctaveOffsetMap.get(edoStep) || 0;
                        }
                        // In compact-one mode, keep tones within a single-octave span around replicate base
                        if (!this.splitExtendedChordsAcrossOctaves) {
                            const maxOct = replicateBaseOct + 1; // slight upward spill for upper degrees
                            const minOct = replicateBaseOct;      // keep base as lower bound
                            octave = Math.min(maxOct, Math.max(minOct, octave));
                        }
                        // Do not suppress repeated roots; show all strings across octaves

                        const freq = this.getFrequency(step, octave, currentTuning);
                        // Map back to an interval tag for display/coloring; fallback to semitone-derived
                        const intervalTag = intervals.find(iv => (isCustomChord ? iv : this.mapIntervalToEDO(iv, currentTuning)) === edoStep) ?? intervals[i % intervals.length];
                        stringFreqs.push({ freq, step, octave, interval: intervalTag });
                    }
                }
                
                // Visual ordering depends on Play Mode selection
                // Default to high at top (descending) for chords/arp; allow 'low-high' to flip
                const __pm = (this.playMode || 'high-low');
                const __desc = (__pm === 'low-high') ? false : true;
                stringFreqs.sort((a,b)=> __desc ? (b.freq - a.freq) : (a.freq - b.freq));

                // Calculate string sizing to fill full height of column
                const availableHeight = column.offsetHeight || 500; // Default height if not available
                const headerHeight = 40;
                const stringsHeight = availableHeight - headerHeight - 2; // Minimal padding
                const numStrings = stringFreqs.length;
                const stringHeight = Math.max(1, Math.floor(stringsHeight / numStrings) - 0.5); // Ensure strings are visible
                const stringMargin = 0.2; // Minimal margin
                
                // Create strings container that fills remaining space
                const stringsContainer = document.createElement('div');
                stringsContainer.className = 'strings-column';
                // Use real header height if available to avoid clipping
                const headerEl = column.querySelector('.extension-header');
                const headerPx = Math.max(56, headerEl ? headerEl.offsetHeight : headerHeight);
                const stringsHeightPx = Math.max(0, (column.offsetHeight || availableHeight) - headerPx - 2);
                stringsContainer.style.cssText = `
                    flex: 1;
                    overflow: hidden;
                    padding: 1px 1px 8px 1px; /* bottom bounding box */
                    height: calc(100% - ${headerPx}px);
                    display: flex;
                    flex-direction: column;
                    justify-content: flex-start; /* we'll distribute gaps manually */
                `;
                // Respect global invert-strings preference
                try { if (document.documentElement.classList.contains('invert-strings')) stringsContainer.style.flexDirection = 'column-reverse'; } catch(_) {}
                // Subtle root tint based on current root note color (very dark)
                try {
                    const semi = this.stepToSemitone(currentRoot, tuningSize);
                    const accent = this.getChromaticColorForSemitone(semi) || '#000000';
                    const tint = (hex => {
                        const m = /^#?([0-9a-f]{6})$/i.exec(hex || '');
                        if (!m) return 'rgba(0,0,0,0)';
                        const n = parseInt(m[1], 16);
                        let r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                        // heavy darken: keep only ~6-12 of 255
                        r = Math.max(6, Math.floor(r * 0.08));
                        g = Math.max(6, Math.floor(g * 0.08));
                        b = Math.max(6, Math.floor(b * 0.08));
                        return `linear-gradient(to bottom, rgba(${r},${g},${b},0.12), rgba(${r},${g},${b},0.08))`;
                    })(accent);
                    stringsContainer.style.setProperty('--root-tint-gradient', tint);
                    const headerEl = column.querySelector('.extension-header');
                    if (headerEl) headerEl.style.setProperty('--root-tint-gradient', tint);
                } catch (_) {}
                
                // Compute microtonal gap distribution (bigger intervals = bigger vertical gaps)
                // Normalize using log-frequency distances so triads keep consistent relative spacing across keys/roots.
                let gapsPx = [];
                try {
                    const coreH = 4; // .string-core height
                    const baseGap = 2; // minimum gap between lines
                    // Use log2 frequency to make distances proportional to musical intervals and key-invariant
                    const logs = stringFreqs.map(sd => Math.log2(Math.max(1e-9, sd.freq)));
                    const dists = [];
                    for (let i=0;i<logs.length-1;i++) dists.push(Math.max(0, Math.abs(logs[i+1] - logs[i])));
                    const sum = dists.reduce((a,b)=>a+b,0) || 1;
                    const extraSpace = Math.max(0, stringsHeightPx - (stringFreqs.length * coreH) - ((stringFreqs.length-1) * baseGap));
                    gapsPx = dists.map(d => (d/sum) * extraSpace);
                    // Safety: lengths align (gaps between items)
                    if (gapsPx.length !== Math.max(0, stringFreqs.length-1)) gapsPx = new Array(Math.max(0, stringFreqs.length-1)).fill(0);
                } catch(_) { gapsPx = new Array(Math.max(0, stringFreqs.length-1)).fill(0); }

                stringFreqs.forEach((stringData, stringIndex) => {
                    const row = document.createElement('div');
                    row.className = 'string';
                    if (stringIndex > 0) {
                        const gap = (gapsPx[stringIndex-1] || 0) + 2; // include base gap
                        row.style.marginTop = `${gap.toFixed(2)}px`;
                    }
                    row.dataset.index = stringIndex;
                    row.dataset.column = column.dataset.chordType || 'unknown';
                    row.dataset.frequency = stringData.freq;
                    row.dataset.noteIndex = stringData.step;
                    // Persist the interval for later recalculation (e.g., during auto-lock recompute)
                    row.dataset.interval = stringData.interval;
                    // Also persist octave and relative EDO step (interval mapped in current tuning)
                    // Store the interval relative to the chord's stored root (model.fixedRootStepAbs)
                    try {
                        const tuningSize = currentTuning || this.getTuningStepsPerOctave();
                        // For edoStep calculation, always use the stored model root (if available) as reference
                        let referenceRoot = 0;
                        if (model && typeof model.fixedRootStepAbs === 'number') {
                            referenceRoot = model.fixedRootStepAbs; // This should always be 0 for edited chords
                        }
                        // Calculate interval relative to the reference root
                        const relStep = ((stringData.step - currentRoot + referenceRoot) % tuningSize + tuningSize) % tuningSize;
                        row.dataset.edoStep = String(relStep);
                        console.log('STRING GENERATION: stringData.step =', stringData.step, 'currentRoot =', currentRoot, 'referenceRoot =', referenceRoot, 'relStep =', relStep);
                    } catch (_) {
                        // Fallback: omit if cannot compute
                    }
                    row.dataset.octave = String(stringData.octave);
                    // Tag middle octave rows (3–4) for subtle highlighting
                    try {
                        const oct = parseInt(row.dataset.octave, 10);
                        if (oct === 3 || oct === 4) row.classList.add('mid-octave');
                    } catch(_) {}

                    // Colors: universal pitch-based (C..B spectrum)
                    const uniColor = this.getUniversalPitchColorForStep(stringData.step, tuningSize);
                    const baseColor = uniColor.color;
                    const glowColor = (baseColor && baseColor.toLowerCase() === '#000000') ? '#555555' : baseColor;
                    row.dataset.glowColor = glowColor;

                    // Visible core
                    const core = document.createElement('div');
                    core.className = 'string-core';
                    core.style.background = baseColor;
                    core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;

                    row.title = `${noteNames[stringData.step] || `Note ${stringData.step}`} - Oct${stringData.octave} - ${stringData.freq.toFixed(1)}Hz`;

                    // Hover effects on core
                    row.addEventListener('mouseenter', () => {
                        core.style.transform = 'scaleY(1.25)';
                        core.style.boxShadow = `0 0 6px ${glowColor}, 0 0 14px ${glowColor}CC, 0 0 28px ${glowColor}88`;
                    });
                    row.addEventListener('mouseleave', () => {
                        core.style.transform = 'scaleY(1)';
                        core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;
                    });

                    // Attach core
                    row.appendChild(core);
                    stringsContainer.appendChild(row);

                    // Precompute vibration period and store on core
                    const period = this.computeVibrationPeriod(stringData.freq, stringData.step);
                    core.style.setProperty('--vib-period', period + 'ms');
                });
                // Append first, then fit and apply play mode
                column.appendChild(stringsContainer);
                // Footer removed; height already correct. Now ensure fit and stretch gaps to fill height.
                this.ensureStringsFullyVisible(stringsContainer);
                try { this._distributeStringGapsToFill(stringsContainer); } catch(_) {}
                requestAnimationFrame(()=>{ try { this._distributeStringGapsToFill(stringsContainer); } catch(_) {} });
                try { this.applyPlayModeToColumnVisual(column); } catch(_) {}
            }

            // Shrink string heights uniformly if overflow would hide octaves
            ensureStringsFullyVisible(parent){
                if(!parent) return;
                const strings = Array.from(parent.querySelectorAll('.string'));
                if(!strings.length) return;
                // small timeout ensures layout values are settled if heights were zero initially
                const adjust = ()=>{
                    const visibleH = parent.clientHeight;
                    if(visibleH<=0) return;
                    const total = strings.reduce((sum,s)=> sum + s.offsetHeight, 0);
                    if(total <= visibleH) return; // fits already
                    const target = Math.max(1, Math.floor((visibleH - (strings.length*0.4)) / strings.length));
                    strings.forEach(s=>{ s.style.height = target + 'px'; });
                };
                // Run twice (immediate + next frame) to catch late layout
                adjust();
                requestAnimationFrame(adjust);
            }

            // Make rows span the full container by distributing vertical margins according to log-frequency distances.
            _distributeStringGapsToFill(parent) {
                if (!parent) return;
                const rows = Array.from(parent.querySelectorAll('.string'));
                if (rows.length < 2) return;
                const H = parent.clientHeight;
                if (!H || H <= 0) return;
                const baseGap = 2;
                const heights = rows.map(r => r.offsetHeight);
                const sumHeights = heights.reduce((a,b)=>a+b,0);
                let remaining = H - sumHeights - baseGap * (rows.length - 1);
                if (remaining < 0) remaining = 0;
                const logs = rows.map(r => Math.log2(Math.max(1e-9, parseFloat(r.dataset.frequency)||0)));
                const dists = [];
                for (let i=0; i<logs.length-1; i++) dists.push(Math.max(0, Math.abs(logs[i+1] - logs[i])));
                let sum = dists.reduce((a,b)=>a+b,0);
                if (!(sum > 1e-9)) { sum = dists.length || 1; for (let i=0;i<dists.length;i++) dists[i] = 1; }
                rows.forEach((r,i)=>{
                    if (i===0) { r.style.marginTop = '0px'; return; }
                    const extra = remaining * (dists[i-1] / sum);
                    r.style.marginTop = (baseGap + extra).toFixed(2) + 'px';
                });
            }

            // Add footer with ARP/CHORD trigger buttons to a column
            addColumnFooter(column) {
                // Footer buttons removed - header tap now handles chord/ARP triggering
                // Remove any existing footer
                const existingFooter = column.querySelector('.extension-footer');
                if (existingFooter) existingFooter.remove();
                
                // No footer needed anymore - header handles all triggering
                
                // Update strings container height to use full space (no footer)
                const stringsContainer = column.querySelector('.strings-column');
                const headerEl = column.querySelector('.extension-header');
                if (stringsContainer && headerEl) {
                    const headerPx = Math.max(56, headerEl.offsetHeight);
                    // No footer height needed anymore
                    stringsContainer.style.height = `calc(100% - ${headerPx}px)`;
                }
            }

            // Footer-related functions removed - header now handles all triggering
            
            handleTriggerButtonClick(column, clientY) {
                // Only trigger if we're in a valid mode
                const isArpMode = this.arpEnabled && !this.chordsEnabled;
                const isChordMode = this.chordsEnabled && !this.arpEnabled;
                
                if (isArpMode) {
                    this.triggerArpForColumn(column, clientY);
                } else if (isChordMode) {
                    this.triggerChordForColumn(column, clientY);
                } else {
                    // No feedback needed since there are no buttons to flash anymore
                    console.log('ARP/CHORD mode is disabled - no action taken');
                }
            }

            // Trigger ARP for a specific column via footer button
            triggerArpForColumn(column, clientY) {
                // Enable ARP mode temporarily if not already enabled
                const wasArpEnabled = this.arpEnabled;
                this.arpEnabled = true;
                
                // Use quantized chord change for proper timing
                this._scheduleQuantizedArpChordChange(column, clientY);
                
                // Visual feedback
                const arpButton = column.querySelector('.arp-trigger');
                if (arpButton) {
                    arpButton.classList.add('active');
                    setTimeout(() => arpButton.classList.remove('active'), 200);
                }
            }
            
            // Trigger CHORD for a specific column via footer button
            triggerChordForColumn(column, clientY) {
                // Enable CHORD mode temporarily if not already enabled
                const wasChordsEnabled = this.chordsEnabled;
                this.chordsEnabled = true;
                
                // Use immediate chord execution (chords don't need transport sync like ARP)
                this._executeChordChange(column, clientY);
                
                // Visual feedback
                const chordButton = column.querySelector('.chord-trigger');
                if (chordButton) {
                    chordButton.classList.add('active');
                    setTimeout(() => chordButton.classList.remove('active'), 200);
                }
            }

            // ===== Play Mode helpers: compute sequence and apply visual order =====
            // Group strings by octave (ascending), each group sorted low->high by frequency
            groupStringsByOctave(rows){
                const byOct = new Map();
                for (const r of rows){
                    const o = parseInt(r.dataset.octave||'0',10);
                    if (!byOct.has(o)) byOct.set(o, []);
                    byOct.get(o).push(r);
                }
                const octKeys = Array.from(byOct.keys()).sort((a,b)=> a-b);
                const groups = octKeys.map(o=> byOct.get(o).sort((a,b)=> (parseFloat(a.dataset.frequency)||0)-(parseFloat(b.dataset.frequency)||0)));
                return { groups, octaves: octKeys };
            }

            // Helper: from a column and a y-position, determine the tapped octave number
            _getTappedOctave(columnElement, yClient){
                try {
                    const colRect = columnElement.getBoundingClientRect();
                    const container = columnElement.querySelector('.strings-column');
                    if (!container) return null;
                    const rows = Array.from(container.querySelectorAll('.string'));
                    if (rows.length === 0) return null;
                    const hitY = yClient - colRect.top;
                    let best = null; let bestDist = Infinity;
                    for (const r of rows){
                        const rr = r.getBoundingClientRect();
                        const center = (rr.top + rr.height/2) - colRect.top;
                        const d = Math.abs(center - hitY);
                        if (d < bestDist){ bestDist = d; best = r; }
                    }
                    if (!best) return null;
                    const o = parseInt(best.dataset.octave||'0',10);
                    return Number.isFinite(o) ? o : null;
                } catch(_) { return null; }
            }

            // Helper: compute simultaneous chord targets for "Chords" mode
            _computeChordsModeTargets(columnElement, tappedOctave){
                const out = { stringsInOctave: [], bassFreq: null };
                try {
                    const rows = Array.from(columnElement.querySelectorAll('.strings-column .string'));
                    if (rows.length === 0) return out;
                    const tuning = this.currentTuning || 12;
                    // 1) Pick chord tones whose dataset.octave === tappedOctave
                    out.stringsInOctave = rows.filter(r => parseInt(r.dataset.octave||'0',10) === tappedOctave);
                    if (out.stringsInOctave.length === 0) {
                        // Fallback: choose closest octave group
                        let best = null; let bestDelta = Infinity;
                        const byOct = new Map();
                        rows.forEach(r=>{
                            const o = parseInt(r.dataset.octave||'0',10);
                            if (!byOct.has(o)) byOct.set(o, []);
                            byOct.get(o).push(r);
                        });
                        for (const [o, arr] of byOct.entries()){
                            const d = Math.abs(o - tappedOctave);
                            if (d < bestDelta){ bestDelta = d; best = arr; }
                        }
                        if (best) out.stringsInOctave = best;
                    }
                    // 2) Add sustained root bass within G1..C3 range
                    const baseStep = this._getEffectiveColumnRootStep(columnElement);
                    out.bassFreq = this._computeBassFreqInRange(baseStep, (typeof this._lastBassFreq==='number'?this._lastBassFreq:null), tuning);
                } catch(_) {}
                return out;
            }

            // Helper: compute the effective absolute root step for a column, honoring locks and transposes
            _getEffectiveColumnRootStep(columnElement){
                try {
                    const edoNow = this.currentTuning || 12;
                    const norm = (v,m)=> ((v % m) + m) % m;
                    const g = norm((this.transposeDelta || 0), edoNow);
                    const l = norm((+columnElement?.dataset?.localTranspose || 0), edoNow);
                    try { console.log('[ROOT] compute', { edoNow, g, l, col: columnElement?.dataset?.chordId || columnElement?.dataset?.originalPosition }); } catch(_){ }

                    // 1) Locked chord explicit root (absolute in its own tuning)
                    const locked = this.lockedChords?.get(columnElement);
                    if (locked && typeof locked.lockedRoot === 'number'){
                        const srcEdo = locked.lockedTuning || edoNow;
                        // Preserve exact cents across EDOs: convert step→cents→step, avoiding 12‑TET rounding
                        const lockedNorm = ((locked.lockedRoot % srcEdo) + srcEdo) % srcEdo;
                        const stepHere = (lockedNorm * edoNow) / srcEdo; // may be fractional to preserve microtones
                        return norm(stepHere + l, edoNow); // locked follows only local transpose
                    }

                    // 2) Per-chord fixed root from model, if available
                    try {
                        const id = columnElement?.dataset?.chordId;
                        let idx = -1; if (id) idx = (this.chordExtensions||[]).findIndex(c=> c && (String(c.id)===String(id)));
                        if (idx < 0 && columnElement?.dataset?.originalPosition != null){
                            const op = parseInt(columnElement.dataset.originalPosition,10);
                            if (!isNaN(op) && op >= 0) idx = op;
                        }
                        const model = (idx>=0)? (this.chordExtensions||[])[idx] : null;
                        if (model && typeof model.fixedRootStepAbs === 'number'){
                            const srcEdo = model.fixedRootTuning || edoNow;
                            // Preserve exact cents across EDOs
                            const fixedNorm = ((model.fixedRootStepAbs % srcEdo) + srcEdo) % srcEdo;
                            const stepHere = (fixedNorm * edoNow) / srcEdo; // fractional allowed
                            const valFixed = norm(stepHere + g + l, edoNow);
                            try { console.log('[ROOT] fixedRootStepAbs→', valFixed); } catch(_){ }
                            return valFixed;
                        }
                    } catch(_){ /* ignore */ }

                    // 2b) Derive root directly from rendered strings if possible (prefer exact root degree 0)
                    try {
                        const rootRow = columnElement?.querySelector?.('.strings-column .string[data-interval="0"]');
                        if (rootRow) {
                            const n = parseInt(rootRow.dataset?.noteIndex||'NaN',10);
                            if (Number.isFinite(n)) {
                                const valDirect = norm(n, edoNow);
                                try { console.log('[ROOT] from data-interval=0 row→', valDirect); } catch(_){ }
                                return valDirect;
                            }
                        }
                    } catch(_){ /* ignore */ }

                    // 3) Fallback: parse header name (root letter + accidental) to estimate absolute root step
                    //    This uses the current improved naming pipeline, so headers should reflect audible roots.
                    try {
                        const headerNameEl = columnElement?.querySelector?.('.extension-header .chord-name');
                        let header = headerNameEl ? (headerNameEl.dataset?.lockedName || headerNameEl.textContent || '') : '';
                        header = header.trim().replace(/^🔒\s*/, '');
                        // Support ASCII and unicode accidentals
                        const m = header.match(/^\s*([A-G])([#b♯♭]?)/);
                        if (m){
                            const acc = (m[2]||'').replace('♯','#').replace('♭','b');
                            const semi = this.rootToSemitone(m[1], acc);
                            const stepHere = this.semitoneToStep(semi, edoNow);
                            const valHdr = norm(stepHere + g + l, edoNow);
                            try { console.log('[ROOT] from header→', valHdr); } catch(_){ }
                            return valHdr;
                        }
                    } catch(_){ /* ignore */ }

                    // 4) Fallback to current global root with deltas
                    const base = this.currentRoot || 0;
                    const valBase = norm(base + g + l, edoNow);
                    try { console.log('[ROOT] fallback currentRoot→', valBase); } catch(_){ }
                    return valBase;
                } catch(_) { return (this.currentRoot || 0); }
            }

            // Helper: pick a bass frequency for an absolute step within the musical range B1..C3 (inclusive).
            // Prefers continuity to the previous bass when provided; otherwise chooses mid-range.
            _computeBassFreqInRange(absStep, prevFreq = null, edo = (this.currentTuning || 12)){
                try {
                    const s = ((absStep % edo) + edo) % edo;
                    try { console.log('[BASS] rangeSelect absStep=', absStep, 'edo=', edo, 'prevFreq=', prevFreq); } catch(_){ }
                    // Bass range: B1 to C3 (restricted range)
                    const bStep = this.semitoneToStep(11, edo); // B
                    const cStep = this.semitoneToStep(0, edo); // C
                    const minF = this.getFrequency(bStep, 1, edo); // B1 (61.7 Hz)
                    const maxF = this.getFrequency(cStep, 3, edo); // C3 (130.8 Hz)
                    const candidates = [1,2,3]
                        .map(oct => ({ f: this.getFrequency(s, oct, edo), oct }))
                        .filter(x => isFinite(x.f) && x.f > 0);
                    // Strictly within bounds B1-C3
                    const within = candidates.filter(x => x.f >= Math.min(minF, maxF) && x.f <= Math.max(minF, maxF));
                    const pool = within.length ? within : [];  // Don't fall back to out-of-range notes
                    if (!pool.length) return null;
                    const chooseBy = (target)=> pool.reduce((best, x)=>{
                        const d = Math.abs(Math.log2(x.f) - target);
                        return (!best || d < best.d) ? {x, d} : best;
                    }, null).x.f;
                    if (prevFreq && isFinite(prevFreq) && prevFreq>0){
                        return chooseBy(Math.log2(prevFreq));
                    }
                    const mid = Math.log2(Math.sqrt(minF * maxF)); // center in log-space
                    return chooseBy(mid);
                } catch(_){ return null; }
            }
            
            // Helper: Convert chord root name (like "C", "F#", "Bb") to step number
            _chordRootNameToStep(rootName, edo = 12) {
                if (!rootName || typeof rootName !== 'string') return null;
                
                // Basic note mapping for 12-EDO (can be extended for other EDOs)
                const noteMap = {
                    'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5,
                    'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11,
                    // Support Unicode symbols
                    'C♯': 1, 'D♭': 1, 'D♯': 3, 'E♭': 3, 'F♯': 6, 'G♭': 6, 'G♯': 8, 'A♭': 8, 'A♯': 10, 'B♭': 10
                };
                
                const cleanRoot = rootName.trim().replace(/[^\w#♯♭b]/g, '');
                const step12 = noteMap[cleanRoot];
                
                if (step12 === undefined) return null;
                
                // Convert from 12-EDO to target EDO
                return Math.round((step12 * edo) / 12);
            }
            
            // Helper: Update bass using specific chord root with GLIDE - DISABLED (only bass grid should play bass)
            _updateBassWithChordRoot(columnElement, rootStep) {
                // DISABLED: Only bass grid should control bass playback
                return;
                /*
                if (!this.bassEnabled || rootStep === null) return;
                
                try {
                    const edo = this.currentTuning || 12;
                    const target = this._computeBassFreqInRange(rootStep, (typeof this._heldBassLiveFreq==='number'?this._heldBassLiveFreq:null), edo);
                    
                    if (!isFinite(target) || target <= 0) return;
                    
                    // If there is no existing bass, start one
                    if (!this._heldBassVoice) {
                        // Locally save ADSR and panning, then restore after starting bass
                        const savedEnv1 = { ...this.envelope };
                        const savedEnv2 = { ...this.osc2Envelope };
                        const prevWidth = this.panning ? this.panning.width : null;
                        
                        try {
                            // Minimal, smooth bass envelope
                            this.envelope.attack = 0.005; this.envelope.decay = 0.05; this.envelope.sustain = 0.95; this.envelope.release = 0.08;
                            this.osc2Envelope.attack = 0.005; this.osc2Envelope.decay = 0.05; this.osc2Envelope.sustain = 0.95; this.osc2Envelope.release = 0.08;
                            // Force center pan
                            if (this.panning) this.panning.width = 0;
                            this.playFrequency(target, null, 'bass');
                        } finally {
                            // Restore settings
                            if (this.panning && prevWidth != null) this.panning.width = prevWidth;
                            Object.assign(this.envelope, savedEnv1);
                            Object.assign(this.osc2Envelope, savedEnv2);
                        }
                        
                        this._heldBassVoiceKey = target;
                        const v = this.activeOscillators.get(this._heldBassVoiceKey);
                        if (v) {
                            try { if (v.releaseTimeout) { clearTimeout(v.releaseTimeout); v.releaseTimeout = null; } } catch(_){ }
                            this._heldBassVoice = v; this._heldBassLiveFreq = target;
                        }
                    } else {
                        // Update existing bass to new frequency immediately
                        if (this._heldBassVoice && this._heldBassVoice.frequency) {
                            this._heldBassVoice.frequency.setValueAtTime(target, this._heldBassVoice.frequency.context.currentTime);
                            this._heldBassLiveFreq = target;
                        }
                    }
                } catch(err) {
                    console.warn('Bass chord root update failed:', err);
                }
                */
            }
            
            getPatternSequence(base, mode){
                // base: array of string elements ordered low->high (ascending by freq)
                const asc = base;
                const desc = base.slice().reverse();
                const altEnds = (arr)=>{ const a=arr.slice(); const out=[]; let i=0,j=a.length-1; while(i<=j){ if(i<=j) out.push(a[i++]); if(i<=j) out.push(a[j--]); } return out; };
                const altCenter = (arr)=>{ const a=arr.slice(); const mid=Math.floor((a.length-1)/2); const out=[]; let l=mid, r=mid+1; if(a.length%2===1){ out.push(a[mid]); l=mid-1; r=mid+1; } while(l>=0 || r<a.length){ if(r<a.length) out.push(a[r++]); if(l>=0) out.push(a[l--]); } return out; };
                switch(mode){
                    case 'low-high': return asc;
                    case 'high-low': return desc;
                    case 'alt-ends': return altEnds(asc);
                    case 'alt-center': return altCenter(asc);
                    default: return desc; // default visual top-high
                }
            }

            // Playback-oriented pattern builder: allows repeats (e.g., 123,234,345,456) within the swipe window
            getPatternPlaybackSequence(base, mode){
                // base: array of string elements ordered low->high WITHIN the gesture window
                const asc = base;
                const desc = base.slice().reverse();
                const altEnds = (arr)=>{ const a=arr.slice(); const out=[]; let i=0,j=a.length-1; while(i<=j){ if(i<=j) out.push(a[i++]); if(i<=j) out.push(a[j--]); } return out; };
                const altCenter = (arr)=>{ const a=arr.slice(); const mid=Math.floor((a.length-1)/2); const out=[]; let l=mid, r=mid+1; if(a.length%2===1){ out.push(a[mid]); l=mid-1; r=mid+1; } while(l>=0 || r<a.length){ if(r<a.length) out.push(a[r++]); if(l>=0) out.push(a[l--]); } return out; };
                if (typeof this.groupStringsByOctave === 'function'){
                    const { groups } = this.groupStringsByOctave(asc);
                    const out = [];
                    for (const g of groups){
                        switch(mode){
                            case 'low-high': out.push(...g); break;
                            case 'high-low': out.push(...g.slice().reverse()); break;
                            case 'alt-ends': out.push(...altEnds(g)); break;
                            case 'alt-center': out.push(...altCenter(g)); break;
                            default: out.push(...g.slice().reverse()); break; // default top-high
                        }
                    }
                    return out;
                }
                switch(mode){
                    case 'low-high': return asc.slice();
                    case 'high-low': return desc.slice();
                    case 'alt-ends': return altEnds(asc);
                    case 'alt-center': return altCenter(asc);
                    default: return desc.slice();
                }
            }

            // ===== ARP Engine =====
            _ensureArpDefaults(){
                if (this._arp) return;
                this._arp = {
                    bpm: 120,
                    quant: '1/16',
                    tuplet: 0,
                    chordQuant: '1/4',
                    chordsHold: 'bar:1',
                    npc: 3,
                    chordsNpc: 3,
                    pattern: 'up',
                    gatePct: 50,
                    // Sequence/chord state
                    active: false,
                    seq: [],
                    column: null,
                    span: { active:false, yMin:null, yMax:null, octMin:null, octMax:null },
                    startTickAlign: 0,
                    gateMs: 0,
                    pendingSwitch: null,
                    // Bass state
                    bassFreq: null,
                    bassVoice: null,
                    bassLiveFreq: null,
                    bassHold: true,
                    // Lead glide state
                    glide: false,
                    glideMs: null,
                    leadVoice: null,
                    leadLiveFreq: null
                };
                // Precompute a gateMs based on current tick length if transport exists
                const tickMs = this._arpTransport?.tickMs || 250;
                this._arp.gateMs = Math.max(5, Math.floor(((this._arp.gatePct||50)/100) * tickMs));
            }

            // Global ARP transport: keeps a shared bar-aligned clock so chord changes stay in time
            _ensureArpTransport(){
                if (this._arpTransport) return;
                this._arpTransport = {
                    running: false,
                    timer: null,
                    bpm: 120,
                    quant: '1/8',
                    tuplet: 0,
                    swingPct: (function(){
                        try { const v = localStorage.getItem('xen_swing_pct'); return Math.max(0, Math.min(75, v!=null? parseFloat(v): 0)); } catch(_) { return 0; }
                    })(),
                    isTriplet: false,
                    beatMs: 500,
                    tickMs: 250,
                    ticksPerBeat: 2,
                    beatsPerBar: 4,
                    ticksPerBar: 8,
                    tickCounter: 0,
                    absTickCounter: 0,
                    nextAt: 0,
                    lastActiveTick: 0,
                    lastActiveAbsTick: 0,
                    inactivityStopScheduled: false,
                    stopAtBarIndex: null,
                    metronomeOn: false,
                    _metroLastClickAt: 0,
                    holdStopAtAbsTick: null,
                    // Deferred settings application (apply atomically after 2 beats)
                    deferApplyAtAbsTick: null,
                    deferFlags: null,
                    pendingSwingPct: null
                };
            }

                // ===== Debug utilities =====
                _dbg(tag, ...args){
                    try{
                        if (!this._debug) return;
                        const ts = new Date().toISOString().split('T')[1].replace('Z','');
                        const msg = `[${ts}] ${tag}: ${args.map(a=>{
                            if (a == null) return String(a);
                            if (typeof a === 'object') {
                                try { return JSON.stringify(a); } catch { return String(a); }
                            }
                            return String(a);
                        }).join(' ')}`;
                        this._debugLogs.push(msg);
                        if (this._debugLogs.length > (this._debugMax||500)) this._debugLogs.splice(0, this._debugLogs.length - (this._debugMax||500));
                        if (this._debugConsole) {
                            const el = document.createElement('div');
                            el.textContent = msg;
                            this._debugConsole.appendChild(el);
                            this._debugConsole.scrollTop = this._debugConsole.scrollHeight;
                        }
                        // Mirror to devtools console for convenience
                        try { console.log(msg); } catch {}
                    } catch {}
                }
                setDebug(on){ this._debug = !!on; this._dbg('DEBUG', 'setDebug=', this._debug); }
                _installDebugPanel(){
                    if (!this._debugUI) return; // disabled per user request
                    if (this._debugPanelInstalled) return;
                    this._debugPanelInstalled = true;
                    const panel = document.createElement('div');
                    panel.id = 'omnidebug';
                    panel.style.cssText = 'position:fixed;right:8px;bottom:8px;width:420px;max-height:40vh;background:rgba(0,0,0,0.7);color:#0f0;font:12px/1.4 monospace;z-index:99999;border-radius:6px;box-shadow:0 2px 8px rgba(0,0,0,0.5);display:flex;flex-direction:column;';
                    const bar = document.createElement('div');
                    bar.style.cssText = 'display:flex;align-items:center;gap:8px;padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.1);';
                    const title = document.createElement('div'); title.textContent = 'XENON Debug'; title.style.flex='1';
                    const chk = document.createElement('input'); chk.type = 'checkbox'; chk.checked = !!this._debug; chk.title='Enable debug logging';
                    chk.addEventListener('change', ()=>{ this.setDebug(chk.checked); });
                    const clr = document.createElement('button'); clr.textContent = 'Clear'; clr.style.cssText='background:#222;color:#fff;border:1px solid #444;border-radius:3px;padding:2px 6px;cursor:pointer;';
                    clr.addEventListener('click', ()=>{ this._debugLogs.length=0; if (this._debugConsole) this._debugConsole.textContent=''; });
                    const dl = document.createElement('button'); dl.textContent = 'Download'; dl.style.cssText=clr.style.cssText;
                    dl.addEventListener('click', ()=>{
                        const blob = new Blob([this._debugLogs.join('\n')], {type:'text/plain'});
                        const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='xenon-debug.log'; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
                    });
                    bar.appendChild(title); bar.appendChild(chk); bar.appendChild(clr); bar.appendChild(dl);
                    const body = document.createElement('div'); body.style.cssText='overflow:auto;padding:8px;flex:1;';
                    this._debugConsole = body;
                    panel.appendChild(bar); panel.appendChild(body);
                    document.body.appendChild(panel);
                    // Flush any buffered logs
                    (this._debugLogs||[]).forEach(m=>{ const el=document.createElement('div'); el.textContent=m; body.appendChild(el); });
                    body.scrollTop = body.scrollHeight;
                }
            
            // PLAY button flashing functions
            _startPlayButtonFlashing() {
                // Stop any existing flashing
                this._stopPlayButtonFlashing();
                
                const playBtn = document.getElementById('playSeqBtn');
                if (!playBtn) return;
                
                // Get BPM and calculate beat interval
                const bpmEl = document.getElementById('universalBpm');
                const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                const beatMs = 60000 / Math.max(20, bpm);
                
                // Flash on every beat
                let isFlashing = false;
                this._playFlashTimer = setInterval(() => {
                    if (this._isSequencing) {
                        isFlashing = !isFlashing;
                        if (isFlashing) {
                            playBtn.style.backgroundColor = '#ff6b6b';
                            playBtn.style.color = '#fff';
                            playBtn.style.transform = 'scale(1.05)';
                        } else {
                            playBtn.style.backgroundColor = '';
                            playBtn.style.color = '';
                            playBtn.style.transform = '';
                        }
                    } else {
                        this._stopPlayButtonFlashing();
                    }
                }, beatMs / 2); // Flash twice per beat for visual clarity
            }
            
            _stopPlayButtonFlashing() {
                if (this._playFlashTimer) {
                    clearInterval(this._playFlashTimer);
                    this._playFlashTimer = null;
                }
                
                const playBtn = document.getElementById('playSeqBtn');
                if (playBtn) {
                    playBtn.style.backgroundColor = '';
                    playBtn.style.color = '';
                    playBtn.style.transform = '';
                }
            }
            
            _refreshArpTransportTiming(){
                this._ensureArpDefaults();
                this._ensureArpTransport();
                
                // Read current values from UI controls (universal only)
                const bpmEl = document.getElementById('universalBpm');
                const quantEl = document.getElementById('universalQuant');
                const swingEl = document.getElementById('universalSwing');
                
                const bpm = Math.max(20, Number(bpmEl?.value) || this._arp?.bpm || this._arpTransport.bpm || 120);
                const quant = quantEl?.value || this._arp?.quant || this._arpTransport.quant || '1/16';
                let swingPct = this._arpTransport.swingPct || 0;
                if (swingEl && swingEl.value != null) {
                    const sv = parseFloat(swingEl.value);
                    if (isFinite(sv)) swingPct = Math.max(0, Math.min(75, sv));
                }
                
                // Update _arp values to match UI
                if (this._arp) {
                    this._arp.bpm = bpm;
                    this._arp.quant = quant;
                }
                // Parse time signature now to compute bar math early
                const timeSignatureEl = document.getElementById('universalTimeSignature');
                const tsRaw = timeSignatureEl ? String(timeSignatureEl.value||'4/4') : '4/4';
                let tsNum = 4, tsDen = 4;
                try {
                    const [n,d] = tsRaw.split('/').map(v=>parseInt(v,10));
                    if (Number.isFinite(n) && n>0) tsNum = n;
                    if (Number.isFinite(d) && d>0) tsDen = d;
                } catch(_) {}
                // Support merged tuplet values via quant like "tuplet:7" or "tuplet:7/8"
                let tupletN = 0;
                let tupletDen = 4; // base against quarter unless specified
                if (typeof quant === 'string' && quant.startsWith('tuplet:')){
                    const spec = quant.slice(7);
                    const parts = spec.split('/');
                    const n = parseInt(parts[0],10);
                    const d = parts[1] != null ? parseInt(parts[1],10) : (tsDen || 4);
                    if (Number.isFinite(n) && n>0) tupletN = n; else tupletN = 0;
                    if (Number.isFinite(d) && d>0) tupletDen = d; else tupletDen = 4;
                } else {
                    tupletN = Math.max(0, this._arp?.tuplet || 0);
                    tupletDen = 4;
                }
                const beatMs = 60000 / bpm;
                let ticksPerBeat = 4; // default grid approximating 1/16
                let tickMs;
                if (tupletN > 0){
                    // Tuplet relative to note 1/tupletDen (quarter-relative base 4)
                    const noteMs = beatMs * (4/tupletDen);
                    tickMs = noteMs / tupletN;
                    ticksPerBeat = Math.max(1, Math.round(beatMs / tickMs));
                    this._arpTransport.isTriplet = false;
                } else {
                    const tri = q => q.endsWith('T');
                    const base = quant.replace('T','');
                    const map = { '1/1':1, '1/2':2, '1/4':4, '1/8':8, '1/16':16, '1/32':32 };
                    const div = map[base] || 16;
                    // quarter note is 1 beat; 1/div of whole note = (4/div) beats per tick
                    const beatsPerTick = tri(quant) ? ((4/div) * (2/3)) : (4/div);
                    ticksPerBeat = Math.max(1, Math.round(1/Math.max(1e-6, beatsPerTick)));
                    tickMs = beatMs * beatsPerTick;
                    this._arpTransport.isTriplet = tri(quant);
                }
                // Effective beats-per-bar in quarter-beats: N * 4 / D
                const effectiveBeatsPerBar = (tsNum * 4) / tsDen;
                // Prefer integer ticksPerBar for stable modulo; round from duration ratio
                const ticksPerBar = Math.max(1, Math.round((beatMs * effectiveBeatsPerBar) / tickMs));
                // Disable swing when using tuplets or triplets
                if (tupletN > 0 || this._arpTransport.isTriplet) swingPct = 0;
                this._arpTransport.swingPct = swingPct;
                const timeSignature = `${tsNum}/${tsDen}`;
                Object.assign(this._arpTransport, { bpm, quant, tuplet: tupletN, beatMs, tickMs, ticksPerBeat, beatsPerBar: effectiveBeatsPerBar, ticksPerBar, timeSignature });
                // Update gate based on current tick
                const gateMs = Math.max(5, Math.floor(((this._arp?.gatePct||50)/100) * tickMs));
                this._arp.gateMs = gateMs;
            }

            _startArpTransport(){
                this._ensureArpTransport();
                this._refreshArpTransportTiming();
                this._checkLoopBehavior(); // Check loop setting on start
                if (this._arpTransport.running) return;
                this._arpTransport.running = true;
                const now = (performance && performance.now) ? performance.now() : Date.now();
                const tickMs = this._arpTransport.tickMs;
                // Align nextAt to the next subdivision to minimize latency and keep stable phase
                const rem = now % tickMs;
                this._arpTransport.nextAt = now + (rem ? (tickMs - rem) : 0);
                const runTick = ()=>{
                    if (!this._arpTransport.running) return;
                    const t = (performance && performance.now) ? performance.now() : Date.now();
                    // Metronome click on beat, accented downbeat (beat indicators follow transport phase including swing)
                    try {
                        if (this._arpTransport.metronomeOn) {
                            const isBeat = (this._arpTransport.tickCounter % (this._arpTransport.ticksPerBeat||1)) === 0;
                            if (isBeat) {
                                const isDownbeat = this._arpTransport.tickCounter === 0;
                                const freq = isDownbeat ? 1400 : 1000;
                                const dur = Math.max(10, Math.min(40, Math.floor(this._arpTransport.tickMs * 0.35)));
                                this._clickMetronome(freq, dur);
                            }
                        }
                    } catch(_) { }

                    // Apply any pending chord/arp switch if it's time
                    try {
                        if (this._arp?.pendingSwitch) {
                            const ps = this._arp.pendingSwitch;
                            const nowAbs = this._arpTransport.absTickCounter|0;
                            if (ps.atAbsTick != null && nowAbs >= ps.atAbsTick) {
                                // In PLAY sequencing, hard-cut previous chord and bass at the boundary
                                try {
                                    if (this._isSequencing) {
                                        try { this.stopAllActiveNotes(); } catch(_){ }
                                        try { if (this._heldBassLiveFreq) this.stopFrequency(this._heldBassLiveFreq, null, 'bass'); } catch(_){ }
                                        try { if (this._arp?.bassLiveFreq) this.stopFrequency(this._arp.bassLiveFreq, null, 'bass'); } catch(_){ }
                                        try { this._heldBassVoice = null; this._heldBassLiveFreq = null; this._heldBassVoiceKey = null; } catch(_){ }
                                        try { if (this._arp){ this._arp.bassVoice = null; this._arp.bassLiveFreq = null; } } catch(_){ }
                                    }
                                } catch(_){ }
                                // Align new sequence to current transport phase if requested
                                if (ps.alignPhaseToTickCounter) {
                                    this._arp.startTickAlign = this._arpTransport.tickCounter;
                                }
                                // Activate with prepared data
                                this._arp.seq = Array.isArray(ps.seq) ? ps.seq : (this._arp.seq||[]);
                                // Recompute bass at switch time based on the target column's effective root,
                                // preferring continuity to the currently sounding bass.
                                try {
                                    const col = ps.column || this._arp.column;
                                    const tuning = this.currentTuning || 12;
                                    const prev = (typeof this._arp?.bassLiveFreq === 'number' && this._arp.bassLiveFreq>0)
                                        ? this._arp.bassLiveFreq
                                        : (Number.isFinite(ps.bassFreq) ? ps.bassFreq : (this._arp?.bassFreq||null));
                                    if (col) {
                                        const step = this._getEffectiveColumnRootStep(col);
                                        const bf = this._computeBassFreqInRange(step, prev, tuning);
                                        if (bf && isFinite(bf) && bf>0) {
                                            this._arp.bassFreq = bf;
                                        } else if (Number.isFinite(ps.bassFreq)) {
                                            this._arp.bassFreq = ps.bassFreq;
                                        }
                                    } else if (Number.isFinite(ps.bassFreq)) {
                                        this._arp.bassFreq = ps.bassFreq;
                                    }
                                } catch(_) {
                                    if (Number.isFinite(ps.bassFreq)) this._arp.bassFreq = ps.bassFreq;
                                }
                                this._arp.column = ps.column || this._arp.column;
                                // Persist ascending map for morph mapping lookups post-switch
                                try { this._arp.mapAsc = Array.isArray(ps.mapAsc) ? ps.mapAsc.slice() : (this._arp.mapAsc||[]); } catch(_) {}
                                // Store morph state for GLIDE
                                if (ps.morph){
                                    this._arp.morph = {
                                        startAbsTick: nowAbs,
                                        source: Array.isArray(ps.morph.source)? ps.morph.source.slice():[],
                                        currentTargets: Array.isArray(ps.morph.target)? ps.morph.target.slice():[],
                                        target: Array.isArray(ps.morph.target)? ps.morph.target.slice():[]
                                    };
                                } else {
                                    this._arp.morph = null;
                                }
                                // Independent lanes: honor requested mode ('arp' or 'chord')
                                this._arp.mode = ps.mode || 'arp';
                                this._arp.npc = Number.isFinite(ps.npc) ? ps.npc : (this._arp.npc||3);
                                if (ps.enableChord) {
                                    try {
                                        // Ensure chord voices sustain (no auto-release)
                                        this._sustainActive = true;
                                        const rows = Array.isArray(ps.chordRows) ? ps.chordRows : [];
                                        const canSlide = !!this._chordSlideEnabled;
                                        const anyActive = !!(this.activeOscillators && this.activeOscillators.size > 0);

                                        // Non-slide mode: hard switch to the new chord at the boundary
                                        if (!canSlide) {
                                            try { this.stopAllActiveNotes(); } catch(_){ }
                                            try { if (this._chordSlideVoices) this._chordSlideVoices.clear(); } catch(_){ }
                                        }

                                        // Seed chord voices if nothing is playing yet (first step), otherwise keep sustaining/gliding
                                        if (!anyActive || !canSlide) {
                                            const played = new Set();
                                            const bfLive = this._arp?.bassLiveFreq || this._heldBassLiveFreq || this._heldBassVoiceKey || null;
                                            const groupId = ((this._chordSlideGroupId||0)+1) >>> 0; this._chordSlideGroupId = groupId;
                                            rows.forEach(r=>{
                                                let f = parseFloat(r?.dataset?.frequency);
                                                if (!f || !isFinite(f) || f<=0){
                                                    try{
                                                        const step = parseInt(r.dataset.noteIndex,10);
                                                        const oct = parseInt(r.dataset.octave,10);
                                                        const tuning = this.currentTuning || 12;
                                                        if (Number.isFinite(step)) f = this.getFrequency(((step%tuning)+tuning)%tuning, Number.isFinite(oct)?oct:4, tuning);
                                                    }catch(_){ f = NaN; }
                                                }
                                                const isBass = !!(bfLive && Math.abs((f - bfLive)/bfLive) <= 5e-5);
                                                if (isFinite(f) && f>0 && !played.has(f) && !isBass){
                                                    played.add(f);
                                                    // Use dedicated CHORD oscillator lane
                                                    this.playFrequency(f, r, 'chord');
                                                    try { if (this._chordSlideVoices) this._chordSlideVoices.set(r, { startFreq: f, startLog2: Math.log2(f), groupId }); } catch(_){ }
                                                }
                                            });
                                        }
                                    } catch(_){ }
                                }
                                this._arp.active = true;
                                this._arp.pendingSwitch = null;
                                // Update held bass to follow ARP chord switches without gliding
                                try {
                                    if (this._arp?.column) {
                                        this._updateHeldBassForColumn(this._arp.column);
                                    }
                                } catch(_){ }
                            }
                        }
                    } catch(_) { }

                    // Apply any deferred settings at the scheduled transport boundary
                    try {
                        const dfAt = this._arpTransport.deferApplyAtAbsTick;
                        if (dfAt != null) {
                            const nowAbs = this._arpTransport.absTickCounter|0;
                            if (nowAbs >= dfAt) {
                                const flags = this._arpTransport.deferFlags || {};
                                // Transport/time updates (bpm/quant/swing/tuplet/time signature)
                                if (flags.transport || flags.swing || flags.grid) {
                                    if (flags.swing && this._arpTransport.pendingSwingPct != null) {
                                        this._arpTransport.swingPct = Math.max(0, Math.min(75, this._arpTransport.pendingSwingPct|0));
                                        this._arpTransport.pendingSwingPct = null;
                                    }
                                    try { this._refreshArpTransportTiming(); } catch(_) {}
                                }
                                // Rebuild drum grid if time signature changed
                                if (flags.grid) {
                                    try { this._updateDrumGridForTimeSignature(); } catch(_) {}
                                }
                                // MIDI settings updates (channels, ports, octave, velocity)
                                if (flags.midi) {
                                    try {
                                        const velEl = document.getElementById('midiDefaultVelocity');
                                        if (velEl && window.midi) {
                                            const v = Math.max(1, Math.min(127, parseInt(velEl.value||'100',10)));
                                            window.midi.defaultVelocity = v;
                                        }
                                    } catch(_) {}
                                    try {
                                        const octEl = document.getElementById('midiOctaveOffset');
                                        if (octEl && window.midi) {
                                            window.midi.octaveOffset = parseInt(octEl.value||'0',10) || 0;
                                        }
                                    } catch(_) {}
                                    try {
                                        const secs = ['strum1','strum2','chord','arp','bass'];
                                        for (const sec of secs) {
                                            const inEl = document.getElementById('midiIn-'+sec);
                                            if (inEl && window.midi) {
                                                window.midi.inputChannelMap[sec] = Math.max(0, Math.min(15, parseInt(inEl.value||'0',10)|0));
                                            }
                                            const outEl = document.getElementById('midiOut-'+sec);
                                            if (outEl && window.midi) {
                                                const sel = outEl.options[outEl.selectedIndex];
                                                const id = sel ? (sel.value || sel.getAttribute('data-id') || sel.textContent || '') : '';
                                                window.midi.outputPortMap[sec] = id || null;
                                            }
                                        }
                                    } catch(_) {}
                                }
                                // EDO tuning changes (deferred)
                                if (flags.edo != null) {
                                    try {
                                        if (typeof this.updateTuningSystem === 'function') {
                                            this.updateTuningSystem(flags.edo);
                                        }
                                        // If a sequence is loaded, regenerate it with the new EDO
                                        const textChordInput = document.getElementById('textChordInput');
                                        if (textChordInput && textChordInput.value.trim().length > 0) {
                                            if (typeof this.createSequenceFromTextarea === 'function') {
                                                console.log('🔄 Deferred regenerating chord sequence with new EDO:', flags.edo);
                                                this.createSequenceFromTextarea();
                                            }
                                        }
                                    } catch(_) {}
                                }
                                // ARP mode changes (deferred)
                                if (flags.arpMode) {
                                    try {
                                        const nextState = flags.arpMode;
                                        if (nextState === 'chords') { 
                                            this.chordsEnabled = true; 
                                            this.arpEnabled = false; 
                                        } else if (nextState === 'arp') { 
                                            this.chordsEnabled = false; 
                                            this.arpEnabled = true; 
                                        } else if (nextState === 'both') { 
                                            this.chordsEnabled = true; 
                                            this.arpEnabled = true; 
                                        } else { 
                                            this.chordsEnabled = false; 
                                            this.arpEnabled = false; 
                                        }
                                        this.syncPlayMode();
                                        this.updateModeUI();
                                        console.log('🎵 Deferred ARP mode change to:', nextState);
                                    } catch(_) {}
                                }
                                // Clear deferral state
                                this._arpTransport.deferApplyAtAbsTick = null;
                                this._arpTransport.deferFlags = null;
                            }
                        }
                    } catch(_) { }

                    // Auto-stop ARP after post-release HOLD duration if scheduled
                    try {
                        const drumsActive = !!document.querySelector('.drum-step.active');
                        if (!this._isSequencing && !drumsActive && this._arpTransport.holdStopAtAbsTick != null) {
                            const nowAbs = this._arpTransport.absTickCounter|0;
                            if (nowAbs >= this._arpTransport.holdStopAtAbsTick) {
                                this._dbg && this._dbg('ARP:HOLD:STOP', nowAbs);
                                this._arpTransport.holdStopAtAbsTick = null;
                                try { this._stopArp(); } catch(_) {}
                            }
                        }
                    } catch(_) { }

                    // Play any active ARP voice aligned to global tickCounter
                        if (this._arp && this._arp.active && this._arp.seq && this._arp.seq.length){
                            // Suppress per-tick gating while in chord mode; sustain is handled at switch time
                            if (this._arp.mode === 'chord'){
                                this._arpTransport.lastActiveTick = this._arpTransport.tickCounter;
                                this._arpTransport.lastActiveAbsTick = this._arpTransport.absTickCounter;
                                this._arpTransport.inactivityStopScheduled = false;
                                this._arpTransport.stopAtBarIndex = null;
                                // Skip the step-gate block entirely in chord mode
                            } else if (this._arp.mode === 'arp') {
                            // ARP mode: gate per tick (works in PLAY when ARP is enabled OR during sequencing)
                            const seq = this._arp.seq;
                            const idx = (this._arpTransport.tickCounter - (this._arp.startTickAlign||0));
                            const el = seq[((idx%seq.length)+seq.length)%seq.length];
                            
                            // Determine gate duration: ARP steps use quant-based gate (HOLD controls chord switching)
                            const gateMs = this._arp.gateMs || Math.max(5, Math.floor(((this._arp.gatePct||50)/100) * this._arpTransport.tickMs));
                            
                            if (el == null) {
                                // Rest step: do nothing but still advance
                                this._arpTransport.lastActiveTick = this._arpTransport.tickCounter;
                                this._arpTransport.lastActiveAbsTick = this._arpTransport.absTickCounter;
                                this._arpTransport.inactivityStopScheduled = false;
                                this._arpTransport.stopAtBarIndex = null;
                                // No early return; allow scheduler to continue
                            }
                            // Support chords-per-step: el can be a Node or an array of Nodes
                            const playOne = (node)=>{
                                let f = node ? parseFloat(node.dataset.frequency) : NaN;
                                if (!f || !isFinite(f) || f<=0){
                                    try{
                                        const step = parseInt(node.dataset.noteIndex,10);
                                        const oct = parseInt(node.dataset.octave,10);
                                        const tuning = this.currentTuning || 12;
                                        if (Number.isFinite(step)) f = this.getFrequency(((step%tuning)+tuning)%tuning, Number.isFinite(oct)?oct:4, tuning);
                                    }catch(_){ }
                                }
                                const bfLive = this._arp?.bassLiveFreq;
                                const isBassStep = !!(bfLive && Math.abs((f - bfLive) / bfLive) <= 5e-5);
                                if (f && isFinite(f) && f>0 && !isBassStep){
                                    this.playFrequency(f, null, 'arp');
                                    setTimeout(()=>{
                                        try {
                                            const bf = this._arp?.bassLiveFreq;
                                            if (!bf || Math.abs((f - bf)/bf) > 5e-5) {
                                                this.stopFrequency(f, null, 'arp');
                                            }
                                        } catch(_) { /* ignore */ }
                                    }, gateMs);
                                }
                            };
                            if (Array.isArray(el)) {
                                el.forEach(node => playOne(node));
                            } else {
                                playOne(el);
                            }
                            }

                            // Bass disabled in ARP slide per request
                            // Alternate panning on each step
                            try { if (this.panning && this.panning.mode === 'alternating') this.panning.alternateState = !this.panning.alternateState; } catch(_){ }
                            this._arpTransport.lastActiveTick = this._arpTransport.tickCounter;
                            this._arpTransport.lastActiveAbsTick = this._arpTransport.absTickCounter;
                            // Any new activity cancels a pending inactivity stop
                            this._arpTransport.inactivityStopScheduled = false;
                            this._arpTransport.stopAtBarIndex = null;
                            }
            // Drums: advance playhead and trigger on step boundaries
            try { this._drumsOnTransportTick(); } catch(_) { }
                    // Advance transport tick and schedule next, correcting drift
                    this._arpTransport.tickCounter = (this._arpTransport.tickCounter + 1) % (this._arpTransport.ticksPerBar||64);
                    this._arpTransport.absTickCounter = (this._arpTransport.absTickCounter + 1) >>> 0; // keep as non-negative int
                    // Apply swing to the next interval if eligible with pair compensation
                    let nextDelta = this._arpTransport.tickMs;
                    const tpb = this._arpTransport.ticksPerBeat||1;
                    const swingPct = Math.max(0, Math.min(75, this._arpTransport.swingPct||0));
                    if (swingPct > 0 && (tpb % 2 === 0) && !this._arpTransport.isTriplet && (this._arpTransport.tuplet||0)===0) {
                        const withinBeat = this._arpTransport.tickCounter % tpb;
                        const prevWithin = ((this._arpTransport.tickCounter - 1 + tpb) % tpb);
                        const swingShift = (swingPct/100) * this._arpTransport.tickMs;
                        // Delay off-beats
                        if ((withinBeat % 2) === 1) {
                            nextDelta = this._arpTransport.tickMs + swingShift;
                        } else if ((prevWithin % 2) === 1) {
                            // Compensate immediately after an off-beat to keep average tempo stable
                            nextDelta = Math.max(0, this._arpTransport.tickMs - swingShift);
                        } else {
                            nextDelta = this._arpTransport.tickMs;
                        }
                    }
                    // Resync at bar boundaries to eliminate accumulated drift
                    if (this._arpTransport.tickCounter === 0) {
                        this._arpTransport.nextAt = t + nextDelta;
                    } else {
                        this._arpTransport.nextAt += nextDelta;
                    }
                    // If inactivity is scheduled and still no active ARP voice, stop after a full empty bar at bar boundary
                    // Keep transport running if metronome is on
                    const drumsActive2 = !!document.querySelector('.drum-step.active');
                    if (!this._arpTransport.metronomeOn && !drumsActive2 && this._arpTransport.inactivityStopScheduled && (!this._arp || !this._arp.active)){
                        const tpBar = this._arpTransport.ticksPerBar || 16;
                        const curBarIdx = Math.floor(this._arpTransport.absTickCounter / tpBar);
                        if (this._arpTransport.stopAtBarIndex != null && curBarIdx >= this._arpTransport.stopAtBarIndex && this._arpTransport.tickCounter === 0){
                            this._stopArpTransport();
                            return;
                        }
                    }
                    const delay = Math.max(0, this._arpTransport.nextAt - ((performance && performance.now) ? performance.now() : Date.now()));
                    this._arpTransport.timer = setTimeout(runTick, delay);
                };
                const firstDelay = Math.max(0, this._arpTransport.nextAt - now);
                this._arpTransport.timer = setTimeout(runTick, firstDelay);
            }

            _stopArpTransport(){
                if (!this._arpTransport) return;
                this._arpTransport.running = false;
                if (this._arpTransport.timer){ clearTimeout(this._arpTransport.timer); this._arpTransport.timer = null; }
                this._arpTransport.inactivityStopScheduled = false;
            }

            _scheduleTransportStopAfterInactivity(){
                this._ensureArpTransport();
                if (this._arpTransport.inactivityStopScheduled) return;
                this._arpTransport.inactivityStopScheduled = true;
                // Compute the bar index after one full empty bar from now
                const tpBar = this._arpTransport.ticksPerBar || 16;
                const curBarIdx = Math.floor((this._arpTransport.absTickCounter || 0) / tpBar);
                this._arpTransport.stopAtBarIndex = curBarIdx + 1; // stop at the beginning of the next bar after an empty one
            }

            _parseQuantToMs(quant, bpm){
                const beatMs = 60000 / Math.max(1, bpm);
                const tri = q => q.endsWith('T');
                const base = quant.replace('T','');
                const map = { '1/1':1, '1/2':2, '1/4':4, '1/8':8, '1/16':16, '1/32':32 };
                const div = map[base] || 8;
                let dur = beatMs * (4/div);
                if (tri(quant)) dur *= 2/3; // triplet
                return dur;
            }

            // Very short click routed to the existing voice chain (no reverb)
            _clickMetronome(freq, durMs){
                try {
                    if (!this.audioContext) return;
                    const ctx = this.audioContext;
                    const osc = ctx.createOscillator();
                    const amp = ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = Math.max(100, Math.min(3000, freq||1000));
                    amp.gain.value = 0.0001;
                    // Short click envelope
                    const now = ctx.currentTime;
                    amp.gain.setValueAtTime(0.0001, now);
                    amp.gain.exponentialRampToValueAtTime(0.5, now + 0.002);
                    amp.gain.exponentialRampToValueAtTime(0.0001, now + Math.max(0.015, (durMs||20)/1000));
                    // Route before reverb, to final mix dry path
                    osc.connect(amp);
                    amp.connect(this._drive ? this._drive.input : this.finalMixer || this.audioContext.destination);
                    osc.start();
                    osc.stop(now + Math.max(0.02, (durMs||20)/1000 + 0.005));
                } catch(_) { }
            }

            _buildArpSequence(rows, pattern, tappedStep){
                // Build an ascending/descending ladder across octaves starting from the root in the base octave
                // so NPC can exceed chord size: e.g., C3,E3,G3,C4,E4,G4 for NPC=6
                const safeAsc = rows.slice().sort((a,b)=> (parseFloat(a?.dataset?.frequency)||0)-(parseFloat(b?.dataset?.frequency)||0));
                const npc = Math.max(1, (this._getGlobalNpc ? this._getGlobalNpc() : (this._arp?.npc|0)) || 1);
                // Custom typed numeric pattern support: "1[23]1[23]1[56]1[x]" etc.
                try {
                    const txtEl = document.getElementById('universalPatternText');
                    const patternGrid = document.getElementById('patternGrid');
                    let txt = '';
                    
                    // Get pattern text from appropriate source
                    const universalPattern = document.getElementById('universalPattern');
                    if (universalPattern && universalPattern.value === 'custom') {
                        // CUSTOM mode: use text field
                        txt = txtEl ? String(txtEl.value||'').trim() : '';
                    } else {
                        // Non-CUSTOM modes: use computed pattern from grid dots
                        txt = (patternGrid && patternGrid._computedPattern) ? String(patternGrid._computedPattern).trim() : '';
                    }
                    
                    if (txt) {
                        // Build a 1-indexed pool from ascending ladder (spanning octaves already)
                        const pool = safeAsc;
                        const tokens = [];
                        let i=0; const N = txt.length;
                        while (i<N) {
                            const ch = txt[i];
                            if (ch === ' ') { i++; continue; }
                            if (ch === 'x' || ch === 'X') { tokens.push(null); i++; continue; }
                            if (ch === '[') {
                                i++;
                                const group = [];
                                while (i<N && txt[i] !== ']') {
                                    const c = txt[i];
                                    if (/[0-9]/.test(c)) {
                                        let num = c; i++;
                                        while (i<N && /[0-9]/.test(txt[i])) { num += txt[i++]; }
                                        const idx = parseInt(num,10);
                                        if (Number.isFinite(idx) && idx>=1 && idx<=pool.length) group.push(pool[idx-1]);
                                        continue;
                                    } else if (c === 'x' || c === 'X') {
                                        // rest within group ignored (no sound)
                                        i++;
                                        continue;
                                    } else if (c === ' ') { i++; continue; }
                                    else { i++; }
                                }
                                if (i<N && txt[i] === ']') i++;
                                tokens.push(group.length? group : null);
                                continue;
                            }
                            if (/[0-9]/.test(ch)) {
                                let num = ch; i++;
                                while (i<N && /[0-9]/.test(txt[i])) { num += txt[i++]; }
                                const idx = parseInt(num,10);
                                if (Number.isFinite(idx) && idx>=1 && idx<=pool.length) tokens.push(pool[idx-1]); else tokens.push(null);
                                continue;
                            }
                            // Unknown char: skip
                            i++;
                        }
                        // For custom typed patterns, play exactly the typed sequence.
                        // Transport modulo handles repetition at QUANT rate independent of bar length.
                        if (tokens.length > 0) return tokens;
                    }
                } catch(_) {}
                const altEnds = (arr)=>{ const a=arr.slice(); const out=[]; let i=0,j=a.length-1; while(i<=j){ if(i<=j) out.push(a[i++]); if(i<=j) out.push(a[j--]); } return out; };
                const altCenter = (arr)=>{ const a=arr.slice(); const mid=Math.floor((a.length-1)/2); const out=[]; let l=mid, r=mid+1; if(a.length%2===1){ out.push(a[mid]); l=mid-1; r=mid+1; } while(l>=0 || r<a.length){ if(r<a.length) out.push(a[r++]); if(l>=0) out.push(a[l--]); } return out; };

                // Column + octave inventory (3..9)
                const firstEl = safeAsc[0];
                const column = firstEl?.closest ? firstEl.closest('.extension-column') : null;
                if (!column) {
                    // Fallback to simple slicing if we cannot resolve column (still start from lowest/root-like)
                    const asc = safeAsc;
                    const desc = asc.slice().reverse();
                    switch(pattern){
                        case 'up': return asc.slice(0, npc);
                        case 'down': return desc.slice(0, npc);
                        case 'updown': { 
                            const a = asc.slice(0, npc); 
                            if (a.length <= 1) return a;
                            const result = [];
                            // Add ascending sequence
                            result.push(...a);
                            // Add descending sequence (excluding first and last to avoid repeats)
                            if (a.length > 2) {
                                const desc = a.slice(1, -1).reverse();
                                result.push(...desc);
                            }
                            return result; // Proper up-down without repeating endpoints
                        }
                        case 'downup': { 
                            const d = desc.slice(0, npc); 
                            if (d.length <= 1) return d;
                            const result = [];
                            // Add descending sequence
                            result.push(...d);
                            // Add ascending sequence (excluding first and last to avoid repeats)
                            if (d.length > 2) {
                                const asc = d.slice(1, -1).reverse();
                                result.push(...asc);
                            }
                            return result; // Proper down-up without repeating endpoints
                        }
                        case 'alt-ends': return altEnds(asc).slice(0, npc);
                        case 'alt-center': return altCenter(asc).slice(0, npc);
                        case 'random': return asc.sort(()=>Math.random()-0.5).slice(0, npc);
                        default: return asc.slice(0, npc);
                    }
                }

                // Map desired step order from the tapped octave and rotate so the tapped degree is first
                // Unique desired steps (by EDO step) to avoid per-octave duplicates that block cross-octave extension
                let desiredSteps = safeAsc
                    .map(r => parseInt(r.dataset?.edoStep||'NaN',10))
                    .filter(n=>Number.isFinite(n));
                if (desiredSteps.length) {
                    const seen = new Set();
                    desiredSteps = desiredSteps.filter(st => { if (seen.has(st)) return false; seen.add(st); return true; });
                }
                if (desiredSteps.length){
                    const anchor = (Number.isFinite(tappedStep) ? tappedStep : desiredSteps[0]);
                    const idx = desiredSteps.indexOf(anchor);
                    if (idx > 0) desiredSteps = desiredSteps.slice(idx).concat(desiredSteps.slice(0, idx));
                }
                const allStrings = Array.from(column.querySelectorAll('.strings-column .string'));
                const byOct = new Map();
                allStrings.forEach(r=>{
                    const o = parseInt(r.dataset?.octave||'0',10);
                    if (o>=3 && o<=9){ if(!byOct.has(o)) byOct.set(o,[]); byOct.get(o).push(r); }
                });
                // Align each octave's rows to base order
                const alignOct = (o)=>{
                    const grp = (byOct.get(o)||[]).slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0)-(parseFloat(b.dataset.frequency)||0));
                    if (!grp.length) return [];
                    if (!desiredSteps.length) return grp;
                    const gMap = new Map(grp.map(r=> [parseInt(r.dataset.edoStep||'NaN',10), r]));
                    const out = [];
                    desiredSteps.forEach(st=>{ const rr = gMap.get(st); if(rr) out.push(rr); });
                    return out.length? out : grp;
                };
                // Determine base octave
                const baseOct = parseInt(safeAsc[0]?.dataset?.octave||'4',10);
                const ascOcts = []; for(let o=baseOct; o<=9; o++) ascOcts.push(o);
                const descOcts = []; for(let o=baseOct; o>=3; o--) descOcts.push(o);
                const ladderAsc = ascOcts.flatMap(o=> alignOct(o));
                const ladderDesc = descOcts.flatMap(o=> alignOct(o).slice().reverse());

                // Rotate ladders so the tapped degree in the base octave is first
                const baseGroup = alignOct(baseOct);
                const anchorStep = Number.isFinite(tappedStep) ? tappedStep : (baseGroup.length? parseInt(baseGroup[0]?.dataset?.edoStep||'NaN',10) : null);
                const anchorRow = baseGroup.find(r=> Number.isFinite(anchorStep) && parseInt(r.dataset?.edoStep||'NaN',10) === anchorStep) || baseGroup[0];
                const rotateToStart = (arr, el)=>{ const i = arr.indexOf(el); return (i>0) ? (arr.slice(i).concat(arr.slice(0,i))) : arr; };
                if (anchorRow){
                    // For 'up' variants we want ascending starting at anchor; for 'down' starting at anchor descending
                    // We rotate here; the switch(pattern) below will still apply up/down shapes and NPC trimming.
                    for (let k=0; k<1; k++) { /* no-op loop to keep scope clear */ }
                    // Replace ladders with rotated versions without mutating originals unexpectedly
                    var ladderAscRot = rotateToStart(ladderAsc, anchorRow);
                    var ladderDescRot = rotateToStart(ladderDesc, anchorRow);
                } else {
                    var ladderAscRot = ladderAsc;
                    var ladderDescRot = ladderDesc;
                }

                // Walk patterns: repeat directional motifs with boundary bounce (exclude endpoints on reversal)
                const buildWalk = (ladder, motif)=>{
                    // motif is an array of +1/-1 steps, e.g., [1,1,-1] (UUD) or [-1,-1,1] (DDU)
                    const L = ladder.length;
                    if (L === 0) return [];
                    if (L === 1) return ladder.slice(0, Math.min(npc, 1));
                    const out = [];
                    let idx = 0; // start at anchor (rotated start)
                    out.push(ladder[idx]);
                    let m = 0;
                    while (out.length < npc) {
                        let step = motif[m % motif.length];
                        let next = idx + step;
                        // Bounce at boundaries; exclude repeating endpoints on reversal
                        if (next >= L) {
                            // Hit top; reflect
                            next = L - 2; // step to the one below top
                            // Also adjust motif direction by flipping current step
                            step = -1;
                            m = (m + 1) % motif.length; // advance motif to keep rhythm-like feel
                        } else if (next < 0) {
                            // Hit bottom; reflect
                            next = 1; // step to the one above bottom
                            step = 1;
                            m = (m + 1) % motif.length;
                        } else {
                            m = (m + 1) % motif.length;
                        }
                        idx = next;
                        out.push(ladder[idx]);
                    }
                    return out;
                };

                switch(pattern){
                    case 'up': return ladderAscRot.slice(0, npc);
                    case 'down': return ladderDescRot.slice(0, npc);
                    case 'updown': {
                        const a = ladderAscRot.slice(0, npc);
                        if (a.length <= 1) return a;
                        const result = [];
                        // Add ascending sequence
                        result.push(...a);
                        // Add descending sequence (excluding first and last to avoid repeats)
                        if (a.length > 2) {
                            const desc = a.slice(1, -1).reverse();
                            result.push(...desc);
                        }
                        return result; // Proper up-down without repeating endpoints
                    }
                    case 'downup': {
                        const d = ladderDescRot.slice(0, npc);
                        if (d.length <= 1) return d;
                        const result = [];
                        // Add descending sequence
                        result.push(...d);
                        // Add ascending sequence (excluding first and last to avoid repeats)
                        if (d.length > 2) {
                            const asc = d.slice(1, -1).reverse();
                            result.push(...asc);
                        }
                        return result; // Proper down-up without repeating endpoints
                    }
                    case 'walk-up': return buildWalk(ladderAscRot, [1, 1, -1]); // UUD UUD ...
                    case 'walk-down': return buildWalk(ladderDescRot, [-1, -1, 1]); // DDU DDU ...
                    case 'alt-ends': return altEnds(ladderAscRot.length? ladderAscRot : ladderAsc).slice(0, npc);
                    case 'alt-center': return altCenter(ladderAscRot.length? ladderAscRot : ladderAsc).slice(0, npc);
                    case 'random': {
                        const base = ladderAscRot.length? ladderAscRot : ladderAsc;
                        return base.slice().sort(()=>Math.random()-0.5).slice(0, npc);
                    }
                    default: return ladderAscRot.length? ladderAscRot.slice(0, npc) : ladderAsc.slice(0, npc);
                }
            }

    _startArp(columnElement, clientY, preservePosition = false){
        this._dbg && this._dbg('ARP:START', columnElement?.dataset?.chordId || columnElement?.dataset?.originalPosition, 'clientY=', clientY, 'preserve=', preservePosition);
        
        // Preserve current NPC position if requested
        const preservedNPC = preservePosition && this._arp ? this._arp.currentNPC : null;
        const preservedTransportRunning = preservePosition && this._arpTransport ? this._arpTransport.running : false;
        
        this._ensureArpDefaults();
        this._ensureArpTransport();
        
        // Store the current column for same-chord detection
        this._arp.column = columnElement;
        // Suppress per-note panning auto-toggle while ARP owns alternation
        this._suppressPanningAutoToggle = true;
    // Per request: ensure no ARP bass is active while using ARP/slide
    try { if (this._arp?.bassVoice && this._arp?.bassLiveFreq) { this.stopFrequency(this._arp.bassLiveFreq, null, 'bass'); } } catch(_){ this._dbg && this._dbg('ARP:BASS:STOP:ERR'); }
    if (this._arp){ this._arp.bassVoice = null; this._arp.bassLiveFreq = null; this._arp.bassFreq = null; }
    // No bass updates from ARP start
        // Capture UI values
        try {
            const bpmEl = document.getElementById('universalBpm');
            const quantEl = document.getElementById('universalQuant');
            const patEl = document.getElementById('universalPattern');
            const npcEl = document.getElementById('universalNpc');
            const chordHoldEl = document.getElementById('chordHold');
            // Wire arpPattern change listener (universal)
            if (patEl && !patEl._wired){
                patEl._wired = true;
                patEl.addEventListener('change', ()=>{ this._arp.pattern = patEl.value || 'up'; });
            }
            // Wire global NPC change listener
            if (npcEl && !npcEl._wired){
                npcEl._wired = true;
                npcEl.addEventListener('change', ()=>{ this._arp.npc = Math.max(1, Math.min(64, parseInt(npcEl.value)||3)); });
            }
            if (bpmEl) this._arp.bpm = Math.max(20, Math.min(300, parseInt(bpmEl.value)||120)); this._dbg && this._dbg('ARP:UI', 'bpm=', this._arp.bpm);
            if (quantEl) {
                this._arp.quant = quantEl.value || '1/16';
                if (this._arp.quant.startsWith('tuplet:')){
                    const n = parseInt(this._arp.quant.split(':')[1],10);
                    this._arp.tuplet = Number.isFinite(n) && n>0 ? n : 0;
                } else {
                    this._arp.tuplet = 0;
                }
            }
            if (patEl) this._arp.pattern = patEl.value || 'up';
            if (npcEl) this._arp.npc = Math.max(1, Math.min(64, parseInt(npcEl.value)||3)); this._dbg && this._dbg('ARP:UI', 'npc=', this._arp.npc);
            if (chordHoldEl) this._arp.chordsHold = chordHoldEl.value || 'bar:1';
            this._arp.gatePct = 50;
            this._arp.glide = false; // glide removed
            this._arp.glideMs = 0;
        } catch(_){ }

        // Build note list for arpeggio range consistent with PLAY mode (octaves 3–9)
        // Respect a previously locked octave (from chord gesture) if present; else use the tapped octave and lock it for the ARP gesture
        let tappedOct = Number.isFinite(this._slideOctaveLock) ? this._slideOctaveLock : this._getTappedOctave(columnElement, clientY);
        if (!Number.isFinite(this._slideOctaveLock) && Number.isFinite(tappedOct)) this._slideOctaveLock = tappedOct;
        const rowsAll = Array.from(columnElement.querySelectorAll('.strings-column .string'));
        // Use C3-C9 octave window for PATTERN (pattern arpeggios use melodic range)
        const within = rowsAll.filter(r => {
            const o = parseInt(r.dataset.octave||'0',10);
            return o>=3 && o<=9; // C3–C9 range for pattern arpeggios
        });
    const npc = Math.max(1, (this._getGlobalNpc ? this._getGlobalNpc() : (this._arp.npc|0)));
        const pat = this._arp.pattern || 'up';
        // Determine tapped step within tapped octave for anchoring NPC palette
        let tappedStep = null;
        try {
            const y = clientY;
            // Find the row at this Y within the tapped octave
            const hit = document.elementFromPoint(columnElement.getBoundingClientRect().left + 1, y);
            const row = hit && hit.closest ? hit.closest('.string') : null;
            tappedStep = row ? parseInt(row.dataset?.edoStep||'NaN',10) : null;
        } catch(_) { tappedStep = null; }
        // Base ascending order for mapping (low->high), first npc items
        const asc = within.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0) - (parseFloat(b.dataset.frequency)||0));
        const mapAsc = asc.slice(0, npc);
    let seq = this._buildArpSequence(within, pat, tappedStep);
        this._dbg && this._dbg('ARP:SEQ', 'oct=', tappedOct, 'pat=', pat, 'npc=', npc, 'len=', seq.length);
        // Directional strum shift in ARP: move order by one note based on vertical motion
        try {
            if (typeof clientY === 'number'){
                const lastY = this._arp._lastStartY;
                const dy = (typeof lastY==='number') ? (clientY - lastY) : 0;
                this._arp._lastStartY = clientY;
                if (dy < -6 && seq.length>1){ // upward motion: rotate left
                    const first = seq.shift(); seq.push(first);
                } else if (dy > 6 && seq.length>1){ // downward motion: rotate right
                    const last = seq.pop(); seq.unshift(last);
                }
            }
        } catch(_){ }
    this._arp.seq = seq;
    // Bass disabled in ARP per request
        // Decide when to apply this change based on chord-change quant and bar position
    const tpBeat = this._arpTransport.ticksPerBeat || 1;
    const tpBar = this._arpTransport.ticksPerBar || (tpBeat*4);
    const curTick = this._arpTransport.tickCounter|0;
    const absTick = this._arpTransport.absTickCounter|0;
    // Align chord change to the next tick; if we're in the last beat of the bar, wait for the next bar downbeat
    const inLastBeatOfBar = curTick >= (tpBar - tpBeat);
    const ticksToNextBar = (tpBar - (curTick % tpBar)) % tpBar;
    const targetAbsTick = inLastBeatOfBar ? (absTick + ticksToNextBar) : (absTick + 1);
    const alignToCurrentPhase = false; // preserve transport phase so step index reflects current bar position

        // Prepare morph mapping for GLIDE mode: index-aligned source→target sets (follow seq order)
        let targetFreqs = [];
        try {
            const tuning = this.currentTuning || 12;
            // Use the exact sequence order for morph targets so indices match transport step indices
            const seqForMorph = Array.isArray(seq) && seq.length ? seq : mapAsc;
            targetFreqs = seqForMorph.map(r=>{
                const step = parseInt(r.dataset.noteIndex,10);
                const oct = parseInt(r.dataset.octave,10);
                const s = ((step%tuning)+tuning)%tuning; return this.getFrequency(s, Number.isFinite(oct)?oct:4, tuning);
            }).filter(f=> isFinite(f) && f>0);
        } catch(_){ targetFreqs = []; }
        // Source set: previous targets if available; else current targets (no jump)
        let sourceFreqs = [];
        try { sourceFreqs = (this._arp?.morph?.currentTargets && Array.isArray(this._arp.morph.currentTargets) && this._arp.morph.currentTargets.length) ? this._arp.morph.currentTargets.slice(0, targetFreqs.length) : targetFreqs.slice(); } catch(_){ sourceFreqs = targetFreqs.slice(); }

        // Queue pending switch so transport applies exactly on time
    this._arp.pendingSwitch = {
            atAbsTick: targetAbsTick >>> 0,
            alignPhaseToTickCounter: alignToCurrentPhase,
            seq: seq,
            bassFreq: this._arp.bassFreq,
            column: columnElement,
            mapAsc: mapAsc,
            morph: {
                source: sourceFreqs,
                target: targetFreqs
            }
    };
    this._dbg && this._dbg('ARP:PENDING', 'atTick=', this._arp.pendingSwitch.atAbsTick, 'q=', this._arp.quant, 'hold=', this._arp.chordQuant);
        // Ensure transport is running so scheduled switch will occur
        this._startArpTransport();
        // Visual highlight now
        try { this.highlightKeyboardForColumn(columnElement); this.currentActiveColumnEl = columnElement; } catch(_){ }
    }

            // Wire UI for metronome toggle and chord-change quantization selector
            // Compute target rows for a chord slide based on nearest-voicing selection
        _getGlobalNpc(){
                try {
                    const n1 = parseInt(document.getElementById('universalNpc')?.value||'');
            const n = Number.isFinite(n1) ? n1 : (this._arp?.npc || 3);
            // Allow up to 64 notes per cycle to match UI and PLAY behavior
            return Math.max(1, Math.min(64, n|0));
                } catch(_) {
            return Math.max(1, Math.min(64, (this._arp?.npc||3)|0));
                }
            }
            _computeChordSlideTargets(targetColumnEl){
                this._dbg && this._dbg('SLIDE/TARGETS:start', targetColumnEl?.dataset?.chordId || targetColumnEl?.dataset?.originalPosition, 'octLock=', this._slideOctaveLock);
                try {
                    if (!targetColumnEl) return [];
                    const desiredDegrees = this._getChordDegreesForColumn(targetColumnEl);
                    // Determine tapped octave window if available; lock to the octave originally tapped for the gesture
                    const lockedOct = Number.isFinite(this._slideOctaveLock) ? this._slideOctaveLock : null;
                    const tappedOct = Number.isFinite(lockedOct) ? lockedOct : (Number.isFinite(this._lastTappedOctave) ? this._lastTappedOctave : (this._chordsModeAnchorOctave ?? 4));
                    const baseOct = Math.max(3, Math.min(9, tappedOct));
                    const npcTarget = this._getGlobalNpc();
                    // Collect candidate strings across octaves [3..9]
                    const allStrings = Array.from(targetColumnEl.querySelectorAll('.strings-column .string'))
                        .filter(s=>{ const o = parseInt(s.dataset.octave||'0',10); return Number.isFinite(o) && o>=3 && o<=9; });
                    // Fast path: build an ascending ladder across octaves aligned by desired degrees
                    const fOf = (el)=>{
                        try{
                            const tuning = this.currentTuning || 12;
                            const step = parseInt(el.dataset.noteIndex,10);
                            const oct = parseInt(el.dataset.octave,10);
                            if (!Number.isFinite(step) || !Number.isFinite(oct)) return NaN;
                            const s = ((step % tuning) + tuning) % tuning;
                            return this.getFrequency(s, oct, tuning);
                        }catch(_){ return NaN; }
                    };
                    const tuning = this.currentTuning || 12;
                    const degsOrdered = Array.from(new Set(desiredDegrees.map(iv=> ((iv%tuning)+tuning)%tuning)))
                        .sort((a,b)=> this.stepToSemitone(a, tuning) - this.stepToSemitone(b, tuning));
                    const byOct = new Map();
                    for (const s of allStrings){
                        const o = parseInt(s.dataset.octave||'0',10);
                        if (!byOct.has(o)) byOct.set(o, []);
                        byOct.get(o).push(s);
                    }
                    const alignOct = (o)=>{
                        const grp = (byOct.get(o)||[]).slice().sort((a,b)=> (fOf(a)||0)-(fOf(b)||0));
                        if (!grp.length) return [];
                        if (!degsOrdered.length) return grp;
                        const gMap = new Map(grp.map(r=> [((parseInt(r.dataset.interval,10)||0)%tuning + tuning)%tuning, r]));
                        const out = [];
                        degsOrdered.forEach(d=>{ const rr = gMap.get(d); if (rr) out.push(rr); });
                        return out.length ? out : grp;
                    };
                    const octsAsc = []; for (let o=baseOct; o<=9; o++) octsAsc.push(o);
                    const ladder = octsAsc.flatMap(o=> alignOct(o));
                    if (ladder.length){
                        const picked = ladder.slice(0, npcTarget);
                        picked.sort((a,b)=> (fOf(a)||0) - (fOf(b)||0));
                        this._dbg && this._dbg('SLIDE/TARGETS:end', 'count=', picked.length);
                        return picked;
                    }
                    // Fallback to single-octave logic below if no ladder could be formed
                    const strings = allStrings.filter(s=> parseInt(s.dataset.octave||'0',10)===baseOct);
                    // Group by degree to preserve chord tones; prefer nearest to previous voicing if known
                    const degSet = new Set(desiredDegrees.map(iv=> ((iv%tuning)+tuning)%tuning));
                    const byDeg = new Map();
                    for (const s of strings){
                        const d = parseInt(s.dataset.interval,10);
                        const key = ((d%tuning)+tuning)%tuning;
                        if (!degSet.has(key)) continue;
                        if (!byDeg.has(key)) byDeg.set(key, []);
                        byDeg.get(key).push(s);
                    }
                    // Sort each degree's candidates low->high to enable stable 1:1 mapping across slides
                    for (const [k, list] of byDeg.entries()){
                        list.sort((a,b)=> (fOf(a)||0) - (fOf(b)||0));
                    }
            // Build a 6-voice target by walking degrees in semitone order
            // Direction bias kept (affects choice order if multiple strings per degree within the same octave)
                    const dy = (typeof this._chordSlideLastDY==='number') ? this._chordSlideLastDY : 0;
                    const verticalBiasUp = dy < -2;   // moving up
                    const verticalBiasDown = dy > 2;  // moving down
                    const degs = Array.from(byDeg.keys()).sort((a,b)=> this.stepToSemitone(a, tuning) - this.stepToSemitone(b, tuning));
                    const picked = [];
            // First pass: prefer specific ordering of candidates per degree depending on bias
                    for (const d of degs){
                        if (picked.length>=npcTarget) break;
                        const list = byDeg.get(d) || [];
                        if (verticalBiasUp){
                            const hiPref = list.find(r=> parseInt(r.dataset.octave,10)===highOct);
                            if (hiPref) { picked.push(hiPref); continue; }
                            const lo = list.find(r=> parseInt(r.dataset.octave,10)===lowOct);
                            if (lo) picked.push(lo);
                        } else {
                            const lo = list.find(r=> parseInt(r.dataset.octave,10)===lowOct);
                            if (lo) picked.push(lo);
                        }
                    }
            // Second pass: fill remaining from the same octave pool
                    for (const d of degs){
                        if (picked.length>=npcTarget) break;
                        const list = byDeg.get(d) || [];
                        if (verticalBiasDown){
                            const lo2 = list.find(r=> parseInt(r.dataset.octave,10)===lowOct);
                            if (lo2 && !picked.includes(lo2)) { picked.push(lo2); continue; }
                const hi = list.find(r=> parseInt(r.dataset.octave,10)===highOct);
                if (hi && !picked.includes(hi)) picked.push(hi);
                        } else {
                            const hi = list.find(r=> parseInt(r.dataset.octave,10)===highOct);
                            if (hi && !picked.includes(hi)) picked.push(hi);
                        }
                    }
            // If still short, fill with nearest within window by frequency order (still within the single octave)
                    if (picked.length < npcTarget){
                        const pool = strings.slice().sort((a,b)=> (fOf(a)||0) - (fOf(b)||0));
                        for (const s of pool){ if (picked.length>=npcTarget) break; if (!picked.includes(s)) picked.push(s); }
                    }
                    // Sort final targets low->high to keep voice indices stable and avoid consolidation
                    picked.sort((a,b)=> (fOf(a)||0) - (fOf(b)||0));
                    this._dbg && this._dbg('SLIDE/TARGETS:end', 'count=', picked.length);
                    return picked;
                } catch(_) { return []; }
            }

            // Retune currently active chord voices towards target rows using nearest-neighbor mapping
            // Optional third param glideOverrideMs lets callers (e.g., PLAY) stretch the bend over HOLD length
            _retuneActiveChordVoicesToTargets(targetRows, velocity=0){
                this._dbg && this._dbg('SLIDE/RETUNE', 'voices=', this._chordSlideVoices?.size||0, 'targets=', targetRows?.length||0);
                if (!Array.isArray(targetRows) || targetRows.length===0) return;
                const ctxNow = this.audioContext?.currentTime || 0;
                const tuner = this.currentTuning || 12;
                // Gather active voices from map that are still sounding
                const activePairs = [];
                if (this._chordSlideVoices && this._chordSlideVoices.size){
                    for (const [stringEl, meta] of this._chordSlideVoices.entries()){
                        // Prefer CHORD lane voices; fall back to default pool for safety
                        let voice = null;
                        try {
                            if (this.activeChordOscillators && this.activeChordOscillators.size) {
                                voice = Array.from(this.activeChordOscillators.values()).find(v => v.element === stringEl) || null;
                            }
                            if (!voice && this.activeOscillators && this.activeOscillators.size) {
                                voice = Array.from(this.activeOscillators.values()).find(v => v.element === stringEl) || null;
                            }
                        } catch(_) { voice = null; }
                        const f = parseFloat(stringEl?.dataset?.frequency);
                        if (!voice || !isFinite(f) || f<=0) continue;
                        activePairs.push({ stringEl, meta, voice, curFreq: f, curLog: Math.log2(f) });
                    }
                }
                if (!activePairs.length) return;
                // Sort sources and targets by frequency
                const sources = activePairs.slice().sort((a,b)=> a.curFreq - b.curFreq);
                const targets = targetRows.map(r=>{
                        try{
                            const tuning = this.currentTuning || 12;
                            const step = parseInt(r.dataset.noteIndex,10);
                            const oct = parseInt(r.dataset.octave,10);
                            if (!Number.isFinite(step) || !Number.isFinite(oct)) return { row:r, f: NaN };
                            const s = ((step % tuning)+tuning)%tuning;
                            const f = this.getFrequency(s, oct, tuning);
                            return { row:r, f };
                        }catch(_){ return { row:r, f: NaN }; }
                    })
                    .filter(t=> isFinite(t.f) && t.f>0)
                    .sort((a,b)=> a.f - b.f);
                const count = Math.min(sources.length, targets.length, Math.max(6, this._getGlobalNpc() || 6));
                // Nearest-neighbor unique matching: for each source, pick the closest unused target
                const used = new Set();
                const mappings = [];
                for (let i=0; i<count; i++){
                    const s = sources[i];
                    let bestJ = -1; let bestD = Infinity;
                    for (let j=0; j<targets.length; j++){
                        if (used.has(j)) continue;
                        const d = Math.abs(targets[j].f - s.curFreq);
                        if (d < bestD){ bestD = d; bestJ = j; }
                    }
                    if (bestJ >= 0){ used.add(bestJ); mappings.push({ src: s, trg: targets[bestJ] }); }
                }
                // Immediate frequency change (no gliding)
                for (const {src, trg} of mappings){
                    const v = src.voice;
                    const f1 = trg.f * Math.pow(2, this.oscillators.osc1.octave + ((this.oscillators.osc1.detune + (this.oscillators.osc1.coarse * (1200 / tuner))) / 1200));
                    const f2 = trg.f * Math.pow(2, this.oscillators.osc2.octave + ((this.oscillators.osc2.detune + (this.oscillators.osc2.coarse * (1200 / tuner))) / 1200));
                    try {
                        if (v.osc1?.frequency?.cancelScheduledValues){ v.osc1.frequency.cancelScheduledValues(ctxNow); v.osc1.frequency.setValueAtTime(f1, ctxNow); }
                        if (v.osc2?.frequency?.cancelScheduledValues){ v.osc2.frequency.cancelScheduledValues(ctxNow); v.osc2.frequency.setValueAtTime(f2, ctxNow); }
                        // Update last known frequency for subsequent mapping
                        src.stringEl.dataset.frequency = String(trg.f);
                    } catch(_){ this._dbg && this._dbg('SLIDE/RETUNE:ERR'); }
                }
            }

            // Enhanced touch responsiveness system to prevent missed taps and improve sensitivity
            _enhanceTouchResponsiveness(touchEvent) {
                // Pre-mark touch targets to ensure they register properly
                Array.from(touchEvent.changedTouches || touchEvent.touches || []).forEach(touch => {
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (target) {
                        // Mark visual feedback immediately for responsive UI
                        target.classList.add('touch-active');
                        setTimeout(() => target.classList.remove('touch-active'), 150);
                        
                        // Pre-cache element relationships to avoid lookup delays during trigger
                        const stringEl = target.closest('[data-frequency]');
                        const columnEl = target.closest('.extension-column');
                        
                        if (stringEl && columnEl) {
                            // Store cached references for faster access during handleStringTrigger
                            stringEl._cachedColumn = columnEl;
                            stringEl._lastCacheTime = performance.now();
                        }
                    }
                });
                
                // Reset any existing throttling states for immediate responsiveness
                this._resetTouchThrottling();
            }
            
            // Reset touch throttling to allow immediate responses
            _resetTouchThrottling() {
                const now = performance.now();
                // Don't reset if we just did this very recently (prevents spam)
                if (this._lastThrottleReset && (now - this._lastThrottleReset) < 10) return;
                this._lastThrottleReset = now;
                
                // Clear throttling for more responsive subsequent touches
                document.querySelectorAll('[data-frequency]').forEach(stringEl => {
                    if (stringEl.lastTriggerTime && (now - stringEl.lastTriggerTime) > 15) {
                        // Allow immediate retrigger for strings that haven't been hit recently
                        stringEl.lastTriggerTime = Math.max(0, stringEl.lastTriggerTime - 15);
                    }
                });
            }

            // Throttled continuous update while sliding: retune active voices immediately
            _updateChordSlideContinuously(columnEl){
                this._dbg && this._dbg('SLIDE/CONT', columnEl?.dataset?.chordId || columnEl?.dataset?.originalPosition);
                const now = performance.now();
                const minInterval = 30; // ~33Hz max update
                if (this._lastChordSlideImmediateAt && (now - this._lastChordSlideImmediateAt) < minInterval) return;
                this._lastChordSlideImmediateAt = now;
                try {
                    const targets = this._computeChordSlideTargets(columnEl);
                    // Use immediate change (no glide)
                    this._retuneActiveChordVoicesToTargets(targets, 0);
                } catch(_){ }
                // Update held bass immediately
                try { this._updateHeldBassForColumn(columnEl); } catch(_){ this._dbg && this._dbg('BASS/HELD:update:ERR'); }
                try { this._markChordSlideActivity(); } catch(_){ }
            }
            // Mark CHORD slide activity and (re)schedule idle-stop
            _markChordSlideActivity(){
                this._lastChordSlideTime = performance.now();
                if (!this._chordSlideActive) return;
                try { clearTimeout(this._chordSlideIdleTimer); } catch(_) {}
                // Idle stop after base timeout (no glide timing needed)
                const baseIdle = Math.max(0, Number(this._chordSlideIdleMs) || 2000);
                const ms = Math.max(250, baseIdle);
                this._chordSlideIdleTimer = setTimeout(()=>{
                    try{
                        if (this.chordsEnabled && this._chordSlideActive) {
                            this.stopAllActiveNotes();
                            // Also clear any tracked bass voice so it can be restarted cleanly next time
                            this._chordBassVoice = null; this._lastBassFreq = null;
                            this._heldBassVoice = null; this._heldBassLiveFreq = null; this._heldBassVoiceKey = null;
                            this._sustainActive = false; this._chordsGestureActive = false; this._slideOctaveLock = null;
                        }
                    }catch(_){ }
                }, ms);
            }
            
            // Update PLAY/STOP button states based on SLIDE mode
            _updatePlayStopButtonStates() {
                try {
                    const playBtn = document.getElementById('playSeqBtn');
                    const stopBtn = document.getElementById('stopSeqBtn');
                    if (playBtn) {
                        playBtn.disabled = this._chordSlideEnabled;
                        playBtn.style.opacity = this._chordSlideEnabled ? '0.4' : '1';
                        playBtn.style.cursor = this._chordSlideEnabled ? 'not-allowed' : 'pointer';
                        playBtn.title = this._chordSlideEnabled ? 'PLAY disabled in SLIDE mode - use touch/click gestures' : 'Play one bar per chord (order)';
                    }
                    if (stopBtn) {
                        stopBtn.disabled = this._chordSlideEnabled;
                        stopBtn.style.opacity = this._chordSlideEnabled ? '0.4' : '1';
                        stopBtn.style.cursor = this._chordSlideEnabled ? 'not-allowed' : 'pointer';
                        stopBtn.title = this._chordSlideEnabled ? 'STOP disabled in SLIDE mode' : 'Stop sequencing immediately';
                    }
                } catch(_) {}
            }
            
            // ================== QUANTIZED CHORD CHANGES ==================
            
            // Check if chord changes should be quantized to the beat
            _shouldQuantizeChordChange() {
                // Enhanced touch sensitivity: prefer immediate response in touch mode
                // Check if we're in an active touch gesture - if so, be more permissive with immediate triggers
                const isTouchGesture = this.activeTouches && this.activeTouches.size > 0;
                
                // FORCE quantization to FULL BEATS (quarter notes), not subdivisions
                this._ensureArpTransport();
                this._refreshArpTransportTiming();
                const now = (performance && performance.now) ? performance.now() : Date.now();
                
                // Use beatMs instead of tickMs to quantize to full beats
                const beatMs = this._arpTransport?.beatMs || (60000 / (this._arpTransport?.bpm || 120));
                
                // Calculate time to next beat boundary
                let timeToNextBeat;
                if (this._arpTransport && this._arpTransport.running && Number.isFinite(this._arpTransport.nextAt)) {
                    // Find the next beat boundary from the current transport position
                    const currentTick = Math.floor((now - this._arpTransport.startAt) / (this._arpTransport.tickMs || 100));
                    const ticksPerBeat = this._arpTransport.ticksPerBeat || 4;
                    const nextBeatTick = Math.ceil((currentTick + 1) / ticksPerBeat) * ticksPerBeat;
                    const nextBeatTime = this._arpTransport.startAt + (nextBeatTick * this._arpTransport.tickMs);
                    timeToNextBeat = Math.max(0, nextBeatTime - now);
                } else {
                    // If not running, use mathematical beat alignment
                    const rem = now % beatMs;
                    timeToNextBeat = rem ? (beatMs - rem) : 0;
                }
                
                // Enhanced quantization window for touch responsiveness
                // Touch gestures get a larger immediate window (up to 25% of beat time vs 10%)
                const baseWindow = beatMs * 0.10;
                const touchWindow = isTouchGesture ? beatMs * 0.25 : baseWindow;
                const quantizationWindow = Math.min(120, Math.max(20, touchWindow));
                
                if (timeToNextBeat <= quantizationWindow) {
                    return { shouldQuantize: false, nextBeatMs: 0 };
                }
                return { shouldQuantize: true, nextBeatMs: timeToNextBeat };
            }

            // Schedule an ARP start to happen on the next quantized beat
            _scheduleQuantizedArpStart(columnElement, clientY, delayMs) {
                // Clear any pending quantized ARP change timer
                if (this._pendingQuantizedArpStart) {
                    try { clearTimeout(this._pendingQuantizedArpStart.timer); } catch(_){}
                    this._pendingQuantizedArpStart = null;
                }

                if (!columnElement || !Number.isFinite(delayMs) || delayMs <= 0) {
                    this._startArp(columnElement, clientY);
                    return;
                }

                console.log('[QUANTIZE] Scheduling ARP start in', Math.round(delayMs), 'ms on next beat');

                // Schedule the ARP start
                this._pendingQuantizedArpStart = {
                    columnElement,
                    clientY,
                    timer: setTimeout(() => {
                        try {
                            this._pendingQuantizedArpStart = null;
                            this._startArp(columnElement, clientY);
                            console.log('[QUANTIZE] Executed ARP start');
                        } catch(_) {}
                    }, delayMs)
                };
            }

            // Schedule a bass change to happen on the next quantized beat  
            _scheduleQuantizedBassChange(columnElement, delayMs) {
                // Clear any pending quantized bass change timer
                if (this._pendingQuantizedBassChange) {
                    try { clearTimeout(this._pendingQuantizedBassChange.timer); } catch(_){}
                    this._pendingQuantizedBassChange = null;
                }

                if (!columnElement || !Number.isFinite(delayMs) || delayMs <= 0) {
                    this._updateHeldBassForColumn(columnElement);
                    return;
                }

                console.log('[QUANTIZE] Scheduling BASS change in', Math.round(delayMs), 'ms on next beat');

                // Schedule the bass change
                this._pendingQuantizedBassChange = {
                    columnElement,
                    timer: setTimeout(() => {
                        try {
                            this._pendingQuantizedBassChange = null;
                            this._updateHeldBassForColumn(columnElement);
                            console.log('[QUANTIZE] Executed BASS change');
                        } catch(_) {}
                    }, delayMs)
                };
            }
            
            // Quantized wrapper for bass updates - checks if should quantize to beat
            _updateHeldBassForColumnQuantized(columnElement) {
                try {
                    const quantizedChange = this._shouldQuantizeChordChange();
                    if (quantizedChange.shouldQuantize) {
                        this._scheduleQuantizedBassChange(columnElement, quantizedChange.nextBeatMs);
                    } else {
                        this._updateHeldBassForColumn(columnElement);
                    }
                } catch(_) {
                    this._updateHeldBassForColumn(columnElement);
                }
            }
            
            // Schedule a chord change to happen on the next quantized beat
            _scheduleQuantizedChordChange(columnElement, clientY, _delayMs) {
                // Clear any pending quantized change timer (we switch to transport-aligned scheduling)
                if (this._pendingQuantizedChordChange) {
                    try { clearTimeout(this._pendingQuantizedChordChange.timer); } catch(_){}
                    this._pendingQuantizedChordChange = null;
                }

                if (!columnElement) return;

                // Stop current chord notes immediately to prepare for the change (bass is handled separately)
                try {
                    if (this._chordSlideVoices && this._chordSlideVoices.size) {
                        const toStop = new Set();
                        this._chordSlideVoices.forEach(v => { if (v && Number.isFinite(v.startFreq)) toStop.add(v.startFreq); });
                        toStop.forEach(f => { try { this.stopFrequency(f, null, 'chord'); } catch(_){} });
                        this._chordSlideVoices.clear();
                    }
                    // Also proactively stop any lingering CHORD-lane voices to avoid overlap at the switch
                    try {
                        if (this.activeChordOscillators && this.activeChordOscillators.size) {
                            const keys = Array.from(this.activeChordOscillators.keys());
                            keys.forEach(k => { try { this.stopFrequency(k, null, 'chord'); } catch(_){} });
                        }
                    } catch(_) {}
                } catch(_){}

                // Cancel any chord hold timer since we're switching chords
                if (this._chordHoldTimer) { try { clearTimeout(this._chordHoldTimer); } catch(_){} this._chordHoldTimer = null; }

                // Build ARP sequence and chord rows for the target column at the next transport beat
                try {
                    this._ensureArpTransport();
                    this._refreshArpTransportTiming();
                    const absTick = this._arpTransport.absTickCounter|0;
                    // Schedule to the very next transport tick (QUANT subdivision)
                    const targetAbsTick = (absTick + 1) >>> 0;

                    // Determine NPC and pattern
                    const npc = this._getGlobalNpc ? this._getGlobalNpc() : Math.max(1, Math.min(64, (this._arp?.npc||3)|0));
                    const pattern = (this._arp?.pattern) || 'up';

                    // Compute tapped step for anchoring from pointer Y if available
                    let tappedStep = null;
                    try {
                        const hit = document.elementFromPoint(columnElement.getBoundingClientRect().left + 1, clientY);
                        const row = hit && hit.closest ? hit.closest('.string') : null;
                        tappedStep = row ? parseInt(row.dataset?.edoStep||'NaN',10) : null;
                    } catch(_) { tappedStep = null; }

                    const rowsAll = Array.from(columnElement.querySelectorAll('.strings-column .string'));
                    const ascAll = rowsAll.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0) - (parseFloat(b.dataset.frequency)||0));
                    const ascHigh = ascAll.filter(r => (parseInt(r.dataset.octave||'0',10) >= 5));
                    const within = ascHigh.length ? ascHigh : ascAll; // prefer high register
                    const mapAsc = within.slice(0, npc);
                    const seq = this._buildArpSequence(within, pattern, tappedStep).slice(0, npc);

                    // Prepare morph mapping targets for smooth GLIDE transitions if enabled
                    let targetFreqs = [];
                    try {
                        const tuning = this.currentTuning || 12;
                        const seqForMorph = Array.isArray(seq) && seq.length ? seq : mapAsc;
                        targetFreqs = seqForMorph.map(r=>{
                            const step = parseInt(r.dataset.noteIndex,10);
                            const oct = parseInt(r.dataset.octave,10);
                            const s = ((step%tuning)+tuning)%tuning; return this.getFrequency(s, Number.isFinite(oct)?oct:4, tuning);
                        }).filter(f=> isFinite(f) && f>0);
                    } catch(_) { targetFreqs = []; }
                    let sourceFreqs = [];
                    try { sourceFreqs = (this._arp?.morph?.currentTargets && Array.isArray(this._arp.morph.currentTargets) && this._arp.morph.currentTargets.length) ? this._arp.morph.currentTargets.slice(0, targetFreqs.length) : targetFreqs.slice(); } catch(_){ sourceFreqs = targetFreqs.slice(); }

                    // Determine ARP/CHORD toggle state
                    const arpOn = !!this.arpEnabled;
                    const chordOn = !!this.chordsEnabled;
                    // UI NPC (per-lane)
                    const npcUI = npc;
                    let finalSeq = seq;
                    let finalMapAsc = mapAsc;
                    let chordRows = [];
                    let mode = 'arp';
                    let finalNpc = npcUI;

                    // Build bottom/top split when both are enabled
                    if (arpOn && chordOn) {
                        // Bottom NPC for chords
                        const chordCount = Math.max(1, Math.min(npcUI, ascAll.length));
                        chordRows = ascAll.slice(0, chordCount);
                        // Top NPC for arp with high-register preference
                        const arpCount = chordCount;
                        const arpCandidates = (ascHigh.length >= arpCount) ? ascHigh : ascAll;
                        const arpPool = arpCandidates.slice(-arpCount);
                        finalMapAsc = arpPool.slice();
                        finalSeq = this._buildArpSequence(arpPool, pattern, tappedStep).slice(0, arpCount);
                        finalNpc = arpCount;
                        mode = 'arp'; // run arp ticks while sustaining chord layer
                    } else if (chordOn && !arpOn) {
                        // CHORD only: build NPC high chord from the tapped note within C3..C5
                        const tapInfo = this._findTapRowInColumn(columnElement, clientY);
                        chordRows = this._buildNpcHighChordFromTap(columnElement, tapInfo, npcUI);
                        finalSeq = []; // no arp
                        finalMapAsc = [];
                        finalNpc = chordRows.length || npcUI;
                        mode = 'chord';
                    } else {
                        // ARP only: prefer high register as before, no chord layer
                        const arpCandidates = ascHigh.length ? ascHigh : ascAll;
                        const arpPool = arpCandidates.slice(0, npcUI);
                        finalMapAsc = arpPool.slice();
                        finalSeq = this._buildArpSequence(arpPool, pattern, tappedStep).slice(0, npcUI);
                        chordRows = [];
                        finalNpc = npcUI;
                        mode = 'arp';
                    }

                    // Queue a single pendingSwitch according to mode/toggles
                    this._arp.pendingSwitch = {
                        atAbsTick: targetAbsTick,
                        alignPhaseToTickCounter: true,
                        seq: finalSeq,
                        bassFreq: this._arp?.bassFreq,
                        column: columnElement,
                        mapAsc: finalMapAsc,
                        mode,
                        npc: finalNpc,
                        enableChord: chordOn,
                        chordRows,
                        morph: (finalSeq && finalSeq.length) ? { source: sourceFreqs, target: targetFreqs } : null
                    };
                    // Ensure transport is running to service the pending switch
                    this._startArpTransport();
                    // Visual indicator
                    try { this.highlightKeyboardForColumn(columnElement); this.currentActiveColumnEl = columnElement; } catch(_){ }
                    this._dbg && this._dbg('QUANT:PENDING', 'atAbsTick=', targetAbsTick, 'npc=', npc, 'pat=', pattern);
                } catch(e) {
                    console.error('Quantized scheduling failed, falling back to immediate:', e);
                    try { this._executeChordChange(columnElement, clientY); } catch(_){}
                }
            }
            
            // Execute the actual chord change: route through transport pendingSwitch for parity with PLAY
            _executeChordChange(columnElement, clientY) {
                try {
                    this._scheduleQuantizedChordChange(columnElement, clientY, 0);
                } catch (e) {
                    // Fallback to immediate play if scheduling fails
                    try { this.playChordChordsMode(columnElement, clientY); } catch(_) {}
                }
            }
            
            // Schedule quantized chord change for ARP mode (preserves transport position and NPC)
            _scheduleQuantizedArpChordChange(columnElement, clientY) {
                if (!columnElement) return;
                
                // Check if we should quantize based on current transport state
                const quantizedChange = this._shouldQuantizeChordChange();
                
                // Calculate current NPC position from transport state
                let currentNPC = 0;
                if (this._arpTransport && this._arp && this._arp.seq) {
                    const idx = (this._arpTransport.tickCounter - (this._arp.startTickAlign || 0));
                    currentNPC = ((idx % this._arp.seq.length) + this._arp.seq.length) % this._arp.seq.length;
                }
                
                if (quantizedChange.shouldQuantize) {
                    // Clear any existing pending ARP chord change
                    if (this._pendingArpChordChange) {
                        try { clearTimeout(this._pendingArpChordChange.timer); } catch(_){}
                        this._pendingArpChordChange = null;
                    }
                    
                    // Schedule the chord change for the next quantized beat
                    this._pendingArpChordChange = {
                        columnElement: columnElement,
                        clientY: clientY,
                        preserveNPC: currentNPC,
                        timer: setTimeout(() => {
                            try {
                                // Switch to the new chord preserving ARP timing
                                this._startArp(columnElement, clientY, true); // true = preserve position
                                
                                // Adjust startTickAlign to maintain the same NPC position
                                if (this._arpTransport && this._arp && this._arp.seq && this._pendingArpChordChange) {
                                    const targetIdx = this._pendingArpChordChange.preserveNPC || 0;
                                    this._arp.startTickAlign = this._arpTransport.tickCounter - targetIdx;
                                }
                            } catch(e) {
                                // Fallback: just start the ARP normally
                                this._startArp(columnElement, clientY);
                            }
                            this._pendingArpChordChange = null;
                        }, quantizedChange.nextBeatMs)
                    };
                } else {
                    // Within quantization window - execute immediately but preserve position
                    this._startArp(columnElement, clientY, true); // true = preserve position
                    
                    // Adjust startTickAlign to maintain the same NPC position
                    if (this._arpTransport && this._arp && this._arp.seq) {
                        this._arp.startTickAlign = this._arpTransport.tickCounter - currentNPC;
                    }
                }
            }
            
            // Held bass: start a single sustained bass to the column's effective root within G1..C3. - DISABLED
            _updateHeldBassForColumn(columnElement){
                // DISABLED: Only bass grid should control bass playback
                return;
                /*
                this._dbg && this._dbg('BASS/HELD:call', 'enabled=', this._heldBassEnabled, 'col=', columnElement?.dataset?.chordId || columnElement?.dataset?.originalPosition);
                if (this._heldBassEnabled === false || this.bassEnabled === false) return;
                try{
                    const edo = this.currentTuning || 12;
                    const step = this._getEffectiveColumnRootStep(columnElement);
                    this._dbg && this._dbg('BASS/HELD:step', step, 'edo=', edo);
                    const target = this._computeBassFreqInRange(step, (typeof this._heldBassLiveFreq==='number'?this._heldBassLiveFreq:null), edo);
                    this._dbg && this._dbg('BASS/HELD:target', target);
                    if (!isFinite(target) || target<=0) return;
                    // If there is no existing bass, start one with minimal attack/release and centered pan
                    if (!this._heldBassVoice){
                        this._dbg && this._dbg('BASS/HELD:start', target);
                        // Locally save ADSR and panning width, then restore immediately after starting the bass
                        const savedEnv1 = { ...this.envelope };
                        const savedEnv2 = { ...this.osc2Envelope };
                        const prevWidth = this.panning ? this.panning.width : null;
                        try {
                            // Minimal, smooth bass envelope
                            this.envelope.attack = 0.005; this.envelope.decay = 0.05; this.envelope.sustain = 0.95; this.envelope.release = 0.08;
                            this.osc2Envelope.attack = 0.005; this.osc2Envelope.decay = 0.05; this.osc2Envelope.sustain = 0.95; this.osc2Envelope.release = 0.08;
                            // Force center pan by collapsing width temporarily
                            if (this.panning) this.panning.width = 0;
                            this.playFrequency(target, null, 'bass');
                        } finally {
                            // Restore panning width and global ADSR immediately to avoid affecting other voices
                            if (this.panning && prevWidth != null) this.panning.width = prevWidth;
                            Object.assign(this.envelope, savedEnv1);
                            Object.assign(this.osc2Envelope, savedEnv2);
                        }
                        // Track by the starting key; capture the voice now or shortly after if not yet present
                        this._heldBassVoiceKey = target;
                        const v = this.activeBassOscillators.get(this._heldBassVoiceKey);
                        if (v){
                            try { if (v.releaseTimeout) { clearTimeout(v.releaseTimeout); v.releaseTimeout = null; } } catch(_){ }
                            this._heldBassVoice = v; this._heldBassLiveFreq = target;
                            // Set up HOLD duration auto-release for bass
                            try {
                                const holdSelect = document.getElementById('universalHold');
                                const holdValue = holdSelect ? holdSelect.value : 'bar:1';
                                const [kind, valStr] = String(holdValue).split(':');
                                const n = Math.max(1, parseInt(valStr || '1', 10));
                                
                                // Calculate hold duration in milliseconds
                                const bpmEl = document.getElementById('universalBpm');
                                const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                                const beatMs = 60000 / Math.max(20, bpm);
                                
                                // Get time signature
                                const timeSignatureEl = document.getElementById('universalTimeSignature');
                                const timeSignature = timeSignatureEl ? timeSignatureEl.value : '4/4';
                                const [beatsPerBar] = timeSignature.split('/').map(Number);
                                const barMs = beatMs * (beatsPerBar || 4);
                                
                                const holdDurationMs = (kind === 'beat') ? n * beatMs : n * barMs;
                                v.releaseTimeout = setTimeout(() => {
                                    try {
                                        this.stopFrequency(target, null, 'bass');
                                        if (this._heldBassVoice === v) {
                                            this._heldBassVoice = null;
                                            this._heldBassLiveFreq = null;
                                            this._heldBassVoiceKey = null;
                                        }
                                    } catch(_) {}
                                }, holdDurationMs);
                            } catch(_) {}
                        } else {
                            setTimeout(()=>{
                                try{
                                    const vv = this.activeBassOscillators.get(this._heldBassVoiceKey);
                                    if (vv){
                                        try { if (vv.releaseTimeout) { clearTimeout(vv.releaseTimeout); vv.releaseTimeout = null; } } catch(_){ }
                                        this._heldBassVoice = vv; this._heldBassLiveFreq = target;
                                        // Set up HOLD duration auto-release for bass
                                        try {
                                            const holdSelect = document.getElementById('universalHold');
                                            const holdValue = holdSelect ? holdSelect.value : 'bar:1';
                                            const [kind, valStr] = String(holdValue).split(':');
                                            const n = Math.max(1, parseInt(valStr || '1', 10));
                                            
                                            // Calculate hold duration in milliseconds
                                            const bpmEl = document.getElementById('universalBpm');
                                            const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                                            const beatMs = 60000 / Math.max(20, bpm);
                                            
                                            // Get time signature
                                            const timeSignatureEl = document.getElementById('universalTimeSignature');
                                            const timeSignature = timeSignatureEl ? timeSignatureEl.value : '4/4';
                                            const [beatsPerBar] = timeSignature.split('/').map(Number);
                                            const barMs = beatMs * (beatsPerBar || 4);
                                            
                                            const holdDurationMs = (kind === 'beat') ? n * beatMs : n * barMs;
                                            vv.releaseTimeout = setTimeout(() => {
                                                try {
                                                    this.stopFrequency(target, null, 'bass');
                                                    if (this._heldBassVoice === vv) {
                                                        this._heldBassVoice = null;
                                                        this._heldBassLiveFreq = null;
                                                        this._heldBassVoiceKey = null;
                                                    }
                                                } catch(_) {}
                                            }, holdDurationMs);
                                        } catch(_) {}
                                    }
                                }catch(_){ }
                            }, 0);
                        }
                        return;
                    }
                    // Update existing bass to new target immediately
                    const v = this._heldBassVoice || (this._heldBassVoiceKey!=null ? this.activeBassOscillators.get(this._heldBassVoiceKey) : null);
                    const ctxNow = this.audioContext?.currentTime || 0;
                    const tuner = edo;
                    const f1 = target * Math.pow(2, this.oscillators.osc1.octave + ((this.oscillators.osc1.detune + (this.oscillators.osc1.coarse * (1200 / tuner))) / 1200));
                    const f2 = target * Math.pow(2, this.oscillators.osc2.octave + ((this.oscillators.osc2.detune + (this.oscillators.osc2.coarse * (1200 / tuner))) / 1200));
                    let updated = false;
                    try {
                        if (v.osc1?.frequency?.cancelScheduledValues && v.osc2?.frequency?.cancelScheduledValues) {
                            v.osc1.frequency.cancelScheduledValues(ctxNow);
                            v.osc1.frequency.setValueAtTime(f1, ctxNow);
                            v.osc2.frequency.cancelScheduledValues(ctxNow);
                            v.osc2.frequency.setValueAtTime(f2, ctxNow);
                            updated = true;
                        }
                    } catch(_){ updated = false; }
                    if (!updated) {
                        this._dbg && this._dbg('BASS/HELD:restartFallback');
                        // Fall back: stop the old held bass and restart at target
                        try { if (this._heldBassLiveFreq) this.stopFrequency(this._heldBassLiveFreq, null, 'bass'); } catch(_){ }
                        this._heldBassVoice = null; this._heldBassLiveFreq = null; this._heldBassVoiceKey = null;
                        try { this._updateHeldBassForColumn(columnElement); } catch(_){ }
                        return;
                    }
                    this._heldBassLiveFreq = target;
                    // Set up HOLD duration auto-release for updated bass
                    try {
                        const holdSelect = document.getElementById('universalHold');
                        const holdValue = holdSelect ? holdSelect.value : 'bar:1';
                        const [kind, valStr] = String(holdValue).split(':');
                        const n = Math.max(1, parseInt(valStr || '1', 10));
                        
                        // Calculate hold duration in milliseconds
                        const bpmEl = document.getElementById('universalBpm');
                        const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                        const beatMs = 60000 / Math.max(20, bpm);
                        
                        // Get time signature
                        const timeSignatureEl = document.getElementById('universalTimeSignature');
                        const timeSignature = timeSignatureEl ? timeSignatureEl.value : '4/4';
                        const [beatsPerBar] = timeSignature.split('/').map(Number);
                        const barMs = beatMs * (beatsPerBar || 4);
                        
                        const holdDurationMs = (kind === 'beat') ? n * beatMs : n * barMs;
                        if (v && v.releaseTimeout) {
                            clearTimeout(v.releaseTimeout);
                        }
                        if (v) {
                            v.releaseTimeout = setTimeout(() => {
                                try {
                                    this.stopFrequency(target, null, 'bass');
                                    if (this._heldBassVoice === v) {
                                        this._heldBassVoice = null;
                                        this._heldBassLiveFreq = null;
                                        this._heldBassVoiceKey = null;
                                    }
                                } catch(_) {}
                            }, holdDurationMs);
                        }
                    } catch(_) {}
                    this._dbg && this._dbg('BASS/HELD:updateOK', target);
                } catch(_){ }
                */
            }
            // In CHORD slide: sustain a single bass voice and GLIDE it to the new effective root.
            _playChordSlideBassNow(columnElement){
                // Disabled per user request: no bass during chord slide
                return;
            }
            _wireTransportUI(){
                try {
                                // Hard reset transport so PLAY behaves identically every time
                                try {
                                    omnichord._stopArpTransport();
                                    omnichord._ensureArpTransport();
                                    const t = omnichord._arpTransport;
                                    if (t) {
                                        t.tickCounter = 0;
                                        t.absTickCounter = 0;
                                        t.nextAt = ((performance && performance.now) ? performance.now() : Date.now());
                                        t.running = false;
                                        t.inactivityStopScheduled = false;
                                        t.stopAtBarIndex = null;
                                    }
                                    if (omnichord._arp) {
                                        omnichord._arp.pendingSwitch = null;
                                        omnichord._arp.active = false;
                                        omnichord._arp.seq = [];
                                        omnichord._arp.startTickAlign = 0;
                                        omnichord._arp.morph = null;
                                    }
                                    // Stop any lingering voices so we start from silence
                                    try { omnichord.stopAllActiveNotes(); } catch(_){ }
                                    try { omnichord.stopAllDrums && omnichord.stopAllDrums(); } catch(_){ }
                                } catch(_){ }
                    // Chord/Slide Bass toggle replaced by universal bass button elsewhere
                } catch(_){ }
            }

            _stopArp(){
                this._dbg && this._dbg('ARP:STOP');
                if (!this._arp) return;
                // Deactivate the ARP voice but keep transport running; we'll stop after 1 bar if nothing resumes
                this._arp.active = false;
                this._arp.seq = [];
                this._arp.column = null;
                // Disable sustain so new notes return to normal envelope behavior outside PLAY chord-hold
                this._sustainActive = false;
                // Release any octave lock so next gesture can define a new one
                this._slideOctaveLock = null;
                // Stop sustained ARP voices (lead + bass)
                try {
                    if (this._arp.leadVoice && this._arp.leadLiveFreq){ this.stopFrequency(this._arp.leadLiveFreq, null); }
                } catch(_){ }
                try {
                    if (this._arp.bassVoice && this._arp.bassLiveFreq){
                        if (!this._arp.bassVoice.isGlobalBass) this.stopFrequency(this._arp.bassLiveFreq, null, 'bass');
                    }
                } catch(_){ }
                this._arp.leadVoice = null; this._arp.leadLiveFreq = null;
                this._arp.bassVoice = null; this._arp.bassLiveFreq = null;
                // Re-enable per-note panning auto-toggle when ARP voice stops
                this._suppressPanningAutoToggle = false;
                // Schedule a timed hold-stop based on HOLD selector, aligned to bars or beats (skip while sequencing)
                try {
                    if (this._isSequencing) return; // sequencing drives progression explicitly
                    this._ensureArpTransport();
                    // Use universalHold (fallback to chordHold) as the unified HOLD source
                    const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                    const hold = holdEl ? String(holdEl.value||'bar:1') : 'bar:1';
                    const [kind, valStr] = String(hold).split(':');
                    const n = Math.max(1, parseInt(valStr||'1',10));
                    const tpBeat = this._arpTransport.ticksPerBeat || 1;
                    const tpBar = this._arpTransport.ticksPerBar || (tpBeat*4);
                    let ticks = tpBar; // default 1 bar
                    if (kind === 'beat') ticks = n * tpBeat; else if (kind === 'bar') ticks = n * tpBar;
                    const nowAbs = this._arpTransport.absTickCounter|0;
                    this._arpTransport.holdStopAtAbsTick = (nowAbs + ticks) >>> 0;
                    this._dbg && this._dbg('ARP:HOLD', hold, 'ticks=', ticks, 'stopAt=', this._arpTransport.holdStopAtAbsTick);
                } catch(_) {
                    // Fallback to inactivity stop if parsing fails
                    this._scheduleTransportStopAfterInactivity();
                }
            }

            // Reset all rendered string elements' dataset.frequency back to their original pitch
            // based on stored dataset.noteIndex (absolute step) and dataset.octave.
            _resetAllStringFrequencies(){
                this._dbg && this._dbg('RESET/STRINGS');
                try {
                    const tuning = this.currentTuning || 12;
                    document.querySelectorAll('.strings-column .string').forEach(row => {
                        const step = parseInt(row.dataset.noteIndex, 10);
                        const oct = parseInt(row.dataset.octave, 10);
                        if (!Number.isFinite(step) || !Number.isFinite(oct)) return;
                        const s = ((step % tuning) + tuning) % tuning;
                        const f = this.getFrequency(s, oct, tuning);
                        if (Number.isFinite(f) && f > 0) row.dataset.frequency = String(f);
                    });
                } catch(_) { /* no-op */ }
            }

            applyPlayModeToColumnVisual(column){
                this._dbg && this._dbg('VIS/APPLY', column?.dataset?.chordId || column?.dataset?.originalPosition, this.playMode);
                try {
                    const container = column.querySelector('.strings-column');
                    if (!container) return;
                    const rows = Array.from(container.querySelectorAll('.string'));
                    if (rows.length===0) return;
                    // Derive visual pattern from strumMode even when playMode is 'chords' or 'arp'
                    let mode = this.playMode || 'high-low';
                    if (mode === 'chords' || mode === 'arp') {
                        switch(this.strumMode){
                            case 'up': mode = 'low-high'; break;
                            case 'down': mode = 'high-low'; break;
                            case 'alt-centers': mode = 'alt-center'; break;
                            case 'alt-ends': default: mode = 'alt-ends'; break;
                        }
                    }
                    let seq = [];
                    if ((mode === 'alt-ends' || mode === 'alt-center') && typeof this.groupStringsByOctave === 'function'){
                        const { groups } = this.groupStringsByOctave(rows);
                        for (const g of groups){
                            if (mode === 'alt-ends'){
                                const a = g.slice(); let i=0, j=a.length-1; while(i<=j){ if(i<=j) seq.push(a[i++]); if(i<=j) seq.push(a[j--]); }
                            } else {
                                const a=g.slice(); const mid=Math.floor((a.length-1)/2); let l=mid, r=mid+1; if(a.length%2===1){ seq.push(a[mid]); l=mid-1; r=mid+1; } while(l>=0 || r<a.length){ if(r<a.length) seq.push(a[r++]); if(l>=0) seq.push(a[l--]); }
                            }
                        }
                    } else {
                        // Base ascending by frequency
                        const asc = rows.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0)-(parseFloat(b.dataset.frequency)||0));
                        seq = this.getPatternSequence(asc, mode);
                    }
                    // Apply CSS order and store play order index based on first occurrence
                    const seen = new Set(); let orderIdx = 0;
                    for (const el of seq){
                        if (seen.has(el)) continue;
                        seen.add(el);
                        el.style.order = String(orderIdx);
                        el.dataset.playOrder = String(orderIdx);
                        orderIdx++;
                    }
                    // Append any remaining rows not included
                    rows.forEach(el=>{
                        if (!seen.has(el)){
                            el.style.order = String(orderIdx);
                            el.dataset.playOrder = String(orderIdx);
                            orderIdx++;
                        }
                    });
                } catch(e) { console.warn('applyPlayModeToColumnVisual failed:', e); }
            }

            applyPlayModeToAllColumns(){
                document.querySelectorAll('.extension-column').forEach(col=> this.applyPlayModeToColumnVisual(col));
                const prev = document.getElementById('previewChordColumn');
                if (prev) this.applyPlayModeToColumnVisual(prev);
            }
            
            adjustColorBrightness(hexColor, percent) {
                // Utility function to adjust color brightness
                const num = parseInt(hexColor.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
            
            hexToRgb(hex) {
                // Convert hex color to RGB values
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }
            
            mapIntervalToEDO(interval, tuning = null) {
                // Map 12-TET intervals to the nearest equivalent in the current EDO
                // This preserves diatonic relationships properly
                const tuningSize = tuning || this.getTuningStepsPerOctave();
                const currentTuning = tuning || this.currentTuning;
                
                if (currentTuning === 12) {
                    // For 12-TET, return the interval as-is
                    return Math.round(interval);
                }
                
                // For other EDOs, map to the nearest step that preserves musical relationships
                const exactStep = (interval * tuningSize) / 12;
                return Math.round(exactStep);
            }
            
            getBaseTriadForQuality(quality) {
                // Return standard diatonic intervals in semitones
                // These will be properly mapped to EDO steps by mapIntervalToEDO
                let intervals = [0]; // Root
                
                switch (quality) {
                    case 'major':
                        intervals.push(4); // Major third (4 semitones)
                        intervals.push(7); // Perfect fifth (7 semitones)
                        break;
                    case 'minor':
                        intervals.push(3); // Minor third (3 semitones)
                        intervals.push(7); // Perfect fifth (7 semitones)
                        break;
                    case 'neutral':
                        intervals.push(3.5); // Neutral third (3.5 semitones)
                        intervals.push(7); // Perfect fifth (7 semitones)
                        break;
                    case 'diminished':
                        intervals.push(3); // Minor third
                        intervals.push(6); // Diminished fifth
                        break;
                    case 'augmented':
                        intervals.push(4); // Major third
                        intervals.push(8); // Augmented fifth
                        break;
                    case 'sus2':
                        intervals.push(2); // Major second
                        intervals.push(7); // Perfect fifth
                        break;
                    case 'sus4':
                        intervals.push(5); // Perfect fourth
                        intervals.push(7); // Perfect fifth
                        break;
                    default:
                        intervals.push(4); // Default to major third
                        intervals.push(7); // Perfect fifth
                        break;
                }
                
                return intervals;
            }
            
            convertExtensionsToIntervals(extensions) {
                // Return extensions as semitone intervals that will be mapped by mapIntervalToEDO
                const intervals = [];
                
                extensions.forEach(ext => {
                    switch (ext) {
                        case '6':
                            intervals.push(9); // Major 6th (9 semitones)
                            break;
                        case '7':
                            intervals.push(10); // Minor 7th (10 semitones)
                            break;
                        case 'maj7':
                            intervals.push(11); // Major 7th (11 semitones)
                            break;
                        case '9':
                            intervals.push(10); // 7th (required for 9th chords)
                            intervals.push(14); // 9th (2 semitones up an octave = 14)
                            break;
                        case '11':
                            intervals.push(10); // 7th (required for 11th chords)
                            intervals.push(14); // 9th (often included in 11th chords)
                            intervals.push(17); // 11th (5 semitones up an octave = 17)
                            break;
                        case 's11':
                        case '#11':
                            intervals.push(10); // 7th
                            intervals.push(14); // 9th
                            intervals.push(18); // #11th (6 semitones up an octave = 18)
                            break;
                        case '13':
                            intervals.push(10); // 7th (required for 13th chords)
                            intervals.push(14); // 9th (usually included)
                            intervals.push(17); // 11th (usually included)
                            intervals.push(21); // 13th (9 semitones up an octave = 21)
                            break;
                        case 's13':
                        case '#13':
                            intervals.push(10); // 7th
                            intervals.push(14); // 9th
                            intervals.push(17); // 11th
                            intervals.push(22); // #13th (10 semitones up an octave = 22)
                            break;
                        case 'sus2':
                            intervals.push(2); // Major 2nd
                            break;
                        case 'sus4':
                            intervals.push(5); // Perfect 4th
                            break;
                        case 'add9':
                            intervals.push(14); // 9th (2 semitones up an octave, no 7th)
                            break;
                        case 'neutral7':
                            intervals.push(10); // Still minor 7th, but will be applied to neutral triads
                            break;
                        case 'neutral11':
                            intervals.push(10); // 7th
                            intervals.push(14); // 9th
                            intervals.push(17); // 11th
                            break;
                    }
                });
                
                return intervals;
            }

            // Attach long-press drag and dwell-to-swap on a column (initiation on header or free space only)
            attachColumnDragHandlers(column) {
                try {
                    const container = document.getElementById('extensionColumns');
                    if (!container || !column) return;
                    const header = column.querySelector('.extension-header');
                    if (!header) return;

                    // Capture omnichord instance for event handlers
                    const omnichord = this;

                    const LONG_PRESS_MS = 200;
                    const DWELL_MS = 200;
                    const JITTER_PX = 6;
                    const DELETE_THRESHOLD_PX = 5; // delete only if dragged to top of the viewport

                    let pressTimer = null;
                    let isDragging = false;
                    let startX = 0, startY = 0;
                    let grabOffsetX = 0, grabOffsetY = 0;
                    let placeholder = null;
                    let dwellTimer = null;
                    let deleteIntent = false;
                    let originalAbsIndex = null;
                    let lastSwapTarget = null;
                    let lastSwapTargetAbsIndex = null;

                    const getPointer = (e) => (e.touches && e.touches[0]) || e;
                    const canStartFrom = (target) => {
                        // allow from header or empty space inside column; block buttons
                        if (!target) return false;
                        if (target.closest('.chord-action-button') || target.closest('.lock-button')) return false;
                        return target.closest('.extension-header') || target.closest('.extension-column');
                    };

                    const swapNodes = (a, b) => {
                        if (!a || !b || a === b) return;
                        const aMarker = document.createElement('div');
                        const bMarker = document.createElement('div');
                        const parent = a.parentNode;
                        if (!parent || !b.parentNode) return;
                        parent.insertBefore(aMarker, a);
                        parent.insertBefore(bMarker, b);
                        parent.replaceChild(b, aMarker);
                        parent.replaceChild(a, bMarker);
                    };

                    const onPressStart = (e) => {
                        // Avoid starting drag while editing a header text
                        const t = e.target;
                        if (t && (t.getAttribute && t.getAttribute('contenteditable') === 'true')) return;
                        if (!canStartFrom(e.target)) return;
                        const p = getPointer(e);
                        startX = p.clientX; startY = p.clientY;
                        // Start drag timer - will be cancelled if tap ends quickly
                        pressTimer = setTimeout(() => beginDrag(p), LONG_PRESS_MS);
                    };

                    const cancelPress = () => { if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; } };

                    const maybeCancelOnMove = (e) => {
                        if (!pressTimer) return;
                        const p = getPointer(e);
                        if (Math.abs(p.clientX - startX) > JITTER_PX || Math.abs(p.clientY - startY) > JITTER_PX) cancelPress();
                    };

                    const beginDrag = (p) => {
                        isDragging = true;
                        column.classList.add('dragging');
                        const rect = column.getBoundingClientRect();
                        grabOffsetX = p.clientX - rect.left;
                        grabOffsetY = p.clientY - rect.top;
                        column.style.width = rect.width + 'px';
                        column.style.height = rect.height + 'px';
                        column.style.position = 'fixed';
                        column.style.zIndex = 9999;
                        column.style.pointerEvents = 'none';
                        column.style.transform = 'scale(1.03)';
                        column.style.boxShadow = '0 12px 22px rgba(0,0,0,0.35)';

                        placeholder = document.createElement('div');
                        placeholder.className = 'extension-column placeholder';
                        placeholder.style.width = rect.width + 'px';
                        placeholder.style.height = rect.height + 'px';
                        placeholder.style.flex = '1';
                        placeholder.style.border = '2px dashed rgba(255,255,255,0.3)';
                        column.parentNode.insertBefore(placeholder, column);

                        // Capture the absolute index for the dragged column (for data swap)
                        try {
                            if (this.getIndexFromColumn) {
                                originalAbsIndex = this.getIndexFromColumn(column);
                            } else if (column.dataset && column.dataset.originalPosition) {
                                originalAbsIndex = parseInt(column.dataset.originalPosition, 10);
                            } else {
                                originalAbsIndex = Array.from(container.querySelectorAll('.extension-column')).indexOf(column);
                            }
                        } catch (_) { originalAbsIndex = null; }
                        lastSwapTarget = null;
                        lastSwapTargetAbsIndex = null;

                        moveDrag(p);
                        window.addEventListener('mousemove', onMove, { passive: false });
                        window.addEventListener('touchmove', onMove, { passive: false });
                        window.addEventListener('mouseup', onEnd);
                        window.addEventListener('touchend', onEnd);
                    };

                    const moveDrag = (p) => {
                        const x = p.clientX - grabOffsetX;
                        const y = p.clientY - grabOffsetY;
                        column.style.left = x + 'px';
                        column.style.top = y + 'px';

                        // delete intent near top
                        // Only flag delete when pointer is near the very top of the viewport
                        const shouldDelete = (p.clientY <= DELETE_THRESHOLD_PX);
                        if (shouldDelete !== deleteIntent) {
                            deleteIntent = shouldDelete;
                            column.classList.toggle('delete-intent', deleteIntent);
                        }

                        const siblings = Array.from(container.querySelectorAll('.extension-column'))
                            .filter(el => el !== column && !el.classList.contains('placeholder'));
                        let over = siblings.find(el => {
                            const r = el.getBoundingClientRect();
                            return p.clientX > r.left && p.clientX < r.right && p.clientY > r.top && p.clientY < r.bottom;
                        });

                        // Fallback using elementFromPoint for reliability across browsers
                        if (!over) {
                            const hit = document.elementFromPoint(p.clientX, p.clientY);
                            const hitCol = hit && hit.closest ? hit.closest('.extension-column') : null;
                            if (hitCol && hitCol !== column && !hitCol.classList.contains('placeholder')) {
                                over = hitCol;
                            }
                        }

                        if (over) {
                            if (!dwellTimer) {
                dwellTimer = setTimeout(() => {
                                    if (!placeholder || !over.parentNode) return;
                                    if (over !== lastSwapTarget) {
                                        swapNodes(placeholder, over);
                                        lastSwapTarget = over;
                                        try {
                                            lastSwapTargetAbsIndex = this.getIndexFromColumn ? this.getIndexFromColumn(over) : (over.dataset && over.dataset.originalPosition ? parseInt(over.dataset.originalPosition, 10) : null);
                                        } catch(_) { lastSwapTargetAbsIndex = null; }
                    // Allow subsequent swaps by resetting the dwell timer state
                    clearTimeout(dwellTimer);
                    dwellTimer = null;
                                    }
                                }, DWELL_MS);
                            }
                        } else if (dwellTimer) {
                            clearTimeout(dwellTimer); dwellTimer = null;
                        }
                    };

                    const onMove = (e) => { if (!isDragging && pressTimer) { maybeCancelOnMove(e); return; } if (!isDragging) return; const p = getPointer(e); moveDrag(p); e.preventDefault(); };

                    const onEnd = () => {
                        cancelPress();
                        window.removeEventListener('mousemove', onMove);
                        window.removeEventListener('touchmove', onMove);
                        window.removeEventListener('mouseup', onEnd);
                        window.removeEventListener('touchend', onEnd);
                        if (dwellTimer) { clearTimeout(dwellTimer); dwellTimer = null; }

                        column.classList.remove('dragging');
                        column.style.position = '';
                        column.style.left = '';
                        column.style.top = '';
                        column.style.zIndex = '';
                        column.style.pointerEvents = '';
                        column.style.transform = '';
                        column.style.boxShadow = '';
                        column.style.width = '';
                        column.style.height = '';

            if (deleteIntent) {
                            deleteIntent = false;
                            // remove column and update data (do not recreate nodes for others)
                            const idx = this.getIndexFromColumn ? this.getIndexFromColumn(column) : Array.from(container.children).indexOf(column);
                            if (idx > -1) {
                                this.chordExtensions.splice(idx, 1);
                                column.remove();
                                this.normalizeChordPositions?.();
                                this.saveChordConfiguration?.();
                                // Regenerate to recalc columns and ensure gap removal and sizing
                                try {
                                    if (typeof this.preserveLockedChordsAndRegenerate === 'function') {
                                        this.preserveLockedChordsAndRegenerate();
                                    } else if (typeof this.generateExactChordColumns === 'function' && (this.chordExtensions||[]).some(c=>c.isCustom)) {
                                        this.generateExactChordColumns();
                                    } else if (typeof this.generateExtensionColumns === 'function') {
                                        this.generateExtensionColumns();
                                    }
                                    // Ensure gaps are closed
                                    if (typeof this._rebuildChordGridAfterDeletion === 'function') {
                                        this._rebuildChordGridAfterDeletion();
                                    }
                                } catch(_) {}
                            }
                            if (placeholder) placeholder.remove();
                            return;
                        }

                        if (placeholder && placeholder.parentNode) {
                            placeholder.parentNode.insertBefore(column, placeholder);
                            placeholder.remove();
                        }

                        // Rebuild data order from DOM to reflect the final visual order (works for single swap or cascades)
                        const orderedEls = Array.from(container.querySelectorAll('.extension-column'));
                        if (Array.isArray(this.chordExtensions) && orderedEls.length) {
                            const newArray = [];
                            for (let i = 0; i < orderedEls.length; i++) {
                                const el = orderedEls[i];
                                const oldIdx = el.dataset && el.dataset.originalPosition ? parseInt(el.dataset.originalPosition, 10) : i;
                                const model = this.chordExtensions[oldIdx] ?? this.chordExtensions[i];
                                if (model) {
                                    model.position = i;
                                    newArray.push(model);
                                    // Update dataset to new index for consistent future operations
                                    try { el.dataset.originalPosition = String(i); } catch(_) {}
                                }
                            }
                            if (newArray.length === this.chordExtensions.length) {
                                this.chordExtensions = newArray;
                                this.normalizeChordPositions?.();
                                this.saveChordConfiguration?.();
                                // Ensure the visible header names/lock states match the new underlying model order
                                if (typeof this.syncColumnHeaderToModel === 'function') {
                                    for (let i = 0; i < orderedEls.length; i++) {
                                        try { this.syncColumnHeaderToModel(orderedEls[i], this.chordExtensions[i]); } catch(_) {}
                                    }
                                }
                            }
                        }
                    };

                    const onPressEnd = (e) => {
                        // If press timer is still running, this was a quick tap
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                            
                            // Don't interfere with header action buttons
                            if (
                                e.target.classList.contains('lock-button') ||
                                e.target.classList.contains('chord-action-button') ||
                                e.target.tagName === 'BUTTON'
                            ) {
                                return;
                            }
                            
                            console.log('?? Header quick tap - triggering chord/ARP');
                            
                            // Use the same logic as the footer trigger button
                            const rect = column.getBoundingClientRect();
                            const midY = rect.top + rect.height * 0.5;
                            omnichord.handleTriggerButtonClick(column, midY);
                        }
                    };

                    // Initiation only from header or free space
                    header.addEventListener('mousedown', (e) => { if (e.button !== 0) return; onPressStart(e); });
                    header.addEventListener('touchstart', (e) => { onPressStart(e); }, { passive: true });
                    header.addEventListener('mouseup', (e) => { onPressEnd(e); });
                    header.addEventListener('touchend', (e) => { onPressEnd(e); });

                } catch (err) { console.error('attachColumnDragHandlers error:', err); }
            }
            
            getTuningStepsPerOctave() {
                // Handle custom tuning objects
                if (typeof this.currentTuning === 'object' && this.currentTuning.type === 'custom') {
                    // For non-octave tunings, we need to calculate how many steps make an octave
                    const [num, den] = this.currentTuning.ratio;
                    const ratioInOctaves = Math.log2(num / den);
                    return this.currentTuning.divisions / ratioInOctaves;
                }
                
                if (typeof this.currentTuning === 'string') {
                    switch(this.currentTuning) {
                        case 'carlos-alpha': return 78.0;
                        case 'carlos-beta': return 18.8;
                        case 'carlos-gamma': return 34.1895;
                        case 'carlos-delta': return 10.024;
                        case 'lucy': return 6.283; // approximately 2p
                        case 'pythagorean':
                        case 'just':
                        case 'meantone':
                            return 12;
                        case 'arabic': return 24;
                        case 'gamelan-pelog': return 7;
                        case 'gamelan-slendro': return 5;
                        default: return 12;
                    }
                }
                return this.currentTuning;
            }

            // Synchronize a column's header text and lock UI to the provided chord model
            syncColumnHeaderToModel(column, chordModel) {
                if (!column || !chordModel) return;
                const chordNameEl = column.querySelector('.chord-name');
                const lockBtn = column.querySelector('.lock-button');
                if (!chordNameEl) return;

                if (chordModel.isLocked && chordModel.lockedData) {
                    const locked = chordModel.lockedData;
                    const rootName = (this.getNoteNames()[locked.lockedRoot] || locked.lockedRoot);
                    if (locked.chordName && /^[A-G][#b]?/.test(locked.chordName)) {
                        chordNameEl.textContent = locked.chordName;
                    } else if (locked.chordName) {
                        chordNameEl.textContent = `${rootName}${locked.chordName}`;
                    } else {
                        chordNameEl.textContent = `${rootName}${chordModel.name || ''}`;
                    }
                    chordNameEl.style.color = '#4CAF50';
                    chordNameEl.style.fontWeight = 'bold';
                    chordNameEl.dataset.isLocked = 'true';
                    chordNameEl.dataset.lockedName = chordNameEl.textContent;
                    if (lockBtn) {
                        lockBtn.innerHTML = '🔒';
                        lockBtn.classList.add('locked');
                        lockBtn.title = `LOCKED to ${rootName} root with all settings`;
                    }
                } else {
                    chordNameEl.textContent = (chordModel.name || '');
                    chordNameEl.style.color = '';
                    chordNameEl.style.fontWeight = '';
                    chordNameEl.dataset.isLocked = '';
                    chordNameEl.dataset.lockedName = '';
                    if (lockBtn) {
                        lockBtn.innerHTML = '🔓';
                        lockBtn.classList.remove('locked');
                        lockBtn.title = 'Lock complete sonic snapshot';
                    }
                }
            }

            addSimpleClickHandlers() {
                // Simple click handlers no longer needed - drag system handles tap and hold
                // debug removed
            }

            stopAllActiveNotes() {
                // Use the unified stop logic that matches osc1/osc2 structure
                try {
                    this.stopAllStrings();
                } catch (_) {
                    // Fallback: manual release for any remaining entries in all oscillator pools
                    const now = this.audioContext ? this.audioContext.currentTime : 0;
                    const allPools = [
                        this.activeOscillators,
                        this.activeStrumOscillators,
                        this.activeChordOscillators,
                        this.activeArpOscillators,
                        this.activeBassOscillators
                    ];
                    
                    for (const pool of allPools) {
                        if (!pool) continue;
                        for (const [id, info] of pool) {
                            // Preserve the independent global bass
                            if (info && info.isGlobalBass) continue;
                            try {
                                if (info.osc1Envelope) {
                                    info.osc1Envelope.gain.cancelScheduledValues(now);
                                    info.osc1Envelope.gain.setValueAtTime(info.osc1Envelope.gain.value, now);
                                    info.osc1Envelope.gain.linearRampToValueAtTime(0, now + (this.envelope?.release || 0.2));
                                }
                                if (info.osc2Envelope) {
                                    info.osc2Envelope.gain.cancelScheduledValues(now);
                                    info.osc2Envelope.gain.setValueAtTime(info.osc2Envelope.gain.value, now);
                                    info.osc2Envelope.gain.linearRampToValueAtTime(0, now + (this.osc2Envelope?.release || 0.2));
                                }
                                const maxRel = Math.max(this.envelope?.release || 0.2, this.osc2Envelope?.release || 0.2);
                                if (info.osc1) info.osc1.stop(now + maxRel);
                                if (info.osc2) info.osc2.stop(now + maxRel);
                            } catch {}
                            pool.delete(id);
                        }
                    }
                }
                // Clear held-bass references so a fresh one can be started next time
                try { this._heldBassVoice = null; this._heldBassLiveFreq = null; this._heldBassVoiceKey = null; } catch(_){ }
                // Also stop any active drum voices
                try { this.stopAllDrums && this.stopAllDrums(); } catch(_){ }
            }

            handleStringTrigger(event, touchId = null) {
                // During sequencing, just allow STRUM mode - don't affect sequence progression
                if (this._isSequencing) {
                    // Force STRUM mode during sequencing
                    if (this.playMode !== 'strum') {
                        this.playMode = 'strum';
                        this.updatePlayModeButtons();
                    }
                }
                
                // Ensure AudioContext is running on every swipe sample for reliability
                try {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume().catch(()=>{});
                    }
                } catch(_) {}
                const elements = document.elementsFromPoint(event.clientX, event.clientY);
                const stringElement = elements.find(el => el.classList.contains('string'));
                
                if (stringElement) {
                    // If a blank chord is pending and user is strumming another column, inherit immediately
                    try {
                        if (this.pendingBlankChordId) {
                            const srcCol = stringElement.closest && stringElement.closest('.extension-column');
                            const pendingCol = document.querySelector(`.extension-column[data-chord-id='${this.pendingBlankChordId}']`);
                            const isSame = pendingCol && srcCol && pendingCol === srcCol;
                            if (srcCol && pendingCol && !isSame) {
                                const headerName = srcCol.querySelector('.extension-header .chord-name')?.textContent?.trim() || '';
                                if (headerName !== '|') {
                                    const relSteps = this.getChordStepsForColumn(srcCol);
                                    const edo = this.currentTuning || 12;
                                    const absSteps = relSteps.map(s=> ((s % edo)+edo)%edo);
                                    const best = this._chooseBestRootByQuality(absSteps, edo);
                                    const rootAbs = best.root;
                                    const normalized = absSteps.map(s=> ((s - rootAbs)%edo+edo)%edo).sort((a,b)=> this.stepToSemitone(a,edo)-this.stepToSemitone(b,edo));
                                    const idx = (this.chordExtensions||[]).findIndex(c=> String(c.id)===String(this.pendingBlankChordId));
                                    if (idx >= 0) {
                                        const model = this.chordExtensions[idx];
                                        model.intervals = normalized;
                                        model.fixedRootStepAbs = rootAbs;
                                        model.fixedRootTuning = edo;
                                        const newName = this.computeFullChordNameFromAbsoluteSteps([rootAbs, ...normalized.map(x=> (rootAbs + x)%edo)], edo);
                                        model.name = newName;
                                        try {
                                            const nameEl = pendingCol.querySelector('.extension-header .chord-name');
                                            if (nameEl) { nameEl.textContent = newName; nameEl.dataset.lockedName = newName; }
                                            const old = pendingCol.querySelector('.strings-column');
                                            if (old) old.remove();
                                            this.generateStringsForColumn(pendingCol, model.intervals, true);
                                            this.highlightKeyboardForColumn(pendingCol);
                                            this.currentActiveColumnEl = pendingCol;
                                        } catch(_) {}
                                        this.pendingBlankChordId = null;
                                        try { this.saveChordConfiguration(); } catch(_) {}
                                    }
                                }
                            }
                        }
                    } catch(_) {}
                    const stringIndex = stringElement.dataset.index;
                    const column = parseInt(stringElement.dataset.column) || stringElement.dataset.column;
                    // Build a stable key for this string in its column
                    const stringKey = `${column}|${stringIndex}`;
                    // Identify pointer: mouse vs specific touch id (derive from event if needed)
                    let pointerKey;
                    if (touchId !== null && touchId !== undefined) {
                        pointerKey = `t${touchId}`;
                    } else if (event && typeof event === 'object' && 'identifier' in event && event.identifier !== undefined && event.identifier !== null) {
                        pointerKey = `t${event.identifier}`;
                    } else {
                        pointerKey = 'mouse';
                    }
                    const lastKey = this._pointerLastStringKey.get(pointerKey);
                    const trackingSet = touchId !== null ? 
                        this.activeTouches.get(touchId)?.triggeredStrings : 
                        this.triggeredStrings;
                    
                    // Throttle triggering per string to avoid audio spam but maintain responsiveness
                    const now = performance.now();
                    const lastTrigger = stringElement.lastTriggerTime || 0;
                    const minInterval = 35; // 35ms minimum between triggers per string (≤28/s) - improved touch sensitivity
                    
                    // Skip retrigger if same pointer is still on the same string and sustain gesture is active
                    const sameStringAsLast = (lastKey === stringKey);
                    if (!sameStringAsLast && (now - lastTrigger > minInterval)) {
                        this.currentPlayingColumn = column;
                        // Try to cache actual column element and light keyboard - enhanced with pre-cached lookup
                        try {
                            let columnEl = null;
                            // Use cached column if available and recent (performance optimization)
                            if (stringElement._cachedColumn && stringElement._lastCacheTime && 
                                (now - stringElement._lastCacheTime) < 200) {
                                columnEl = stringElement._cachedColumn;
                            } else {
                                // Fallback to DOM lookup
                                columnEl = stringElement.closest('.extension-column');
                                if (!columnEl && typeof column === 'string') {
                                    columnEl = document.querySelector(`.extension-column[data-chord-type='${column}']`);
                                }
                                // Cache for next time
                                if (columnEl) {
                                    stringElement._cachedColumn = columnEl;
                                    stringElement._lastCacheTime = now;
                                }
                            }
                            if (columnEl) {
                                this.currentActiveColumnEl = columnEl;
                                this.highlightKeyboardForColumn(columnEl);
                            }
                        } catch(_) {}
                        const frequency = parseFloat(stringElement.dataset.frequency);
                        // Use 'strum' source type for independent oscillators during PLAY mode
                        const sourceType = this._isSequencing ? 'strum' : 'default';
                        this.playFrequency(frequency, stringElement, sourceType);
                        this.updateCurrentChord(column);
                        
                        stringElement.lastTriggerTime = now;
                        // Update last-hit key for this pointer
                        this._pointerLastStringKey.set(pointerKey, stringKey);
                        
                        // Add to tracking for cleanup
                        if (trackingSet) {
                            trackingSet.add(stringIndex);
                            // Quick removal to allow retriggering
                            setTimeout(() => {
                                trackingSet.delete(stringIndex);
                            }, 20);
                        }
                    }
                }
            }

            handlePaletteStringTrigger(event) {
                const elements = document.elementsFromPoint(event.clientX, event.clientY);
                const stringElement = elements.find(el => el.classList.contains('string') && el.dataset.paletteIndex !== undefined);
                
                if (stringElement) {
                    const stringIndex = stringElement.dataset.index;
                    const paletteIndex = stringElement.dataset.paletteIndex;
                    const rawFrequency = stringElement.dataset.frequency;
                    
                    // Throttle triggering per string to avoid audio spam but maintain responsiveness
                    const now = performance.now();
                    const lastTrigger = stringElement.lastTriggerTime || 0;
                    const minInterval = 35; // 35ms minimum between triggers per string (≤28/s) - improved touch sensitivity
                    
                    if (now - lastTrigger > minInterval && !this.paletteTriggeredStrings.has(stringIndex)) {
                        const frequency = parseFloat(rawFrequency);
                        
                        if (!isNaN(frequency) && isFinite(frequency)) {
                            this.playFrequency(frequency, stringElement, 'chord');
                            
                            stringElement.lastTriggerTime = now;
                            this.paletteTriggeredStrings.add(stringIndex);
                            
                            // Quick removal to allow retriggering
                            setTimeout(() => {
                                this.paletteTriggeredStrings.delete(stringIndex);
                            }, 20);
                        } else {
                            // invalid frequency - no-op
                        }
                    }
                }
            }

            updateCurrentChord(column) {
                // Resolve the column element from dataset.column (chordType) or fallback to closest
                let columnElement = document.querySelector(`[data-chord-type="${column}"]`) || document.querySelector(`[data-column="${column}"]`);
                if (!columnElement) {
                    try { columnElement = document.querySelector(`.extension-column[data-chord-type='${column}']`); } catch(_){}
                }
                // If user was creating a new chord, auto-save it before switching context
                if (this.chordCreationMode && this.selectedIntervals && this.selectedIntervals.length > 1) {
                    try {
                        const edo = this.currentTuning || 12;
                        const absSteps = this.selectedIntervals.map(iv => ((iv % edo) + edo) % edo);
                        const pendingName = this.computeFullChordNameFromAbsoluteSteps(absSteps, edo);
                        this.finalizePreviewChord(pendingName);
                        this.chordCreationMode = false;
                    } catch(e) { /* ignore */ }
                }
                // Apply piano-locked preset if one exists for this chord's structure
                if (columnElement && this.pianoLockedChords && this.pianoLockedChords.size > 0) {
                    try {
                        const headerElement = columnElement.querySelector('.extension-header');
                        const chordData = this.getChordDataFromColumn(columnElement, headerElement);
                        if (chordData) {
                            const lock = this.findPianoLockData(chordData);
                            if (lock) {
                                this.applyPianoLockedSettings(lock);
                                // Preload/warm this chord for instant play
                                try { this.preloadPianoLockedChord(columnElement); } catch(_) {}
                            }
                        }
                    } catch(_) {}
                }
                // Mark active column for keyboard interactions
                this.currentPlayingColumn = column;
                // Cache the active column element for keyboard-driven live edits
                this.currentActiveColumnEl = columnElement || this.currentActiveColumnEl;
                // Light keyboard notes for the active chord if possible
                try { if (columnElement) this.highlightKeyboardForColumn(columnElement); } catch(_) {}
            }

            playChordStrum(columnElement, chordData, startY, endY) {
                // Chords mode: play all tones simultaneously in tapped octave + bass root, sustain until release
                if ((this.playMode || 'high-low') === 'chords') {
                    const tapY = (typeof startY === 'number' && typeof endY === 'number') ? (startY + endY) / 2 : (columnElement?.getBoundingClientRect()?.top || 0);
                    this.playChordChordsMode(columnElement, tapY);
                    return;
                }
                // Ensure audio is ready once for this strum
                if (typeof this.ensureAudioContext === 'function') {
                    // Fire and forget; individual notes also guard, but this minimizes per-note overhead
                    this.ensureAudioContext().catch(()=>{});
                }
                // If there's a newly created blank chord pending, and the user strums another chord first,
                // inherit that strummed chord's tones into the pending blank chord.
                try {
                    if (this.pendingBlankChordId && columnElement) {
                        const pendingId = this.pendingBlankChordId;
                        // Locate the pending column/model
                        const pendingCol = document.querySelector(`.extension-column[data-chord-id='${pendingId}']`);
                        const pendingIdx = (this.chordExtensions||[]).findIndex(c=> String(c.id)===String(pendingId));
                        const isPendingBlank = pendingIdx >= 0 && Array.isArray(this.chordExtensions[pendingIdx].intervals) && this.chordExtensions[pendingIdx].intervals.length === 0;
                        // Ensure we're not strumming the pending column itself
                        const isSameCol = pendingCol && pendingCol === columnElement;
                        // Avoid copying from separators
                        const headerName = columnElement.querySelector('.extension-header .chord-name')?.textContent?.trim() || '';
                        const isSeparator = headerName === '|';
                        if (isPendingBlank && !isSameCol && !isSeparator) {
                            const relSteps = this.getChordStepsForColumn(columnElement);
                            const edo = this.currentTuning || 12;
                            // Choose lowest by 12TET quality and normalize
                            const absSteps = relSteps.map(s=> ((s % edo)+edo)%edo);
                            const best = this._chooseBestRootByQuality(absSteps, edo);
                            const rootAbs = best.root;
                            const normalized = absSteps.map(s=> ((s - rootAbs)%edo+edo)%edo).sort((a,b)=> this.stepToSemitone(a,edo)-this.stepToSemitone(b,edo));
                            // Write into pending model
                            const model = this.chordExtensions[pendingIdx];
                            model.intervals = normalized;
                            model.fixedRootStepAbs = rootAbs;
                            model.fixedRootTuning = edo;
                            const newName = this.computeFullChordNameFromAbsoluteSteps([rootAbs, ...normalized.map(x=> (rootAbs + x)%edo)], edo);
                            model.name = newName;
                            // Update pending column UI
                            if (pendingCol) {
                                try {
                                    const nameEl = pendingCol.querySelector('.extension-header .chord-name');
                                    if (nameEl) { nameEl.textContent = newName; nameEl.dataset.lockedName = newName; }
                                    const old = pendingCol.querySelector('.strings-column');
                                    if (old) old.remove();
                                    this.generateStringsForColumn(pendingCol, model.intervals, true);
                                    this.highlightKeyboardForColumn(pendingCol);
                                    this.currentActiveColumnEl = pendingCol;
                                } catch(_) {}
                            }
                            // Clear pending flag to avoid further copies
                            this.pendingBlankChordId = null;
                            // Persist
                            try { this.saveChordConfiguration(); } catch(_) {}
                        }
                    }
                } catch(_) {}
                // Check if this chord is locked
                let originalSettings = null;
                const lockedChord = this.lockedChords?.get(columnElement);
                
                // Resolve piano-locked settings for this chord (keyed by chord SHAPE)
                let pianoLockedData = null;
                try {
                    // Prefer direct intervals from rendered strings to build a stable shape
                    const relSteps = this.getChordStepsForColumn(columnElement);
                    const chordForLock = {
                        name: (columnElement.querySelector('.extension-header .chord-name')?.textContent||'').trim(),
                        quality: this.currentQuality,
                        intervals: Array.isArray(relSteps) ? relSteps : []
                    };
                    pianoLockedData = this.findPianoLockData(chordForLock);
                } catch(_) {}
                
                if (lockedChord) {
                    console.log('?? Playing locked chord:', lockedChord.chordName, 'locked to root:', lockedChord.lockedRoot);
                    // Store current settings
                    originalSettings = this.captureCurrentSettings();
                    // Apply locked settings
                    this.applyLockedChordSettings(lockedChord);
                    
                    // Always make sure we're using the locked root for playback
                    if (this.currentRoot !== lockedChord.lockedRoot) {
                        console.log('?? Overriding current root', this.currentRoot, 'with locked root:', lockedChord.lockedRoot, 'for playback');
                        this.currentRoot = lockedChord.lockedRoot;
                    }
                } else if (pianoLockedData) {
                    // Apply piano-locked settings (oscillator & effects only)
                    console.log('🎹 Playing chord with piano-locked settings:', pianoLockedData.chordName);
                    this.applyPianoLockedSettings(pianoLockedData);
                }
                
                // Get all strings in the column
                const strings = Array.from(columnElement.querySelectorAll('.string'));
                if (strings.length === 0) return;
                
                // Calculate which strings to play based on start and end positions
                const columnRect = columnElement.getBoundingClientRect();
                const relativeStartY = startY - columnRect.top;
                const relativeEndY = endY - columnRect.top;
                
                // Determine strum direction and range
                const strumDown = relativeEndY > relativeStartY;
                const minY = Math.min(relativeStartY, relativeEndY);
                const maxY = Math.max(relativeStartY, relativeEndY);
                
                // Filter strings that fall within the strum range
                let stringsToPlay = strings.filter(string => {
                    const stringRect = string.getBoundingClientRect();
                    const stringY = stringRect.top + stringRect.height / 2 - columnRect.top;
                    return stringY >= minY && stringY <= maxY;
                });
                // Fallback: if the gesture window captured no strings (e.g., tiny swipe), play them all
                if (stringsToPlay.length === 0) stringsToPlay = strings;
                
                // Build playback sequence from the subset within the gesture window
                const ascAll = strings.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0)-(parseFloat(b.dataset.frequency)||0));
                const baseAscInWindow = ascAll.filter(s=> stringsToPlay.includes(s));
                // Allow repeated notes for arpeggio patterns where applicable
                let playbackSeq = (typeof this.getPatternPlaybackSequence==='function')
                    ? this.getPatternPlaybackSequence(baseAscInWindow, this.playMode||'high-low')
                    : baseAscInWindow.slice();
                // Fallback to play-order if pattern builder failed
                if (!Array.isArray(playbackSeq) || playbackSeq.length===0) {
                    playbackSeq = stringsToPlay.slice().sort((a,b)=> (parseInt(a.dataset.playOrder||'0',10) - parseInt(b.dataset.playOrder||'0',10)));
                }
                // For non-forced modes, reverse order on upward strum so patterns follow gesture direction
                if (this.playMode && !['low-high','high-low'].includes(this.playMode)) {
                    if (!strumDown) playbackSeq = playbackSeq.slice().reverse();
                }
                const originalCount = stringsToPlay.length;
                stringsToPlay = playbackSeq;
                
                // Per-string delay controls perceptibility of order; if we expanded notes (repeats), squeeze to same span
                const baseDelay = Number.isFinite(this.strumDelayMs) ? this.strumDelayMs : 20;
                const factor = Math.max(1, stringsToPlay.length / Math.max(1, originalCount));
                const strumDelay = baseDelay / factor;
                
                stringsToPlay.forEach((string, index) => {
                    setTimeout(() => {
                        let frequency = parseFloat(string.dataset.frequency);
                        if (!frequency || isNaN(frequency) || !isFinite(frequency) || frequency <= 0) {
                            // Compute a safe fallback from stored step/octave
                            try {
                                const step = parseInt(string.dataset.noteIndex, 10);
                                const oct = parseInt(string.dataset.octave, 10);
                                const tuning = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                                if (Number.isFinite(step)) {
                                    frequency = this.getFrequency(((step % tuning) + tuning) % tuning, Number.isFinite(oct) ? oct : 4, tuning);
                                }
                            } catch(_) {}
                        }
                        if (frequency && !isNaN(frequency) && isFinite(frequency) && frequency > 0) {
                            // Route STRUM notes to the dedicated pool so they don't interfere with CHORD voices
                            this.playFrequency(frequency, string, 'strum');
                            
                            // Minimal visual feedback for speed on core only
                            const core = string.querySelector('.string-core');
                            if (core) {
                                core.style.transform = 'scaleY(1.15)';
                                core.style.filter = 'brightness(1.12)';
                                setTimeout(() => {
                                    core.style.transform = 'scaleY(1)';
                                    core.style.filter = 'brightness(1)';
                                }, 90);
                            }
                        }
                    }, index * strumDelay);
                });

                // Let the per-note auto-release handle note lengths so attacks have time to be heard
                // (Previously we forced an early stop at ~200ms which could mute long attacks.)

                // Update keyboard highlighting for current chord tones and keep until next chord
                try { this.highlightKeyboardForColumn(columnElement); this.currentActiveColumnEl = columnElement; } catch(_) {}
                
                // Restore original settings if this was a locked chord
                if (originalSettings) {
                    // Defer restoration until after the strum completes and notes pass their attack/decay
                    const strumSpanMs = Math.max(0, (stringsToPlay.length - 1) * strumDelay);
                    const noteADMs = Math.max(
                        (this.envelope.attack + this.envelope.decay) * 1000,
                        (this.osc2Envelope.attack + this.osc2Envelope.decay) * 1000
                    );
                    const restoreDelay = Math.max(250, strumSpanMs + noteADMs + 50);
                    setTimeout(() => {
                        this.restoreSettings(originalSettings);
                        console.log('?? Restored original settings after locked chord playback');
                    }, restoreDelay);
                }
            }

            // New: Chords Play Mode implementation
            playChordChordsMode(columnElement, clientY){
                if (!columnElement) return;
                
                try { this.ensureAudioContext && this.ensureAudioContext(); } catch(_){}
                
                // Different sustain behavior for sequencing vs manual play
                if (this._isSequencing) {
                    // During sequencing: don't set indefinite sustain, let HOLD duration control it
                    this._sustainActive = false;
                    this._chordsGestureActive = true;
                } else {
                    // Manual play: sustain gate active until mouseup/touchend
                    this._sustainActive = true;
                    this._chordsGestureActive = true;
                }
                // Mark slide active if enabled so tap-to-slide works immediately on subsequent taps
                this._chordSlideActive = !!this._chordSlideEnabled;
                // Lock the tapped octave for the duration of this gesture
                try {
                    const tappedForLock = this._getTappedOctave(columnElement, clientY);
                    if (this._slideOctaveLock == null && Number.isFinite(tappedForLock)) this._slideOctaveLock = tappedForLock;
                } catch(_) {}
                // Immediately update held bass to start gliding as the chord is engaged
                try { this._updateHeldBassForColumn(columnElement); } catch(_) { }
                // Reset any prior detunes from previous slides
                try { this._resetAllStringFrequencies(); } catch(_) { }
                // Prepare slide state
                this._chordSlideVoices && this._chordSlideVoices.clear && this._chordSlideVoices.clear();
                this._chordSlideStartColumn = columnElement;
                if (this._chordSlideActive){
                    this._chordSlideHoverColumn = columnElement;
                    this._chordSlideCommittedColumn = columnElement;
                    this._chordSlideHoverSince = performance.now();
                    this._markChordSlideActivity();
                }
                // Reset pointer last-hit so over-strum can begin cleanly
                try { this._pointerLastStringKey.set('mouse', null); } catch(_){ }

                // Build an NPC high chord from the tapped note within octaves C3..C5
                const npcLimit = this._getGlobalNpc ? this._getGlobalNpc() : (this._arp?.chordsNpc || this._arp?.npc || 3);
                const tapInfo = this._findTapRowInColumn(columnElement, clientY);
                let rowsToPlay = this._buildNpcHighChordFromTap(columnElement, tapInfo, npcLimit);

        // Play selection simultaneously
        const groupId = ((this._chordSlideGroupId||0)+1) >>> 0; this._chordSlideGroupId = groupId;
        rowsToPlay.forEach(string => {
                    let frequency = parseFloat(string.dataset.frequency);
                    if (!frequency || !isFinite(frequency) || frequency <= 0){
                        try {
                            const step = parseInt(string.dataset.noteIndex,10);
                            const oct = parseInt(string.dataset.octave,10);
                            const tuning = this.currentTuning || 12;
                            if (Number.isFinite(step)) frequency = this.getFrequency(((step%tuning)+tuning)%tuning, Number.isFinite(oct)?oct:4, tuning);
                        } catch(_){ }
                    }
                    if (frequency && isFinite(frequency) && frequency>0){
            this.playFrequency(frequency, string, 'chord');
            try { if (this._chordSlideVoices) this._chordSlideVoices.set(string, { startFreq: frequency, startLog2: Math.log2(frequency), groupId }); } catch(_){ }
                        try{ string.classList.add('active'); setTimeout(()=> string.classList.remove('active'), 120); }catch(_){ }
                    }
                });

                // Ensure held bass is aligned after voices start (double-call is safe and ensures catch-up)
                try { this._updateHeldBassForColumn(columnElement); } catch(_){ }

                // Remember last voicing (use log2 frequency positions for distance)
                if (rowsToPlay && rowsToPlay.length){
                    const toPitch = (el)=>{
                        const f = parseFloat(el.dataset.frequency);
                        return (f && f>0) ? Math.log2(f) : null;
                    };
                    const pitches = rowsToPlay.map(toPitch).filter(v=> v!=null).sort((a,b)=>a-b);
                    const avgOct = (()=>{
                        const arr = rowsToPlay.map(r=> parseFloat(r.dataset.octave)).filter(Number.isFinite);
                        if (!arr.length) return 4;
                        return arr.reduce((a,b)=>a+b,0)/arr.length;
                    })();
                    this._lastChordVoicing = { pitches, avgOctave: avgOct };
                }

                try { this.highlightKeyboardForColumn(columnElement); this.currentActiveColumnEl = columnElement; } catch(_){}
                
                // Add automatic HOLD duration for CHORD mode
                try {
                    // Clear any existing chord hold timer
                    if (this._chordHoldTimer) {
                        clearTimeout(this._chordHoldTimer);
                        this._chordHoldTimer = null;
                    }
                    
                    // Get HOLD duration from universal control
                    const holdSelect = document.getElementById('universalHold') || document.getElementById('chordHold');
                    const holdValue = holdSelect ? holdSelect.value : 'bar:1';
                    const [kind, valStr] = String(holdValue).split(':');
                    const n = Math.max(1, parseInt(valStr || '1', 10));
                    
                    // Calculate hold duration in milliseconds
                    const bpmEl = document.getElementById('universalBpm');
                    const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                    const beatMs = 60000 / Math.max(20, bpm);
                    
                    // Get time signature with denominator awareness
                    const timeSignatureEl = document.getElementById('universalTimeSignature');
                    const tsRaw = timeSignatureEl ? String(timeSignatureEl.value||'4/4') : '4/4';
                    let tsNum=4, tsDen=4; try { const [n,d] = tsRaw.split('/').map(x=>parseInt(x,10)); if(Number.isFinite(n)&&n>0) tsNum=n; if(Number.isFinite(d)&&d>0) tsDen=d; } catch(_) {}
                    const beatsPerBar = (tsNum * 4) / tsDen;
                    const barMs = beatMs * beatsPerBar;
                    // HOLD strictly defines duration; enforce minimum of one quant step (1/8) so fastest change is 1/8 note
                    const quantMinMs = beatMs * 0.5; // 1/8 of 4/4 beat
                    const baseHoldMs = (kind === 'beat') ? n * beatMs : n * barMs;
                    const holdMs = Math.max(quantMinMs, baseHoldMs);
                    
                    // Set timer to automatically release chord after HOLD duration
                    this._chordHoldTimer = setTimeout(() => {
                        if (this._sustainActive && this._chordsGestureActive) {
                            this._sustainActive = false;
                            this._chordsGestureActive = false;
                            this._slideOctaveLock = null;
                            this.stopAllActiveNotes();
                        }
                        this._chordHoldTimer = null;
                    }, holdMs);
                } catch(err) {
                    console.warn('CHORD hold duration setup failed:', err);
                }
            }

            // Determine all chord degrees (EDO steps) for a column's chord model
            _getChordDegreesForColumn(column){
                try {
                    const id = column.dataset.chordId;
                    let idx = -1;
                    if (id) idx = (this.chordExtensions || []).findIndex(c => (String(c.id)===String(id)));
                    if (idx < 0 && column.dataset.originalPosition != null) {
                        const op = parseInt(column.dataset.originalPosition,10);
                        if (!isNaN(op) && op >= 0) idx = op;
                    }
                    const model = (idx>=0)? this.chordExtensions[idx] : null;
                    const EDO = (model?.fixedRootTuning) || this.currentTuning || 12;
                    let ints = Array.isArray(model?.intervals) ? model.intervals.slice() : [];
                    if (!ints.length) {
                        // Try derive from rendered steps
                        ints = this.getChordStepsForColumn(column);
                    }
                    // Unique and sort by semitone equivalence for stable order
                    const uniq = Array.from(new Set(ints)).map(s=> ((s%EDO)+EDO)%EDO);
                    uniq.sort((a,b)=> this.stepToSemitone(a, EDO) - this.stepToSemitone(b, EDO));
                    return uniq;
                } catch(_) {
                    // Fallback to a major triad mapping if model lookup fails
                    return [0,4,7].map(semi=> Math.round((semi * (this.currentTuning||12))/12));
                }
                // Schedule idle stop after activity
                try { this._markChordSlideActivity(); } catch(_){ }
            }

            // Find the closest string row to a tap inside a column
            _findTapRowInColumn(columnElement, clientY) {
                try {
                    if (!columnElement) return null;
                    const colRect = columnElement.getBoundingClientRect();
                    const container = columnElement.querySelector('.strings-column');
                    if (!container) return null;
                    const rows = Array.from(container.querySelectorAll('.string'));
                    if (!rows.length) return null;
                    const relY = clientY - colRect.top;
                    let best = null, bestDist = Infinity;
                    for (const r of rows) {
                        const rr = r.getBoundingClientRect();
                        const cy = (rr.top + rr.height/2) - colRect.top;
                        const d = Math.abs(cy - relY);
                        if (d < bestDist) { bestDist = d; best = r; }
                    }
                    if (!best) return null;
                    const edo = this.currentTuning || 12;
                    const oct = parseInt(best.dataset.octave||'NaN', 10);
                    let step = parseInt(best.dataset.edoStep||best.dataset.interval||'NaN', 10);
                    if (!Number.isFinite(step)) {
                        const nAbs = parseInt(best.dataset.noteIndex||'NaN', 10);
                        if (Number.isFinite(nAbs)) {
                            const rootAbs = this._getEffectiveColumnRootStep(columnElement);
                            step = ((nAbs - rootAbs) % edo + edo) % edo;
                        }
                    } else {
                        step = ((step % edo) + edo) % edo;
                    }
                    const f = parseFloat(best.dataset.frequency||'NaN');
                    return { row: best, octave: Number.isFinite(oct)?oct:null, step: Number.isFinite(step)?step:null, freq: Number.isFinite(f)?f:null };
                } catch(_) { return null; }
            }

            // Build NPC chord tones constrained to a single octave (C3..C5), respecting transpose and voice-leading
            _buildNpcHighChordFromTap(columnElement, tapInfo, npc) {
                try {
                    const out = [];
                    if (!columnElement || !tapInfo || !tapInfo.row) return out;
                    const edo = this.currentTuning || 12;
                    const all = Array.from(columnElement.querySelectorAll('.strings-column .string'));
                    if (!all.length) return out;

                    // Map rows by (octave|relativeStep) where relativeStep is against current effective root
                    const byKey = new Map();
                    const effRoot = this._getEffectiveColumnRootStep(columnElement);
                    for (const r of all) {
                        const o = parseInt(r.dataset.octave||'NaN', 10);
                        if (!Number.isFinite(o)) continue;
                        const nAbs = parseInt(r.dataset.noteIndex||'NaN', 10);
                        if (!Number.isFinite(nAbs)) continue;
                        const st = ((nAbs - effRoot) % edo + edo) % edo;
                        byKey.set(o + '|' + st, r);
                    }

                    // Desired degrees (unique, semitone-ordered), relative to the chord model (and thus effRoot)
                    let degs = this._getChordDegreesForColumn(columnElement) || [];
                    degs = Array.from(new Set(degs.map(s => ((s%edo)+edo)%edo)));
                    degs.sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo));

                    const want = Math.max(1, Math.min(64, npc|0));
                    const take = Math.min(want, degs.length);

                    // Determine a single target octave in [3..5] for all tones
                    const octFromTap = Number.isFinite(tapInfo.octave) ? tapInfo.octave : 4;
                    const lastAvg = (this._lastChordVoicing && Number.isFinite(this._lastChordVoicing.avgOctave))
                        ? this._lastChordVoicing.avgOctave : null;
                    const clamp35 = (o)=> Math.max(3, Math.min(5, o|0));

                    // Candidate octave order: nearest to last voicing, then tap, then center (4), then edges
                    const cand = [];
                    if (lastAvg != null) cand.push(clamp35(Math.round(lastAvg)));
                    cand.push(clamp35(octFromTap));
                    cand.push(4, 3, 5);
                    // Deduplicate preserving order
                    const candOcts = Array.from(new Set(cand));

                    // Try to find an octave that contains all requested degrees
                    let chosenRows = null;
                    let bestPartial = { rows: [], matches: -1, octave: null };
                    for (const o of candOcts) {
                        const rows = [];
                        let matches = 0;
                        for (let i=0;i<take;i++){
                            const d = degs[i];
                            const r = byKey.get(o + '|' + d);
                            if (r) { rows.push(r); matches++; }
                        }
                        if (matches === take) { chosenRows = rows; break; }
                        if (matches > bestPartial.matches) bestPartial = { rows, matches, octave: o };
                    }

                    if (!chosenRows) {
                        // Use the octave with the most matches to keep voicing consistent within a single octave
                        chosenRows = bestPartial.rows;
                    }

                    return Array.isArray(chosenRows) ? chosenRows.slice(0, take) : [];
                } catch(_) { return []; }
            }

            // Choose a voicing minimizing motion to previous chord and constrained to maxSpanOct octaves
            _pickNearestVoicingRows(column, desiredIntervals, anchorOct, lastLogPitches, maxSpanOct = 1.5){
                try {
                    const rows = Array.from(column.querySelectorAll('.strings-column .string'));
                    if (!rows.length) return [];
                    const tuning = this.currentTuning || 12;

                    // Degree -> candidate rows
                    const byDeg = new Map();
                    desiredIntervals.forEach(iv=> byDeg.set(((iv%tuning)+tuning)%tuning, []));
                    for (const r of rows){
                        const deg = parseInt(r.dataset.interval,10);
                        const oct = parseInt(r.dataset.octave,10);
                        if (!Number.isFinite(deg) || !Number.isFinite(oct)) continue;
                        const key = ((deg%tuning)+tuning)%tuning;
                        if (!byDeg.has(key)) continue;
                        // Exclude octave 2 from voice-leading candidates
                        if (oct >= 3) byDeg.get(key).push(r);
                    }
                    const degs = Array.from(byDeg.keys());
                    if (degs.length === 0) return [];
            // Sort candidates per degree by octave, then proximity to anchor
                    for (const [k, list] of byDeg.entries()){
                        list.sort((a,b)=>{
                            const oa = parseInt(a.dataset.octave,10)||0;
                            const ob = parseInt(b.dataset.octave,10)||0;
                if (oa !== ob) return oa - ob;
                return Math.abs(oa - anchorOct) - Math.abs(ob - anchorOct);
                        });
                    }

                    // Order degrees by semitone ascending for stable mapping to sorted previous pitches
                    degs.sort((a,b)=> this.stepToSemitone(a, tuning) - this.stepToSemitone(b, tuning));

                    // Build target pitch vector (log2) aligned to degree order
                    const buildTargets = (N)=>{
                        if (!Array.isArray(lastLogPitches) || lastLogPitches.length===0){
                            return null; // anchor-driven selection only
                        }
                        const prev = lastLogPitches.slice().sort((x,y)=>x-y);
                        const M = prev.length;
                        if (M === N) return prev;
                        const T = new Array(N);
                        // Map indices proportionally
                        for (let i=0;i<N;i++){
                            const t = (i*(M-1))/(N-1);
                            const lo = Math.floor(t), hi = Math.ceil(t);
                            if (lo===hi) T[i] = prev[lo]; else T[i] = (prev[lo] + prev[hi]) / 2;
                        }
                        return T;
                    };
                    const targets = buildTargets(degs.length);

                    // Greedy selection: per degree, choose row closest to target; avoid reusing the same element
                    const chosen = [];
                    const used = new Set();
                    const log2f = (el)=>{ const f=parseFloat(el.dataset.frequency)||0; return (f>0)? Math.log2(f) : null; };
                    degs.forEach((deg, i)=>{
                        const list = byDeg.get(deg) || [];
                        let best = null, bestCost = Infinity;
                        for (const r of list){
                            if (used.has(r)) continue;
                            const p = log2f(r); if (p==null) continue;
                            const oct = parseInt(r.dataset.octave,10)||0;
                            let cost;
                            if (targets){
                                cost = Math.abs(p - targets[i]) + 0.25*Math.abs(oct - anchorOct);
                            } else {
                                cost = Math.abs(oct - anchorOct) + 0.001*Math.abs((parseFloat(r.dataset.frequency)||0) - 0);
                            }
                            if (cost < bestCost){ bestCost = cost; best = r; }
                        }
                        if (best){ used.add(best); chosen.push(best); }
                    });
                    if (!chosen.length) return [];

                    // Span control with octave rolling
                    const toPitches = ()=> chosen.map(log2f).filter(v=>v!=null).sort((a,b)=>a-b);
                    const withinSpan = ()=>{
                        const octs = chosen.map(r=> parseInt(r.dataset.octave,10)||0).sort((a,b)=>a-b);
                        if (!octs.length) return true;
                        return (octs[octs.length-1] - octs[0]) <= maxSpanOct + 1e-6;
                    };
                    const tryShift = (index, dir)=>{
                        // dir: +1 move up to next higher candidate; -1 move down
                        const deg = degs[index];
                        const list = byDeg.get(deg) || [];
                        if (!list.length) return false;
                        const cur = chosen[index];
                        const pos = list.indexOf(cur);
                        let nextIdx = pos + dir;
                        while (nextIdx>=0 && nextIdx<list.length){
                            const cand = list[nextIdx];
                            if (!cand || chosen.includes(cand)) { nextIdx += dir; continue; }
                            chosen[index] = cand; return true;
                        }
                        return false;
                    };

                    let guard = 0;
                    while (!withinSpan() && guard < 16){
                        guard++;
                        const octs = chosen.map(r=> parseInt(r.dataset.octave,10)||0).sort((a,b)=>a-b);
                        const meanOct = octs.reduce((a,b)=>a+b,0)/octs.length;
                        // If drifting upward, raise the lowest degree; else lower the highest (within 3..5)
                        if (meanOct >= anchorOct){
                            // find index of chosen with lowest pitch
                            let minIdx = 0; let minVal = Infinity;
                            chosen.forEach((r,i)=>{ const v = parseInt(r.dataset.octave,10)||0; if (v<minVal){ minVal=v; minIdx=i; } });
                            if (!tryShift(minIdx, +1)) break;
                        } else {
                            let maxIdx = 0; let maxVal = -Infinity;
                            chosen.forEach((r,i)=>{ const v = parseInt(r.dataset.octave,10)||0; if (v>maxVal){ maxVal=v; maxIdx=i; } });
                            if (!tryShift(maxIdx, -1)) break;
                        }
                    }
                    return chosen;
                } catch(_) { return []; }
            }

            // Compute the set of current chord tones (relative steps) for a column
            getChordStepsForColumn(column){
                if (!column) return [];
                const lockedChord = this.lockedChords?.get(column);
                let tuningSize = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                // Gather distinct relative steps from rendered strings
                const strings = Array.from(column.querySelectorAll('.strings-column .string'));
                const relSteps = new Set();
                strings.forEach(row => {
                    const stepStr = row.dataset.edoStep;
                    if (stepStr != null) {
                        const s = ((parseInt(stepStr,10) % tuningSize)+tuningSize)%tuningSize;
                        relSteps.add(s);
                    } else {
                        // Fallback: compute from noteIndex and current root
                        const noteIdx = parseInt(row.dataset.noteIndex,10);
                        const root = this.currentRoot || 0;
                        const s = ((noteIdx - root) % tuningSize + tuningSize) % tuningSize;
                        relSteps.add(s);
                    }
                });
                return Array.from(relSteps.values());
            }

            // Light the keyboard keys/dots that match the current chord tones
            highlightKeyboardForColumn(column){
                console.log('=== HIGHLIGHT FUNCTION CALLED ===');
                console.log('this.transposeDelta at start of highlight function:', this.transposeDelta);
                console.log('column:', column);
                
                const kb = document.querySelector('#rootGrid .piano-keyboard, #modalRootGrid .piano-keyboard');
                if (!kb || !column) {
                    console.log('Missing kb or column:', {kb: !!kb, column: !!column});
                    return;
                }
                
                // Get chord model and optional locked snapshot
                const kbEdo = this.currentTuning || 12;
                let chordIntervals = [];
                let tuningSize = kbEdo;
                let baseRoot = 0;
                let model = null;
                const lockedChord = this.lockedChords?.get(column) || null;

                try {
                    const id = column.dataset.chordId;
                    let idx = -1;
                    if (id) idx = (this.chordExtensions || []).findIndex(c => (String(c.id)===String(id)));
                    if (idx < 0 && column.dataset.originalPosition != null) {
                        const op = parseInt(column.dataset.originalPosition,10);
                        if (!isNaN(op) && op >= 0) idx = op;
                    }
                    model = (idx>=0)? this.chordExtensions[idx] : null;
                    console.log('HIGHLIGHT DEBUG: model =', model, 'lockedChord =', !!lockedChord);
                } catch(e) { console.error('HIGHLIGHT ERROR (model lookup):', e); }

                if (model && Array.isArray(model.intervals)) {
                    chordIntervals = [...model.intervals];
                    tuningSize = model.fixedRootTuning || kbEdo;
                } else {
                    // Fallback to rendered steps if model missing
                    chordIntervals = this.getChordStepsForColumn(column);
                    tuningSize = kbEdo;
                }

                // Compute effective baseRoot to align lights with audio/name
                const edo = tuningSize;
                const norm = (v,m)=> ((v % m) + m) % m;
                const g = norm((this.transposeDelta || 0), edo);
                const l = norm((+column.dataset.localTranspose || 0), edo);

                if (lockedChord && typeof lockedChord.lockedRoot === 'number') {
                    // Locked chords preserve exact pitch; follow local transpose only
                    baseRoot = norm((lockedChord.lockedRoot || 0) + l, edo);
                } else if (model && typeof model.fixedRootStepAbs === 'number' && model.fixedRootTuning) {
                    baseRoot = norm((model.fixedRootStepAbs % edo) + g + l, edo);
                } else {
                    baseRoot = norm((this.currentRoot || 0) + g + l, edo);
                }
                console.log('HIGHLIGHT ROOT:', {baseRoot, edo, g, l, tuningSize});
                
                // Clear previous chord-tone marks and any inline glow
                kb.querySelectorAll('[data-step]').forEach(el=>{
                    el.classList.remove('chord-tone');
                    try { el.style.boxShadow = ''; el.style.outlineColor = ''; } catch(_){}
                });

                // Apply colored glow per chord tone (by pitch class/semitone color)
                chordIntervals.forEach(rel =>{
                    // Compute absolute step: baseRoot + interval
                    const abs = ((baseRoot + rel) % tuningSize + tuningSize) % tuningSize;
                    console.log('HIGHLIGHT APPLY: rel =', rel, 'baseRoot =', baseRoot, 'abs =', abs);
                    
                    // Map to keyboard EDO if needed
                    let kbAbs = abs;
                    if (tuningSize !== kbEdo) {
                        const cents = (abs * 1200) / tuningSize;
                        kbAbs = Math.round((cents * kbEdo) / 1200);
                        kbAbs = ((kbAbs % kbEdo) + kbEdo) % kbEdo;
                    }
                    
                    const semi = this.stepToSemitone(kbAbs, kbEdo);
                    const color = this.getChromaticColorForSemitone(semi);
                    if (kbEdo === 12) {
                        // Match any element whose data-step % 12 equals kbAbs % 12
                        kb.querySelectorAll('[data-step]').forEach(el=>{
                            const ds = parseInt(el.dataset.step,10);
                            if ((ds % 12) === (kbAbs % 12)) {
                                el.classList.add('chord-tone');
                                try {
                                    el.style.boxShadow = `0 0 10px 3px ${color}99, 0 0 18px 6px ${color}55`;
                                    el.style.outlineColor = color;
                                } catch(_){ }
                            }
                        });
                    } else {
                        kb.querySelectorAll(`[data-step='${kbAbs}']`).forEach(el=>{
                        el.classList.add('chord-tone');
                        try {
                            el.style.boxShadow = `0 0 10px 3px ${color}99, 0 0 18px 6px ${color}55`;
                            el.style.outlineColor = color;
                        } catch(_){ }
                    });
                    }
                });
            }

            // Resolve the active column element to mutate when editing via keyboard
            getActiveColumnElement(){
                if (this.currentActiveColumnEl && document.body.contains(this.currentActiveColumnEl)) return this.currentActiveColumnEl;
                // Fallback: use currentPlayingColumn id
                if (this.currentPlayingColumn != null) {
                    const el = document.querySelector(`[data-column="${this.currentPlayingColumn}"]`);
                    if (el) return el;
                }
                // No active column
                return null;
            }

            // Lookup a chord column DOM element by its stable id
            getColumnByChordId(id){
                if (!id) return null;
                try { return document.querySelector(`.extension-column[data-chord-id='${id}']`); } catch(_) { return null; }
            }

            // Toggle an absolute keyboard step in the currently active chord
            toggleNoteInActiveChord(absStep){
                console.log('=== TOGGLE NOTE DEBUG START ===');
                console.log('toggleNoteInActiveChord called with absStep:', absStep);
                console.log('Current transposeDelta:', this.transposeDelta);
                console.log('Current currentTuning:', this.currentTuning);
                // Re-entrancy guard
                if (this._toggling) return; this._toggling = true; setTimeout(()=>{ this._toggling = false; }, 0);
                const column = this.getActiveColumnElement();
                if (!column) return;
                // Allow editing even if previously locked (universal editor model)
                // Determine tuning and base root for this column
                const lockedChord = this.lockedChords?.get(column) || null;
                let tuningSize = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                // Compute base root exactly like highlight/audio, in EFFECTIVE space (includes transpose as applicable)
                let baseRoot = 0;
                try {
                    // Resolve chord model if present
                    let idxModel = column.dataset.originalPosition != null ? parseInt(column.dataset.originalPosition,10) : -1;
                    if (isNaN(idxModel) || idxModel < 0) {
                        const id = column.dataset.chordId;
                        idxModel = (this.chordExtensions || []).findIndex(c => (c.id===id));
                    }
                    const chordModel = (idxModel>=0)? this.chordExtensions[idxModel] : null;
                    console.log('BASEROOT CALCULATION: lockedChord =', !!lockedChord, 'chordModel =', !!chordModel);
                    console.log('BASEROOT CALCULATION: this.currentRoot =', this.currentRoot, 'this.transposeDelta =', this.transposeDelta);
                    if (lockedChord) {
                        const edo = lockedChord.lockedTuning || tuningSize;
                        const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                        baseRoot = ((lockedChord.lockedRoot ?? 0) + localDelta) % edo;
                        tuningSize = edo;
                        console.log('BASEROOT CALCULATION: lockedChord path, baseRoot =', baseRoot);
                    } else if (chordModel && typeof chordModel.fixedRootStepAbs === 'number' && chordModel.fixedRootTuning) {
                        tuningSize = chordModel.fixedRootTuning;
                        const edo = tuningSize;
                        const g = ((this.transposeDelta || 0) % edo + edo) % edo; // INCLUDE global transpose to match effective clicks
                        const l = ((+column.dataset.localTranspose || 0) % edo + edo) % edo; // INCLUDE local transpose
                        baseRoot = (((chordModel.fixedRootStepAbs % edo) + g + l) % edo + edo) % edo;
                        console.log('BASEROOT CALCULATION: fixedRoot path, fixedRootStepAbs =', chordModel.fixedRootStepAbs, 'g =', g, 'l =', l, 'baseRoot =', baseRoot);
                    } else {
                        const edo = tuningSize;
                        const g = ((this.transposeDelta || 0) % edo + edo) % edo; // INCLUDE global transpose
                        const l = ((+column.dataset.localTranspose || 0) % edo + edo) % edo; // INCLUDE local transpose
                        const start = (this.currentRoot ?? 0) % edo;
                        baseRoot = (((start + g + l) % edo) + edo) % edo;
                        console.log('BASEROOT CALCULATION: default path, start =', start, 'g =', g, 'l =', l, 'baseRoot =', baseRoot);
                    }
                } catch {}
                // Define keyboard EDO for reference
                const kbEdo = this.currentTuning || 12;
                // If the chord's model EDO differs from the keyboard, migrate the chord model to the keyboard EDO first
                // so that adding micro-steps never snaps back to the old EDO grid.
                if (!lockedChord && kbEdo !== tuningSize) {
                    try {
                        let idx = column.dataset.originalPosition != null ? parseInt(column.dataset.originalPosition,10) : this.findChordPosition?.(column) ?? -1;
                        if (isNaN(idx) || idx < 0) {
                            const id = column.dataset.chordId;
                            idx = (this.chordExtensions || []).findIndex(c => (c.id===id));
                        }
                        if (idx >= 0) {
                            const chordModel = this.chordExtensions[idx];
                            const mapStep = (s, fromEdo, toEdo) => {
                                const cents = (s * 1200) / fromEdo;
                                return ((Math.round((cents * toEdo) / 1200) % toEdo) + toEdo) % toEdo;
                            };
                            // Migrate relative intervals
                            if (Array.isArray(chordModel.intervals)) {
                                chordModel.intervals = chordModel.intervals.map(v => mapStep(((v % tuningSize)+tuningSize)%tuningSize, tuningSize, kbEdo));
                            }
                            // Migrate fixed root if present; otherwise map baseRoot
                            if (typeof chordModel.fixedRootStepAbs === 'number' && chordModel.fixedRootTuning) {
                                chordModel.fixedRootStepAbs = mapStep(((chordModel.fixedRootStepAbs % tuningSize)+tuningSize)%tuningSize, tuningSize, kbEdo);
                                chordModel.fixedRootTuning = kbEdo;
                            } else {
                                baseRoot = mapStep(baseRoot, tuningSize, kbEdo);
                            }
                            chordModel.isCustom = true;
                            // Adopt new tuning size for subsequent calculations
                            tuningSize = kbEdo;
                        }
                    } catch(_) {}
                }
                let absInTarget = ((absStep % tuningSize)+tuningSize)%tuningSize;
                // Compute relative step to toggle
                const rel = ((absInTarget - baseRoot) % tuningSize + tuningSize) % tuningSize;
                console.log('=== INTERVAL CALCULATION ===');
                console.log('toggleNoteInActiveChord: absStep =', absStep, 'baseRoot =', baseRoot, 'rel =', rel, 'tuningSize =', tuningSize);
                console.log('absInTarget =', absInTarget);
                // Get the chord model behind this column
                let idx = column.dataset.originalPosition != null ? parseInt(column.dataset.originalPosition,10) : this.findChordPosition?.(column) ?? -1;
                if (isNaN(idx) || idx < 0 || idx >= (this.chordExtensions?.length||0)) {
                    // Attempt alternative: match by dataset.chordId
                    const id = column.dataset.chordId;
                    idx = (this.chordExtensions || []).findIndex(c => (c.id===id));
                }
                if (idx < 0) return;
                const chordModel2 = this.chordExtensions[idx];
                if (!chordModel2) return;
                const prevIntervals = (chordModel2 && Array.isArray(chordModel2.intervals)) ? chordModel2.intervals.slice() : [];
                const wasCustom = !!(chordModel2 && chordModel2.isCustom);
                // Work on a set of intervals in this tuning; intervals are already EDO steps for customs
                const set = new Set((chordModel2.intervals || []).map(v => ((v % tuningSize)+tuningSize)%tuningSize));
                console.log('=== CHORD MODEL DEBUG ===');
                console.log('chordModel2.intervals (before) =', chordModel2.intervals);
                console.log('chordModel2.fixedRootStepAbs =', chordModel2.fixedRootStepAbs);
                console.log('toggleNoteInActiveChord: current intervals before toggle =', Array.from(set));
                // Toggle presence including the current root; allow removing it to enable re-rooting by lowest note
                const preSize = set.size;
                const hadRel = set.has(rel);
                if (hadRel) set.delete(rel); else set.add(rel);
                // If this was the first tone added to a truly blank chord, make that tone the root immediately
                if (preSize === 0 && !hadRel && set.size === 1) {
                    // Override baseRoot to the clicked absolute step so naming matches what you hear
                    baseRoot = absInTarget;
                    // Reset intervals so the selected tone is the root (0)
                    set.clear();
                    set.add(0);
                    try { console.log('FIRST NOTE: set root to abs', baseRoot, 'and zeroed intervals'); } catch(_) {}
                }
                // treat it as the real first note: re-root to the clicked absolute step and zero intervals.
                else if (preSize === 1 && !hadRel) {
                    const prevWasExactlyZero = (prevIntervals.length === 1) && ((((prevIntervals[0] % tuningSize)+tuningSize)%tuningSize) === 0);
                    const isNonZeroClick = (((rel % tuningSize)+tuningSize)%tuningSize) !== 0;
                    if (prevWasExactlyZero && isNonZeroClick && !wasCustom) {
                        baseRoot = absInTarget;
                        set.clear();
                        set.add(0);
                    }
                }
                console.log('toggleNoteInActiveChord: intervals after toggle =', Array.from(set));
                // Allow empty set temporarily (blank chord) until user adds notes
                const relSorted = Array.from(set.values()).sort((a,b)=>{
                    const sa = this.stepToSemitone(a, tuningSize);
                    const sb = this.stepToSemitone(b, tuningSize);
                    return sa - sb;
                });
                if (relSorted.length === 0) {
                    chordModel2.intervals = [];
                    delete chordModel2.fixedRootStepAbs;
                    delete chordModel2.fixedRootTuning;
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                    this.generateStringsForColumn(column, [], true);
                    try {
                        const nameEl = column.querySelector('.extension-header .chord-name');
                        nameEl.textContent = 'New';
                        nameEl.dataset.lockedName = nameEl.textContent;
                    } catch {}
                    try { this.highlightKeyboardForColumn(column); } catch {}
                    // If this emptied chord is the latest created, mark it pending again for inheritance
                    try {
                        const thisId = column.dataset.chordId;
                        if (thisId) this.pendingBlankChordId = thisId;
                    } catch(_) {}
                    this._scheduleEditSave(column);
                    return;
                }
                // Choose a musical root by best quality in 12-TET space, then normalize
                const absSet = relSorted.map(v => ((baseRoot + v) % tuningSize + tuningSize) % tuningSize);
                // Normalize RELATIVE to the effective baseRoot so we don't bake transpose into stored intervals
                const preservedRoot = ((baseRoot % tuningSize) + tuningSize) % tuningSize;
                const normalized = absSet.map(s => ((s - preservedRoot) % tuningSize + tuningSize) % tuningSize).sort((a,b)=>{
                    const sa = this.stepToSemitone(a, tuningSize);
                    const sb = this.stepToSemitone(b, tuningSize);
                    return sa - sb;
                });
                console.log('NORMALIZATION DEBUG: absSet =', absSet, 'preservedRoot =', preservedRoot, 'normalized =', normalized);
                chordModel2.intervals = normalized;
                // Store the untransposed absolute base root to avoid double-applying g/l later
                try {
                    const edoStore = tuningSize;
                    const norm = (v,m)=> ((v % m) + m) % m;
                    const g = norm((this.transposeDelta || 0), edoStore);
                    const lcl = norm((+column.dataset.localTranspose || 0), edoStore);
                    chordModel2.fixedRootStepAbs = norm(preservedRoot - g - lcl, edoStore);
                } catch(_) {
                    chordModel2.fixedRootStepAbs = preservedRoot;
                }
                chordModel2.fixedRootTuning = tuningSize;
                // Treat any chord that has been edited from the keyboard as a custom chord in EDO steps
                chordModel2.isCustom = true;
                console.log('=== FINAL RESULT ===');
                console.log('TOGGLE NOTE END: Updated chord fixedRootStepAbs =', chordModel2.fixedRootStepAbs, 'intervals =', chordModel2.intervals);
                console.log('=== TOGGLE NOTE DEBUG END ===');
                // Build absolute steps for naming in EFFECTIVE space so the header shows the heard root (includes local/global)
                const absForName = [baseRoot, ...normalized.map(x=> ((baseRoot + x) % tuningSize + tuningSize) % tuningSize)];
                const newName = this.computeFullChordNameFromAbsoluteSteps(absForName, tuningSize);
                // Update header text to always include computed root (from lowest note)
                try {
                    const nameEl = column.querySelector('.extension-header .chord-name');
                    nameEl.textContent = newName;
                    nameEl.dataset.lockedName = nameEl.textContent;
                } catch {}
                // Persist the new name on the chord model so future regenerations keep it
                try { chordModel2.name = newName; } catch {}
                // First time we add notes to the pending blank chord, clear the pending flag
                try {
                    if (this.pendingBlankChordId && String(column.dataset.chordId) === String(this.pendingBlankChordId)) {
                        this.pendingBlankChordId = null;
                    }
                } catch(_) {}
                // Regenerate strings for this column only; drop exact snapshot so changes apply
                if (lockedChord && lockedChord.exactFrequencies) lockedChord.exactFrequencies = [];
                const oldContainer = column.querySelector('.strings-column');
                if (oldContainer) oldContainer.remove();
                if (lockedChord) this.generateStringsForColumnWithLockedSettings(column, chordModel2.intervals, lockedChord);
                else this.generateStringsForColumn(column, chordModel2.intervals, chordModel2.isCustom||false);
                // Refresh keyboard highlight
                try { this.highlightKeyboardForColumn(column); } catch {}
                this._scheduleEditSave(column);
                // Lightly preview the updated chord
                try {
                    const rows = Array.from(column.querySelectorAll('.strings-column .string'));
                    rows.slice(0, Math.min(rows.length, 6)).forEach((row, i)=>{
                        const f = parseFloat(row.dataset.frequency);
                        if (!isNaN(f)) setTimeout(()=> this.playFrequency(f, row, 'chord'), i*10);
                    });
                } catch {}
            }

            async playFrequency(frequency, element, sourceType = 'default') {
                console.log('playFrequency called with:', frequency, 'Hz', element ? 'element present' : 'no element', 'source:', sourceType);
                
                // START TRANSPORT CLOCK AS SOON AS FIRST NOTE IS TRIGGERED
                try {
                    if (this.chordsEnabled || this.arpEnabled) {
                        this._startArpTransport();
                    }
                } catch(_) {}
                
                // Validate frequency before processing
                if (!frequency || isNaN(frequency) || !isFinite(frequency) || frequency <= 0) {
                    console.error('Invalid frequency passed to playFrequency:', frequency);
                    return;
                }

                // Ensure AudioContext is ready
                const audioReady = await this.ensureAudioContext();
                if (!audioReady) {
                    console.warn('AudioContext not ready, skipping playback');
                    return;
                }
                
                // Select appropriate oscillator pool and per-instrument config
                let oscillatorPool; let inst = null; let octaveOffset = 0;
                switch (sourceType) {
                    case 'strum':
                        oscillatorPool = this.activeStrumOscillators; inst = { a: this.instruments.strum1, b: this.instruments.strum2 };
                        // STRUM notes play one octave higher during PLAY mode
                        octaveOffset = this._isSequencing ? 1 : 0; break;
                    case 'chord':
                        oscillatorPool = this.activeChordOscillators; inst = { a: this.instruments.chord, b: null }; break;
                    case 'arp':
                        oscillatorPool = this.activeArpOscillators; inst = { a: this.instruments.arp, b: null }; break;
                    case 'bass':
                        oscillatorPool = this.activeBassOscillators; inst = { a: this.instruments.bass, b: null }; break;
                    default:
                        oscillatorPool = this.activeOscillators; inst = { a: this.instruments.strum1, b: this.instruments.strum2 }; break;
                }
                
                // Enforce instrument pitch ranges
                const tuning = this.currentTuning || 12;
                const cStep = this.semitoneToStep(0, tuning);
                const c1 = this.getFrequency(cStep, 1, tuning);
                const c3 = this.getFrequency(cStep, 3, tuning);
                const c5 = this.getFrequency(cStep, 5, tuning);
                const c9 = this.getFrequency(cStep, 9, tuning);
                let fClamped = frequency;
                if (sourceType === 'bass') {
                    // Clamp to C1..C3 via nearest octave displacement
                    const min = Math.min(c1, c3), max = Math.max(c1, c3);
                    while (fClamped < min) fClamped *= 2;
                    while (fClamped > max) fClamped /= 2;
                } else if (sourceType === 'chord') {
                    // CHORDS low register: C3..C5
                    const min = Math.min(c3, c5), max = Math.max(c3, c5);
                    while (fClamped < min) fClamped *= 2;
                    while (fClamped > max) fClamped /= 2;
                } else if (sourceType === 'arp' || sourceType === 'strum') {
                    // Lead/strum range: C3..C9
                    const min = Math.min(c3, c9), max = Math.max(c3, c9);
                    while (fClamped < min) fClamped *= 2;
                    while (fClamped > max) fClamped /= 2;
                }
                // Apply octave offset after clamping
                const adjustedFrequency = fClamped * Math.pow(2, octaveOffset);
                
                // Apply volume level based on source type (chords 25% quieter)
                let volumeMultiplier = 1.0;
                switch (sourceType) {
                    case 'chord':
                        volumeMultiplier = 0.75; // 25% quieter
                        break;
                    case 'strum':
                    case 'arp':
                    case 'bass':
                    default:
                        volumeMultiplier = 1.0; // Full volume
                        break;
                }
                
                console.log(`[${sourceType.toUpperCase()}] Playing ${frequency}Hz -> ${adjustedFrequency}Hz (octave offset: ${octaveOffset}, volume: ${Math.round(volumeMultiplier * 100)}%)`);
                
                // Check if this string belongs to a piano-locked chord and apply those settings
                const isDomEl = element && typeof element === 'object' && (element.closest || element.classList || element.querySelector);
                const safeElement = isDomEl ? element : null;
                const columnElement = safeElement && safeElement.closest ? safeElement.closest('.extension-column') : null;
                let pianoLockedData = null;
                let originalSettings = null;
                
                if (columnElement) {
                    try {
                        const relSteps = this.getChordStepsForColumn(columnElement);
                        const chordData = {
                            name: (columnElement.querySelector('.extension-header .chord-name')?.textContent||'').trim(),
                            quality: this.currentQuality,
                            intervals: Array.isArray(relSteps) ? relSteps : []
                        };
                        pianoLockedData = this.findPianoLockData(chordData);
                    } catch(_) {}
                }
                
                if (pianoLockedData) {
                    console.log('🎹 Applying piano-locked settings for playback:', pianoLockedData.chordName);
                    
                    // Store current settings for immediate restoration
                    originalSettings = {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 },
                        envelope: { ...this.envelope },
                        osc2Envelope: { ...this.osc2Envelope },
                        reverb: { ...this.reverb },
                        panning: { ...this.panning },
                        volume: this.volume,
                        masterVolume: this.masterVolume
                    };
                    
                    // Apply piano-locked settings temporarily (UI DOES NOT CHANGE)
                    this.applyPianoLockedSettings(pianoLockedData);
                }
                
                // If oscillator already exists in this pool, stop it first to prevent overlap
                if (oscillatorPool.has(frequency)) {
                    this.stopFrequency(frequency, safeElement, sourceType);
                }
                
                if (!this.audioContext) return;
                
                // Create dual oscillators (or single) with separate envelopes
                let osc1, osc2;
                const osc1Envelope = this.audioContext.createGain();
                const osc2Envelope = this.audioContext.createGain();
                const osc1Gain = this.audioContext.createGain();
                const osc2Gain = this.audioContext.createGain();
                const finalMixer = this.audioContext.createGain();
                
                // Create oscillator 1 (or noise)
                const o1 = inst?.a?.osc || this.oscillators.osc1;
                if (o1.type === 'noise') {
                    osc1 = this.createNoiseSource();
                } else {
                    osc1 = this.audioContext.createOscillator();
                    const t1 = o1.type;
                    if (['sine','sawtooth','square','pulse','fullrect','halfrect','parabolic','stair'].includes(t1)) {
                        osc1.setPeriodicWave(this.getCustomPeriodicWave(t1, o1.pulseWidth, o1.shapeWidth));
                    } else { osc1.type = t1; }
                    const totalDetune1 = (o1.detune||0) + ((o1.coarse||0) * (1200 / tuning));
                    const freq1 = adjustedFrequency * Math.pow(2, (o1.octave||0) + (totalDetune1 / 1200));
                    osc1.frequency.setValueAtTime(freq1, this.audioContext.currentTime);
                }
                
                // Create oscillator 2 (or noise)
                const useSecond = (sourceType === 'strum' || sourceType === 'default');
                const o2 = inst?.b?.osc || this.oscillators.osc2;
                if (useSecond && o2 && o2.type === 'noise') {
                    osc2 = this.createNoiseSource();
                } else if (useSecond && o2) {
                    osc2 = this.audioContext.createOscillator();
                    const t2 = o2.type;
                    if (['sine','sawtooth','square','pulse','fullrect','halfrect','parabolic','stair'].includes(t2)) {
                        osc2.setPeriodicWave(this.getCustomPeriodicWave(t2, o2.pulseWidth, o2.shapeWidth));
                    } else { osc2.type = t2; }
                    const totalDetune2 = (o2.detune||0) + ((o2.coarse||0) * (1200 / tuning));
                    const freq2 = adjustedFrequency * Math.pow(2, (o2.octave||0) + (totalDetune2 / 1200));
                    osc2.frequency.setValueAtTime(freq2, this.audioContext.currentTime);
                } else {
                    // No second osc for chord/arp/bass
                    osc2 = this.audioContext.createOscillator();
                    osc2.type = 'sine';
                    osc2.frequency.setValueAtTime(0.0001, this.audioContext.currentTime);
                    osc2Gain.gain.value = 0; // muted
                }
                
                // Set oscillator levels with volume multiplier applied
                osc1Gain.gain.value = (inst?.a?.osc?.level ?? this.oscillators.osc1.level) * volumeMultiplier;
                osc2Gain.gain.value = (inst?.b?.osc?.level ?? this.oscillators.osc2.level) * volumeMultiplier;
                
                // Connect oscillators through their individual envelopes
                if (o1.type === 'noise') {
                    // Add a resonant peak at the played frequency using a peaking EQ
                    const totalDetune1 = (o1.detune||0) + ((o1.coarse||0) * (1200 / tuning));
                    const center1 = frequency * Math.pow(2, (o1.octave||0) + (totalDetune1 / 1200));
                    const peak1 = this.audioContext.createBiquadFilter();
                    peak1.type = 'peaking';
                    const c1 = Math.max(10, Math.min(this.audioContext.sampleRate/2, center1));
                    peak1.frequency.setValueAtTime(c1, this.audioContext.currentTime);
                    // Shape Width controls Q of the resonant peak too
                    {
                        const sw = Math.max(0, Math.min(1, o1.shapeWidth ?? 0.5));
                        const minQ = 0.5, maxQ = 60;
                        const q = minQ * Math.pow(maxQ / minQ, sw);
                        peak1.Q.setValueAtTime(q, this.audioContext.currentTime);
                    }
                    // Level -> 0..+48 dB; 0 dB means plain brown noise
                    const lvlNorm1 = Math.max(0, Math.min(1, ((inst?.a?.osc?.level ?? this.oscillators.osc1.level) || 0) / 0.125));
                    peak1.gain.setValueAtTime(lvlNorm1 * 48, this.audioContext.currentTime);
                    osc1.connect(peak1);
                    peak1.connect(osc1Gain);
                } else {
                    // Direct connect; shaping is embedded in the PeriodicWave
                    osc1.connect(osc1Gain);
                }
                osc1Gain.connect(osc1Envelope);
                
                if (useSecond && o2 && o2.type === 'noise') {
                    const totalDetune2 = (o2.detune||0) + ((o2.coarse||0) * (1200 / tuning));
                    const center2 = frequency * Math.pow(2, (o2.octave||0) + (totalDetune2 / 1200));
                    const peak2 = this.audioContext.createBiquadFilter();
                    peak2.type = 'peaking';
                    const c2 = Math.max(10, Math.min(this.audioContext.sampleRate/2, center2));
                    peak2.frequency.setValueAtTime(c2, this.audioContext.currentTime);
                    {
                        const sw = Math.max(0, Math.min(1, o2.shapeWidth ?? 0.5));
                        const minQ = 0.5, maxQ = 60;
                        const q = minQ * Math.pow(maxQ / minQ, sw);
                        peak2.Q.setValueAtTime(q, this.audioContext.currentTime);
                    }
                    const lvlNorm2 = Math.max(0, Math.min(1, ((inst?.b?.osc?.level ?? this.oscillators.osc2.level) || 0) / 0.125));
                    peak2.gain.setValueAtTime(lvlNorm2 * 48, this.audioContext.currentTime);
                    osc2.connect(peak2);
                    peak2.connect(osc2Gain);
                } else {
                    osc2.connect(osc2Gain);
                }
                osc2Gain.connect(osc2Envelope);
                // Mix envelopes into final mixer
                osc1Envelope.connect(finalMixer);
                osc2Envelope.connect(finalMixer);
                console.log('Both oscillators mixed (with per-oscillator bandpass shaping)');
                
                const currentTime = this.audioContext.currentTime;
                
                // No DC sources used for shape width anymore

                // Create panner and apply panning based on mode (BEFORE reverb)
                const panner = this.audioContext.createStereoPanner();
                let panValue = 0; // Default center
                
                switch (this.panning.mode) {
                    case 'frequency':
                        // Pan based on frequency (low = left, high = right)
                        const logFreq = Math.log2(frequency / 220); // A3 as reference
                        panValue = Math.max(-1, Math.min(1, logFreq * 0.3)) * this.panning.width;
                        break;
                    case 'random':
                        // Random panning
                        panValue = (Math.random() * 2 - 1) * this.panning.width;
                        break;
                    case 'rotating':
                        // Rotating panning
                        this.panning.rotationAngle += 0.1;
                        panValue = Math.sin(this.panning.rotationAngle) * this.panning.width;
                        break;
                    case 'alternating':
                        // Alternating left/right; when ARP is running, step-driven toggle occurs in scheduler
                        if (!this._suppressPanningAutoToggle) {
                            this.panning.alternateState = !this.panning.alternateState;
                        }
                        panValue = (this.panning.alternateState ? 1 : -1) * this.panning.width;
                        break;
                    default:
                        // Center
                        panValue = 0;
                        break;
                }
                // Ensure BASS is always mono/center
                if (sourceType === 'bass') panValue = 0;
                panner.pan.setValueAtTime(panValue, currentTime);
                
                // FX Send routing based on instrument setting
                const instrumentType = sourceType === 'strum' ? 'strum1' : sourceType; // Handle strum mapping
                const sendToFX = this.instruments[instrumentType]?.fxSend ?? true;
                
                // Connect: finalMixer → panner → routing destination
                finalMixer.connect(panner);
                
                if (sendToFX) {
                    // Send to effects chain (reverb, delay, etc.) via master gainNode
                    panner.connect(this.gainNode);
                    console.log(`[${sourceType.toUpperCase()}] Sent to FX chain`);
                } else {
                    // Bypass effects - connect directly to master output via a dry path
                    // We need to create a bypass path that avoids the FX processing
                    if (!this.dryGainNode) {
                        this.dryGainNode = this.audioContext.createGain();
                        this.dryGainNode.connect(this.audioContext.destination);
                        this.dryGainNode.gain.value = this.masterVolume;
                    }
                    panner.connect(this.dryGainNode);
                    console.log(`[${sourceType.toUpperCase()}] Bypassed FX chain`);
                }
                
                // ADSR envelopes per instrument
                let env1Attack, env1Decay, env1Sustain, env1Release;
                let env2Attack, env2Decay, env2Sustain, env2Release;
                const e1 = inst?.a?.env || this.envelope;
                const e2 = inst?.b?.env || this.osc2Envelope;
                if (sourceType === 'chord') {
                    // Force sustain for chords, but use chord env A for attack/release feel
                    env1Attack = e1.attack; env1Decay = 1000; env1Sustain = 1.0; env1Release = e1.release;
                    env2Attack = (e2?.attack ?? e1.attack); env2Decay = 1000; env2Sustain = 1.0; env2Release = (e2?.release ?? e1.release);
                } else {
                    env1Attack = e1.attack; env1Decay = e1.decay; env1Sustain = e1.sustain; env1Release = e1.release;
                    env2Attack = (e2?.attack ?? e1.attack); env2Decay = (e2?.decay ?? e1.decay); env2Sustain = (e2?.sustain ?? e1.sustain); env2Release = (e2?.release ?? e1.release);
                }
                // Prevent zero-attack degenerate ramps (some browsers ignore ramp-to at same time)
                const minAttack = 0.003; // 3ms
                env1Attack = Math.max(minAttack, Number(env1Attack) || 0);
                env2Attack = Math.max(minAttack, Number(env2Attack) || 0);
                
                const osc1AttackTime = currentTime + env1Attack;
                const osc1DecayTime = osc1AttackTime + env1Decay;
                
                osc1Envelope.gain.setValueAtTime(0, currentTime);
                osc1Envelope.gain.linearRampToValueAtTime(1, osc1AttackTime); // Attack
                osc1Envelope.gain.linearRampToValueAtTime(env1Sustain, osc1DecayTime); // Decay to sustain
                
                // OSC 2 ADSR envelope (separate OSC 2 ADSR)
                const osc2AttackTime = currentTime + env2Attack;
                const osc2DecayTime = osc2AttackTime + env2Decay;
                
                osc2Envelope.gain.setValueAtTime(0, currentTime);
                osc2Envelope.gain.linearRampToValueAtTime(1, osc2AttackTime); // Attack
                osc2Envelope.gain.linearRampToValueAtTime(env2Sustain, osc2DecayTime); // Decay to sustain
                
                osc1.start();
                osc2.start();
                
                // If we applied piano-locked settings, restore the original synthesizer state immediately
                if (originalSettings) {
                    console.log('🎹 Restoring original settings (no UI change)');
                    
                    // Restore from the stored original settings
                    Object.assign(this.oscillators.osc1, originalSettings.osc1);
                    Object.assign(this.oscillators.osc2, originalSettings.osc2);
                    Object.assign(this.envelope, originalSettings.envelope);
                    Object.assign(this.osc2Envelope, originalSettings.osc2Envelope);
                    Object.assign(this.reverb, originalSettings.reverb);
                    Object.assign(this.panning, originalSettings.panning);
                    this.volume = originalSettings.volume;
                    this.masterVolume = originalSettings.masterVolume;
                    
                    // Update audio context nodes if available
                    if (this.wetGainNode && this.dryGainNode) {
                        this.wetGainNode.gain.value = this.reverb.wet;
                        this.dryGainNode.gain.value = this.masterVolume;
                    }
                    if (this.reverbFilterNode) {
                        this.reverbFilterNode.frequency.value = this.reverb.filterCutoff;
                    }
                    if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                    if (this.gainNode) {
                        this.gainNode.gain.value = this.volume * this.masterVolume;
                    }
                }
                
                // Auto-release logic based on source type and sustain state
                let releaseTimeout = null;
                
                if (sourceType === 'chord' || sourceType === 'bass') {
                    // Chord and Bass modes: always use HOLD duration, even if sustain is active
                    const holdSelect = document.getElementById('universalHold') || document.getElementById('chordHold');
                    const holdValue = holdSelect ? holdSelect.value : 'bar:1';
                    const [kind, valStr] = String(holdValue).split(':');
                    const n = Math.max(1, parseInt(valStr || '1', 10));
                    
                    // Calculate hold duration in milliseconds
                    const bpmEl = document.getElementById('universalBpm');
                    const bpm = bpmEl ? parseInt(bpmEl.value) : 120;
                    const beatMs = 60000 / Math.max(20, bpm);
                    
                    // Get time signature
                    const timeSignatureEl = document.getElementById('universalTimeSignature');
                    const timeSignature = timeSignatureEl ? timeSignatureEl.value : '4/4';
                    const [beatsPerBar] = timeSignature.split('/').map(Number);
                    const barMs = beatMs * (beatsPerBar || 4);
                    // Enforce minimum hold = 1/8 note regardless of time signature
                    const quantMinMs = beatMs * 0.5;
                    const baseHoldMs = (kind === 'beat') ? n * beatMs : n * barMs;
                    const holdMs = Math.max(quantMinMs, baseHoldMs);
                    
                    releaseTimeout = setTimeout(() => {
                        this.stopFrequency(frequency, safeElement, sourceType);
                    }, holdMs);
                    
                    console.log(`[${sourceType.toUpperCase()}] Auto-release scheduled in ${holdMs}ms (${holdValue})`);
                    
                } else if (!this._sustainActive && sourceType !== 'arp') {
                    // Other modes: release at end of decay if sustain not active
                    const endOfDecayTime = Math.max(osc1DecayTime, osc2DecayTime);
                    const releaseDelayMs = Math.max(0, (endOfDecayTime - currentTime) * 1000);
                    releaseTimeout = setTimeout(() => {
                        this.stopFrequency(frequency, safeElement, sourceType);
                    }, releaseDelayMs);
                }

                // Store oscillator data along with the exact ADSR values used at note start
                oscillatorPool.set(frequency, { 
                    osc1, 
                    osc2, 
                    osc1Envelope,
                    osc2Envelope,
                    finalMixer,
                    panner,
                    osc1Gain,
                    osc2Gain,
                    releaseTimeout,
                    isGlobalBass: (sourceType === 'bass'),
                    element: safeElement,
                    startTime: currentTime,
                    env1: {
                        attack: env1Attack,
                        decay: env1Decay,
                        sustain: env1Sustain,
                        release: env1Release
                    },
                    env2: {
                        attack: env2Attack,
                        decay: env2Decay,
                        sustain: env2Sustain,
                        release: env2Release
                    }
                });
                if (safeElement) {
                    safeElement.classList.add('active');
                    const core = safeElement.querySelector('.string-core');
                    if (core) {
                        const stepIndex = parseInt(safeElement.dataset.noteIndex||'0',10);
                        const period = this.computeVibrationPeriod(frequency, stepIndex);
                        core.style.setProperty('--vib-period', period + 'ms');
                        core.classList.add('vibrating');
                    }
                }
            }

            stopFrequency(frequency, element, sourceType = 'default') {
                // Select appropriate oscillator pool based on source type
                let oscillatorPool;
                switch (sourceType) {
                    case 'strum':
                        oscillatorPool = this.activeStrumOscillators;
                        break;
                    case 'chord':
                        oscillatorPool = this.activeChordOscillators;
                        break;
                    case 'arp':
                        oscillatorPool = this.activeArpOscillators;
                        break;
                    case 'bass':
                        oscillatorPool = this.activeBassOscillators;
                        break;
                    default:
                        oscillatorPool = this.activeOscillators;
                }
                
                const osc = oscillatorPool.get(frequency);
                if (!osc) return;
                
                const { osc1, osc2, osc1Envelope, osc2Envelope, releaseTimeout, env1, env2 } = osc;
                
                // Clear auto-release timeout
                if (releaseTimeout) {
                    clearTimeout(releaseTimeout);
                }
                
                // Remove from active oscillators immediately to prevent overlap
                oscillatorPool.delete(frequency);
                
                try {
                    const currentTime = this.audioContext.currentTime;
                    
                    // Apply OSC 1 release envelope
                    osc1Envelope.gain.cancelScheduledValues(currentTime);
                    osc1Envelope.gain.setValueAtTime(osc1Envelope.gain.value, currentTime);
                    osc1Envelope.gain.linearRampToValueAtTime(0, currentTime + Math.max(0, env1?.release ?? this.envelope.release));
                    
                    // Apply OSC 2 release envelope
                    osc2Envelope.gain.cancelScheduledValues(currentTime);
                    osc2Envelope.gain.setValueAtTime(osc2Envelope.gain.value, currentTime);
                    osc2Envelope.gain.linearRampToValueAtTime(0, currentTime + Math.max(0, env2?.release ?? this.osc2Envelope.release));
                    
                    // Stop oscillators after the longer of the two release times (based on the values used at note start)
                    const maxReleaseTime = Math.max(Math.max(0, env1?.release ?? this.envelope.release), Math.max(0, env2?.release ?? this.osc2Envelope.release));
                    osc1.stop(currentTime + maxReleaseTime);
                    osc2.stop(currentTime + maxReleaseTime);
                    
                    
                    console.log('Note stopped with', maxReleaseTime, 'second release time');
                    
                    // Clean up visual indicator
                    setTimeout(() => {
                        if (element) {
                            element.classList.remove('active');
                            const core = element.querySelector('.string-core');
                            if (core) core.classList.remove('vibrating');
                        }
                    }, maxReleaseTime * 1000 + 50);
                } catch (error) {
                    console.warn('Error stopping oscillator:', error);
                    if (element) {
                        element.classList.remove('active');
                        const core = element.querySelector('.string-core');
                        if (core) core.classList.remove('vibrating');
                    }
                }
            }

            stopAllStrings() {
                // Stop across all oscillator pools with the correct source type
                try {
                    const pools = [
                        { pool: this.activeOscillators, type: 'default' },
                        { pool: this.activeStrumOscillators, type: 'strum' },
                        { pool: this.activeChordOscillators, type: 'chord' },
                        { pool: this.activeArpOscillators, type: 'arp' },
                        { pool: this.activeBassOscillators, type: 'bass' }
                    ];
                    for (const { pool, type } of pools) {
                        if (!pool || pool.size === 0) continue;
                        // Snapshot keys to avoid mutation during iteration
                        const keys = Array.from(pool.keys());
                        for (const k of keys) {
                            try {
                                const info = pool.get(k);
                                // Preserve global bass if flagged
                                if (info && info.isGlobalBass) continue;
                                this.stopFrequency(k, info?.element || null, type);
                            } catch (e) {
                                console.warn('stopAllStrings: error stopping', type, k, e);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('stopAllStrings: pooled stop failed, falling back', e);
                    try { this.stopAllActiveNotes(); } catch(_) {}
                }
                // Clear per-gesture tracking
                this.triggeredStrings.clear();
                // Clear held-bass references as well
                try { this._heldBassVoice = null; this._heldBassLiveFreq = null; this._heldBassVoiceKey = null; } catch(_){ }
            }

            // Tutorial System
            initTutorial() {
                this.tutorialStep = 0;
                this.tutorialSteps = [
                    { title: "Hi! Let's make music", text: "Tap the big + to add a chord. We'll build it together.", highlight: "#createNewChordBtn" },
                    { title: "Pick your tuning (EDO)", text: "EDO = how many steps in an octave. Try 12, 19, or 24.", highlight: "#edoQuickInput" },
                    { title: "Add notes on the top row", text: "Click the white/black circles or colored dots to add sounds. Pick at least two.", highlight: "#rootGrid" },
                    { title: "Strum your chord", text: "Click and drag up/down the new box to hear it. Numbers 1–0 also trigger boxes!", highlight: "#extensionColumns" },
                    { title: "Transpose everything", text: "Use the ▲ ▼ on the left of the keyboard or press + / - on your keys.", highlight: ".transpose-controls-left" },
                    { title: "Try ARP mode", text: "Click ARP on the CHORD/ARP toggle, set a BPM and Quant, then hold a chord box to hear a pattern.", highlight: "#modeChordArp" },
                    { title: "Change your sound", text: "Open OSCILLATORS and try Sine/Saw/Square, then tweak ADSR.", highlight: "#oscillatorsSection" },
                    { title: "Add space & motion", text: "Open EFFECTS to add reverb or make the sound move left-right.", highlight: "#effectsSection" },
                    { title: "Type a sequence", text: "Click SEQ and type chords (like I IV V or C F G).", highlight: "#openTextChordParserBtn" },
                    { title: "Save your song", text: "💾 saves the full .XEN session; ⬇️ also exports .XEN.", highlight: "#bottomExportOMGBtn" },
                    { title: "You're ready!", text: "Keep adding chords, strum, and experiment. Music rewards curiosity.", highlight: null }
                ];

                document.getElementById('tutorialButton').addEventListener('click', () => {
                    this.startTutorial();
                });

                document.getElementById('tutorialNext').addEventListener('click', () => {
                    this.nextTutorialStep();
                });

                document.getElementById('tutorialPrev').addEventListener('click', () => {
                    this.prevTutorialStep();
                });

                document.getElementById('tutorialSkip').addEventListener('click', () => {
                    this.endTutorial();
                });

                // Initialize escape mechanisms
                this.initTutorialEscapes();
            }

            startTutorial() {
                this.tutorialStep = 0;
                document.getElementById('tutorialOverlay').style.display = 'block';
                this.showTutorialStep();
                this.greyOutAll();
                
                // Add escape mechanisms
                document.addEventListener('keydown', this.tutorialEscapeHandler);
            }

            showTutorialStep() {
                const step = this.tutorialSteps[this.tutorialStep];
                document.getElementById('tutorialTitle').textContent = step.title;
                document.getElementById('tutorialText').textContent = step.text;

                // Update button states
                document.getElementById('tutorialPrev').style.display = this.tutorialStep > 0 ? 'inline-block' : 'none';
                document.getElementById('tutorialNext').textContent = this.tutorialStep < this.tutorialSteps.length - 1 ? 'Next' : 'Finish';

                // Position tutorial box
                this.positionTutorialBox(step.highlight);

                // Highlight current element
                this.highlightElement(step.highlight);
            }

            positionTutorialBox(selector) {
                const tutorialBox = document.getElementById('tutorialBox');
                
                if (selector) {
                    const element = document.querySelector(selector);
                    if (element) {
                        const rect = element.getBoundingClientRect();
                        const boxWidth = 400;
                        const boxHeight = 250;
                        
                        // Try to position next to the element
                        let left = rect.right + 20;
                        let top = rect.top;
                        
                        // Keep box on screen
                        if (left + boxWidth > window.innerWidth) {
                            left = rect.left - boxWidth - 20;
                        }
                        if (left < 20) {
                            left = 20;
                        }
                        
                        if (top + boxHeight > window.innerHeight) {
                            top = window.innerHeight - boxHeight - 20;
                        }
                        if (top < 20) {
                            top = 20;
                        }
                        
                        tutorialBox.style.left = `${left}px`;
                        tutorialBox.style.top = `${top}px`;
                        tutorialBox.style.transform = 'none';
                    } else {
                        // Center if element not found
                        tutorialBox.style.left = '50%';
                        tutorialBox.style.top = '50%';
                        tutorialBox.style.transform = 'translate(-50%, -50%)';
                    }
                } else {
                    // Center the box
                    tutorialBox.style.left = '50%';
                    tutorialBox.style.top = '50%';
                    tutorialBox.style.transform = 'translate(-50%, -50%)';
                }
            }

            highlightElement(selector) {
                // Remove previous highlights
                document.querySelectorAll('.tutorial-highlight').forEach(el => {
                    el.classList.remove('tutorial-highlight');
                    el.style.position = '';
                    el.style.zIndex = '';
                    el.style.filter = '';
                });

                if (selector) {
                    const element = document.querySelector(selector);
                    if (element) {
                        element.classList.add('tutorial-highlight');
                        element.style.position = 'relative';
                        element.style.zIndex = '2100';
                        element.style.filter = 'brightness(1.5) contrast(1.2)';
                    }
                }
            }

            greyOutAll() {
                // Create overlay instead of using filter to avoid breaking highlighting
                const overlay = document.createElement('div');
                overlay.id = 'tutorialGreyOverlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 1900;
                    pointer-events: none;
                `;
                document.body.appendChild(overlay);
            }

            ungreyAll() {
                const overlay = document.getElementById('tutorialGreyOverlay');
                if (overlay) {
                    overlay.remove();
                }
                // Also remove any filters that might have been applied
                document.body.style.filter = '';
            }

            nextTutorialStep() {
                if (this.tutorialStep < this.tutorialSteps.length - 1) {
                    this.tutorialStep++;
                    this.showTutorialStep();
                } else {
                    this.endTutorial();
                }
            }

            prevTutorialStep() {
                if (this.tutorialStep > 0) {
                    this.tutorialStep--;
                    this.showTutorialStep();
                }
            }

            endTutorial() {
                document.getElementById('tutorialOverlay').style.display = 'none';
                this.ungreyAll();
                this.highlightElement(null);
                
                // Remove any event listeners that might interfere
                document.removeEventListener('keydown', this.tutorialEscapeHandler);
            }

            // Add escape key handler and click-to-close functionality
            initTutorialEscapes() {
                // ESC key to close tutorial
                this.tutorialEscapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.endTutorial();
                    }
                };

                // Click outside tutorial box to close
                document.getElementById('tutorialOverlay').addEventListener('click', (e) => {
                    if (e.target.id === 'tutorialOverlay') {
                        this.endTutorial();
                    }
                });
            }

            // Random Dice System
            initRandomDice() {
                document.getElementById('randomDiceButton').addEventListener('click', () => {
                    this.randomizeEverything();
                });
            }

            randomizeEverything() {
                // 🎹 PROTECTION: Store all piano-locked settings AND preloaded presets before randomization
                const protectedPianoLocks = new Map();
                const protectedPresets = new Map();
                
                if (this.pianoLockedChords && this.pianoLockedChords.size > 0) {
                    
                    // Create deep copies of all piano lock data
                    this.pianoLockedChords.forEach((lockData, key) => {
                        protectedPianoLocks.set(key, {
                            ...lockData,
                            presetId: lockData.presetId, // Preserve preset ID
                            osc1: { ...lockData.osc1 },
                            osc2: { ...lockData.osc2 },
                            envelope: { ...lockData.envelope },
                            osc2Envelope: { ...lockData.osc2Envelope },
                            reverb: { ...lockData.reverb },
                            panning: { ...lockData.panning },
                            volume: { ...lockData.volume }
                        });
                    });
                    
                    // Also protect preloaded presets
                    this.preloadedPresets.forEach((presetData, presetId) => {
                        protectedPresets.set(presetId, {
                            ...presetData,
                            osc1: { ...presetData.osc1 },
                            osc2: { ...presetData.osc2 },
                            envelope: { ...presetData.envelope },
                            osc2Envelope: { ...presetData.osc2Envelope },
                            reverb: { ...presetData.reverb },
                            panning: { ...presetData.panning },
                            volume: { ...presetData.volume }
                        });
                    });
                } else {
                    
                }
                
                // Animate the dice button
                const diceBtn = document.getElementById('randomDiceButton');
                diceBtn.style.transform = 'rotate(720deg)';
                setTimeout(() => {
                    diceBtn.style.transform = '';
                }, 600);

                // Focus purely on oscillator sound design - no tuning/chord changes
                this.randomizeOscillator(1); // STRUM 1
                this.randomizeOscillator(2); // STRUM 2
                this.randomizeInstrument('chord'); // CHORD/ARP OSC 3
                this.randomizeInstrument('arp'); // ARP OSC 3 (separate instance)
                // BASS (OSC 4) is NOT randomized by DICE per user requirements

                // Effects are NEVER randomized by dice (per requirements)
                // this.randomizeEffects(); // disabled

                // 🎹 RESTORE: Put back all piano-locked settings and presets after randomization
                if (protectedPianoLocks.size > 0) {
                    this.pianoLockedChords = protectedPianoLocks;
                    
                    // Restore preloaded presets
                    this.preloadedPresets = protectedPresets;
                    
                    // Also restore the UI button states for piano locks
                    setTimeout(() => {
                        this.restorePianoLockStates();
                        // Warm all currently piano-locked columns (use markers or backend flags)
                        try {
                            document.querySelectorAll('.extension-column.piano-locked-col').forEach(col => { try { this.preloadPianoLockedChord(col); } catch(_){} });
                            document.querySelectorAll('.extension-column').forEach(col => {
                                try {
                                    const hdr = col.querySelector('.extension-header');
                                    const cd = (typeof this.getChordDataFromColumn === 'function') ? this.getChordDataFromColumn(col, hdr) : null;
                                    if (cd && cd.isPianoLocked) { try { this.preloadPianoLockedChord(col); } catch(_){} }
                                } catch(_){}
                            });
                        } catch(_) {}
                    }, 100);
                }
            }

            // Create a tiny, near-silent tick through the full chain to wake up the audio graph/IR
            async warmUpAudioGraph(durationMs = 18) {
                try {
                    const ok = await this.ensureAudioContext();
                    if (!ok || !this.audioContext || !this.gainNode) return;
                    // Short sine pip at -60dB to exercise convolver/panner/gain path without being audible
                    const osc = this.audioContext.createOscillator();
                    const g = this.audioContext.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, this.audioContext.currentTime);
                    g.gain.setValueAtTime(0.001, this.audioContext.currentTime); // ~-60 dB
                    osc.connect(g);
                    g.connect(this.gainNode);
                    const t0 = this.audioContext.currentTime;
                    osc.start(t0);
                    osc.stop(t0 + Math.max(0.001, durationMs/1000));
                } catch(_) { /* ignore */ }
            }

            // Preload/warm a piano-locked chord's preset and current notes for instant playback
            async preloadPianoLockedChord(columnElement) {
                if (!columnElement) return;
                try {
                    const relSteps = this.getChordStepsForColumn(columnElement);
                    const chordData = { intervals: Array.isArray(relSteps) ? relSteps : [] };
                    const pianoLockedData = this.findPianoLockData(chordData);
                    if (!pianoLockedData) return;
                    // Build a warmup key that changes with preset and transpositions
                    const lt = String(+columnElement.dataset.localTranspose || 0);
                    const gt = String(this.transposeDelta || 0);
                    const warmKey = `${pianoLockedData.lockKey || pianoLockedData.presetId}:${lt}:${gt}`;
                    if (this.preloadedChordWarmups.has(warmKey)) return; // already warm
                    this.preloadedChordWarmups.add(warmKey);

                    // Snapshot current synth state, apply preset briefly, warm audio, then restore
                    const originalSettings = {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 },
                        envelope: { ...this.envelope },
                        osc2Envelope: { ...this.osc2Envelope },
                        volume: this.volume,
                        masterVolume: this.masterVolume
                    };
                    this.applyPianoLockedSettings(pianoLockedData);
                    await this.warmUpAudioGraph(18);
                    // Touch current string frequencies to ensure datasets are present (no audio triggered)
                    try {
                        const strings = columnElement.querySelectorAll('.string');
                        strings.forEach(el => { void el.dataset.frequency; });
                    } catch(_) { }
                    // Restore original state (no UI change)
                    Object.assign(this.oscillators.osc1, originalSettings.osc1);
                    Object.assign(this.oscillators.osc2, originalSettings.osc2);
                    Object.assign(this.envelope, originalSettings.envelope);
                    Object.assign(this.osc2Envelope, originalSettings.osc2Envelope);
                    this.volume = originalSettings.volume;
                    this.masterVolume = originalSettings.masterVolume;
                    // Reverb/panning untouched
                    if (this.gainNode) this.gainNode.gain.value = this.volume * this.masterVolume;
                } catch(_) { /* no-op */ }
            }

            randomizeOscillator(oscNum) {
                const waveforms = ['sine', 'sawtooth', 'square', 'triangle', 'pulse', 'fullrect', 'halfrect', 'trapezoid', 'parabolic', 'stair'];
                const randomWave = waveforms[Math.floor(Math.random() * waveforms.length)];
                
                // Set waveform by updating the buttons
                const waveButtons = document.querySelectorAll(`[data-wave][data-osc="${oscNum}"]`);
                waveButtons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.wave === randomWave) {
                        btn.classList.add('active');
                    }
                });
                this.oscillators[`osc${oscNum}`].type = randomWave;
                const pwContainer = document.querySelector(`.pulse-width-container[data-osc="${oscNum}"]`);
                if (randomWave === 'pulse') {
                    const pw = 5 + Math.floor(Math.random() * 90);
                    const pwSlider = document.getElementById(`osc${oscNum}PulseWidth`);
                    const pwValue = document.getElementById(`osc${oscNum}PulseWidthValue`);
                    this.oscillators[`osc${oscNum}`].pulseWidth = pw / 100;
                    if (pwSlider) pwSlider.value = String(pw);
                    if (pwValue) pwValue.textContent = `${pw}%`;
                    if (pwContainer) pwContainer.style.display = 'block';
                } else if (pwContainer) {
                    pwContainer.style.display = 'none';
                }

                // Skip volume, coarse, fine, octave randomization to maintain tuning
                // Only randomize ADSR controls within their actual slider ranges
                
                // Use correct slider IDs - OSC1 has no prefix, OSC2 has "osc2" prefix
                const attackSliderID = oscNum === 1 ? 'attackSlider' : 'osc2AttackSlider';
                const decaySliderID = oscNum === 1 ? 'decaySlider' : 'osc2DecaySlider';
                const sustainSliderID = oscNum === 1 ? 'sustainSlider' : 'osc2SustainSlider';
                const releaseSliderID = oscNum === 1 ? 'releaseSlider' : 'osc2ReleaseSlider';
                
                const attackValueID = oscNum === 1 ? 'attackValue' : 'osc2AttackValue';
                const decayValueID = oscNum === 1 ? 'decayValue' : 'osc2DecayValue';
                const sustainValueID = oscNum === 1 ? 'sustainValue' : 'osc2SustainValue';
                const releaseValueID = oscNum === 1 ? 'releaseValue' : 'osc2ReleaseValue';

                const attackSlider = document.getElementById(attackSliderID);
                const decaySlider = document.getElementById(decaySliderID);
                const sustainSlider = document.getElementById(sustainSliderID);
                const releaseSlider = document.getElementById(releaseSliderID);
                
                // Get the actual slider min/max values for proper randomization
                let attackMin = 1; // default minimum
                let attackMax = 1000; // default for OSC1
                if (attackSlider) {
                    attackMin = Math.max(1, parseInt(attackSlider.min)); // Ensure minimum 1ms
                    attackMax = parseInt(attackSlider.max);
                }
                
                // Randomize ADSR parameters
                // Requirement: limit ATTACK randomization to 0–200ms (keep slider max at 1000ms)
                const attackRandomMinMs = 0;
                const attackRandomMaxMs = Math.min(200, attackMax);
                const attack = attackRandomMinMs + Math.random() * (attackRandomMaxMs - attackRandomMinMs);
                const decay = Math.random() * 300; // 0-300ms
                const sustain = Math.random() * 0.5; // 0-50%
                const release = Math.random() * 1000; // 0-1000ms (cap)

                if (attackSlider) {
                    attackSlider.value = attack;
                    const attackValue = document.getElementById(attackValueID);
                    if (attackValue) attackValue.textContent = `${Math.round(attack)}ms`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.attack = attack / 1000;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.attack = attack / 1000;
                    }
                    console.log(`?? OSC${oscNum} Attack set to ${Math.round(attack)}ms`);
                }
                if (decaySlider) {
                    decaySlider.value = decay;
                    const decayValue = document.getElementById(decayValueID);
                    if (decayValue) decayValue.textContent = `${Math.round(decay)}ms`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.decay = decay / 1000;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.decay = decay / 1000;
                    }
                    console.log(`?? OSC${oscNum} Decay set to ${Math.round(decay)}ms`);
                }
                if (sustainSlider) {
                    sustainSlider.value = sustain * 100;
                    const sustainValue = document.getElementById(sustainValueID);
                    if (sustainValue) sustainValue.textContent = `${Math.round(sustain * 100)}%`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.sustain = sustain;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.sustain = sustain;
                    }
                    console.log(`?? OSC${oscNum} Sustain set to ${Math.round(sustain * 100)}%`);
                }
                if (releaseSlider) {
                    releaseSlider.value = release;
                    const releaseValue = document.getElementById(releaseValueID);
                    if (releaseValue) releaseValue.textContent = `${Math.round(release)}ms`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.release = Math.min(1, release / 1000);
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.release = Math.min(1, release / 1000);
                    }
                    console.log(`?? OSC${oscNum} Release set to ${Math.round(release)}ms`);
                }

                // Update ADSR values in the internal structure (backup)
                if (this.adsrSettings && this.adsrSettings[`osc${oscNum}`]) {
                    this.adsrSettings[`osc${oscNum}`].attack = attack / 1000;
                    this.adsrSettings[`osc${oscNum}`].decay = decay / 1000;
                    this.adsrSettings[`osc${oscNum}`].sustain = sustain;
                    this.adsrSettings[`osc${oscNum}`].release = release / 1000;
                }
                
                console.log(`🎲 Randomized OSC${oscNum}: ${randomWave} wave, A:${Math.round(attack)} D:${Math.round(decay)} S:${Math.round(sustain*100)}% R:${Math.round(release)}`);
            }

            randomizeInstrument(instName) {
                if (!this.instruments[instName]) {
                    console.warn(`No instrument configuration found for: ${instName}`);
                    return;
                }

                const waveforms = ['sine', 'sawtooth', 'square', 'triangle', 'pulse', 'fullrect', 'halfrect', 'trapezoid', 'parabolic', 'stair'];
                const randomWave = waveforms[Math.floor(Math.random() * waveforms.length)];
                
                // Set waveform by updating the buttons and internal state
                const waveButtons = document.querySelectorAll(`[data-wave][data-inst="${instName}"]`);
                waveButtons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.wave === randomWave) {
                        btn.classList.add('active');
                    }
                });
                this.instruments[instName].osc.type = randomWave;

                // Handle pulse width for pulse waves
                const pwContainerId = `${instName}PulseWidthContainer`;
                const pwContainer = document.getElementById(pwContainerId);
                if (randomWave === 'pulse') {
                    const pw = 5 + Math.floor(Math.random() * 90);
                    const pwSlider = document.getElementById(`${instName}PulseWidth`);
                    const pwValue = document.getElementById(`${instName}PulseWidthValue`);
                    this.instruments[instName].osc.pulseWidth = pw / 100;
                    if (pwSlider) pwSlider.value = String(pw);
                    if (pwValue) pwValue.textContent = `${pw}%`;
                    if (pwContainer) pwContainer.style.display = 'block';
                } else if (pwContainer) {
                    pwContainer.style.display = 'none';
                }

                // Randomize ADSR parameters
                const attack = Math.random() * 200; // 0-200ms
                const decay = Math.random() * 300; // 0-300ms
                const sustain = Math.random() * 0.5; // 0-50%
                const release = Math.random() * 1000; // 0-1000ms

                // Update UI sliders and internal state
                const attackSlider = document.getElementById(`${instName}AttackSlider`);
                const decaySlider = document.getElementById(`${instName}DecaySlider`);
                const sustainSlider = document.getElementById(`${instName}SustainSlider`);
                const releaseSlider = document.getElementById(`${instName}ReleaseSlider`);
                
                if (attackSlider) {
                    attackSlider.value = attack;
                    const attackValue = document.getElementById(`${instName}AttackValue`);
                    if (attackValue) attackValue.textContent = `${Math.round(attack)}ms`;
                    this.instruments[instName].env.attack = attack / 1000;
                }
                if (decaySlider) {
                    decaySlider.value = decay;
                    const decayValue = document.getElementById(`${instName}DecayValue`);
                    if (decayValue) decayValue.textContent = `${Math.round(decay)}ms`;
                    this.instruments[instName].env.decay = decay / 1000;
                }
                if (sustainSlider) {
                    sustainSlider.value = sustain * 100;
                    const sustainValue = document.getElementById(`${instName}SustainValue`);
                    if (sustainValue) sustainValue.textContent = `${Math.round(sustain * 100)}%`;
                    this.instruments[instName].env.sustain = sustain;
                }
                if (releaseSlider) {
                    releaseSlider.value = release;
                    const releaseValue = document.getElementById(`${instName}ReleaseValue`);
                    if (releaseValue) releaseValue.textContent = `${Math.round(release)}ms`;
                    this.instruments[instName].env.release = release / 1000;
                }

                console.log(`🎲 Randomized ${instName.toUpperCase()}: ${randomWave} wave, A:${Math.round(attack)} D:${Math.round(decay)} S:${Math.round(sustain*100)}% R:${Math.round(release)}`);
            }

            randomizeEffects() {
                // Random reverb settings with wider ranges
                const reverbWet = Math.random() * 0.9; // 0-90% wet
                const reverbDecay = 0.3 + Math.random() * 5.7; // 0.3-6 seconds
                const reverbCut = 800 + Math.random() * 19200; // 800Hz-20kHz

                const reverbWetSlider = document.getElementById('reverbWet');
                const reverbDecaySlider = document.getElementById('reverbDecay');
                const reverbCutSlider = document.getElementById('reverbFilterCutoff');

                if (reverbWetSlider) {
                    reverbWetSlider.value = reverbWet * 10; // slider is 0-10 scale
                    if (this.reverb) this.reverb.wet = reverbWet;
                    if (this.wetGainNode && this.dryGainNode) {
                        this.wetGainNode.gain.value = reverbWet;
                        this.dryGainNode.gain.value = this.masterVolume;
                    }
                    if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                    const reverbWetValue = document.getElementById('reverbWetValue');
                    if (reverbWetValue) reverbWetValue.textContent = `${Math.round(reverbWet * 100)}%`;
                }
                if (reverbDecaySlider) {
                    reverbDecaySlider.value = reverbDecay;
                    if (this.reverb) this.reverb.decay = reverbDecay;
                    const reverbDecayValue = document.getElementById('reverbDecayValue');
                    if (reverbDecayValue) reverbDecayValue.textContent = `${reverbDecay.toFixed(1)}s`;
                }
                if (reverbCutSlider) {
                    reverbCutSlider.value = reverbCut;
                    if (this.reverbFilterNode) this.reverbFilterNode.frequency.value = reverbCut;
                    const reverbCutValue = document.getElementById('reverbFilterCutoffValue');
                    if (reverbCutValue) reverbCutValue.textContent = `${Math.round(reverbCut)}Hz`;
                }

                // Random panning mode and width
                const panModes = ['center', 'random', 'frequency', 'rotating', 'alternating', 'wide'];
                const panMode = panModes[Math.floor(Math.random() * panModes.length)];
                const panWidth = 0.2 + Math.random() * 0.8; // 20-100% width
                
                const panSelector = document.getElementById('panningMode');
                const panWidthSlider = document.getElementById('panningWidth');
                
                if (panSelector) {
                    panSelector.value = panMode;
                    this.panning.mode = panMode;
                }
                if (panWidthSlider) {
                    panWidthSlider.value = panWidth * 100;
                    this.panning.width = panWidth;
                    const panWidthValue = document.getElementById('panningWidthValue');
                    if (panWidthValue) panWidthValue.textContent = `${Math.round(panWidth * 100)}%`;
                }
                
                console.log(`??? Randomized effects: ${panMode} panning (${Math.round(panWidth * 100)}%), ${reverbDecay.toFixed(1)}s reverb`);
            }
        }

        // Initialize the instrument when the page loads
        let omnichord;
    window.addEventListener('load', () => {
            // === BPM-quantized time controls & editable ms labels ===
            window.TimeGrid = {
                // Musical divisions including triplets and quintuple subdivision (1/5 bar)
                divisions: [
                    '1/32','1/16','1/8','1/8T','1/4','1/4T','1/5bar','1/2','1','2bar','4bar','8bar'
                ],
                // Convert a division key to milliseconds for the current bpm
                toMs(div, bpm){
                    const beatMs = 60000 / Math.max(1, bpm||120);
                    let barMs;
                    try {
                        const tsEl = document.getElementById('universalTimeSignature');
                        const raw = tsEl ? String(tsEl.value||'4/4') : '4/4';
                        const [n,d] = raw.split('/').map(v=>parseInt(v,10));
                        const tsNum = (Number.isFinite(n) && n>0) ? n : 4;
                        const tsDen = (Number.isFinite(d) && d>0) ? d : 4;
                        const beatsPerBar = (tsNum * 4) / tsDen;
                        barMs = beatMs * beatsPerBar;
                    } catch(_) { barMs = beatMs * 4; }
                    switch(div){
                        case '1/32': return beatMs/8;
                        case '1/16': return beatMs/4;
                        case '1/8T': return (beatMs/3); // triplet 1/8 over beat
                        case '1/8': return beatMs/2;
                        case '1/4T': return (2*beatMs/3);
                        case '1/4': return beatMs;
                        case '1/5bar': return barMs/5;
                        case '1/2': return 2*beatMs;
                        case '1': return 4*beatMs;
                        case '2bar': return 2*barMs;
                        case '4bar': return 4*barMs;
                        case '8bar': return 8*barMs;
                        default: return Math.max(1, Number(div)||300);
                    }
                },
                nearestDivision(ms, bpm){
                    let best = '1/16';
                    let bestErr = Infinity;
                    for (const d of this.divisions){
                        const t = this.toMs(d, bpm);
                        const err = Math.abs(t - ms);
                        if (err < bestErr){ bestErr = err; best = d; }
                    }
                    return best;
                }
            };
            function getBpm(){
                const main=document.getElementById('universalBpm');
                if (main) return Number(main.value)||120;
                const mini=document.getElementById('drumBpmMini');
                return mini? (Number(mini.value)||120) : 120;
            }
            function formatMs(ms){
                if (ms >= 1000) return `${(ms/1000).toFixed(ms%1000?2:1)}s`;
                return `${Math.round(ms)}ms`;
            }
            function parseMsText(text){
                if (!text) return null;
                const t = String(text).trim().toLowerCase();
                if (t.endsWith('ms')) return Number(t.replace('ms','').trim());
                if (t.endsWith('s')) return Number(t.replace('s','').trim())*1000;
                const n = Number(t);
                return Number.isFinite(n)? n : null;
            }
            // Track Shift globally so users can press it anytime to get ms-precision dragging
            if (!window.__timeGridShiftHooked){
                window.__timeGridShiftHooked = true;
                window.__timeGridShiftPressed = false;
                window.addEventListener('keydown', (e)=>{ if (e.key === 'Shift') window.__timeGridShiftPressed = true; });
                window.addEventListener('keyup',   (e)=>{ if (e.key === 'Shift') window.__timeGridShiftPressed = false; });
                window.addEventListener('blur', ()=>{ window.__timeGridShiftPressed = false; });
            }
            // Map glide slider position (0..1000) to ms: 0=1/32, 500=1 bar, 1000=8 bars
            function glidePosToMs(pos, bpm){
                pos = Math.max(0, Math.min(1000, Number(pos)||0));
                const bar = window.TimeGrid.toMs('1', bpm);
                const leftMs = window.TimeGrid.toMs('1/32', bpm);
                const rightMs = window.TimeGrid.toMs('8bar', bpm);
                if (pos === 500) return bar;
                if (pos < 500){
                    const t = pos/500; // 0..1
                    // geometric-ish taper towards shorter values for better resolution
                    const k = Math.pow(t, 1.6);
                    return leftMs + (bar - leftMs) * k;
                } else {
                    const t = (pos-500)/500; // 0..1
                    const k = Math.pow(t, 1.2);
                    return bar + (rightMs - bar) * k;
                }
            }
            function msToGlidePos(ms, bpm){
                const bar = window.TimeGrid.toMs('1', bpm);
                const leftMs = window.TimeGrid.toMs('1/32', bpm);
                const rightMs = window.TimeGrid.toMs('8bar', bpm);
                ms = Math.max(leftMs, Math.min(rightMs, Number(ms)||bar));
                if (ms === bar) return 500;
                if (ms < bar){
                    const t = (ms - leftMs) / (bar - leftMs);
                    const k = Math.pow(Math.max(0, Math.min(1, t)), 1/1.6);
                    return Math.round(k * 500);
                } else {
                    const t = (ms - bar) / (rightMs - bar);
                    const k = Math.pow(Math.max(0, Math.min(1, t)), 1/1.2);
                    return Math.round(500 + k * 500);
                }
            }
            function wireQuantizedTimeSlider(sliderId, labelId, opts){
                const slider = document.getElementById(sliderId);
                const label = document.getElementById(labelId);
                if (!slider || !label) return;
                const isGlide = /glide/i.test(sliderId);
                const minMs = isGlide ? window.TimeGrid.toMs('1/32', getBpm()) : (Number(slider.min)||10);
                const maxMs = isGlide ? window.TimeGrid.toMs('8bar', getBpm())  : (Number(slider.max)||120000);
                let shifting = false; // deprecated local flag; kept for pointer events
                let recursing = false;
                // optional sticky division memory (per control)
                const stickyKey = `div@${labelId}`;
                let stickyDiv = null;
                // if user typed an explicit ms value, keep it until they type a division or drag without Shift
                let manualMs = false;
                const snap = (bypassQuantize)=>{
                    const bpm = getBpm();
                    let v;
                    if (isGlide){
                        // Interpret slider.value as position 0..1000 and map to ms
                        v = glidePosToMs(Number(slider.value)||500, bpm);
                    } else {
                        v = Number(slider.value)||minMs;
                    }
                    const wantBypass = !!(bypassQuantize || shifting || window.__timeGridShiftPressed || manualMs);
                    if (!wantBypass){
                        // Choose the division nearest to the current slider position
                        const div = window.TimeGrid.nearestDivision(v, bpm);
                        v = Math.min(maxMs, Math.max(minMs, window.TimeGrid.toMs(div, bpm)));
                        if (isGlide){ slider.value = String(msToGlidePos(v, bpm)); } else { slider.value = String(Math.round(v)); }
                        // Persist sticky for glides and other musical time controls
                        stickyDiv = div; try { sessionStorage.setItem(stickyKey, div); } catch(_) {}
                    } else {
                        // Keep raw ms while bypassing quantization
                        v = Math.min(maxMs, Math.max(minMs, v));
                        if (isGlide){ slider.value = String(msToGlidePos(v, bpm)); } else { slider.value = String(Math.round(v)); }
                    }
                    if (label){
                        // For glides, show musical division when quantized; show ms when bypassing
                        if (isGlide && !wantBypass){
                            label.textContent = stickyDiv || window.TimeGrid.nearestDivision(v,bpm);
                        } else {
                            label.textContent = formatMs(v);
                        }
                    }
                    return v;
                };
                // initial render
                try { stickyDiv = sessionStorage.getItem(stickyKey) || null; } catch(_) {}
                // For glides, initialize slider position to reflect current ms value
                if (isGlide){
                    const bpm = getBpm();
                    const initMs = stickyDiv ? window.TimeGrid.toMs(stickyDiv, bpm) : glidePosToMs(Number(slider.value)||500, bpm);
                    slider.value = String(msToGlidePos(initMs, bpm));
                }
                snap(false);
                // respond to slider moves
                slider.addEventListener('input', ()=>{ 
                    if (recursing) return; 
                    const before = Number(slider.value);
                    const bypassNow = (window.__timeGridShiftPressed || shifting || manualMs);
                    // If user is not bypassing now and previously typed ms, return to quantized mode
                    if (!bypassNow && manualMs) manualMs = false;
                    // If Shift currently held, bypass quantization to allow fine ms control
                    const v = snap(bypassNow); 
                    if (Math.round(before) !== Math.round(v)){
                        // propagate quantized value to other listeners
                        recursing = true;
                        setTimeout(()=>{ try{ slider.dispatchEvent(new Event('input', {bubbles:false})); } finally { recursing=false; } }, 0);
                    }
                });
                // shift precision
                slider.addEventListener('pointerdown', (e)=>{ shifting = !!(e.shiftKey || window.__timeGridShiftPressed); });
                slider.addEventListener('pointerup', ()=>{ shifting=false; });
                slider.addEventListener('pointercancel', ()=>{ shifting=false; });
                // respond to BPM changes to resnap value to the grid
                const bpmEl = document.getElementById('universalBpm');
                if (bpmEl){ bpmEl.addEventListener('input', ()=>{ 
                    // When BPM changes, keep ms if user is in manualMs or holding Shift; otherwise re-quantize
                    const v = snap(window.__timeGridShiftPressed || manualMs); 
                    recursing = true; 
                    setTimeout(()=>{ try{ slider.dispatchEvent(new Event('input', {bubbles:false})); } finally { recursing=false; } }, 0);
                }); }
                // label typing (accepts ms or s; for glides, also accept division tokens like 1/2, 2bar)
                label.addEventListener('keydown', (e)=>{
                    if (e.key === 'Enter'){
                        e.preventDefault();
                        const txt = String(label.textContent||'').trim().toLowerCase();
                        // try division tokens first (e.g., 1/2, 2bar)
                        let nextMs = null;
                        if (/(^\d+\/\d+$)|bar$|t$/.test(txt)){
                            stickyDiv = txt.replace(/\s+/g,'');
                            // normalize common aliases
                            const aliases = { '1/1':'1', '1':'1', '1bar':'1', '2bars':'2bar', '4bars':'4bar', '8bars':'8bar' };
                            stickyDiv = aliases[stickyDiv] || stickyDiv;
                            nextMs = window.TimeGrid.toMs(stickyDiv, getBpm());
                            manualMs = false; // return to quantized mode
                        } else {
                            const ms = parseMsText(txt);
                            if (Number.isFinite(ms)) nextMs = ms;
                        }
                        if (Number.isFinite(nextMs)){
                            const clamped = Math.min(maxMs, Math.max(minMs, nextMs));
                            slider.value = String(Math.round(clamped));
                            if (/(^\d+\/\d+$)|bar$|t$/.test(txt)){
                                // Division: quantize and show division (for glides) or ms (others)
                                const v = snap(false);
                                recursing = true; 
                                setTimeout(()=>{ try{ slider.dispatchEvent(new Event('input', {bubbles:false})); } finally { recursing=false; } }, 0);
                            } else {
                                // Explicit ms/s typed: keep raw ms and show ms; notify listeners
                                manualMs = true;
                                if (label) label.textContent = formatMs(clamped);
                                recursing = true;
                                setTimeout(()=>{ try{ slider.dispatchEvent(new Event('input', {bubbles:false})); } finally { recursing=false; } }, 0);
                            }
                        } else { snap(); }
                        label.blur();
                    }
                });
                label.addEventListener('blur', ()=>{ snap(); });
            }
            // Wire key time controls
            try {
                wireQuantizedTimeSlider('chordGlideMs', 'chordGlideMsValue');
                wireQuantizedTimeSlider('delayTime', 'delayTimeValue');
                // panning speed uses seconds in UI, still accept ms typing
                (function(){
                    const s=document.getElementById('panningSpeed');
                    const l=document.getElementById('panningSpeedValue');
                    if (!s||!l) return;
                    const render=()=>{ l.textContent = formatMs(Number(s.value)||0).replace('ms','ms').replace(/^(\d+(?:\.\d+)?)s$/, '$1s'); };
                    render();
                    s.addEventListener('input', render);
                    // quantize to BPM grid as well
                    wireQuantizedTimeSlider('panningSpeed','panningSpeedValue');
                })();
                // ADSR sliders (attack/decay/release for both OSCs) — attacks are free ms-only
                wireQuantizedTimeSlider('decaySlider','decayValue');
                wireQuantizedTimeSlider('releaseSlider','releaseValue');
                // attacks are wired directly above in input listeners; keep them unquantized
                wireQuantizedTimeSlider('osc2DecaySlider','osc2DecayValue');
                wireQuantizedTimeSlider('osc2ReleaseSlider','osc2ReleaseValue');
            } catch(_) {}
            omnichord = new MicrotonalOmnichord();
            window.omnichord = omnichord; // Make it globally accessible
            try { console.log('[DEBUG] window.load: omnichord ready; debug=', !!omnichord._debug); } catch(_){ }

            // Initialize keyboard modal on startup (make it draggable and wire controls)
            // Use setTimeout to ensure all other initialization is complete
            setTimeout(() => {
                try {
                const keyboardModal = document.getElementById('keyboardModal');
                if (keyboardModal) {
                    // Make keyboard modal draggable from startup
                    if (!keyboardModal._draggableSet) {
                        makeDraggable(keyboardModal);
                        keyboardModal._draggableSet = true;
                        console.log('✅ Keyboard modal made draggable on startup');
                    }
                    
                    // Wire transpose buttons from startup
                    const transposeUp = document.getElementById('transposeUpBtnModal');
                    const transposeDown = document.getElementById('transposeDownBtnModal');
                    const originalUp = document.getElementById('transposeUpBtn');
                    const originalDown = document.getElementById('transposeDownBtn');
                    if (transposeUp && originalUp && !transposeUp._wired) {
                        transposeUp._wired = true;
                        transposeUp.addEventListener('click', () => originalUp.click());
                        console.log('✅ Keyboard transpose UP wired on startup');
                    }
                    if (transposeDown && originalDown && !transposeDown._wired) {
                        transposeDown._wired = true;
                        transposeDown.addEventListener('click', () => originalDown.click());
                        console.log('✅ Keyboard transpose DOWN wired on startup');
                    }
                    
                    // Generate initial keyboard layout
                    if (window.omnichord && typeof omnichord.generateRootButtons === 'function') {
                        // Move root grid into modal
                        const modalRootGrid = document.getElementById('modalRootGrid');
                        const rootGrid = document.getElementById('rootGrid');
                        if (modalRootGrid && rootGrid) {
                            modalRootGrid.innerHTML = '';
                            modalRootGrid.appendChild(rootGrid);
                            rootGrid.style.display = 'block';
                        }
                        
                        omnichord.generateRootButtons();
                        console.log('✅ Keyboard buttons generated on startup');
                    }
                    
                    // Ensure EDO sync is working for keyboard input
                    const keyboardEDO = document.getElementById('edoQuickInputKeyboard');
                    const transportEDO = document.getElementById('edoQuickInputTransport');
                    if (keyboardEDO && transportEDO) {
                        // Sync keyboard EDO with transport EDO
                        keyboardEDO.value = transportEDO.value;
                        console.log('✅ Keyboard EDO synced with transport on startup');
                    }
                    
                    console.log('✅ Keyboard modal fully initialized on startup');
                }
            } catch(e) {
                console.error('❌ Error initializing keyboard modal on startup:', e);
            }
            }, 100); // Small delay to ensure DOM is ready

            // Minimal Web MIDI manager providing init/send/receive APIs and integration
            (function(){
                class WebMIDIManager {
                    constructor() {
                        this.enabled = false;
                        this.midiAccess = null;
                        this.inputs = new Map();
                        this.outputs = new Map();
                        this.inputHandler = null;
                        this.channelMap = { strum:1, strum1:1, strum2:2, chord:3, arp:4, bass:5, drum:6, osc1:7, osc2:8, default:6 };
                        this.noteState = new Map(); // key: `${note}@${ch}` -> {ts}
                        this.sustain = false; // CC64 >= 64
                        this.deferredOff = new Set(); // keys to send off when sustain released
                        this._idleTimer = null;
                        this._idleMs = 10000; // 10s PANIC after no interaction
                        this.octaveOffset = 0; // UI-controlled MIDI octave transpose
                        this.defaultVelocity = 100; // UI-controlled default velocity
                        // Per-source octave transpose (octaves, always 12 semitones per octave for MIDI)
                        this.perSourceOctave = { strum1:0, strum2:0, chord:0, arp:0, bass:0, osc1:0, osc2:0, default:0 };
                        // Per-source default velocity (overrides global if set)
                        this.perSourceVelocity = { strum1:100, strum2:100, chord:100, arp:100, bass:100, osc1:100, osc2:100, default:100 };
                        // Per-section MIDI IN channel filter (1=channel 1, not 0=omni)
                        this.inputChannelMap = { strum1:1, strum2:1, chord:1, arp:1, bass:1, default:1 };
                        // Per-section MIDI OUT port selection (stores output.id). null => send to all outputs
                        this.outputPortMap = { strum1:null, strum2:null, chord:null, arp:null, bass:null, drum:null, default:null };
                        this.currentProgram = 0;
                        // Load saved MIDI settings on initialization
                        this.loadMIDISettings();
                    }
                    // Save MIDI settings to localStorage
                    saveMIDISettings() {
                        try {
                            const settings = {
                                inputChannelMap: this.inputChannelMap,
                                outputPortMap: this.outputPortMap,
                                perSourceOctave: this.perSourceOctave,
                                perSourceVelocity: this.perSourceVelocity,
                                octaveOffset: this.octaveOffset,
                                defaultVelocity: this.defaultVelocity
                            };
                            localStorage.setItem('xenmicord_midi_settings', JSON.stringify(settings));
                            console.log('🎛️ MIDI settings saved to localStorage');
                        } catch (e) {
                            console.warn('Failed to save MIDI settings:', e);
                        }
                    }
                    // Load MIDI settings from localStorage
                    loadMIDISettings() {
                        try {
                            const saved = localStorage.getItem('xenmicord_midi_settings');
                            if (saved) {
                                const settings = JSON.parse(saved);
                                if (settings.inputChannelMap) this.inputChannelMap = { ...this.inputChannelMap, ...settings.inputChannelMap };
                                if (settings.outputPortMap) this.outputPortMap = { ...this.outputPortMap, ...settings.outputPortMap };
                                if (settings.perSourceOctave) this.perSourceOctave = { ...this.perSourceOctave, ...settings.perSourceOctave };
                                if (settings.perSourceVelocity) this.perSourceVelocity = { ...this.perSourceVelocity, ...settings.perSourceVelocity };
                                if (typeof settings.octaveOffset === 'number') this.octaveOffset = settings.octaveOffset;
                                if (typeof settings.defaultVelocity === 'number') this.defaultVelocity = settings.defaultVelocity;
                                console.log('🎛️ MIDI settings loaded from localStorage');
                                // Apply loaded settings to UI elements
                                this.applySettingsToUI();
                            }
                        } catch (e) {
                            console.warn('Failed to load MIDI settings:', e);
                        }
                    }
                    // Apply loaded settings to UI elements
                    applySettingsToUI() {
                        try {
                            const sections = ['strum1','strum2','chord','arp','bass','drum'];
                            for (const sec of sections) {
                                const inEl = document.getElementById(`midiIn-${sec}`);
                                const outEl = document.getElementById(`midiOut-${sec}`);
                                const octEl = document.getElementById(`midiOct-${sec}`);
                                const velEl = document.getElementById(`midiVel-${sec}`);
                                if (inEl && this.inputChannelMap[sec] !== undefined) inEl.value = String(this.inputChannelMap[sec]);
                                else if (inEl) inEl.value = '1'; // Default to channel 1
                                if (outEl && this.outputPortMap[sec] !== undefined) outEl.value = String(this.outputPortMap[sec] || '');
                                if (octEl && this.perSourceOctave[sec] !== undefined) octEl.value = String(this.perSourceOctave[sec]);
                                if (velEl && this.perSourceVelocity[sec] !== undefined) velEl.value = String(this.perSourceVelocity[sec]);
                            }
                            // Apply octave offset if element exists
                            const octOffsetEl = document.getElementById('midiOctaveOffset');
                            if (octOffsetEl) octOffsetEl.value = String(this.octaveOffset);
                        } catch (e) {
                            console.warn('Failed to apply MIDI settings to UI:', e);
                        }
                    }
                    async init() {
                        if (!('requestMIDIAccess' in navigator)) {
                            console.warn('Web MIDI not supported in this browser');
                            return false;
                        }
                        try {
                            this.midiAccess = await navigator.requestMIDIAccess({ sysex:false });
                        } catch (e) {
                            console.warn('Web MIDI access denied:', e);
                            return false;
                        }
                        this.refreshPorts();
                        this.midiAccess.onstatechange = () => this.refreshPorts();
                        this.enabled = true;
                        return true;
                    }
                    refreshPorts() {
                        this.inputs.clear();
                        this.outputs.clear();
                        if (!this.midiAccess) return;
                        try {
                            for (const input of this.midiAccess.inputs.values()) {
                                this.inputs.set(input.id, input);
                                input.onmidimessage = (ev)=>this._handleMIDIMessage(ev);
                            }
                            for (const output of this.midiAccess.outputs.values()) {
                                this.outputs.set(output.id, output);
                            }
                        } catch(e){ console.warn('Enumerating MIDI ports failed', e); }
                        try {
                            const inNames = Array.from(this.inputs.values()).map(p=>p.name||p.id);
                            const outNames = Array.from(this.outputs.values()).map(p=>p.name||p.id);
                            const loopIn = inNames.filter(n=>/loopmidi/i.test(String(n)));
                            const loopOut = outNames.filter(n=>/loopmidi/i.test(String(n)));
                            console.log(`[MIDI] Inputs(${this.inputs.size}): ${inNames.join(', ')}`);
                            console.log(`[MIDI] Outputs(${this.outputs.size}): ${outNames.join(', ')}`);
                            if (!loopIn.length && !loopOut.length) {
                                console.warn('[MIDI] No loopMIDI ports detected (case-insensitive search).');
                            } else {
                                console.log(`[MIDI] loopMIDI detected -> In:[${loopIn.join(', ')}] Out:[${loopOut.join(', ')}]`);
                                try {
                                    // Auto-map first loopMIDI OUT to all sections if nothing chosen yet
                                    const haveAnyMapping = Object.values(this.outputPortMap||{}).some(v=>!!v);
                                    if (!haveAnyMapping && loopOut.length) {
                                        const loopId = (()=>{
                                            // Find actual output id corresponding to first detected loopMIDI name
                                            const wanted = loopOut[0];
                                            for (const o of this.outputs.values()) {
                                                const nm = o.name || o.id || '';
                                                if (nm === wanted) return o.id; // exact match
                                            }
                                            // Fallback: first output whose name matches /loopmidi/i
                                            for (const o of this.outputs.values()) {
                                                const nm = o.name || o.id || '';
                                                if (/loopmidi/i.test(nm)) return o.id;
                                            }
                                            return null;
                                        })();
                                        if (loopId) {
                                            ['strum1','strum2','chord','arp','bass','drum','default'].forEach(sec=>{ this.outputPortMap[sec] = loopId; });
                                            console.log(`[MIDI] Auto-mapped loopMIDI port '${loopOut[0]}' (id=${loopId}) to all sections.`);
                                        }
                                    }
                                } catch(e){ console.warn('MIDI auto-map error', e); }
                            }
                        } catch(e){ console.warn('MIDI logging error', e); }
                        try {
                            ['strum1','strum2','chord','arp','bass','drum'].forEach(sec=>{
                                const el = document.getElementById(`midiOut-${sec}`);
                                if (el && el.tagName === 'SELECT') {
                                    this.populateOutputSelect(el);
                                    try {
                                        const sel = this.outputPortMap?.[sec] ?? this.outputPortMap?.default ?? '';
                                        if (sel && Array.from(el.options).some(op=>op.value===sel)) el.value = sel;
                                    } catch(_) {}
                                }
                            });
                        } catch(_){}
                    }
                    onInput(cb){ this.inputHandler = cb; }
                    // If outputTarget provided (string id or WebMIDIOutput), send only to that port; otherwise broadcast to all outputs
                    sendRaw(data, timestamp=0, channel=1, outputTarget=null) {
                        if (!this.enabled || this.outputs.size === 0) return;
                        const status = data[0];
                        const isChanMsg = (status & 0xF0) >= 0x80 && (status & 0xF0) <= 0xE0;
                        const msg = isChanMsg ? [ (status & 0xF0) | ((channel-1) & 0x0F), data[1] ?? 0, data[2] ?? 0 ] : data;
                        const sendTo = (out)=>{ try { out && out.send(msg, timestamp || undefined); } catch(_) {} };
                        if (outputTarget) {
                            const out = (typeof outputTarget === 'string') ? this.outputs.get(outputTarget) : outputTarget;
                            sendTo(out);
                        } else {
                            for (const out of this.outputs.values()) sendTo(out);
                        }
                    }
                    getOutputsArray(){ try { return Array.from(this.outputs.values()); } catch(_) { return []; } }
                    populateOutputSelect(selectEl){
                        try {
                            if (!selectEl) return;
                            const arr = this.getOutputsArray();
                            const prev = selectEl.value || '';
                            while (selectEl.firstChild) selectEl.removeChild(selectEl.firstChild);
                            const optAll = document.createElement('option');
                            optAll.value = '';
                            optAll.textContent = '(All Outputs)';
                            selectEl.appendChild(optAll);
                            arr.forEach(o=>{
                                const opt = document.createElement('option');
                                opt.value = o.id;
                                opt.textContent = o.name || o.id || 'MIDI Out';
                                selectEl.appendChild(opt);
                            });
                            if (prev && Array.from(selectEl.options).some(op=>op.value===prev)) selectEl.value = prev;
                        } catch(_) {}
                    }
                    _portIdFromOutput(output){
                        try {
                            if (!output) return '*';
                            if (typeof output === 'string') return output;
                            return output.id || output.name || '*';
                        } catch(_) { return '*'; }
                    }
                    outputForSource(src){
                        try {
                            const sel = (this.outputPortMap && (this.outputPortMap[src] ?? this.outputPortMap.default)) || null;
                            if (!sel) return null;
                            if (typeof sel === 'string') return this.outputs.get(sel) ? sel : null;
                            // If stored as index (1-based), map to current outputs list
                            const arr = this.getOutputsArray();
                            if (Number.isFinite(sel)) {
                                const idx = Math.max(1, Math.min(arr.length, (sel|0)));
                                return arr[idx-1]?.id || null;
                            }
                            return null;
                        } catch(_) { return null; }
                    }
                    // Normalize note and channel so that final MIDI note stays within 0..127.
                    // If note overflows >127 (or <0), subtract/add EDO steps and move to adjacent channels.
                    // Assumes receiving instrument tunes adjacent channels in octave steps for current EDO.
                    normalizeNoteChannel(note, channel){
                        try {
                            const edo = (window?.omnichord?.currentTuning|0) || 12;
                            // Global MIDI octave offset uses 12 semitones per octave
                            let n = (note|0) + ((this.octaveOffset|0) * 12);
                            let ch = channel|0;
                            if (!Number.isFinite(n) || !Number.isFinite(ch) || edo <= 0) {
                                return { note: Math.max(0, Math.min(127, n|0)), channel: Math.min(16, Math.max(1, ch||1)) };
                            }
                            // Shift up while above 127 by subtracting one EDO octave per extra channel
                            while (n > 127 && edo > 0) { n -= edo; ch += 1; }
                            // Shift down while below 0 by adding one EDO octave per previous channel
                            while (n < 0 && edo > 0) { n += edo; ch -= 1; }
                            // Wrap channel into 1..16 to stay valid
                            if (ch < 1) ch = ((ch % 16) + 16);
                            if (ch > 16) ch = ((ch - 1) % 16) + 1;
                            // Final clamp for safety
                            n = Math.max(0, Math.min(127, n|0));
                            ch = Math.min(16, Math.max(1, ch|0));
                            return { note: n, channel: ch };
                        } catch(_) {
                            return { note: Math.max(0, Math.min(127, note|0)), channel: Math.min(16, Math.max(1, channel||1)) };
                        }
                    }
                    sendNoteOn(note, velocity=100, channel=1, outputTarget=null) {
                        const norm = this.normalizeNoteChannel(note, channel);
                        const n = norm.note;
                        channel = norm.channel;
                        let vRaw = Number.isFinite(velocity) ? velocity : this.defaultVelocity;
                        
                        // Apply master volume scaling to MIDI velocity if available
                        if (typeof this._masterVolumeScale === 'number') {
                            vRaw = vRaw * this._masterVolumeScale;
                        }
                        
                        const v = Math.max(1, Math.min(127, Math.round(vRaw)));
                        this.sendRaw([0x90, n & 0x7F, v], 0, channel, outputTarget);
                        const pId = this._portIdFromOutput(outputTarget);
                        this.noteState.set(`${n}@${channel}@${pId}`, { ts: performance.now() });
                    }
                    sendNoteOff(note, channel=1, outputTarget=null) {
                        const norm = this.normalizeNoteChannel(note, channel);
                        const n = norm.note;
                        channel = norm.channel;
                        this.sendRaw([0x80, n & 0x7F, 0], 0, channel, outputTarget);
                        const pId = this._portIdFromOutput(outputTarget);
                        this.noteState.delete(`${n}@${channel}@${pId}`);
                    }
                    sendProgramChange(program=0, channel=1) {
                        const p = Math.max(0, Math.min(127, Math.round(program)));
                        this.sendRaw([0xC0, p & 0x7F, 0], 0, channel);
                    }
                    sendCC(cc, value, channel=1) {
                        const v = Math.max(0, Math.min(127, Math.round(value)));
                        this.sendRaw([0xB0, cc & 0x7F, v], 0, channel);
                    }
                    // RPN helpers for tuning
                    selectRPN(msb, lsb, channel=1){ this.sendCC(101, msb & 0x7F, channel); this.sendCC(100, lsb & 0x7F, channel); }
                    rpnNull(channel=1){ this.sendCC(101, 127, channel); this.sendCC(100, 127, channel); }
                    dataEntry(msb, lsb=null, channel=1){ this.sendCC(6, msb & 0x7F, channel); if (lsb!=null) this.sendCC(38, lsb & 0x7F, channel); }
                    setFineTune(cents=0, channel=1){
                        const v = Math.max(-100, Math.min(100, Number(cents)||0));
                        const val14 = Math.round((v/100) * 8192) + 8192; // 0..16383
                        const msb = (val14 >> 7) & 0x7F; const lsb = val14 & 0x7F;
                        this.selectRPN(0,1,channel); this.dataEntry(msb, lsb, channel); this.rpnNull(channel);
                    }
                    setCoarseTune(semitones=0, channel=1){
                        const s = Math.max(-64, Math.min(63, Math.round(Number(semitones)||0)));
                        const msb = 64 + s; // 0..127, 64=0
                        this.selectRPN(0,2,channel); this.dataEntry(msb, null, channel); this.rpnNull(channel);
                    }
                    allNotesOff() {
                        // Send All Notes Off (CC123) on all 16 channels (do not cut sounds)
                        for (let ch = 1; ch <= 16; ch++) {
                            this.sendCC(123, 0, ch);
                        }
                        // Clear local note state and deferred offs
                        this.noteState.clear();
                        this.deferredOff.clear();
                    }
                    markActivity() {
                        if (this._idleTimer) clearTimeout(this._idleTimer);
                        this._idleTimer = setTimeout(()=>{
                            // Do not panic while sustain held; re-arm timer instead
                            if (this.sustain) { this.markActivity(); return; }
                            try {
                                this.allNotesOff();
                            } catch(_) {}
                        }, this._idleMs);
                    }
                    _handleMIDIMessage(ev){
                        const [status, d1=0, d2=0] = ev.data || [];
                        const type = status & 0xF0; const ch = (status & 0x0F) + 1;
                        const payload = { status, type, channel: ch, data1: d1, data2: d2, timeStamp: ev.timeStamp };
                        // Basic per-section input filtering: if any section specifies a non-omni channel
                        // and the message channel doesn't match any, drop it from inputHandler.
                        try {
                            const ins = this.inputChannelMap || {};
                            const filters = Object.values(ins).filter(v => Number.isFinite(v) && v>0 && v<=16);
                            let pass = true;
                            if (filters.length>0){ pass = filters.includes(ch); }
                            if (this.inputHandler && pass) this.inputHandler(payload);
                        } catch(_){ if (this.inputHandler) try { this.inputHandler(payload); } catch(_) {}
                        }
                        this.markActivity();
                    }
                }

                const midi = new WebMIDIManager();
                window.midi = midi;

                // Prevent duplicate initialization during session import or re-entrant UI wiring
                if (!window._xenMidiInitGuard) window._xenMidiInitGuard = { prompted:false };

                // Wire MIDI toggle button
                const midiBtn = document.getElementById('midiToggle');
                if (midiBtn && !midiBtn._wired) {
                    midiBtn._wired = true;
                    midiBtn.addEventListener('click', async ()=>{
                        if (!midi.enabled) {
                            // Skip if already initializing to avoid double errors
                            if (midi._initializing) return;
                            midi._initializing = true;
                            const ok = await midi.init();
                            midi._initializing = false;
                            if (ok) {
                                // Detect loopMIDI outputs with short retry window (async enumeration may lag)
                                let hasLoop = false; let firstLoopId = null; let firstLoopName = null; let attempts = 0;
                                for (; attempts < 8; attempts++) { // up to ~8*75ms = 600ms
                                    try {
                                        const outsArr = Array.from(midi.outputs.values());
                                        for (const o of outsArr) {
                                            const nm = String(o.name||o.id||'');
                                            if (/loopmidi/i.test(nm)) { hasLoop = true; if (!firstLoopId){ firstLoopId = o.id; firstLoopName = nm; } }
                                        }
                                        if (hasLoop || outsArr.length > 0) break;
                                    } catch(_) {}
                                    await new Promise(r=>setTimeout(r,75));
                                }
                                // Extra deferred pass (after a microdelay) in case drivers enumerate slower
                                if (!hasLoop && midi.outputs.size === 0) {
                                    await new Promise(r=>setTimeout(r,300));
                                    try {
                                        for (const o of midi.outputs.values()) {
                                            const nm = String(o.name||o.id||'');
                                            if (/loopmidi/i.test(nm)) { hasLoop = true; if (!firstLoopId){ firstLoopId = o.id; firstLoopName = nm; } }
                                        }
                                    } catch(_) {}
                                }
                                if (!hasLoop) {
                                    // If there are zero outputs after retries, check UI for visible outputs; suppress prompt if any outputs appear in UI
                                    const outsCount = midi.outputs.size;
                                    if (outsCount === 0) {
                                        // Double-check UI selects: if any select already populated, treat as outputs visible
                                        let uiVisible = false;
                                        try {
                                            const selIds = ['midiOutputSelect','midiStrumOutput','midiChordOutput','midiArpOutput','midiBassOutput','midiDrumOutput'];
                                            for (const id of selIds) {
                                                const el = document.getElementById(id);
                                                if (el && el.options && el.options.length > 0) { uiVisible = true; break; }
                                            }
                                        } catch(_) {}
                                        if (!uiVisible) {
                                            if (!window._xenMidiInitGuard.prompted) {
                                                window._xenMidiInitGuard.prompted = true;
                                                const msg = 'No MIDI outputs detected yet. If you intend to route to other software, you can install loopMIDI:\nhttps://www.tobias-erichsen.de/software/loopmidi.html';
                                                // Use non-blocking alert style (no redirect) to avoid annoyance; user can still continue once devices appear
                                                try { window.alert(msg); } catch(_) {}
                                            }
                                            // Keep enabled; devices might appear slightly later (hot‑plug)
                                        }
                                    } else {
                                        // Proceed silently; any output counts (hardware or loopback)
                                        try {
                                            if (!firstLoopId) {
                                                const first = Array.from(midi.outputs.values())[0];
                                                if (first) { firstLoopId = first.id; firstLoopName = first.name || first.id; }
                                            }
                                        } catch(_) {}
                                    }
                                    // At this point we do NOT disable MIDI merely for missing loopMIDI; user has some outputs or may have them appear soon.
                                }
                                midiBtn.classList.add('active');
                                try {
                                    // Auto-map first loopMIDI port to all sections if none chosen yet
                                    const haveAnyMapping = Object.values(midi.outputPortMap||{}).some(v=>!!v);
                                    if (!haveAnyMapping && firstLoopId) {
                                        ['strum1','strum2','chord','arp','bass','drum','default'].forEach(sec=>{ midi.outputPortMap[sec] = firstLoopId; });
                                        console.log(`[MIDI] Auto-mapped loopMIDI port '${firstLoopName}' (id=${firstLoopId}) to all sections (toggle).`);
                                    }
                                } catch(_){ }
                                // Mute internal oscillators & drums by reducing masterVolume but remember prior
                                try {
                                    const oc = window.omnichord;
                                    if (oc) {
                                        if (oc._preMidiMasterVolume === undefined) oc._preMidiMasterVolume = oc.masterVolume;
                                        // Set a very low master volume (not zero to keep envelopes functional visually)
                                        oc.masterVolume = 0.0001;
                                        if (oc.gainNode) oc.gainNode.gain.value = oc.volume * oc.masterVolume;
                                        if (oc.dryGainNode) oc.dryGainNode.gain.value = oc.masterVolume;
                                        if (oc.reverbOutGain) oc.reverbOutGain.gain.value = oc.masterVolume;
                                    }
                                } catch(_){ }
                                try { midi.applySettingsToUI(); } catch(_){ }
                                // Light indicator if present
                                try {
                                    const led = document.getElementById('midiStatusLed');
                                    if (led) { led.classList.add('on'); led.title = 'MIDI Enabled'; }
                                } catch(_) {}
                            }
                        } else {
                            midi.enabled = false; midiBtn.classList.remove('active');
                            try {
                                // When MIDI is off, restore MASTER so all oscillators are heard
                                const oc = window.omnichord;
                                if (oc) {
                                    const restore = (typeof oc._preMidiMasterVolume === 'number') ? oc._preMidiMasterVolume : oc.masterVolume;
                                    oc.masterVolume = restore;
                                    if (oc.gainNode) oc.gainNode.gain.value = oc.volume * oc.masterVolume;
                                    if (oc.dryGainNode) oc.dryGainNode.gain.value = oc.masterVolume;
                                    if (oc.reverbOutGain) oc.reverbOutGain.gain.value = oc.masterVolume;
                                    // Clear the pre-MIDI backup so volume controls work normally
                                    delete oc._preMidiMasterVolume;
                                }
                                // Clear MIDI volume scaling
                                if (midi) {
                                    delete midi._masterVolumeScale;
                                }
                            } catch(_) {}
                                try {
                                    const led = document.getElementById('midiStatusLed');
                                    if (led) { led.classList.remove('on'); led.title = 'MIDI Disabled'; }
                                } catch(_) {}
                        }
                        midi.markActivity();
                    });
                }
                // Program change UI removed per request

                // Helper: map internal frequency to MIDI note based on current EDO steps
                // Anchor: C4 = MIDI 60. Each EDO step => +1 MIDI note.
                function freqToMidiNote(freq){
                    try {
                        const oc = window.omnichord;
                        const tuning = oc?.currentTuning || 12;
                        // C in current tuning (semitone 0 -> step in EDO), octave 4
                        const cStep = typeof oc?.semitoneToStep === 'function' ? oc.semitoneToStep(0, tuning) : 0;
                        const c4 = typeof oc?.getFrequency === 'function' ? oc.getFrequency(cStep, 4, tuning) : 261.6256; // fallback C4
                        const stepDiff = Math.round(tuning * Math.log2(freq / c4));
                        const midi = 60 + stepDiff; // C4 anchor, 1 step per EDO unit
                        return midi; // do not clamp here; allow overflow handling later
                    } catch(_) {
                        // Fallback to A440 mapping if anything goes wrong
                        const n = 69 + 12 * Math.log2(freq / 440);
                        return Math.round(n);
                    }
                }
                function channelForSource(src){ return midi.channelMap[src] || midi.channelMap.default; }

                // Hook play/stop to mirror MIDI out with minimal intrusion
                const _playFrequency = omnichord.playFrequency.bind(omnichord);
                omnichord.playFrequency = async function(frequency, element, sourceType='default'){
                    // Send MIDI Note On first to avoid race with quick releases
                    try {
                        if (midi.enabled) {
                            const note = freqToMidiNote(frequency);
                            let targets = (sourceType === 'strum') ? ['strum1','strum2'] : [sourceType];
                            if (sourceType === 'default') {
                                // Mirror to all five primary sections so oscillators still fire independently
                                targets = ['strum1','strum2','chord','arp','bass'];
                            }
                            const velInput = document.getElementById('midiDefaultVelocity');
                            const vGlobal = velInput ? Math.max(1, Math.min(127, parseInt(velInput.value||'100',10))) : 100;
                            midi.defaultVelocity = vGlobal;
                            const octSel = document.getElementById('midiOctaveOffset');
                            midi.octaveOffset = octSel ? (parseInt(octSel.value||'0',10) || 0) : 0;
                            // Helper to derive decay ms per target instrument
                            const decayMsFor = (t) => {
                                try {
                                    const ins = omnichord.instruments || {};
                                    if (t === 'strum1') return Math.max(0, Math.round(((ins.strum1?.env?.decay) ?? omnichord.envelope?.decay ?? 0.2) * 1000));
                                    if (t === 'strum2') return Math.max(0, Math.round(((ins.strum2?.env?.decay) ?? omnichord.osc2Envelope?.decay ?? 0.05) * 1000));
                                    if (t === 'chord')  return Math.max(0, Math.round(((ins.chord?.env?.decay)  ?? 0.2) * 1000));
                                    if (t === 'arp')    return Math.max(0, Math.round(((ins.arp?.env?.decay)    ?? 0.2) * 1000));
                                    if (t === 'bass')   return Math.max(0, Math.round(((ins.bass?.env?.decay)   ?? 0.08) * 1000));
                                    return 200;
                                } catch(_) { return 200; }
                            };
                            for (const tgt of targets) {
                                const chBase = channelForSource(tgt);
                                const perOct = (midi.perSourceOctave && Number.isFinite(midi.perSourceOctave[tgt])) ? (midi.perSourceOctave[tgt]|0) : 0;
                                const stepsPerOct = (window?.omnichord?.currentTuning|0) || 12;
                                const effNote = note + (perOct * stepsPerOct);
                                const norm = midi.normalizeNoteChannel(effNote, chBase);
                                const nNote = norm.note; const nCh = norm.channel;
                                const outSel = midi.outputForSource(tgt);
                                const key = `${nNote}@${nCh}@${(outSel||'*')}`;
                                if ((tgt === 'strum1' || tgt === 'strum2') && midi.noteState.has(key) && !midi.sustain) {
                                    midi.sendNoteOff(nNote, nCh, outSel);
                                }
                                if (tgt === 'chord' && midi.noteState.has(key) && !midi.sustain) {
                                    midi.sendNoteOff(nNote, nCh, outSel);
                                }
                                const perV = (midi.perSourceVelocity && Number.isFinite(midi.perSourceVelocity[tgt])) ? (midi.perSourceVelocity[tgt]|0) : vGlobal;
                                const useV = Math.max(1, Math.min(127, perV));
                                midi.sendNoteOn(nNote, useV, nCh, outSel);
                                // Schedule Note Off based on musical intent per section
                                const epsilonMs = 8;
                                let offDelay = Math.max(10, decayMsFor(tgt)|0);
                                try {
                                    if (tgt === 'chord') {
                                        // HOLD-based duration for chords (e.g., 1 BAR)
                                        const bpmEl = document.getElementById('universalBpm');
                                        const bpm = bpmEl ? (parseFloat(bpmEl.value)||120) : (omnichord._arpTransport?.bpm || 120);
                                        const beatMs = 60000 / Math.max(1, bpm);
                                        const tsEl = document.getElementById('timeSignatureSelect');
                                        const timeSignature = tsEl ? tsEl.value : (omnichord._arpTransport?.timeSignature || '4/4');
                                        const [beatsPerBar] = String(timeSignature).split('/').map(Number);
                                        const barMs = beatMs * (beatsPerBar || 4);
                                        const holdSel = document.getElementById('universalHold') || document.getElementById('chordHold');
                                        const holdVal = holdSel ? String(holdSel.value||'bar:1') : 'bar:1';
                                        const [kind, valStr] = holdVal.split(':');
                                        const n = Math.max(1, parseInt(valStr||'1',10));
                                        const holdMs = (kind === 'beat') ? n*beatMs : n*barMs;
                                        offDelay = Math.max(10, Math.floor(holdMs - epsilonMs));
                                    } else if (tgt === 'arp') {
                                        // QUANT-based duration for ARP (e.g., 1/8 note)
                                        try { if (typeof omnichord._ensureArpTransport === 'function') omnichord._ensureArpTransport(); } catch(_) {}
                                        let quantMs = omnichord._arpTransport?.tickMs;
                                        if (!quantMs || !Number.isFinite(quantMs)) {
                                            const quantEl = document.getElementById('universalQuant');
                                            const bpmEl = document.getElementById('universalBpm');
                                            const bpm = bpmEl ? (parseFloat(bpmEl.value)||120) : (omnichord._arpTransport?.bpm || 120);
                                            const q = quantEl?.value || omnichord._arpTransport?.quant || '1/16';
                                            if (typeof omnichord._parseQuantToMs === 'function') {
                                                quantMs = omnichord._parseQuantToMs(q, bpm);
                                            } else {
                                                const beatMs = 60000 / Math.max(1, bpm);
                                                const base = String(q).replace('T','');
                                                const map = { '1/1':1, '1/2':2, '1/4':4, '1/8':8, '1/16':16, '1/32':32 };
                                                const div = map[base] || 8;
                                                quantMs = beatMs * (4/div);
                                                if (String(q).endsWith('T')) quantMs *= 2/3;
                                            }
                                        }
                                        offDelay = Math.max(10, Math.floor(quantMs - epsilonMs));
                                    } else if (tgt === 'bass') {
                                        // Match CHORD behavior: HOLD-based duration for BASS
                                        const bpmEl = document.getElementById('universalBpm');
                                        const bpm = bpmEl ? (parseFloat(bpmEl.value)||120) : (omnichord._arpTransport?.bpm || 120);
                                        const beatMs = 60000 / Math.max(1, bpm);
                                        const tsEl = document.getElementById('timeSignatureSelect');
                                        const timeSignature = tsEl ? tsEl.value : (omnichord._arpTransport?.timeSignature || '4/4');
                                        const [beatsPerBar] = String(timeSignature).split('/').map(Number);
                                        const barMs = beatMs * (beatsPerBar || 4);
                                        const holdSel = document.getElementById('universalHold') || document.getElementById('chordHold');
                                        const holdVal = holdSel ? String(holdSel.value||'bar:1') : 'bar:1';
                                        const [kind, valStr] = holdVal.split(':');
                                        const n = Math.max(1, parseInt(valStr||'1',10));
                                        const holdMs = (kind === 'beat') ? n*beatMs : n*barMs;
                                        offDelay = Math.max(10, Math.floor(holdMs - epsilonMs));
                                    }
                                } catch(_) {}
                                setTimeout(()=>{
                                    try {
                                        if (!midi.enabled) return;
                                        midi.sendNoteOff(nNote, nCh, outSel);
                                    } catch(_) {}
                                }, offDelay);
                            }
                        }
                    } catch(_) {}
                    await _playFrequency(frequency, element, sourceType);
                    try { midi.markActivity(); } catch(_) {}
                };

                const _stopFrequency = omnichord.stopFrequency.bind(omnichord);
                omnichord.stopFrequency = function(frequency, element, sourceType='default'){
                    try {
                        if (midi.enabled) {
                            const note = freqToMidiNote(frequency);
                            let targets = (sourceType === 'strum') ? ['strum1','strum2'] : [sourceType];
                            if (sourceType === 'default') {
                                targets = ['strum1','strum2','chord','arp','bass'];
                            }
                            for (const tgt of targets) {
                                // Do not send immediate Note Off for CHORD/ARP/BASS; allow HOLD/QUANT timers to release
                                if (tgt === 'chord' || tgt === 'arp' || tgt === 'bass') continue;
                                const chBase = channelForSource(tgt);
                                const perOct = (midi.perSourceOctave && Number.isFinite(midi.perSourceOctave[tgt])) ? (midi.perSourceOctave[tgt]|0) : 0;
                                const stepsPerOct = (window?.omnichord?.currentTuning|0) || 12;
                                const effNote = note + (perOct * stepsPerOct);
                                const norm = midi.normalizeNoteChannel(effNote, chBase);
                                const nNote = norm.note; const nCh = norm.channel;
                                const outSel = midi.outputForSource(tgt);
                                midi.sendNoteOff(nNote, nCh, outSel);
                            }
                        }
                    } catch(_) {}
                    try { midi.markActivity(); } catch(_) {}
                    return _stopFrequency(frequency, element, sourceType);
                };

                // Map keyboard modifiers to MIDI pedals during playback
                (function(){
                    try {
                        if (window.__midiPedalsHooked) return;
                        window.__midiPedalsHooked = true;
                        const usedChannels = ()=>{
                            const s = new Set(Object.values(midi.channelMap||{}));
                            // Always include default channel
                            s.add(midi.channelMap?.default||5);
                            // Also include any channels currently holding notes (for overflow splitting)
                            try {
                                for (const key of midi.noteState.keys()){
                                    const parts = String(key).split('@');
                                    const ch = parseInt(parts[1]||'0',10);
                                    if (ch>=1 && ch<=16) s.add(ch);
                                }
                            } catch(_){}
                            return Array.from(s);
                        };
                        const sendSustain = (on)=>{ try { for (const ch of usedChannels()) midi.sendCC(64, on?127:0, ch); } catch(_){} };
                        const sendSoft = (on)=>{ try { for (const ch of usedChannels()) midi.sendCC(67, on?127:0, ch); } catch(_){} };
                        const flushDeferred = ()=>{}; // No-op: avoid abrupt kills on pedal release
                        window.addEventListener('keydown', (e)=>{
                            if (!midi.enabled) return;
                            // SHIFT: sustain pedal on (edge only, ignore repeats)
                            if (e.key === 'Shift' && !e.repeat){
                                if (!window.__sustainKeyDown){
                                    window.__sustainKeyDown = true;
                                    midi.sustain = true;
                                    sendSustain(true);
                                }
                            }
                            if (e.key === 'Control' && !window.__softPedalDown){
                                window.__softPedalDown = true; sendSoft(true);
                            }
                            // ALT+C: toggle CHORD/ARP mode
                            if (e.altKey && (e.key === 'c' || e.key === 'C')){
                                try { if (window.omnichord && typeof window.omnichord.toggleChordArpMode === 'function') window.omnichord.toggleChordArpMode(); } catch(_) {}
                                e.preventDefault();
                            }
                            // ALT+B: toggle Bass
                            if (e.altKey && (e.key === 'b' || e.key === 'B')){
                                try { if (window.omnichord && typeof window.omnichord.toggleBassMode === 'function') window.omnichord.toggleBassMode(); } catch(_) {}
                                e.preventDefault();
                            }
                            // ALT +/−: octave up/down for ARP and CHORD MIDI
                            if (e.altKey && !e.repeat) {
                                const plus  = (e.key === '+' || e.key === '=' || e.code === 'NumpadAdd');
                                const minus = (e.key === '-' || e.key === '_' || e.code === 'NumpadSubtract');
                                if (plus || minus) {
                                    const delta = plus ? 1 : -1;
                                    try {
                                        midi.perSourceOctave = midi.perSourceOctave || {};
                                        midi.perSourceOctave.chord = (midi.perSourceOctave.chord || 0) + delta;
                                        midi.perSourceOctave.arp   = (midi.perSourceOctave.arp   || 0) + delta;
                                        const chordSel = document.getElementById('midiOct-chord');
                                        if (chordSel) {
                                            const newVal = String(Math.max(-3, Math.min(3, parseInt(chordSel.value || '0', 10) + delta)));
                                            chordSel.value = newVal;
                                        }
                                        const arpSel = document.getElementById('midiOct-arp');
                                        if (arpSel) {
                                            const newVal = String(Math.max(-3, Math.min(3, parseInt(arpSel.value || '0', 10) + delta)));
                                            arpSel.value = newVal;
                                        }
                                    } catch(_) {}
                                    e.preventDefault();
                                }
                            }
                            // ArrowUp: ramp mod wheel up while held, LATCH on release (do not auto-reset)
                            if (e.key === 'ArrowUp' && !window.__modWheelRampActive){
                                window.__modWheelRampActive = true;
                                try { if (!window.__modWheelVal) window.__modWheelVal = 0; } catch(_) {}
                                try { if (window.__modWheelTimer) { clearInterval(window.__modWheelTimer); window.__modWheelTimer = null; } } catch(_){ }
                                window.__modWheelTimer = setInterval(()=>{
                                    try {
                                        window.__modWheelVal = Math.min(127, (window.__modWheelVal||0) + 5);
                                        for (const ch of usedChannels()) midi.sendCC(1, window.__modWheelVal, ch);
                                        if (window.__modWheelVal >= 127){
                                            clearInterval(window.__modWheelTimer); window.__modWheelTimer = null;
                                        }
                                    } catch(_) {}
                                }, 40);
                                e.preventDefault();
                            }
                            // ArrowDown: ramp mod wheel back down while held
                            if (e.key === 'ArrowDown' && !window.__modWheelDownActive){
                                window.__modWheelDownActive = true;
                                try { if (window.__modWheelTimer) { clearInterval(window.__modWheelTimer); window.__modWheelTimer = null; } } catch(_){ }
                                window.__modWheelTimer = setInterval(()=>{
                                    try {
                                        window.__modWheelVal = Math.max(0, (window.__modWheelVal||0) - 5);
                                        for (const ch of usedChannels()) midi.sendCC(1, window.__modWheelVal, ch);
                                        if (window.__modWheelVal <= 0){
                                            clearInterval(window.__modWheelTimer); window.__modWheelTimer = null;
                                        }
                                    } catch(_) {}
                                }, 40);
                                e.preventDefault();
                            }
                        }, {passive:true});
                        window.addEventListener('keyup', (e)=>{
                            if (!midi.enabled) return;
                            // SHIFT: sustain pedal off on keyup
                            if (e.key === 'Shift'){
                                if (window.__sustainKeyDown){ window.__sustainKeyDown = false; }
                                if (midi.sustain){ midi.sustain=false; sendSustain(false); }
                            }
                            if (e.key === 'Control' && window.__softPedalDown){
                                window.__softPedalDown = false; sendSoft(false);
                            }
                            // Stop current mod wheel ramp on ArrowUp release, but DO NOT reset value (latch)
                            if (e.key === 'ArrowUp'){
                                try { if (window.__modWheelTimer){ clearInterval(window.__modWheelTimer); window.__modWheelTimer = null; } } catch(_) {}
                                try { window.__modWheelRampActive = false; } catch(_) {}
                                e.preventDefault();
                            }
                            // Stop ramping down on ArrowDown release (value stays wherever it is)
                            if (e.key === 'ArrowDown'){
                                try { if (window.__modWheelTimer){ clearInterval(window.__modWheelTimer); window.__modWheelTimer = null; } } catch(_) {}
                                try { window.__modWheelDownActive = false; } catch(_) {}
                                e.preventDefault();
                            }
                        }, {passive:true});
                        window.addEventListener('blur', ()=>{
                            if (!midi.enabled) return;
                            if (midi.sustain){ midi.sustain=false; sendSustain(false); }
                            if (window.__softPedalDown){ window.__softPedalDown=false; sendSoft(false); }
                        });
                    } catch(_){}
                })();
                // Incoming MIDI → chord selection + mod wheel strum
                const baseNote = 0; // C-2 (MIDI 0)
                const maxSlots = 32; // 32 slots starting at C-2
                let heldChordSlot = null;
                midi.onInput((msg)=>{
                    if (!midi.enabled) return;
                    const { type, data1, data2 } = msg;
                    if (type === 0x90 && data2 > 0) { // Note On
                        const idx = data1 - baseNote; // 0..31
                        if (idx >= 0 && idx < maxSlots) {
                            heldChordSlot = idx;
                            try { omnichord.playChordByIndex(idx); } catch(_) {}
                        }
                    } else if (type === 0x80 || (type === 0x90 && data2 === 0)) { // Note Off
                        const idx = data1 - baseNote;
                        if (idx >= 0 && idx < maxSlots) {
                            heldChordSlot = null;
                            try { omnichord.stopAllActiveNotes(); } catch(_) {}
                        }
                    } else if (type === 0xB0) { // CC
                        if (data1 === 64) { // Sustain pedal
                            midi.sustain = data2 >= 64;
                        } else if (data1 === 1) { // Mod wheel → strum
                            if (heldChordSlot != null) {
                                // Map CC value to a brief strum gesture across current column
                                const columns = document.querySelectorAll('.extension-column');
                                const col = columns[heldChordSlot] || null;
                                if (col) {
                                    const rect = col.getBoundingClientRect();
                                    const y = rect.top + (1 - (data2/127)) * rect.height;
                                    try { omnichord.playChordStrum(col, {name:'MIDI'}, y-8, y+8); } catch(_) {}
                                }
                            }
                        }
                    }
                });
                // Wire per-section MIDI controls (IN/OUT-PORT/OCTAVE/VELOCITY)
                ;(function(){
                    try {
                        const sections = ['strum1','strum2','chord','arp','bass','drum'];
                        for (const sec of sections){
                            const inEl = document.getElementById(`midiIn-${sec}`);
                            const outEl = document.getElementById(`midiOut-${sec}`);
                            const octEl = document.getElementById(`midiOct-${sec}`);
                            const velEl = document.getElementById(`midiVel-${sec}`);
                            if (inEl){ inEl.addEventListener('change', ()=>{ midi.inputChannelMap[sec] = Math.max(0, Math.min(15, parseInt(inEl.value||'0',10)|0)); try { omnichord._ensureArpTransport(); omnichord._arpTransport.deferFlags = Object.assign(omnichord._arpTransport.deferFlags||{}, { midi:true }); const tpBeat=Math.max(1,omnichord._arpTransport.ticksPerBeat||1); const nowAbs=omnichord._arpTransport.absTickCounter|0; omnichord._arpTransport.deferApplyAtAbsTick=(nowAbs+2*tpBeat)>>>0; } catch(_){} midi.saveMIDISettings(); }); }
                            if (outEl){ outEl.addEventListener('change', ()=>{
                                const id = String(outEl.value||'');
                                midi.outputPortMap[sec] = id || null; // empty = all outputs
                                try { omnichord._ensureArpTransport(); omnichord._arpTransport.deferFlags = Object.assign(omnichord._arpTransport.deferFlags||{}, { midi:true }); const tpBeat=Math.max(1,omnichord._arpTransport.ticksPerBeat||1); const nowAbs=omnichord._arpTransport.absTickCounter|0; omnichord._arpTransport.deferApplyAtAbsTick=(nowAbs+2*tpBeat)>>>0; } catch(_){} midi.saveMIDISettings();
                            }); }
                            if (octEl){ octEl.addEventListener('change', ()=>{ midi.perSourceOctave[sec] = Math.max(-3, Math.min(3, parseInt(octEl.value||'0',10)|0)); midi.saveMIDISettings(); }); }
                            if (velEl){ velEl.addEventListener('change', ()=>{ midi.perSourceVelocity[sec] = Math.max(1, Math.min(127, parseInt(velEl.value||'100',10)|0)); midi.saveMIDISettings(); }); }
                            // Initialize from defaults
                            if (inEl) inEl.value = String(midi.inputChannelMap[sec] ?? 1);
                            if (outEl && outEl.tagName === 'SELECT') {
                                // Populate once now
                                try { midi.populateOutputSelect(outEl); } catch(_){}
                                const sel = midi.outputPortMap[sec] || midi.outputPortMap.default || '';
                                outEl.value = sel || '';
                            }
                            if (octEl) octEl.value = String(midi.perSourceOctave[sec] ?? 0);
                            if (velEl) velEl.value = String(midi.perSourceVelocity[sec] ?? midi.defaultVelocity ?? 100);
                        }
                    } catch(_) {}
                })();

                // Keyboard hotkeys for MIDI velocity: [,] down 5, [.] up 5 (apply to ALL sections)
                (function(){
                    try {
                        if (window.__midiVelHotkeys) return; window.__midiVelHotkeys = true;
                        const clamp127 = (n)=> Math.max(1, Math.min(127, n|0));
                        const adjust = (delta)=>{
                            const inp = document.getElementById('midiDefaultVelocity');
                            let base = Number.isFinite(parseInt(inp?.value||'0',10)) ? (parseInt(inp.value,10)) : (midi.defaultVelocity||100);
                            const newDefault = clamp127(base + delta);
                            if (inp) inp.value = String(newDefault);
                            midi.defaultVelocity = newDefault;
                            try {
                                const sections = ['strum1','strum2','chord','arp','bass','drum'];
                                midi.perSourceVelocity = midi.perSourceVelocity || {};
                                for (const sec of sections){
                                    const el = document.getElementById(`midiVel-${sec}`);
                                    // Derive current value: prefer object, else input, else default
                                    let curVal = midi.perSourceVelocity[sec];
                                    if (!Number.isFinite(curVal)) curVal = Number.parseInt(el?.value||'') || newDefault;
                                    const nextVal = clamp127(curVal + delta);
                                    if (el) el.value = String(nextVal);
                                    midi.perSourceVelocity[sec] = nextVal;
                                }
                            } catch(_) {}
                        };
                        window.addEventListener('keydown', (e)=>{
                            if (!midi.enabled) return;
                            if (e.key === ',') { e.preventDefault(); adjust(-5); }
                            else if (e.key === '.') { e.preventDefault(); adjust(+5); }
                        }, {passive:false});
                    } catch(_){}
                })();
            })();

            // Force 24-EDO at startup before any parsing/sequencing occurs
            try {
                if (omnichord && typeof omnichord.updateTuningSystem === 'function') {
                    omnichord.updateTuningSystem(24);
                }
                const edoPanel = document.getElementById('edoDivisions');
                if (edoPanel) edoPanel.value = '24';
                const edoQuick = document.getElementById('edoQuickInput');
                if (edoQuick) edoQuick.value = '24';
            } catch {}

            // Briefly flash the + and SEQUENCE buttons with helper bubbles
            try {
                const plusBtn = document.getElementById('createNewChordBtn');
                const seqBtn = document.getElementById('openTextChordParserBtn');
                if (plusBtn) {
                    plusBtn.classList.add('flash-cta');
                    const bubble = document.createElement('div');
                    bubble.className = 'hint-bubble';
                    bubble.textContent = 'Add Chord';
                    document.body.appendChild(bubble);
                    const rect = plusBtn.getBoundingClientRect();
                    bubble.style.left = `${rect.left + window.scrollX}px`;
                    bubble.style.top = `${rect.top + window.scrollY - 36}px`;
                    setTimeout(()=>{ bubble.remove(); plusBtn.classList.remove('flash-cta'); }, 3500);
                }
                if (seqBtn) {
                    seqBtn.classList.add('flash-cta-alt');
                    const bubble2 = document.createElement('div');
                    bubble2.className = 'hint-bubble';
                    bubble2.textContent = 'Or click here to type a chord sequence';
                    document.body.appendChild(bubble2);
                    const r2 = seqBtn.getBoundingClientRect();
                    bubble2.style.left = `${r2.left + window.scrollX}px`;
                    bubble2.style.top = `${r2.top + window.scrollY - 36}px`;
                    setTimeout(()=>{ bubble2.remove(); seqBtn.classList.remove('flash-cta-alt'); }, 4000);
                }
            } catch {}

            // Wire transport-related UI (metronome, chord-change quant)
            try { if (omnichord && typeof omnichord._wireTransportUI === 'function') omnichord._wireTransportUI(); } catch {}
            // Ensure ARP UI controls are wired
            try {
                if (omnichord && typeof omnichord._wireTransportUI === 'function') {
                    // _wireTransportUI now also wires ARP controls
                }
            } catch {}

            // Add test function for transpose behavior
            omnichord.testTransposeSequence = function() {
                console.log('🎵 TESTING TRANSPOSE SEQUENCE');
                console.log('Expected: C major → transpose up → C↑E↑G↑ → edit notes correctly');
                
                // Helper functions
                const getKeyboardState = () => {
                    const kb = document.querySelector('#rootGrid .piano-keyboard');
                    const litKeys = [];
                    if (kb) {
                        kb.querySelectorAll('[data-step].chord-tone').forEach(el => {
                            litKeys.push({
                                step: parseInt(el.dataset.step),
                                originalStep: parseInt(el.dataset.originalStep || el.dataset.step),
                                label: el.textContent.trim()
                            });
                        });
                    }
                    return litKeys.sort((a, b) => a.step - b.step);
                };
                
                const getChordName = () => {
                    const col = document.querySelector('.extension-column');
                    const nameEl = col?.querySelector('.extension-header .chord-name');
                    return nameEl?.textContent?.trim()?.replace(/^🔒\s*/, '') || 'Unknown';
                };
                
                const clickKeyByLabel = (label) => {
                    const kb = document.querySelector('#rootGrid .piano-keyboard');
                    const keys = kb.querySelectorAll('[data-step]');
                    for (let key of keys) {
                        if (key.textContent.trim() === label) {
                            console.log(`  Clicking: ${label}`);
                            key.click();
                            return true;
                        }
                    }
                    console.log(`  ❌ Key not found: ${label}`);
                    return false;
                };
                
                const logState = (stepName) => {
                    const state = getKeyboardState();
                    const chordName = getChordName();
                    console.log(`${stepName}:`);
                    console.log(`  Chord: ${chordName}`);
                    console.log(`  Transpose: ${this.transposeDelta}`);
                    console.log(`  Lit keys: ${state.map(k => `${k.label}(${k.step})`).join(', ')}`);
                };
                
                // Set up test environment
                this.currentTuning = 24;
                this.transposeDelta = 0;
                this.generateRootButtons();
                
                setTimeout(() => {
                    logState('1. Initial state');
                    
                    setTimeout(() => {
                        console.log('\n2. Transpose up...');
                        document.querySelector('#transposeUp')?.click();
                        
                        setTimeout(() => {
                            logState('2. After transpose up');
                            console.log('   Expected: Keys should show microtonal notation');
                            
                            setTimeout(() => {
                                console.log('\n✅ Test setup complete. Now manually test:');
                                console.log('   - Click any key and verify correct chord tones light up');
                                console.log('   - The issue was: clicking F would incorrectly light C#, F#, G#');
                                console.log('   - Now it should light the correct chord tones');
                                
                            }, 100);
                        }, 100);
                    }, 100);
                }, 100);
            };

            // Keyboard logo adjustment no longer needed after rebrand; keep namespace for compatibility
            window.PianoApp = window.PianoApp || {};
            window.PianoApp.adjustKeyboardForLogo = undefined;
            
            // Initialize new features
            omnichord.initTutorial();
            omnichord.initRandomDice();
            try { omnichord.wireEffectsPresetsUI(); } catch {}
            // Wire bottom bar SAVE XEN / LOAD XEN
            (function(){
                const bottomExport = document.getElementById('bottomExportOMGBtn');
                if (bottomExport) bottomExport.addEventListener('click', () => { try { omnichord.exportXenState(); } catch(e){ console.error('Export failed', e);} });
                const bottomImport = document.getElementById('bottomImportOMGBtn');
                if (bottomImport) bottomImport.addEventListener('click', () => {
                    const input = document.getElementById('loadSessionInput');
                    if (input) input.click();
                });
                const fileInput = document.getElementById('loadSessionInput');
                if (fileInput) fileInput.onchange = (e)=> { try { omnichord.importXenState(e); } catch(err){ console.error('Import failed', err); }};
            })();

            // Synchronize HOLD controls (universalHold with chordHold)
            try {
                const universalHold = document.getElementById('universalHold');
                const chordHold = document.getElementById('chordHold');
                if (universalHold && chordHold) {
                    universalHold.addEventListener('change', () => {
                        chordHold.value = universalHold.value;
                    });
                }
            } catch (e) {
                console.error('Error setting up HOLD synchronization:', e);
            }

            // Wire PLAY/STOP toggle button (FORCE bracket-aware logic)
            try {
                console.log('🎵 DEBUG: Attempting to wire bracket-aware button');
                const playStopToggle = document.getElementById('playStopToggleBtn');
                const loopCheckbox = document.getElementById('playLoop');
                console.log('🎵 DEBUG: Found button:', playStopToggle);
                if (playStopToggle) {
                    // Force re-wire to ensure bracket-aware logic takes precedence
                    playStopToggle._wired = true; // Mark as wired to prevent other handlers
                    
                    // Remove any existing click listeners and add our bracket-aware one
                    playStopToggle.replaceWith(playStopToggle.cloneNode(true));
                    const freshButton = document.getElementById('playStopToggleBtn');
                    // If LOOP is toggled OFF at any time, immediately stop and kill audio
                    if (loopCheckbox && !loopCheckbox._wiredForStop) {
                        loopCheckbox._wiredForStop = true;
                        loopCheckbox.addEventListener('change', () => {
                            if (!loopCheckbox.checked) {
                                try {
                                    omnichord.stopAllActiveNotes();
                                    try { omnichord.stopAllDrums && omnichord.stopAllDrums(); } catch(_){ }
                                    try { omnichord._resetDrumPlayhead && omnichord._resetDrumPlayhead(); } catch(_){ }
                                    omnichord._sustainActive = false;
                                    omnichord._chordsGestureActive = false;
                                    omnichord._chordSlideActive = false;
                                    omnichord._stopArp();
                                    try { omnichord._stopArpTransport(); } catch(_){ }
                                    if (omnichord._arp) {
                                        omnichord._arp.pendingSwitch = null;
                                        omnichord._arp.active = false;
                                    }
                                    if (omnichord._seqTimer) {
                                        clearTimeout(omnichord._seqTimer);
                                        omnichord._seqTimer = null;
                                    }
                                    omnichord._isSequencing = false;
                                    omnichord._stopPlayButtonFlashing();
                                    if (freshButton) {
                                        freshButton.textContent = 'PLAY';
                                        freshButton.style.background = '#27ae60';
                                        freshButton.style.borderColor = '#2ecc71';
                                    }
                                } catch(_){ }
                            }
                        });
                    }
                    
                    freshButton.addEventListener('click', () => {
                        console.log('🎵 BRACKET-AWARE CLICK HANDLER CALLED');
                        console.log('🎵 DEBUG: omnichord._isSequencing =', omnichord._isSequencing);
                        
                        if (omnichord._isSequencing) {
                            // Currently playing - stop it
                            try {
                                omnichord.stopAllActiveNotes();
                                try { omnichord.stopAllDrums && omnichord.stopAllDrums(); } catch(_){ }
                                try { omnichord._resetDrumPlayhead && omnichord._resetDrumPlayhead(); } catch(_){ }
                                omnichord._sustainActive = false;
                                omnichord._chordsGestureActive = false;
                                omnichord._chordSlideActive = false;
                                omnichord._stopArp();
                                try { omnichord._stopArpTransport(); } catch(_){ }
                                if (omnichord._arp) {
                                    omnichord._arp.pendingSwitch = null;
                                    omnichord._arp.active = false;
                                }
                                if (omnichord._seqTimer) {
                                    clearTimeout(omnichord._seqTimer);
                                    omnichord._seqTimer = null;
                                }
                                omnichord._isSequencing = false;
                                omnichord._stopPlayButtonFlashing();
                                
                                // Update button to show PLAY state
                                freshButton.textContent = 'PLAY';
                                freshButton.style.background = '#27ae60';
                                freshButton.style.borderColor = '#2ecc71';
                            } catch (e) {
                                console.error('Error stopping sequence:', e);
                            }
                        } else {
                            console.log('🎵 DEBUG: Starting new sequence...');
                            // Currently stopped - start playing from bar 1
                            try {
                                // Stop any existing sequence first
                                omnichord.stopAllActiveNotes();
                                omnichord._sustainActive = false;
                                omnichord._chordsGestureActive = false;
                                omnichord._chordSlideActive = false;
                                omnichord._stopArp();
                                if (omnichord._arp) {
                                    omnichord._arp.pendingSwitch = null;
                                    omnichord._arp.active = false;
                                }
                                if (omnichord._seqTimer) {
                                    clearTimeout(omnichord._seqTimer);
                                    omnichord._seqTimer = null;
                                }
                                omnichord._isSequencing = false;
                                
                                // Enhanced synchronization: Ensure all transport systems start on beat 1 together
                                console.log('🎵 SYNCHRONIZED STARTUP: Preparing all transport systems');
                                
                                // 1. PRELOAD AND SYNC ALL TRANSPORT SYSTEMS
                                omnichord._ensureArpDefaults();
                                omnichord._ensureArpTransport();
                                omnichord._refreshArpTransportTiming();
                                
                                // 2. PRELOAD DRUM PATTERNS (ensure at least 1 bar ready)
                                try {
                                    if (window._patternTransport) {
                                        // Sync drum transport BPM with arp transport
                                        window._patternTransport.bpm = omnichord._arpTransport.bpm;
                                        // Preload current drum pattern for immediate playback
                                        const drumSteps = document.querySelectorAll('.drum-step.active');
                                        if (drumSteps.length > 0) {
                                            console.log('🎵 PRELOAD: Drum pattern ready with', drumSteps.length, 'active steps');
                                        }
                                    }
                                } catch(e) { console.log('🎵 Drum preload error:', e); }
                                
                                // 3. PRELOAD BASS PATTERNS
                                try {
                                    if (omnichord.bassEnabled && omnichord._arp) {
                                        // Ensure bass frequency is calculated and ready
                                        const activeCol = document.querySelector('.chord-column.active') || document.querySelector('.chord-column');
                                        if (activeCol) {
                                            const step = omnichord._getEffectiveColumnRootStep(activeCol);
                                            const bassFreq = omnichord._computeBassFreqInRange(step, null, omnichord.currentTuning || 12);
                                            if (bassFreq) {
                                                omnichord._arp.bassFreq = bassFreq;
                                                console.log('🎵 PRELOAD: Bass frequency ready at', bassFreq.toFixed(2), 'Hz');
                                            }
                                        }
                                    }
                                } catch(e) { console.log('🎵 Bass preload error:', e); }
                                
                                // 4. RESET ALL COUNTERS TO ENSURE SYNCHRONIZED START ON BEAT 1
                                if (omnichord._arpTransport) {
                                    omnichord._arpTransport.tickCounter = 0;
                                    omnichord._arpTransport.absTickCounter = 0;
                                    omnichord._arpTransport.beatCounter = 0;
                                    omnichord._arpTransport.barCounter = 0;
                                    console.log('🎵 SYNC: All transport counters reset to 0');
                                }
                                
                                if (window._patternTransport) {
                                    window._patternTransport.stepIndex = 0;
                                    window._patternTransport.beatCounter = 0;
                                    console.log('🎵 SYNC: Drum pattern counters reset to 0');
                                }
                                
                                // 5. START ALL SYSTEMS SIMULTANEOUSLY
                                console.log('🎵 SYNC: Starting all transport systems together...');
                                
                                // Start sequencing mode
                                omnichord._isSequencing = true;
                                
                                // Start play button flashing in time with BPM
                                omnichord._startPlayButtonFlashing();
                                
                                // Read other UI values that might affect the sequence
                                const npcEl = document.getElementById('universalNpc');
                                const patternEl = document.getElementById('universalPattern');
                                const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                                
                                if (omnichord._arp) {
                                    if (npcEl) omnichord._arp.npc = Math.max(1, Number(npcEl.value) || 3);
                                    if (patternEl) omnichord._arp.pattern = patternEl.value || 'up';
                                    if (holdEl) omnichord._arp.chordsHold = holdEl.value || 'bar:1';
                                }
                                
                                // Don't start if no module is enabled (include drums)
                                const hasDrums = !!document.querySelector('.drum-step.active');
                                if (!omnichord.chordsEnabled && !omnichord.arpEnabled && !omnichord.bassEnabled && !hasDrums){
                                    omnichord._stopPlayButtonFlashing();
                                    return;
                                }
                                
                                // Build a row-major ordered list of columns (left-to-right, then next row)
                                console.log('🎵 DEBUG: About to query for columns...');
                                let cols = Array.from(document.querySelectorAll('#extensionColumns .extension-column'));
                                console.log('🎵 DEBUG: Found', cols.length, 'basic extension columns');
                                if (!cols.length) {
                                    console.log('🎵 DEBUG: No columns found - stopping');
                                    omnichord._stopPlayButtonFlashing();
                                    return;
                                }
                                
                                // Get ALL columns including repeat markers for bracket-aware sequencing
                                let allCols = Array.from(document.querySelectorAll('#extensionColumns .extension-column, #extensionColumns .repeat-marker-column'));
                                
                                console.log('🎵 DEBUG: Found', allCols.length, 'total columns for sequencing');
                                console.log('🎵 DEBUG: Column details:', allCols.map((col, i) => ({
                                    index: i,
                                    class: col.className,
                                    text: col.textContent?.trim(),
                                    isExtColumn: col.classList.contains('extension-column'),
                                    isRepeatColumn: col.classList.contains('repeat-marker-column')
                                })));
                                
                                // Sort all columns in visual order first
                                const sortRowMajor = (list)=> list.sort((a,b)=>{
                                    const ra = a.getBoundingClientRect();
                                    const rb = b.getBoundingClientRect();
                                    // Consider elements on the same visual row if their tops are close
                                    const dy = Math.round(ra.top - rb.top);
                                    if (Math.abs(dy) > 4) return dy; // different rows: top first
                                    return ra.left - rb.left; // same row: left to right
                                });
                                allCols = sortRowMajor(allCols);
                                
                                console.log('🎵 All columns for bracket-aware sequencing:', allCols.map(col => ({
                                    class: col.className,
                                    text: col.textContent?.trim(),
                                    nestLevel: col.dataset?.nestLevel
                                })));
                                console.log('🎵 First 6 columns details:');
                                for (let i = 0; i < Math.min(6, allCols.length); i++) {
                                    console.log(`🎵 Index ${i}:`, {
                                        class: allCols[i].className,
                                        text: allCols[i].textContent.trim(),
                                        isChord: allCols[i].classList.contains('extension-column'),
                                        isBracketMarker: allCols[i].classList.contains('repeat-marker-column')
                                    });
                                }
                                
                                // Decide a robust starting point: prefer outer '[' then first chord
                                const firstOuterStartIdx = allCols.findIndex(col => col.classList.contains('repeat-marker-column') && (col.textContent?.trim() === '['));
                                const firstChordIdx = allCols.findIndex(col => col.classList.contains('extension-column'));
                                const startIdx = (firstOuterStartIdx >= 0 ? firstOuterStartIdx : firstChordIdx);
                                if (startIdx === -1) {
                                    console.warn('🎵 No valid start item (no [ marker or chord) — aborting');
                                    omnichord._stopPlayButtonFlashing();
                                    return;
                                }
                                // Use bracket-aware sequencing instead of pre-expansion
                                let sequenceIndex = startIdx;
                                let bracketStack = []; // Stack to track bracket positions and repeat counts
                                
                                const findNextChordIndex = (startIndex) => {
                                    console.log('🎵 Looking for bracket markers starting from index:', startIndex);
                                    console.log('🎵 DEBUG: allCols length:', allCols.length);
                                    console.log('🎵 DEBUG: allCols[0-5] content:', allCols.slice(0, 6).map(col => ({
                                        class: col.className,
                                        text: col.textContent.trim()
                                    })));
                                    
                                    // If we're inside a bracket, use a scanning cursor so nested markers are handled
                                    if (bracketStack.length > 0) {
                                        const b = bracketStack[bracketStack.length - 1];
                                        let i = Math.max(b.cursor || (b.startIndex + 1), startIndex);
                                        console.log('🎵 Inside bracket, scanning from cursor:', i, 'to endIndex:', b.endIndex);
                                        for (; i <= b.endIndex && i < allCols.length; i++) {
                                            const c = allCols[i];
                                            const t = c.textContent.trim();
                                            if (c.classList.contains('extension-column')) {
                                                // Schedule this chord and advance cursor
                                                b.cursor = i + 1;
                                                console.log('🎵 Bracket scan found chord at', i);
                                                return i;
                                            }
                                            if (c.classList.contains('repeat-marker-column')) {
                                                // Let scheduler route markers (nested [ or matching ]/ ]x)
                                                b.cursor = i;
                                                console.log('🎵 Bracket scan hit marker at', i, t);
                                                return i;
                                            }
                                        }
                                        console.warn('🎵 Bracket cursor reached end without finding next item; falling back');
                                    }
                                    
                                    // Normal case: look for next chord or bracket marker
                                    for (let i = startIndex; i < allCols.length; i++) {
                                        const col = allCols[i];
                                        const text = col.textContent.trim();
                                        
                                        console.log('🎵 Scanning index', i, ':', {
                                            class: col.className,
                                            text: text
                                        });
                                        
                                        if (col.classList.contains('repeat-marker-column')) {
                                            console.log('🎵 Found bracket/repeat marker at index', i, '- calling handleBracketLogic');
                                            return i;
                                        } else if (col.classList.contains('extension-column')) {
                                            console.log('🎵 Found next chord at index', i, '- normal progression');
                                            return i;
                                        }
                                    }
                                    return -1;
                                };
                                
                                const handleBracketLogic = (currentIndex) => {
                                    const col = allCols[currentIndex];
                                    const text = col.textContent.trim();
                                    
                                    console.log('🎵 Handling bracket logic at index', currentIndex, 'text:', text);
                                    
                                    if (text === '[') {
                                        // If this is an auto outer and LOOP is OFF, ignore the bracket
                                        try {
                                            const loopChk0 = document.getElementById('playLoop');
                                            if (col.dataset && col.dataset.autoOuter === 'true' && (!loopChk0 || !loopChk0.checked)) {
                                                console.log('🎵 Ignoring auto-outer [ because LOOP is OFF');
                                                return currentIndex + 1;
                                            }
                                        } catch(_){ /* no-op */ }
                                        // Level-aware find of matching end (same nest level)
                                        const startLevel = Number(col.dataset.nestLevel || 0);
                                        let depth = 0;
                                        let endIndex = -1;
                                        let repeatCount = null; // null => no explicit number
                                        for (let i = currentIndex + 1; i < allCols.length; i++) {
                                            const sc = allCols[i];
                                            if (!sc.classList.contains('repeat-marker-column')) continue;
                                            const st = sc.textContent.trim();
                                            const lvl = Number(sc.dataset.nestLevel || 0);
                                            if (st === '[' && lvl > startLevel) {
                                                depth++;
                                            } else if ((st === ']' || /^\]x(\d+)$/.test(st))) {
                                                if (lvl > startLevel) {
                                                    if (depth > 0) depth--;
                                                } else if (lvl === startLevel && depth === 0) {
                                                    endIndex = i;
                                                    if (/^\]x(\d+)$/.test(st)) repeatCount = parseInt(st.match(/^\]x(\d+)$/)[1], 10);
                                                    break;
                                                }
                                            }
                                        }
                                        if (endIndex >= 0) {
                                            const contentStart = currentIndex + 1;
                                            const count = (repeatCount == null ? 0 : repeatCount); // 0 => infinite
                                            console.log('🎵 Found bracket section (level', startLevel, '):', { startIndex: currentIndex, endIndex, repeatCount: count });
                                            bracketStack.push({
                                                startIndex: currentIndex,
                                                endIndex,
                                                contentStart,
                                                cursor: contentStart,
                                                repeatCount: (count === 0 ? Infinity : Math.max(1, count || 1)),
                                                currentRepeat: 1
                                            });
                                            const resolved = findNextChordIndex(contentStart);
                                            return (resolved !== -1 ? resolved : endIndex);
                                        } else {
                                            console.warn('🎵 Malformed bracket - no matching ] or ]x found at same level');
                                            return currentIndex + 1;
                                        }
                                    }
                                    else if (text.match(/^\]x(\d+)$/) || text === ']') {
                                        // If this is an auto outer end and LOOP is OFF, treat as end-of-sequence
                                        try {
                                            const loopChk1 = document.getElementById('playLoop');
                                            if (col.dataset && col.dataset.autoOuter === 'true' && (!loopChk1 || !loopChk1.checked)) {
                                                console.log('🎵 Auto-outer ] encountered with LOOP OFF -> end of sequence');
                                                return allCols.length;
                                            }
                                        } catch(_){ /* no-op */ }
                                        // Handle bracket end + repeat - this should advance the bracket logic
                                        if (bracketStack.length > 0) {
                                            const bracket = bracketStack[bracketStack.length - 1];
                                            // Allow dynamic change by reading marker text/dataset each pass
                                            let explicitCount = null;
                                            if (/^\]x(\d+)$/.test(text)) explicitCount = parseInt(text.match(/^\]x(\d+)$/)[1], 10);
                                            if (col.dataset && col.dataset.repeatCount) explicitCount = parseInt(col.dataset.repeatCount, 10);
                                            if (explicitCount != null) bracket.repeatCount = (explicitCount === 0 ? Infinity : Math.max(1, explicitCount));
                                            console.log('🎵 At bracket end, current repeat:', bracket.currentRepeat, 'of', bracket.repeatCount);
                                            if (bracket.currentRepeat < bracket.repeatCount) {
                                                // Still have repeats left - go back to first chord in bracket
                                                bracket.currentRepeat++;
                                                bracket.cursor = bracket.contentStart;
                                                const resolved = findNextChordIndex(bracket.contentStart);
                                                console.log('🎵 Starting repeat', bracket.currentRepeat, 'jumping to index', resolved);
                                                return (resolved !== -1 ? resolved : bracket.contentStart);
                                            } else {
                                                // Finished all repeats - remove from stack and continue
                                                bracketStack.pop();
                                                console.log('🎵 Finished all bracket repeats, continuing after ]x marker');
                                                return currentIndex + 1;
                                            }
                                        } else {
                                            console.warn('🎵 Found ]x marker without matching [');
                                            return currentIndex + 1;
                                        }
                                    }
                                    else if (text.match(/^[xX](\d+)$/)) {
                                        // Standalone repeat marker - repeats the last bar/chord only
                                        const match = text.match(/^[xX](\d+)$/);
                                        const totalRepeats = parseInt(match[1], 10);
                                        
                                        console.log('🎵 Standalone repeat marker x' + totalRepeats + ' - repeating last chord');
                                        
                                        // Find the previous chord index
                                        let previousChordIndex = -1;
                                        for (let i = currentIndex - 1; i >= 0; i--) {
                                            if (allCols[i].classList.contains('extension-column')) {
                                                previousChordIndex = i;
                                                break;
                                            }
                                        }
                                        
                                        if (previousChordIndex >= 0) {
                                            if (!col.dataset.standaloneRepeatsLeft) {
                                                col.dataset.standaloneRepeatsLeft = totalRepeats - 1;
                                                console.log('🎵 Starting standalone repeats, jumping back to chord at index', previousChordIndex);
                                                return previousChordIndex;
                                            } else {
                                                let repeatsLeft = parseInt(col.dataset.standaloneRepeatsLeft);
                                                repeatsLeft--;
                                                col.dataset.standaloneRepeatsLeft = repeatsLeft;
                                                
                                                if (repeatsLeft > 0) {
                                                    return previousChordIndex;
                                                } else {
                                                    delete col.dataset.standaloneRepeatsLeft;
                                                    console.log('🎵 Finished all standalone repeats');
                                                    return currentIndex + 1;
                                                }
                                            }
                                        } else {
                                            console.warn('🎵 Found standalone repeat marker but no previous chord!');
                                            return currentIndex + 1;
                                        }
                                    }
                                    
                                    return currentIndex + 1;
                                };
                                omnichord._ensureArpDefaults();
                                omnichord._ensureArpTransport();
                                // mark sequencing mode so HOLD and other idle stops don't interfere
                                omnichord._isSequencing = true;
                                const tpBar = omnichord._arpTransport.ticksPerBar || 16;
                                
                                // Get loop checkbox
                                const loopChk = document.getElementById('playLoop');
                                
                                // Add startup buffer to ensure smooth audio playback
                                console.log('🎵 Adding startup buffer to ensure audio readiness...');
                                setTimeout(() => {
                                    console.log('🎵 Startup buffer complete, beginning playback');
                                    console.log('🎵 Initial sequenceIndex is:', sequenceIndex);
                                    // Persist timing across steps (and across wraps) for gapless looping
                                    let nextSwitchAbsTick = null; // absolute tick when the next chord should switch
                                    let holdTicksForStep = null;   // last computed hold ticks
                                    let isFirstStep = true;        // only the very first scheduled step aligns to bar boundary

                                    // Helper: clear standalone xN repeat counters on wrap
                                    const _resetStandaloneRepeatCounters = () => {
                                        try {
                                            for (const c of allCols) {
                                                if (c.classList && c.classList.contains('repeat-marker-column')) {
                                                    if (c.dataset && 'standaloneRepeatsLeft' in c.dataset) {
                                                        delete c.dataset.standaloneRepeatsLeft;
                                                    }
                                                }
                                            }
                                        } catch(_) { /* no-op */ }
                                    };

                                    const scheduleNext = ()=>{
                                        console.log('🎵 scheduleNext called with sequenceIndex:', sequenceIndex);
                                        
                                        // First, check if we're at a bracket marker position
                                        if (sequenceIndex < allCols.length && allCols[sequenceIndex].classList.contains('repeat-marker-column')) {
                                            console.log('🎵 Found bracket marker at current index, handling bracket logic first');
                                            let nextIndex = handleBracketLogic(sequenceIndex);
                                            // Collapse successive markers so we land on a real chord (or end)
                                            while (nextIndex !== -1 && nextIndex < allCols.length && !allCols[nextIndex].classList.contains('extension-column')) {
                                                const advanced = handleBracketLogic(nextIndex);
                                                if (advanced === nextIndex) break; // safety to prevent infinite loop
                                                nextIndex = advanced;
                                            }
                                            if (nextIndex !== -1) {
                                                sequenceIndex = nextIndex;
                                                console.log('🎵 Bracket logic set new sequenceIndex to:', sequenceIndex);
                                            }
                                        }
                                        
                                        // Resolve current chord to schedule (bracket-aware)
                                        if (sequenceIndex >= allCols.length) {
                                            // End-of-sequence; handled after scheduling block
                                        } else if (!allCols[sequenceIndex].classList.contains('extension-column')) {
                                            // Not currently on a chord: resolve to the next real chord (skip markers)
                                            let resolved = findNextChordIndex(sequenceIndex);
                                            // If we hit a marker, run its logic until we reach a chord or end
                                            while (resolved !== -1 && resolved < allCols.length && !allCols[resolved].classList.contains('extension-column')) {
                                                const advanced = handleBracketLogic(resolved);
                                                if (advanced === resolved) break; // safety
                                                resolved = (advanced >= 0 ? advanced : -1);
                                                if (resolved !== -1 && resolved < allCols.length && !allCols[resolved].classList.contains('extension-column')) {
                                                    // Try to find the next chord again from the new position
                                                    resolved = findNextChordIndex(resolved);
                                                }
                                            }
                                            if (resolved === -1 || resolved >= allCols.length) {
                                                // Reached end of sequence
                                                if (loopChk && loopChk.checked){
                                                    console.log('🎵 Looping back to start');
                                                    // Do NOT clear pending switch or stop transport here; allow the current
                                                    // chord switch to occur, then wrap cleanly on the next scheduleNext call.
                                                    _resetStandaloneRepeatCounters();
                                                    // Reset to actual first chord index for the next step after hold
                                                    sequenceIndex = startIdx;
                                                    bracketStack = [];
                                                    // Pre-resolve first chord index so the following step lands on a real chord
                                                    const nextResolved = findNextChordIndex(startIdx);
                                                    if (nextResolved !== -1 && nextResolved < allCols.length) {
                                                        sequenceIndex = nextResolved;
                                                    }
                                                } else {
                                                    // LOOP OFF: Stop everything and reset to ready state
                                                    try {
                                                        omnichord.stopAllActiveNotes();
                                                        try { omnichord.stopAllDrums && omnichord.stopAllDrums(); } catch(_){ }
                                                        try { omnichord._resetDrumPlayhead && omnichord._resetDrumPlayhead(); } catch(_){ }
                                                        omnichord._sustainActive = false; 
                                                        omnichord._chordsGestureActive = false; 
                                                        omnichord._chordSlideActive = false;
                                                        omnichord._stopArp();
                                                        try { omnichord._stopArpTransport(); } catch(_){ }
                                                        if (omnichord._arp) {
                                                            omnichord._arp.pendingSwitch = null;
                                                            omnichord._arp.active = false;
                                                        }
                                                        sequenceIndex = startIdx;
                                                        bracketStack = [];
                                                        freshButton.textContent = 'PLAY';
                                                        freshButton.style.background = '#27ae60';
                                                        freshButton.style.borderColor = '#2ecc71';
                                                    } catch(_){ }
                                                    omnichord._isSequencing = false; 
                                                    omnichord._stopPlayButtonFlashing();
                                                    return;
                                                }
                                            } else {
                                                sequenceIndex = resolved;
                                                console.log('🎵 Resolved to first chord at index:', sequenceIndex);
                                            }
                                        }
                                        
                                        // Safety check after resolution
                                        if (sequenceIndex >= allCols.length) {
                                            if (loopChk && loopChk.checked){
                                                console.log('🎵 Looping back to start');
                                                // Do not stop/clear ARP here; allow current switch to complete
                                                _resetStandaloneRepeatCounters();
                                                sequenceIndex = startIdx;
                                                bracketStack = [];
                                                // Pre-resolve first chord index to ensure we land on a real chord
                                                const nextResolved = findNextChordIndex(startIdx);
                                                if (nextResolved !== -1 && nextResolved < allCols.length) {
                                                    sequenceIndex = nextResolved;
                                                }
                                            } else {
                                                try {
                                                    omnichord.stopAllActiveNotes();
                                                    try { omnichord.stopAllDrums && omnichord.stopAllDrums(); } catch(_){ }
                                                    try { omnichord._resetDrumPlayhead && omnichord._resetDrumPlayhead(); } catch(_){ }
                                                    omnichord._sustainActive = false; 
                                                    omnichord._chordsGestureActive = false; 
                                                    omnichord._chordSlideActive = false;
                                                    omnichord._stopArp();
                                                    try { omnichord._stopArpTransport(); } catch(_){ }
                                                    if (omnichord._arp) {
                                                        omnichord._arp.pendingSwitch = null;
                                                        omnichord._arp.active = false;
                                                    }
                                                    sequenceIndex = startIdx;
                                                    bracketStack = [];
                                                    freshButton.textContent = 'PLAY';
                                                    freshButton.style.background = '#27ae60';
                                                    freshButton.style.borderColor = '#2ecc71';
                                                } catch(_){ }
                                                omnichord._isSequencing = false; 
                                                omnichord._stopPlayButtonFlashing();
                                                return;
                                            }
                                        }
                                        
                                        // At this point, sequenceIndex is the CURRENT chord to schedule
                                        console.log('🎵 Scheduling CURRENT chord at index:', sequenceIndex);
                                    
                                    // Continue with chord switching logic for CURRENT chord
                                    const col = allCols[sequenceIndex];
                                    console.log('🎵 Playing chord at index', sequenceIndex, ':', col.querySelector('.chord-name')?.textContent);
                                    
                                    try {
                                        
                                        // Force-sync transport to bar start before first schedule so BASS/DRUMS/ARP fire together
                                        if (isFirstStep) {
                                            omnichord._arpTransport.tickCounter = 0;
                                            omnichord._arpTransport.absTickCounter = (omnichord._arpTransport.absTickCounter|0);
                                        }
                                        const curTick = omnichord._arpTransport.tickCounter|0;
                                        const absNow = omnichord._arpTransport.absTickCounter|0;
                                        
                                        // Get the column header to extract chord name and root AFTER chord is named
                                        const header = col.querySelector('.extension-column-header');
                                        const chordName = header ? header.textContent.trim() : '';
                                        
                                        // Extract root note from chord name for bass (e.g., "C7" -> "C", "F#m" -> "F#")
                                        let chordRoot = null;
                                        if (chordName){
                                            // Scan for a valid bass note by matching sharp/flat notation
                                            const bassMatch = chordName.match(/^([A-G][#♯b♭]?)/);
                                            if (bassMatch) chordRoot = bassMatch[1].replace(/[♯]/g,'#').replace(/[♭]/g,'b');
                                        }
                                        if (chordRoot && omnichord.bassEnabled){
                                            // Schedule bass note
                                            const baseFreq = omnichord.noteNameToFrequency(chordRoot + '2')||55;
                                            omnichord._arp.bassFreq = baseFreq;
                                        } else {
                                            omnichord._arp.bassFreq = null;
                                        }
                                        
                                        // Determine HOLD length in ticks once per step
                                        const holdSel = document.getElementById('universalHold') || document.getElementById('chordHold');
                                        const hold = holdSel ? String(holdSel.value||'bar:1') : (omnichord._arp?.chordsHold || 'bar:1');
                                        const [kind, valStr] = String(hold).split(':');
                                        const n = Math.max(1, parseInt(valStr||'1',10));
                                        const tpBeat = omnichord._arpTransport.ticksPerBeat || 1;
                                        const holdTicks = (kind==='beat') ? n*tpBeat : n*tpBar;
                                        holdTicksForStep = holdTicks;
                                        
                                        let targetAbsTick = absNow;
                                        if (isFirstStep){
                                            // First-ever step after pressing PLAY: align to immediate bar downbeat
        									const ticksToNextBar = (tpBar - (curTick % tpBar)) % tpBar;
                                            targetAbsTick = absNow + (ticksToNextBar > 0 ? 0 : 0);
                                            nextSwitchAbsTick = (targetAbsTick + holdTicks) >>> 0;
                                            isFirstStep = false;
                                        } else if (Number.isFinite(nextSwitchAbsTick)) {
                                            // Gapless advance (also when wrapping to index 0)
                                            targetAbsTick = nextSwitchAbsTick >>> 0;
                                            nextSwitchAbsTick = (nextSwitchAbsTick + holdTicks) >>> 0;
                                        }
                                        
                                        // Prepare a quick sequence from column strings
                                        const rows = Array.from(col.querySelectorAll('.strings-column .string'));
                                        // During PLAY, treat module toggles as independent lanes; all align to the same grid
                                        const chordsOn = !!omnichord.chordsEnabled;
                                        const arpOn = !!omnichord.arpEnabled;
                                        // Determine NPC: include all unique chord degrees (tensions) during PLAY
                                        const npcUI = (function(){
                                            const n1 = parseInt(document.getElementById('universalNpc')?.value||'');
                                            const n = Number.isFinite(n1)? n1 : (omnichord._arp?.npc||3);
                                            return Math.max(1, Math.min(64, n|0));
                                        })();
                                        // Build CHORD ladder (for sustain voices) and ARP ladder independently
                                        // Build ARP/CHORD ladders, but keep ARP in higher octaves (>=5)
                                        const ascAll = rows.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0) - (parseFloat(b.dataset.frequency)||0));
                                        const ascHigh = ascAll.filter(r => (parseInt(r.dataset.octave||'0',10) >= 5));
                                        // CHORD ladder: optionally group by octave and anchor to last tapped octave
                                        let chordLadder = ascAll;
                                        // Prefer higher-octave chord tones when available to keep chord+ARP texture consistent
                                        const chordHigh = ascAll.filter(r => (parseInt(r.dataset.octave||'0',10) >= 5));
                                        if (chordHigh.length) chordLadder = chordHigh;
                                        if (typeof omnichord.groupStringsByOctave === 'function'){
                                            try {
                                                const { groups } = omnichord.groupStringsByOctave(ascAll);
                                                const baseOct = Number.isFinite(omnichord._lastTappedOctave) ? omnichord._lastTappedOctave : 4;
                                                const filtered = groups.filter(g => Array.isArray(g) && g.length && parseInt(g[0]?.dataset?.octave||'0',10) >= baseOct);
                                                chordLadder = (filtered.length? filtered : groups).flat();
                                            } catch(_){ /* keep ascAll */ }
                                        }
                                        // Expand to all available unique chord degrees so tensions are included
                                        let npcEffective = npcUI;
                                        try {
                                            const edo = omnichord.currentTuning||12;
                                            const norm = (x)=> ((x%edo)+edo)%edo;
                                            const rootAbs = (typeof omnichord._getEffectiveColumnRootStep === 'function') ? omnichord._getEffectiveColumnRootStep(col) : (omnichord.currentRoot||0);
                                            const steps = rows.map(r=> parseInt(r.dataset.noteIndex,10)).filter(n=>Number.isFinite(n));
                                            const uniqDeg = Array.from(new Set(steps.map(st=> norm(st - rootAbs))));
                                            if (uniqDeg.length > npcEffective) npcEffective = uniqDeg.length;
                                        } catch(_) { /* keep npcEffective */ }
                                        const chordRows = chordLadder.slice(0, npcEffective);
                                        
                                        // ARP ladder: rotate to start octave then take NPC and apply pattern
                                        const startOctRaw = Number.isFinite(omnichord._lastTappedOctave) ? omnichord._lastTappedOctave : 4;
                                        const startOct = Math.max(5, startOctRaw);
                                        let rotIndex = ascHigh.findIndex(r => (parseInt(r.dataset.octave||'0',10) >= startOct));
                                        if (rotIndex < 0) rotIndex = 0;
                                        const rotated = (ascHigh.length ? ascHigh : ascAll);
                                        const rotated2 = rotIndex > 0 ? (rotated.slice(rotIndex).concat(rotated.slice(0, rotIndex))) : rotated;
                                        
                                        // Apply pattern to generate proper ARP sequence
                                        let arpSeq = [];
                                        if (arpOn) {
                                            const pattern = omnichord._arp?.pattern || 'up';
                                            // Use builder only for custom typed patterns; otherwise, build from npcEffective so tensions are included
                                            let usedBuilder = false;
                                            try {
                                                const txtEl = document.getElementById('universalPatternText');
                                                const hasCustom = !!(txtEl && String(txtEl.value||'').trim());
                                                if (hasCustom) {
                                                    const sourceRows = chordRows.length ? chordRows : (ascHigh.length ? ascHigh : ascAll);
                                                    const built = omnichord._buildArpSequence(sourceRows, pattern, null) || [];
                                                    if (built.length) { arpSeq = built; usedBuilder = true; }
                                                }
                                            } catch(_) { /* fall through to pattern fallback */ }
                                            if (!usedBuilder) {
                                                // Fallback to simple patterns over the available degrees, limited to UI NPC
                                                const npcSlice = rotated2.slice(0, npcUI);
                                                switch (pattern) {
                                                    case 'up':
                                                        arpSeq = npcSlice;
                                                        break;
                                                    case 'down':
                                                        arpSeq = npcSlice.slice().reverse();
                                                        break;
                                                    case 'updown':
                                                        arpSeq = npcSlice;
                                                        if (npcSlice.length > 2) {
                                                            const desc = npcSlice.slice(1, -1).reverse();
                                                            arpSeq.push(...desc);
                                                        }
                                                        break;
                                                    case 'downup': {
                                                        const descSeq = npcSlice.slice().reverse();
                                                        arpSeq = descSeq;
                                                        if (descSeq.length > 2) {
                                                            const asc = descSeq.slice(1, -1).reverse();
                                                            arpSeq.push(...asc);
                                                        }
                                                        break;
                                                    }
                                                    case 'random':
                                                        arpSeq = npcSlice.slice().sort(() => Math.random() - 0.5);
                                                        break;
                                                    default:
                                                        arpSeq = npcSlice;
                                                }
                                            }
                                        }
                                        const mapAscRef = rotated2;
                                        omnichord._arp.pendingSwitch = {
                                            atAbsTick: targetAbsTick >>> 0,
                                            alignPhaseToTickCounter: true, // align seq phase to transport tick
                                            // Run ARP ticks while optionally sustaining a full chord
                                            seq: arpSeq,
                                            bassFreq: omnichord._arp.bassFreq,
                                            column: col,
                                            mapAsc: mapAscRef,
                                            mode: 'arp',
                                            npc: npcUI,
                                            enableChord: chordsOn,
                                            chordRows
                                        };
                                        // Ensure HOLD doesn't cut transport during sequencing
                                        omnichord._arpTransport.holdStopAtAbsTick = null;
                                        omnichord._startArpTransport();
                                        
                                        // Handle sequence advancement with bracket logic
                                        let nextIndex = sequenceIndex + 1;
                                        
                                        console.log('🎵 Looking for bracket markers starting from index:', nextIndex);
                                        console.log('🎵 DEBUG: allCols length:', allCols.length);
                                        console.log('🎵 DEBUG: allCols[0-5] content:', allCols.slice(0, 6).map(col => ({ 
                                            class: col.className,
                                            text: col.textContent?.trim()
                                        })));
                                        
                                        // Scan ahead to find any bracket markers or repeat markers
                                        let foundBracketLogic = false;
                                        let scanIndex = nextIndex;
                                        
                                        while (scanIndex < allCols.length && !foundBracketLogic) {
                                            const scanCol = allCols[scanIndex];
                                            const scanText = scanCol.textContent?.trim() || '';
                                            console.log('🎵 Scanning index', scanIndex, ':', {
                                                class: scanCol.className,
                                                text: scanText
                                            });
                                            
                                            // Check if this is a bracket or repeat marker by content or class
                                            const isBracketMarker = scanCol.classList.contains('repeat-marker-column') || 
                                                                   scanText === '[' || scanText === ']' || 
                                                                   scanText.match(/^[xX]\d+$/) ||
                                                                   scanText.match(/^\]x\d+$/); // Combined bracket end + repeat
                                            
                                            if (isBracketMarker) {
                                                console.log('🎵 Found bracket/repeat marker at index', scanIndex, '- calling handleBracketLogic');
                                                nextIndex = handleBracketLogic(scanIndex);
                                                // Collapse successive markers so nextIndex lands on a chord or end
                                                while (nextIndex !== -1 && nextIndex < allCols.length && !allCols[nextIndex].classList.contains('extension-column')) {
                                                    const advanced = handleBracketLogic(nextIndex);
                                                    if (advanced === nextIndex) break; // safety
                                                    nextIndex = advanced;
                                                }
                                                foundBracketLogic = true;
                                                break;
                                            } else if (scanCol.classList.contains('extension-column')) {
                                                // Hit another chord before finding bracket logic - normal progression
                                                console.log('🎵 Found next chord at index', scanIndex, '- normal progression');
                                                nextIndex = scanIndex;
                                                break;
                                            } else {
                                                // Skip other elements (separators, etc.)
                                                scanIndex++;
                                            }
                                        }
                                        
                                        if (!foundBracketLogic && scanIndex >= allCols.length) {
                                            console.log('🎵 Reached end of sequence');
                                            nextIndex = allCols.length; // End of sequence
                                        }
                                        
                                        sequenceIndex = nextIndex;
                                        console.log('🎵 Advanced sequence index to:', sequenceIndex);
                                        
                                        // If we advanced past the end, either loop or stop now (before scheduling next tick)
                                        if (sequenceIndex >= allCols.length) {
                                            if (loopChk && loopChk.checked){
                                                console.log('🎵 Looping back to start after reaching end');
                                                // Allow the current chord to sound fully; wrap indices only
                                                _resetStandaloneRepeatCounters();
                                                sequenceIndex = startIdx;
                                                bracketStack = [];
                                            } else {
                                                try {
                                                    omnichord.stopAllActiveNotes();
                                                    omnichord._sustainActive = false; 
                                                    omnichord._chordsGestureActive = false; 
                                                    omnichord._chordSlideActive = false;
                                                    omnichord._stopArp();
                                                    if (omnichord._arp) {
                                                        omnichord._arp.pendingSwitch = null;
                                                        omnichord._arp.active = false;
                                                    }
                                                    freshButton.textContent = 'PLAY';
                                                    freshButton.style.background = '#27ae60';
                                                    freshButton.style.borderColor = '#2ecc71';
                                                } catch(_){ }
                                                omnichord._isSequencing = false; 
                                                omnichord._stopPlayButtonFlashing();
                                                // Reset timing state on full stop
                                                nextSwitchAbsTick = null;
                                                holdTicksForStep = null;
                                                isFirstStep = true;
                                                return;
                                            }
                                        }
                                        
                                        // Calculate proper hold duration in milliseconds (simpler approach)
                                        const bpm = omnichord._arpTransport.bpm || 120;
                                        const beatMs = 60000 / Math.max(20, bpm);
                                        const beatsPerBar = omnichord._arpTransport.beatsPerBar || 4;
                                        const barMs = beatMs * beatsPerBar;
                                        const totalHoldMs = (kind === 'beat') ? (beatMs * n) : (barMs * n);
                                        
                                        // Wait for the hold duration, then schedule next
                                        omnichord._seqTimer = setTimeout(scheduleNext, totalHoldMs);
                                    } catch (err) {
                                        console.error('Error in sequence step:', err);
                                        // Continue to next anyway
                                        sequenceIndex++;
                                        omnichord._seqTimer = setTimeout(scheduleNext, 1000);
                                    }
                                };
                                
                                // Start the sequence
                                scheduleNext();
                                }, 100); // 100ms buffer for audio readiness
                                
                                // Update button to show STOP state
                                freshButton.textContent = 'STOP';
                                freshButton.style.background = '#e74c3c';
                                freshButton.style.borderColor = '#c0392b';
                            } catch (e) {
                                console.error('Error starting sequence:', e);
                            }
                        }
                    });
                }
            } catch (e) {
                console.error('Error setting up play/stop toggle:', e);
            }

            // Wire PLAY (one bar per chord) + Loop + STOP
            try {
                const playBtn = document.getElementById('playSeqBtn');
                const loopChk = document.getElementById('playLoop');
                const stopBtn = document.getElementById('stopSeqBtn');
                
                // DISABLED: playSeqBtn doesn't exist in HTML - this conflicts with bracket-aware playStopToggle
                // The playStopToggleBtn handles all playback with proper bracket support
                
                // Removed playBtn logic to prevent conflicts with bracket-aware sequencing
                
                if (false && playBtn && !playBtn._wired){  // DISABLED
                    playBtn._wired = true;
                    playBtn.addEventListener('click', ()=>{
                        try {
                            // Start PLAY button flashing in time with BPM
                            omnichord._startPlayButtonFlashing();
                            
                            // Sync all transport and ARP settings from UI before starting
                            omnichord._ensureArpDefaults();
                            omnichord._ensureArpTransport();
                            omnichord._refreshArpTransportTiming();
                            
                            // Read other UI values that might affect the sequence
                            const npcEl = document.getElementById('universalNpc');
                            const patternEl = document.getElementById('universalPattern');
                            const holdEl = document.getElementById('universalHold') || document.getElementById('chordHold');
                            
                            if (omnichord._arp) {
                                if (npcEl) omnichord._arp.npc = Math.max(1, Number(npcEl.value) || 3);
                                if (patternEl) omnichord._arp.pattern = patternEl.value || 'up';
                                if (holdEl) omnichord._arp.chordsHold = holdEl.value || 'bar:1';
                            }
                            
                            // Ensure audio is unlocked on user gesture
                                    try { omnichord._sustainActive = false; omnichord._chordsGestureActive = false; omnichord._chordSlideActive = false; } catch(_){ }
                            // If a previous sequencing run is active, stop it cleanly first
                            try { if (omnichord._seqTimer) { clearTimeout(omnichord._seqTimer); omnichord._seqTimer = null; } } catch(_){}
                            try { omnichord._isSequencing = false; } catch(_){}
                            // Don't start if no module is enabled
                            if (!omnichord.chordsEnabled && !omnichord.arpEnabled && !omnichord.bassEnabled){
                                omnichord._stopPlayButtonFlashing();
                                return;
                            }
                            // Build a row-major ordered list of columns (left-to-right, then next row)
                            let cols = Array.from(document.querySelectorAll('#extensionColumns .extension-column'));
                            if (!cols.length) return;
                            const sortRowMajor = (list)=> list.sort((a,b)=>{
                                const ra = a.getBoundingClientRect();
                                const rb = b.getBoundingClientRect();
                                // Consider elements on the same visual row if their tops are close
                                const dy = Math.round(ra.top - rb.top);
                                if (Math.abs(dy) > 4) return dy; // different rows: top first
                                return ra.left - rb.left; // same row: left to right
                            });
                            cols = sortRowMajor(cols);
                            omnichord._ensureArpDefaults();
                            omnichord._ensureArpTransport();
                            // mark sequencing mode so HOLD and other idle stops don't interfere
                            omnichord._isSequencing = true;
                            const tpBar = omnichord._arpTransport.ticksPerBar || 16;
                let i = 0;
                            let nextSwitchAbsTick = null; // absolute tick when the next chord should switch
                let holdTicksForStep = null;   // persist across the scheduleNext closure
                            const scheduleNext = ()=>{
                                if (i >= cols.length){
                                    if (loopChk && loopChk.checked){
                                        // recompute visual order on each loop to respect any layout changes
                                        cols = sortRowMajor(Array.from(document.querySelectorAll('#extensionColumns .extension-column')));
                                        i = 0;
                    } else {
                                        // LOOP OFF: Stop everything and reset to ready state
                                        try {
                                            // Stop all active notes and reset states
                                            omnichord.stopAllActiveNotes();
                                            omnichord._sustainActive = false; 
                                            omnichord._chordsGestureActive = false; 
                                            omnichord._chordSlideActive = false;
                                            
                                            // Stop ARP transport and clear pending switches
                                            omnichord._stopArp();
                                            if (omnichord._arp) {
                                                omnichord._arp.pendingSwitch = null;
                                                omnichord._arp.active = false;
                                            }
                                            
                                            // Reset sequence to beginning for next play
                                            i = 0;
                                        } catch(_){ }
                                        omnichord._isSequencing = false; 
                                        omnichord._stopPlayButtonFlashing();
                                        return;
                                    }
                                }
                                const col = cols[i++];
                                // Trigger ARP start on this column; align the first start to next bar, then advance by HOLD length
                                try {
                                    const curTick = omnichord._arpTransport.tickCounter|0;
                                    const absNow = omnichord._arpTransport.absTickCounter|0;
                                    
                                    // Get the column header to extract chord name and root AFTER chord is named
                                    const header = col.querySelector('.extension-column-header');
                                    const chordName = header ? header.textContent.trim() : '';
                                    
                                    // Extract root note from chord name for bass (e.g., "C7" -> "C", "F#m" -> "F#")
                                    let chordRoot = null;
                                    if (chordName) {
                                        const rootMatch = chordName.match(/^([A-G][#b♯♭]*)/);
                                        if (rootMatch) {
                                            chordRoot = rootMatch[1];
                                        }
                                    }
                                    
                                    // Determine HOLD length in ticks once per step - use universalHold (fallback to chordHold)
                                    const holdSel = document.getElementById('universalHold') || document.getElementById('chordHold');
                                    const hold = holdSel ? String(holdSel.value||'bar:1') : (omnichord._arp?.chordsHold || 'bar:1');
                                    const [kind, valStr] = String(hold).split(':');
                                    const n = Math.max(1, parseInt(valStr||'1',10));
                                    const tpBeat = omnichord._arpTransport.ticksPerBeat || 1;
                                    const holdTicks = (kind==='beat') ? n*tpBeat : n*tpBar;
                    holdTicksForStep = holdTicks;
                                    let targetAbsTick = absNow;
                                    if (i === 1){
                                        const ticksToNextBar = (tpBar - (curTick % tpBar)) % tpBar;
                                        // If we're already on the bar boundary, start immediately (do not wait a full bar)
                                        targetAbsTick = absNow + (ticksToNextBar > 0 ? ticksToNextBar : 0);
                                        nextSwitchAbsTick = (targetAbsTick + holdTicks) >>> 0;
                                    } else if (Number.isFinite(nextSwitchAbsTick)) {
                                        // Lock subsequent switches to the absolute grid
                                        targetAbsTick = nextSwitchAbsTick >>> 0;
                                        nextSwitchAbsTick = (nextSwitchAbsTick + holdTicks) >>> 0;
                                    }
                                    // Prepare a quick sequence from column strings
                                    const rows = Array.from(col.querySelectorAll('.strings-column .string'));
                                    // During PLAY, treat module toggles as independent lanes; all align to the same grid
                                    const chordsOn = !!omnichord.chordsEnabled;
                                    const arpOn = !!omnichord.arpEnabled;
                                    // Treat NPC as global during PLAY
                                    const npcGlobal = (function(){
                                        const n1 = parseInt(document.getElementById('universalNpc')?.value||'');
                                        const n = Number.isFinite(n1)? n1 : (omnichord._arp?.npc||3);
                                        return Math.max(1, Math.min(64, n|0));
                                    })();
                                    // Build CHORD ladder (for sustain voices) and ARP ladder independently
                                    const ascAll = rows.slice().sort((a,b)=> (parseFloat(a.dataset.frequency)||0) - (parseFloat(b.dataset.frequency)||0));
                                    const ascHigh = ascAll.filter(r => (parseInt(r.dataset.octave||'0',10) >= 5));
                                    // CHORD ladder: optionally group by octave and anchor to last tapped octave
                                    let chordLadder = ascAll;
                                    if (typeof omnichord.groupStringsByOctave === 'function'){
                                        try {
                                            const { groups } = omnichord.groupStringsByOctave(ascAll);
                                            const baseOct = Number.isFinite(omnichord._lastTappedOctave) ? omnichord._lastTappedOctave : 4;
                                            const filtered = groups.filter(g => Array.isArray(g) && g.length && parseInt(g[0]?.dataset?.octave||'0',10) >= baseOct);
                                            chordLadder = (filtered.length? filtered : groups).flat();
                                        } catch(_){ /* keep ascAll */ }
                                    }
                                    const chordRows = chordLadder.slice(0, npcGlobal);
                                    
                                    // ARP ladder: use higher octaves (>=5); rotate to start octave then take NPC and apply pattern
                                    const startOctRaw = Number.isFinite(omnichord._lastTappedOctave) ? omnichord._lastTappedOctave : 4;
                                    const startOct = Math.max(5, startOctRaw);
                                    let rotIndex = ascHigh.findIndex(r => (parseInt(r.dataset.octave||'0',10) >= startOct));
                                    if (rotIndex < 0) rotIndex = 0;
                                    const rotatedBase = (ascHigh.length ? ascHigh : ascAll);
                                    const rotated = rotIndex > 0 ? (rotatedBase.slice(rotIndex).concat(rotatedBase.slice(0, rotIndex))) : rotatedBase;
                                    
                                    // Apply pattern to generate proper ARP sequence
                                    let arpSeq = [];
                                    if (arpOn) {
                                        const pattern = omnichord._arp?.pattern || 'up';
                                        // Prefer central builder only when a custom pattern text is provided
                                        let usedBuilder = false;
                                        try {
                                            const txtEl = document.getElementById('universalPatternText');
                                            const hasCustom = !!(txtEl && String(txtEl.value||'').trim());
                                            if (hasCustom) {
                                                const sourceRows = ascHigh.length ? ascHigh : ascAll;
                                                const built = omnichord._buildArpSequence(sourceRows, pattern, null) || [];
                                                if (built.length) { arpSeq = built; usedBuilder = true; }
                                            }
                                        } catch(_) { /* fallback to simple patterns */ }
                                        if (!usedBuilder) {
                                            const npcSlice = rotated.slice(0, npcGlobal);
                                            switch (pattern) {
                                                case 'up':
                                                    arpSeq = npcSlice;
                                                    break;
                                                case 'down':
                                                    arpSeq = npcSlice.slice().reverse();
                                                    break;
                                                case 'updown':
                                                    if (npcSlice.length <= 1) {
                                                        arpSeq = npcSlice;
                                                    } else {
                                                        arpSeq = [...npcSlice];
                                                        if (npcSlice.length > 2) {
                                                            const desc = npcSlice.slice(1, -1).reverse();
                                                            arpSeq.push(...desc);
                                                        }
                                                    }
                                                    break;
                                                case 'downup':
                                                    if (npcSlice.length <= 1) {
                                                        arpSeq = npcSlice;
                                                    } else {
                                                        const descSeq = npcSlice.slice().reverse();
                                                        arpSeq = [...descSeq];
                                                        if (descSeq.length > 2) {
                                                            const asc = descSeq.slice(1, -1).reverse();
                                                            arpSeq.push(...asc);
                                                        }
                                                    }
                                                    break;
                                                case 'walk-up': {
                                                    const L = npcSlice.length;
                                                    if (L <= 2) { arpSeq = npcSlice; break; }
                                                    const motif = [1, 1, -1];
                                                    let idx = 0; arpSeq = [npcSlice[idx]]; let m = 0;
                                                    while (arpSeq.length < npcGlobal) {
                                                        let step = motif[m % motif.length];
                                                        let next = idx + step;
                                                        if (next >= L) { next = L - 2; step = -1; m = (m + 1) % motif.length; }
                                                        else if (next < 0) { next = 1; step = 1; m = (m + 1) % motif.length; }
                                                        else { m = (m + 1) % motif.length; }
                                                        idx = next; arpSeq.push(npcSlice[idx]);
                                                    }
                                                    break;
                                                }
                                                case 'walk-down': {
                                                    const L = npcSlice.length;
                                                    if (L <= 2) { arpSeq = npcSlice.slice().reverse(); break; }
                                                    const motif = [-1, -1, 1];
                                                    let idx = 0; arpSeq = [npcSlice[idx]]; let m = 0;
                                                    while (arpSeq.length < npcGlobal) {
                                                        let step = motif[m % motif.length];
                                                        let next = idx + step;
                                                        if (next >= L) { next = L - 2; step = -1; m = (m + 1) % motif.length; }
                                                        else if (next < 0) { next = 1; step = 1; m = (m + 1) % motif.length; }
                                                        else { m = (m + 1) % motif.length; }
                                                        idx = next; arpSeq.push(npcSlice[idx]);
                                                    }
                                                    break;
                                                }
                                                case 'random':
                                                    arpSeq = npcSlice.slice().sort(() => Math.random() - 0.5);
                                                    break;
                                                case 'alt-ends': {
                                                    const a = npcSlice.slice();
                                                    const out = []; let i = 0, j = a.length - 1;
                                                    while (i <= j) { if (i <= j) out.push(a[i++]); if (i <= j) out.push(a[j--]); }
                                                    arpSeq = out; break;
                                                }
                                                case 'alt-center': {
                                                    const a = npcSlice.slice(); const out = [];
                                                    if (a.length === 0) { arpSeq = out; break; }
                                                    const mid = Math.floor((a.length - 1) / 2); let l = mid, r = mid + 1;
                                                    if (a.length % 2 === 1) { out.push(a[mid]); l = mid - 1; r = mid + 1; }
                                                    while (l >= 0 || r < a.length) { if (r < a.length) out.push(a[r++]); if (l >= 0) out.push(a[l--]); }
                                                    arpSeq = out; break;
                                                }
                                                default:
                                                    arpSeq = npcSlice;
                                            }
                                        }
                                    }
                                    const mapAscRef = rotated;
                                    omnichord._arp.pendingSwitch = {
                                        atAbsTick: targetAbsTick >>> 0,
                                        alignPhaseToTickCounter: true, // align seq phase to transport tick
                                        // Run ARP ticks while optionally sustaining a full chord
                                        seq: arpSeq,
                                        bassFreq: omnichord._arp.bassFreq,
                                        column: col,
                                        mapAsc: mapAscRef,
                                        mode: 'arp',
                                        npc: npcGlobal,
                                        enableChord: chordsOn,
                                        chordRows
                                    };
                                    // Ensure HOLD doesn't cut transport during sequencing
                                    omnichord._arpTransport.holdStopAtAbsTick = null;
                                    omnichord._startArpTransport();
                                } catch(_) {}
                                // Schedule next chord after the configured HOLD length
                                // Use the same holdTicks computed above to keep cadence consistent
                                try { if (omnichord._seqTimer) { clearTimeout(omnichord._seqTimer); } } catch(_){}
                                
                                // Calculate HOLD duration correctly: independent of QUANT
                                // QUANT only affects note subdivision, not bar/beat timing
                                const bpm = omnichord._arpTransport.bpm || 120;
                                const beatMs = 60000 / Math.max(20, bpm);
                                const beatsPerBar = omnichord._arpTransport.beatsPerBar || 4;
                                const barMs = beatMs * beatsPerBar;
                                
                                // Calculate total hold duration based on HOLD setting (min 1/8 note)
                                const holdSel = document.getElementById('universalHold') || document.getElementById('chordHold');
                                const hold = holdSel ? String(holdSel.value||'bar:1') : 'bar:1';
                                const [holdKind, holdValStr] = String(hold).split(':');
                                const holdNum = Math.max(1, parseInt(holdValStr||'1',10));
                                const quantMinMs = beatMs * 0.5; // 1/8 note
                                const baseHoldMs = (holdKind==='beat') ? (beatMs * holdNum) : (barMs * holdNum);
                                const totalHoldMs = Math.max(quantMinMs, baseHoldMs);
                                
                                // Schedule next chord strictly by HOLD duration
                                omnichord._seqTimer = setTimeout(scheduleNext, totalHoldMs);
                            };
                            scheduleNext();
                        } catch(_) {}
                    });
                } // END DISABLED playBtn section
                
                if (stopBtn && !stopBtn._wired){
                    stopBtn._wired = true;
                    stopBtn.addEventListener('click', ()=>{
                        try {
                            // Stop sequencing timer and clear state
                            try { if (omnichord._seqTimer) { clearTimeout(omnichord._seqTimer); omnichord._seqTimer = null; } } catch(_){}
                            omnichord._isSequencing = false;
                            // Clear any sustain/slide flags that could alter next run timing
                            try { omnichord._sustainActive = false; omnichord._chordsGestureActive = false; omnichord._chordSlideActive = false; } catch(_){ }
                            if (omnichord._arp) {
                                omnichord._arp.pendingSwitch = null;
                                omnichord._arp.active = false;
                                omnichord._arp.seq = [];
                            }
                            // Stop transport immediately
                            try { omnichord._stopArpTransport(); } catch(_){ }
                            // Silence all voices (lead and bass)
                            try { omnichord.stopAllActiveNotes(); } catch(_){ }
                        } catch(_) {}
                    });
                }
            } catch(_) {}

        // Auto-hide brand footer only when GLIDE menus are open
            try {
                const brandHost = document.getElementById('brandFooter') || document.getElementById('brandHost');
                const adjustBrand = ()=>{
                    try {
                        if (!brandHost) return;
                        const chordMenuOpen = !!document.getElementById('chordGlideMenu')?.classList.contains('open');
                        const arpMenuOpen = !!document.getElementById('arpGlideMenu')?.classList.contains('open');
                        const hide = chordMenuOpen || arpMenuOpen;
                        brandHost.style.display = hide ? 'none' : 'flex';
                    } catch(_) {}
                };
                window.addEventListener('resize', adjustBrand);
                setInterval(adjustBrand, 1000);
                adjustBrand();
            } catch(_) {}
            
            // Add event handler for chord name saving (ensure no root names are saved)
            const saveChordNameBtn = document.getElementById('saveChordName');
            if (saveChordNameBtn) {
                saveChordNameBtn.addEventListener('click', () => {
                    if (omnichord) {
                        omnichord.saveNewChord();
                    }
                });
            }

            // Startup is now in 24-EDO; do not auto-seed chords to avoid interfering with user-entered sequences
        });
        
        // Add exit prompt for saving to OMG file
        window.addEventListener('beforeunload', (e) => {
            if (omnichord && (omnichord.chordExtensions.length > 0 || omnichord.lockedChords?.size > 0)) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Would you like to save your session to an OMG file?';
                return e.returnValue;
            }
        });
             // Bottom bar panel toggling (uses existing migrated panel-content elements)
             (function(){
                 const bar=document.getElementById('bottomBar');
                 const topMenu=document.getElementById('universalMenu'); // Add top menu for panel buttons
                 const host=document.getElementById('panelHost');
                 if(!host) return;
                 const panels=[...host.querySelectorAll('.panel-content')];
                 let open=null;
                 function show(id){
                     panels.forEach(p=>{p.style.display = (p.dataset.panel===id)?'grid':'none';});
                    host.style.display='block';
                    // Ensure panel is visible at top of viewport
                    try { host.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch(_) {}
                 }
                 function close(){ 
                     host.style.display='none'; 
                     panels.forEach(p=>p.style.display='none'); 
                     open=null; 
                     // Remove active class from both bar and top menu buttons
                     if(bar) bar.querySelectorAll('.panel-btn').forEach(b=>b.classList.remove('active'));
                     if(topMenu) topMenu.querySelectorAll('.panel-btn').forEach(b=>b.classList.remove('active'));
                 }
                 // Expose programmatic closer on the main controller if available
                 if (window.omnichord) {
                     window.omnichord.closeBottomPanel = close;
                 } else {
                     // If not yet initialized, defer until DOMContentLoaded listeners create it
                     document.addEventListener('omnichord-ready', ()=>{ if (window.omnichord) window.omnichord.closeBottomPanel = close; }, { once:true });
                 }
                 
                 // Panel click handler function
                 function handlePanelClick(e) {
                     const btn = e.target.closest('.panel-btn[data-panel]');
                     if(!btn) return; // Ignore non-panel buttons like "+" and "SEQUENCE"
                     const id = btn.dataset.panel;
                     if(!id) return;
                     
                     // Route OSC and FX buttons to floating modals instead of panels
                     if (id === 'osc') {
                         const oscModal = document.getElementById('oscModal');
                         if (oscModal) {
                             oscModal.style.display = 'block';
                             bringModalToFront('oscModal');
                             if (!oscModal._draggableSet) {
                                 makeDraggable(oscModal);
                                 oscModal._draggableSet = true;
                             }
                         }
                         return;
                     }
                     
                     if (id === 'fx') {
                         const fxModal = document.getElementById('fxModal');
                         if (fxModal) {
                             fxModal.style.display = 'block';
                             bringModalToFront('fxModal');
                             if (!fxModal._draggableSet) {
                                 makeDraggable(fxModal);
                                 fxModal._draggableSet = true;
                             }
                         }
                         return;
                     }
                     
                     // Original panel logic for other panels
                     if(open===id){ close(); return; }
                     open = id;
                     show(id);
                     // Set active state on the clicked button only
                     if(bar) bar.querySelectorAll('.panel-btn').forEach(b=>b.classList.toggle('active',b===btn));
                     if(topMenu) topMenu.querySelectorAll('.panel-btn').forEach(b=>b.classList.toggle('active',b===btn));
                 }
                 
                 // Listen for panel buttons in both bottom bar and top menu
                 if(bar) bar.addEventListener('click', handlePanelClick);
                 if(topMenu) topMenu.addEventListener('click', handlePanelClick);
                 
                 window.addEventListener('keydown',e=>{ if(e.key==='Escape') close(); });
                 window.addEventListener('click',e=>{ 
                     if(open && !host.contains(e.target) && 
                        (!bar || !bar.contains(e.target)) && 
                        (!topMenu || !topMenu.contains(e.target))) close(); 
                 });
             })();
             
             // Initialize universal controls
             (function() {
                 // Sync initial values
                 omnichord.syncUniversalControls();
                    // Helper to schedule 2-beat deferred apply
                    function scheduleDeferred(flags){
                        try {
                            omnichord._ensureArpTransport();
                            const tpBeat = Math.max(1, omnichord._arpTransport.ticksPerBeat||1);
                            const nowAbs = omnichord._arpTransport.absTickCounter|0;
                            omnichord._arpTransport.deferApplyAtAbsTick = (nowAbs + (2*tpBeat)) >>> 0;
                            const cur = omnichord._arpTransport.deferFlags || {};
                            omnichord._arpTransport.deferFlags = Object.assign(cur, flags||{});
                        } catch(_) { /* ignore */ }
                    }
                 
                 // Make scheduleDeferred globally accessible for drum controls\n                 window.scheduleDeferred = scheduleDeferred;\n                 // Universal control event handlers
                 const universalBpm = document.getElementById('universalBpm');
                 const universalQuant = document.getElementById('universalQuant');
                 const universalNpc = document.getElementById('universalNpc');
                 const universalHold = document.getElementById('universalHold');
                 const universalPattern = document.getElementById('universalPattern');
                 const universalGlide = document.getElementById('universalGlide');
                 const universalBass = document.getElementById('universalBass');
                 const universalTimeSignature = document.getElementById('universalTimeSignature');
                // Mini Drum header controls (mirror values + events)
                const drumBpmMini = document.getElementById('drumBpmMini');
                const drumTSMini = document.getElementById('drumTSMini');
                const drumQuantMini = document.getElementById('drumQuantMini');
                const drumNpcMini = null; // removed
                const drumSwingMini = null; // removed
                 
                 if (universalBpm) {
                     universalBpm.addEventListener('input', () => {
                         omnichord.applyUniversalSettings();
                         // Defer transport timing change by 2 beats
                         scheduleDeferred({ transport:true });
                         if (drumBpmMini) drumBpmMini.value = String(universalBpm.value||'');
                     });
                 }
                if (drumBpmMini && !drumBpmMini._wired) {
                    drumBpmMini._wired = true;
                    // Initial sync from universal
                    try { drumBpmMini.value = String(document.getElementById('universalBpm')?.value || ''); } catch(_) {}
                    drumBpmMini.addEventListener('input', ()=>{
                        const main = document.getElementById('universalBpm');
                        if (main) { main.value = String(drumBpmMini.value||''); main.dispatchEvent(new Event('input')); }
                    });
                }
                 // Wire MIDI settings controls if present
                 try {
                     const midiOctSel = document.getElementById('midiOctaveOffset');
                     const midiVelInput = document.getElementById('midiDefaultVelocity');
                     if (midiOctSel && !midiOctSel._wired) {
                         midiOctSel._wired = true;
                         midiOctSel.addEventListener('change', ()=>{
                             try { midi.octaveOffset = parseInt(midiOctSel.value||'0',10) || 0; midi.saveMIDISettings(); } catch(_) {}
                             scheduleDeferred({ midi:true });
                         });
                     }
                     if (midiVelInput && !midiVelInput._wired) {
                         midiVelInput._wired = true;
                         midiVelInput.addEventListener('input', ()=>{
                             try {
                                 const v = Math.max(1, Math.min(127, parseInt(midiVelInput.value||'100',10)));
                                 midi.defaultVelocity = v;
                                 midi.saveMIDISettings();
                             } catch(_) {}
                             scheduleDeferred({ midi:true });
                         });
                     }
                 } catch(_) {}
                 
                 if (universalTimeSignature) {
                     universalTimeSignature.addEventListener('change', () => {
                         omnichord.applyUniversalSettings();
                         // Defer grid/transport updates to bar-safe boundary
                         scheduleDeferred({ transport:true, grid:true });
                         if (drumTSMini) drumTSMini.value = String(universalTimeSignature.value||'');
                     });
                 }
                if (drumTSMini && !drumTSMini._wired) {
                    drumTSMini._wired = true;
                    try { drumTSMini.value = String(document.getElementById('universalTimeSignature')?.value || ''); } catch(_) {}
                    drumTSMini.addEventListener('change', ()=>{
                        const main = document.getElementById('universalTimeSignature');
                        if (main) { main.value = String(drumTSMini.value||''); main.dispatchEvent(new Event('change')); }
                    });
                }
                 
                 if (universalQuant) {
                     universalQuant.addEventListener('change', () => {
                         omnichord.applyUniversalSettings();
                         scheduleDeferred({ transport:true });
                         if (drumQuantMini) drumQuantMini.value = String(universalQuant.value||'');
                     });
                 }
                if (drumQuantMini && !drumQuantMini._wired) {
                    drumQuantMini._wired = true;
                    try { drumQuantMini.value = String(document.getElementById('universalQuant')?.value || ''); } catch(_) {}
                    drumQuantMini.addEventListener('change', ()=>{
                        const main = document.getElementById('universalQuant');
                        if (main) { main.value = String(drumQuantMini.value||''); main.dispatchEvent(new Event('change')); }
                    });
                }
                 
                 if (universalNpc) {
                     universalNpc.addEventListener('input', () => {
                         omnichord.applyUniversalSettings();
                     });
                 }
                 
                 if (universalHold) {
                     universalHold.addEventListener('change', () => {
                         omnichord.applyUniversalSettings();
                     });
                 }
                 // Swing control (ARP)
                 const universalSwing = document.getElementById('universalSwing');
                 if (universalSwing && !universalSwing._wired) {
                     universalSwing._wired = true;
                     try {
                         const saved = localStorage.getItem('xen_swing_pct');
                         if (saved != null) universalSwing.value = String(Math.max(0, Math.min(75, parseFloat(saved)||0)));
                     } catch(_) {}
                     universalSwing.addEventListener('input', ()=>{
                         try {
                             const v = Math.max(0, Math.min(75, parseFloat(universalSwing.value||'0')));
                             if (!omnichord._arpTransport) omnichord._ensureArpTransport();
                             if (omnichord._arpTransport) {
                                 if (omnichord._arpTransport.running) {
                                     omnichord._arpTransport.pendingSwingPct = v;
                                 } else {
                                     omnichord._arpTransport.swingPct = v;
                                 }
                             }
                             try { localStorage.setItem('xen_swing_pct', String(v)); } catch(_) {}
                         } catch(_) {}
                         scheduleDeferred({ swing:true });
                     });
                 }
                 
                 if (universalPattern) {
                     // Store previous NPC for CUSTOM mode switching
                     if (!window._previousNpcForCustom) {
                         window._previousNpcForCustom = 3; // default
                     }
                     
                     universalPattern.addEventListener('change', () => {
                         const universalNpc = document.getElementById('universalNpc');
                         const selectedPattern = universalPattern.value;
                         const patternTextEl = document.getElementById('universalPatternText');
                         
                         if (selectedPattern === 'custom') {
                             // Switching TO CUSTOM: store current NPC and ALWAYS set to 9
                             if (universalNpc) {
                                 const currentNpc = parseInt(universalNpc.value) || 3;
                                 if (currentNpc !== 9) {
                                     window._previousNpcForCustom = currentNpc;
                                 }
                                 universalNpc.value = '9'; // ALWAYS 9 for CUSTOM - NO EXCEPTIONS
                                 universalNpc.readOnly = true; // Lock NPC field in CUSTOM mode
                                 console.log('CUSTOM mode: stored previous NPC', window._previousNpcForCustom, 'and LOCKED NPC to 9');
                             }
                             // Clear pattern text initially for CUSTOM mode
                             if (patternTextEl) patternTextEl.value = '';
                         } else {
                             // Switching FROM CUSTOM to regular pattern: unlock NPC and restore previous value
                             if (universalNpc) {
                                 universalNpc.readOnly = false; // Unlock NPC field
                                 if (window._previousNpcForCustom !== undefined) {
                                     universalNpc.value = String(window._previousNpcForCustom);
                                     console.log('Regular pattern mode: unlocked NPC and restored to', window._previousNpcForCustom);
                                 }
                             }
                             // Clear pattern text AND grid for non-CUSTOM modes
                             if (patternTextEl) patternTextEl.value = '';
                             
                             // Clear pattern grid visual state
                             const patternGrid = document.getElementById('patternGrid');
                             if (patternGrid) {
                                 const activeSteps = patternGrid.querySelectorAll('.pattern-step.active');
                                 activeSteps.forEach(step => step.classList.remove('active'));
                             }
                         }
                         
                         omnichord.applyUniversalSettings();
                         omnichord.updateModeUI(); // Update strum button text when pattern changes
                     });
                 }
                 const universalPatternText = document.getElementById('universalPatternText');
                 // Initialize pattern text as empty on startup (only populate when CUSTOM mode is selected)
                 if (universalPatternText) {
                     universalPatternText.value = '';
                 }
                 if (universalPatternText && !universalPatternText._wired) {
                     universalPatternText._wired = true;
                     const handler = ()=>{
                         try {
                             omnichord.applyUniversalSettings();
                             // Rebuild ARP sequence on next edge if active
                             if (omnichord._arp && omnichord._arp.column) {
                                 const col = omnichord._arp.column;
                                 const rowsAll = Array.from(col.querySelectorAll('.strings-column .string'));
                                 const within = rowsAll.filter(r => { const o=parseInt(r.dataset.octave||'0',10); return o>=5 && o<=9; });
                                 const npc = Math.max(1, (omnichord._getGlobalNpc ? omnichord._getGlobalNpc() : (omnichord._arp?.npc|0) || 3));
                                 const seq = omnichord._buildArpSequence(within, omnichord._arp.pattern||'up', null).slice(0, npc);
                                 if (!omnichord._arpTransport) omnichord._ensureArpTransport();
                                 const absTick = omnichord._arpTransport.absTickCounter|0;
                                 omnichord._arp.pendingSwitch = { atAbsTick: (absTick+1)>>>0, alignPhaseToTickCounter:false, seq, bassFreq:omnichord._arp.bassFreq, column:col };
                                 omnichord._startArpTransport();
                             }

                            /* ================= INDEPENDENT PATTERN TRANSPORT =================
                               Provides its own tick counter decoupled from drum/ARP bar length.
                               Guarantees loop at patternLen (data-length on #patternGrid) rather than bar ticks.
                               Uses same BPM & quant base but computes patternTicksPerStep so every step == one grid cell.
                               Protects against note dropping when OSC release tails overlap by tracking active pattern voices.
                            */
                            (function initPatternTransport(){
                                const pg = document.getElementById('patternGrid');
                                if (!pg) return;
                                if (window._patternTransport) return; // singleton
                                const pt = window._patternTransport = {
                                    running: true,
                                    tickCounter: 0,         // counts pattern steps (0..len-1)
                                    absTickCounter: 0,
                                    nextAt: performance.now(),
                                    stepMs: 120,            // dynamic (updated from BPM + quant base)
                                    lastLen: parseInt(pg.dataset.length||'16',10)||16,
                                    activeVoices: new Set(), // track currently sounding pattern notes (id strings)
                                    swingPct: 0,
                                    lastSwingPhase: 0,
                                    guardSkips: 0
                                };
                                // Derive stepMs from universalQuant base (each pattern cell == quant subdivision baseline)
                                function refreshTiming(){
                                    try {
                                        const bpmEl = document.getElementById('universalBpm');
                                        const quantEl = document.getElementById('universalQuant');
                                        const swingEl = document.getElementById('universalSwing');
                                        const bpm = Math.max(20, parseFloat(bpmEl?.value||'120')||120);
                                        const quant = (quantEl?.value||'1/16').trim();
                                        // Parse quant like 1/16, 1/8T, tuplet:5/4
                                        let baseDiv = 16; let isTrip = false; let tupletRatio = 1;
                                        if (/tuplet:\s*(\d+)\/(\d+)/i.test(quant)) {
                                            const m = quant.match(/tuplet:\s*(\d+)\/(\d+)/i); const n=+m[1], d=+m[2]; if(n>0&&d>0) tupletRatio = n/d; baseDiv = 4; // treat quarter as base then scale
                                        } else if (/^1\/(\d+)(t)?$/i.test(quant)) {
                                            const m = quant.match(/^1\/(\d+)(t)?$/i); baseDiv = parseInt(m[1],10)||16; if(m[2]) isTrip=true; }
                                        const beatMs = 60000 / bpm; // quarter note
                                        let stepMs = beatMs * 4 / baseDiv; // if baseDiv=16 -> 1/16
                                        if (isTrip) stepMs *= (2/3); // triplet shorten
                                        if (tupletRatio !== 1) stepMs *= (1/tupletRatio);
                                        const swingPct = Math.max(0, Math.min(75, parseFloat(swingEl?.value||'0')||0));
                                        pt.stepMs = stepMs;
                                        pt.swingPct = swingPct;
                                    } catch(_){}
                                }
                                refreshTiming();
                                // Recalculate timing when universal controls change
                                ['universalBpm','universalQuant','universalSwing'].forEach(id=>{
                                    const el = document.getElementById(id); if(!el) return; el.addEventListener('input', refreshTiming); el.addEventListener('change', refreshTiming);
                                });
                                function patternTokensForColumn(col){
                                    // Extract active notes at a step col reading patternGrid DOM
                                    const lanes = pg.querySelectorAll('.pattern-row');
                                    const notes = [];
                                    lanes.forEach((row,idx)=>{
                                        const lane = row.querySelector('.pattern-lane');
                                        if(!lane) return;
                                        const cell = lane.querySelector(`.pattern-step[data-step="${col}"]`);
                                        if(!cell) return;
                                        if(cell.classList.contains('active')){
                                            // Determine sustain length
                                            let len = parseInt(cell.dataset.len||'1',10)||1;
                                            // Only fire note-on on the origin (not tied continuation)
                                            const tie = cell.dataset.tie === '1';
                                            if(!tie){ notes.push({row:idx, len}); }
                                        }
                                    });
                                    return notes;
                                }
                                function noteId(row,col){ return `r${row}c${col}`; }
                                function scheduleStep(stepIndex){
                                    const len = parseInt(pg.dataset.length||'16',10)||16;
                                    const fireIdx = stepIndex % len;
                                    // Visual playhead update (loop at len)
                                    try {
                                        const ph = pg.querySelector('.pattern-playhead');
                                        if (ph) {
                                            const pct = (fireIdx/len)*100; ph.style.left = pct + '%';
                                        }
                                    } catch(_){}
                                    // Collect notes
                                    const notes = patternTokensForColumn(fireIdx);
                                    // Clear any voices whose sustain expired
                                    if (pt.activeVoices.size){
                                        for (const vid of Array.from(pt.activeVoices)){
                                            const meta = pt[vid];
                                            if (meta && meta.offStep <= stepIndex){
                                                // Send note-off if needed
                                                try { if (meta.stop) meta.stop(); } catch(_){ }
                                                pt.activeVoices.delete(vid); delete pt[vid];
                                            }
                                        }
                                    }
                                    // Trigger new note-ons
                                    notes.forEach(n=>{
                                        const vid = noteId(n.row, fireIdx);
                                        const offStep = stepIndex + n.len; // absolute in pattern stepCounter units
                                        // Fire note (placeholder: call existing MIDI / synth path) — reuse omnichord functions if present
                                        let stopFn = null;
                                        try {
                                            if (window.omnichord && typeof window.omnichord._playPatternNote === 'function') {
                                                stopFn = window.omnichord._playPatternNote(n.row, n.len, fireIdx);
                                            }
                                        } catch(_){ }
                                        pt.activeVoices.add(vid);
                                        pt[vid] = { offStep, stop: stopFn };
                                    });
                                }
                                function loop(){
                                    if(!pt.running) return;
                                    const now = performance.now();
                                    if (now + 1 >= pt.nextAt){ // allow small lookahead tolerance
                                        // Calculate dynamic step duration with swing: even steps extended, odd shortened
                                        const base = pt.stepMs;
                                        const isEven = (pt.tickCounter % 2)===0;
                                        let stepDur = base;
                                        if (pt.swingPct>0){
                                            const swingFactor = pt.swingPct/100;
                                            if (isEven) stepDur = base * (1 + swingFactor*0.5); else stepDur = base * (1 - swingFactor*0.5);
                                        }
                                        scheduleStep(pt.tickCounter);
                                        pt.tickCounter = (pt.tickCounter + 1) >>> 0;
                                        pt.absTickCounter = (pt.absTickCounter + 1) >>> 0;
                                        const len = parseInt(pg.dataset.length||'16',10)||16;
                                        // Hard wrap visual relative index, but absolute continues (for offStep tracking)
                                        if (pt.tickCounter >= 100000000) pt.tickCounter = pt.tickCounter % len; // prevent overflow long-run
                                        pt.nextAt += stepDur;
                                    }
                                    // Guard against drift: if loop falls far behind, resync to now
                                    if (pt.nextAt - now > 5000) pt.nextAt = now + pt.stepMs;
                                    requestAnimationFrame(loop);
                                }
                                pt.nextAt = performance.now() + pt.stepMs;
                                requestAnimationFrame(loop);
                                // Public helper to force timing refresh (e.g., after LEN change for UI)
                                window.refreshPatternTransportTiming = refreshTiming;
                            })();
                         } catch(_) {}
                     };
                     universalPatternText.addEventListener('change', handler);
                     universalPatternText.addEventListener('input', (e)=>{ if (e.inputType==='insertReplacementText') handler(); });
                 }
                 
                 // Bass button is wired earlier via omnichord.toggleBassMode
                 
                // TIME modal wiring
                (function(){
                    const timeBtn = document.getElementById('openTimeModalBtn');
                    const modal = document.getElementById('timeModal');
                    const closeBtn = document.getElementById('closeTimeModalBtn');
                    if (timeBtn && modal) {
                        timeBtn.addEventListener('click', () => { modal.style.display = 'flex'; });
                        if (closeBtn) closeBtn.addEventListener('click', () => { modal.style.display = 'none'; });
                        if (modal) modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });
                    }
                })();
                 
                 // Ensure background clock is running silently
                 try { omnichord._startArpTransport(); } catch(_) {}
                 // Initial mode UI update
                 omnichord.updateModeUI();

                // Auto-initialize MIDI (silent) if not already enabled and API available
                try {
                    if (window.omnichord && !window.omnichord._midiAutoInitTried) {
                        window.omnichord._midiAutoInitTried = true;
                        const midiToggleBtn = document.getElementById('midiToggle');
                        // If the internal MIDI manager exists and not enabled, attempt init
                        if (window.omnichord.midi && !window.omnichord.midi.enabled && navigator.requestMIDIAccess) {
                            window.omnichord.midi.init().then(ok=>{
                                if (ok) console.log('[MIDI] Auto-init success'); else console.warn('[MIDI] Auto-init failed');
                            }).catch(e=>console.warn('[MIDI] Auto-init error', e));
                        } else if (midiToggleBtn && navigator.requestMIDIAccess) {
                            // Fallback: simulate a click to run existing wiring
                            try { midiToggleBtn.click(); } catch(_){ }
                        }
                    }
                } catch(e) { console.warn('MIDI auto-init exception', e); }
                 
                // Simple sidebar button handler function (defined early for onclick)
                window.sidebarBtnClick = function(buttonType) {
                    console.log(`${buttonType.toUpperCase()} button clicked`);
                    const btn = document.getElementById(buttonType + 'Btn');
                    if (!btn) return;
                    
                    btn.classList.toggle('active');
                    
                    switch(buttonType) {
                        case 'keyboard':
                            const section = document.getElementById('keyboardSection');
                            if (section) {
                                section.style.display = btn.classList.contains('active') ? 'block' : 'none';
                            }
                            break;
                            
                        case 'strum':
                            if (window.omnichord && typeof omnichord.toggleStrumMode === 'function') {
                                omnichord.toggleStrumMode();
                            }
                            break;
                            
                        case 'arp':
                            if (window.omnichord && typeof omnichord.toggleChordArpMode === 'function') {
                                omnichord.toggleChordArpMode();
                            }
                            break;
                            
                        case 'pattern':
                            if (btn.classList.contains('active')) {
                                if (typeof showPatternModal === 'function') showPatternModal();
                                if (window._patternTransport) window._patternTransport.running = true;
                            } else {
                                if (typeof closePatternModal === 'function') closePatternModal();
                                if (window._patternTransport) window._patternTransport.running = false;
                            }
                            break;
                            
                        case 'chords':
                            // Chords are always enabled by default
                            break;
                            
                        case 'drums':
                            if (btn.classList.contains('active')) {
                                if (typeof showDrumModal === 'function') showDrumModal();
                            } else {
                                if (typeof closeDrumModal === 'function') closeDrumModal();
                            }
                            break;
                            
                        case 'bass':
                            if (window.omnichord && typeof omnichord.toggleBassMode === 'function') {
                                omnichord.toggleBassMode();
                            }
                            break;
                            
                        case 'midi':
                            const midiActive = btn.classList.contains('active');
                            if (window.omnichord) {
                                omnichord.midiBypassOscillators = midiActive;
                            }
                            const midiToggle = document.getElementById('midiToggle');
                            if (midiToggle && typeof midiToggle.click === 'function') {
                                midiToggle.click();
                            }
                            break;
                    }
                };
                
                console.log('Sidebar button handler ready');
                
                /* ================= SIDEBAR MODULE BUTTONS & MODALS =================
                   Wire up the new left sidebar buttons to control module states and floating modals.
                */
                
                // Modal control functions
                window.showDrumModal = function() {
                    console.log('Opening drum modal');
                    const modal = document.getElementById('drumModal');
                    if (modal) {
                        modal.style.display = 'block';
                        makeDraggable(modal);
                    }
                };
                
                window.closeDrumModal = function() {
                    const modal = document.getElementById('drumModal');
                    if (modal) modal.style.display = 'none';
                    const btn = document.getElementById('drumsBtn');
                    if (btn) btn.classList.remove('active');
                };
                
                window.showPatternModal = function() {
                    console.log('Opening pattern modal');
                    const modal = document.getElementById('patternModal');
                    if (modal) {
                        modal.style.display = 'block';
                        makeDraggable(modal);
                    }
                };
                
                window.closePatternModal = function() {
                    const modal = document.getElementById('patternModal');
                    if (modal) modal.style.display = 'none';
                    const btn = document.getElementById('patternBtn');
                    if (btn) btn.classList.remove('active');
                };
                
                // Make modals draggable by header
                function makeDraggable(element) {
                    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
                    const header = element.querySelector('.modal-header');
                    if (!header) return;
                    
                    header.onmousedown = dragMouseDown;
                    
                    function dragMouseDown(e) {
                        e = e || window.event;
                        e.preventDefault();
                        pos3 = e.clientX;
                        pos4 = e.clientY;
                        document.onmouseup = closeDragElement;
                        document.onmousemove = elementDrag;
                    }
                    
                    function elementDrag(e) {
                        e = e || window.event;
                        e.preventDefault();
                        pos1 = pos3 - e.clientX;
                        pos2 = pos4 - e.clientY;
                        pos3 = e.clientX;
                        pos4 = e.clientY;
                        element.style.top = (element.offsetTop - pos2) + "px";
                        element.style.left = (element.offsetLeft - pos1) + "px";
                    }
                    
                    function closeDragElement() {
                        document.onmouseup = null;
                        document.onmousemove = null;
                    }
                }
                
                // Simple sidebar button handler function
                window.sidebarBtnClick = function(buttonType) {
                    console.log(`${buttonType.toUpperCase()} button clicked`);
                    const btn = document.getElementById(buttonType + 'Btn');
                    if (!btn) return;
                    
                    btn.classList.toggle('active');
                    
                    switch(buttonType) {
                        case 'keyboard':
                            const section = document.getElementById('keyboardSection');
                            if (section) {
                                section.style.display = btn.classList.contains('active') ? 'block' : 'none';
                            }
                            break;
                            
                        case 'strum':
                            if (window.omnichord && typeof omnichord.toggleStrumMode === 'function') {
                                omnichord.toggleStrumMode();
                            }
                            break;
                            
                        case 'arp':
                            if (window.omnichord && typeof omnichord.toggleChordArpMode === 'function') {
                                omnichord.toggleChordArpMode();
                            }
                            break;
                            
                        case 'pattern':
                            if (btn.classList.contains('active')) {
                                showPatternModal();
                                if (window._patternTransport) window._patternTransport.running = true;
                            } else {
                                closePatternModal();
                                if (window._patternTransport) window._patternTransport.running = false;
                            }
                            break;
                            
                        case 'chords':
                            // Chords are always enabled by default
                            break;
                            
                        case 'drums':
                            if (btn.classList.contains('active')) {
                                showDrumModal();
                            } else {
                                closeDrumModal();
                            }
                            break;
                            
                        case 'bass':
                            if (window.omnichord && typeof omnichord.toggleBassMode === 'function') {
                                omnichord.toggleBassMode();
                            }
                            break;
                            
                        case 'midi':
                            const midiActive = btn.classList.contains('active');
                            if (window.omnichord) {
                                omnichord.midiBypassOscillators = midiActive;
                            }
                            const midiToggle = document.getElementById('midiToggle');
                            if (midiToggle && typeof midiToggle.click === 'function') {
                                midiToggle.click();
                            }
                            break;
                    }
                };
                
                console.log('Sidebar button handler ready');
                
                // Initialize default states
                try {
                    const chordsBtn = document.getElementById('chordsBtn');
                    const bassBtn = document.getElementById('bassBtn');
                    
                    if (chordsBtn) chordsBtn.classList.add('active');
                    if (bassBtn) bassBtn.classList.add('active');
                    
                    // Open keyboard modal by default (for half-screen layout)
                    const keyboardBtn = document.getElementById('keyboardBtn');
                    if (keyboardBtn) {
                        keyboardBtn.classList.add('active');
                        // Show keyboard modal on startup
                        setTimeout(() => {
                            if (typeof showKeyboardModal === 'function') {
                                showKeyboardModal();
                            }
                        }, 100);
                    }
                    
                    // Ensure rootGrid exists for keyboard functionality
                    const rootGrid = document.getElementById('rootGrid');
                    if (rootGrid) {
                        console.log('Root grid found, keyboard modal will work');
                    } else {
                        console.error('Root grid not found - keyboard modal will not work!');
                    }
                    
                    console.log('Sidebar buttons initialized');
                } catch(e) {
                    console.error('Error initializing sidebar:', e);
                }
                
             })();
    </script>
    <script>
    // Ensure TIME button opens the modal even if earlier setup didn't wire it
    (function(){
        const bind = () => {
            const btn = document.getElementById('openTimeModalBtn');
            const modal = document.getElementById('timeModal');
            const closeBtn = document.getElementById('closeTimeModalBtn');
            if (!btn || !modal) return false;
            if (!btn._wiredTime) {
                btn._wiredTime = true;
                btn.addEventListener('click', () => { modal.style.display = 'flex'; });
            }
            if (closeBtn && !closeBtn._wiredTime) {
                closeBtn._wiredTime = true;
                closeBtn.addEventListener('click', () => { modal.style.display = 'none'; });
            }
            if (!modal._wiredBackdrop) {
                modal._wiredBackdrop = true;
                modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });
            }
            return true;
        };
        if (!bind()) {
            document.addEventListener('DOMContentLoaded', bind, { once: true });
        }
    })();
    </script>
    
    <script>
    // New Transport Controls functionality (unified with SPACE key logic & master BPM)
    (function(){
        const bind = () => {
            // Transport button handlers
            const playBtn = document.getElementById('playStopTransportBtn');
            const loopToggle = document.getElementById('loopToggle');
            const bpmInput = document.getElementById('transportBpm');
            const legacyPlayToggle = document.getElementById('playStopToggleBtn'); // existing main sequencer button used by SPACE handler

            // Master BPM setter - single source of truth
            function setMasterBpm(raw){
                const bpm = Math.max(20, Math.min(300, parseInt(raw,10) || 120));
                if (window.omnichord && window.omnichord._arpTransport) {
                    window.omnichord._arpTransport.bpm = bpm;
                }
                if (window._patternTransport) {
                    window._patternTransport.bpm = bpm;
                }
                if (bpmInput && bpmInput.value != bpm) bpmInput.value = bpm;
                const drumBpm = document.getElementById('drumBpmMini');
                if (drumBpm && drumBpm.value != bpm) drumBpm.value = bpm;
                const patternBpm = document.getElementById('patternBpm');
                if (patternBpm && patternBpm.value != bpm) patternBpm.value = bpm;
                window.__MASTER_BPM = bpm;
                return bpm;
            }

            // Master volume setter for both oscillators and MIDI
            function setMasterVolume(raw){
                const vol = Math.max(0, Math.min(10, parseFloat(raw) || 10));
                const linear = vol * 0.1; // 0-1 range
                if (window.omnichord) {
                    // Don't override if MIDI has muted (preserve _preMidiMasterVolume logic)
                    if (window.omnichord._preMidiMasterVolume === undefined) {
                        window.omnichord.masterVolume = linear;
                        if (window.omnichord.gainNode) window.omnichord.gainNode.gain.value = window.omnichord.volume * linear;
                        if (window.omnichord.dryGainNode) window.omnichord.dryGainNode.gain.value = linear;
                        if (window.omnichord.reverbOutGain) window.omnichord.reverbOutGain.gain.value = linear;
                    }
                }
                const volInput = document.getElementById('transportMasterVolume');
                if (volInput && volInput.value != vol) volInput.value = vol;
                const legacyVol = document.getElementById('masterVolume');
                if (legacyVol && legacyVol.value != vol) legacyVol.value = vol;
                const volValue = document.getElementById('masterVolumeValue');
                if (volValue) volValue.textContent = Math.round(vol * 10) + '%';
                return vol;
            }

            // Initialize master BPM
            if (typeof window.__MASTER_BPM === 'undefined') {
                const seed = (bpmInput && bpmInput.value) || (document.getElementById('drumBpmMini')?.value) || (document.getElementById('patternBpm')?.value) || 120;
                setMasterBpm(seed);
            } else {
                setMasterBpm(window.__MASTER_BPM);
            }

            if (playBtn && !playBtn._wired) {
                playBtn._wired = true;
                playBtn.addEventListener('click', () => {
                    if (legacyPlayToggle) {
                        legacyPlayToggle.click(); // Delegate to legacy logic (keeps SPACE parity & panic behavior)
                        setTimeout(()=>{
                            const isSequencing = (window.omnichord && window.omnichord._isSequencing);
                            playBtn.innerHTML = isSequencing ? '⏹' : '▶'; // Unicode symbols
                            playBtn.style.background = isSequencing ? '#e74c3c' : '#27ae60';
                            playBtn.style.borderColor = isSequencing ? '#c0392b' : '#2ecc71';
                        }, 10);
                        return;
                    }
                    if (window.omnichord) {
                        const isPlaying = window.omnichord._arpTransport?.isRunning;
                        if (isPlaying) {
                            window.omnichord._stopArpTransport();
                        } else {
                            window.omnichord._startArpTransport();
                        }
                        const nowPlaying = window.omnichord._arpTransport?.isRunning;
                        playBtn.textContent = nowPlaying ? 'STOP' : 'PLAY';
                        playBtn.style.background = nowPlaying ? '#e74c3c' : '#27ae60';
                    }
                });
            }

            // Mirror legacy button state changes into compact playBtn
            if (legacyPlayToggle && playBtn && !legacyPlayToggle._mirrorToTransport) {
                legacyPlayToggle._mirrorToTransport = true;
                const observer = new MutationObserver(()=>{
                    const isSequencing = (window.omnichord && window.omnichord._isSequencing);
                    playBtn.innerHTML = isSequencing ? '⏹' : '▶'; // Unicode symbols
                    playBtn.style.background = isSequencing ? '#e74c3c' : '#27ae60';
                    playBtn.style.borderColor = isSequencing ? '#c0392b' : '#2ecc71';
                });
                observer.observe(legacyPlayToggle, { attributes:true, attributeFilter:['data-state','class','style']});
            }

            // Enhanced loop toggle with proper stop behavior
            const legacyLoop = document.getElementById('playLoop');
            if (loopToggle && legacyLoop && !loopToggle._wired) {
                loopToggle._wired = true;
                
                // Keep them in sync - transport toggle controls legacy checkbox
                loopToggle.addEventListener('change', () => {
                    legacyLoop.checked = loopToggle.checked;
                    if (window.omnichord && window.omnichord._arpTransport) {
                        window.omnichord._arpTransport.loopEnabled = loopToggle.checked;
                        // If unchecking loop and currently playing, prepare to stop after current cycle
                        if (!loopToggle.checked && window.omnichord._isSequencing) {
                            console.log('🎵 LOOP disabled - will stop after current cycle');
                            window.omnichord._arpTransport.stopAfterCurrentCycle = true;
                        }
                    }
                });
                
                // Also sync the other direction if legacy checkbox changes
                if (!legacyLoop._syncedToTransport) {
                    legacyLoop._syncedToTransport = true;
                    legacyLoop.addEventListener('change', () => {
                        loopToggle.checked = legacyLoop.checked;
                        if (window.omnichord && window.omnichord._arpTransport) {
                            window.omnichord._arpTransport.loopEnabled = legacyLoop.checked;
                            // If unchecking loop and currently playing, prepare to stop after current cycle
                            if (!legacyLoop.checked && window.omnichord._isSequencing) {
                                console.log('🎵 LOOP disabled - will stop after current cycle');
                                window.omnichord._arpTransport.stopAfterCurrentCycle = true;
                            }
                        }
                    });
                }
                
                // Initialize sync
                loopToggle.checked = legacyLoop.checked;
            }

            // BPM input handlers
            if (bpmInput && !bpmInput._wired) {
                bpmInput._wired = true;
                bpmInput.addEventListener('input', () => { setMasterBpm(bpmInput.value); });
            }
            const drumBpmMini = document.getElementById('drumBpmMini');
            if (drumBpmMini && !drumBpmMini._wired) {
                drumBpmMini._wired = true;
                drumBpmMini.addEventListener('input', ()=>{ setMasterBpm(drumBpmMini.value); });
            }
            const patternBpm = document.getElementById('patternBpm');
            // Wire transport master volume
            const transportVolInput = document.getElementById('transportMasterVolume');
            if (transportVolInput && !transportVolInput._wired) {
                transportVolInput._wired = true;
                transportVolInput.addEventListener('input', () => { setMasterVolume(transportVolInput.value); });
            }
            // Wire legacy master volume to sync with transport
            const legacyVolInput = document.getElementById('masterVolume');
            if (legacyVolInput && !legacyVolInput._wired) {
                legacyVolInput._wired = true;
                legacyVolInput.addEventListener('input', () => { setMasterVolume(legacyVolInput.value); });
            }
            if (patternBpm && !patternBpm._wired) {
                patternBpm._wired = true;
                patternBpm.addEventListener('input', ()=>{ setMasterBpm(patternBpm.value); });
            }

            // Wire up sidebar button handlers for moved menu items
            const createNewChordBtnSidebar = document.getElementById('createNewChordBtnSidebar');
            if (createNewChordBtnSidebar) {
                createNewChordBtnSidebar.addEventListener('click', () => {
                    const originalBtn = document.getElementById('createNewChordBtn');
                    if (originalBtn) originalBtn.click();
                });
            }
            
            const edoInput = document.getElementById('edoQuickInputSidebar');
            if (edoInput) {
                edoInput.addEventListener('input', () => {
                    const originalInput = document.getElementById('edoQuickInput');
                    if (originalInput) {
                        originalInput.value = edoInput.value;
                        originalInput.dispatchEvent(new Event('input'));
                    }
                });
                if (!edoInput._focusModal) {
                    edoInput._focusModal = true;
                    edoInput.addEventListener('focus', ()=>{ const m=document.getElementById('tuningModal'); if(m) m.style.display='block'; });
                }
            }
            
            const oscPanelBtn = document.getElementById('oscPanelBtn');
            if (oscPanelBtn) {
                oscPanelBtn.addEventListener('click', () => {
                    // Open OSC floating modal
                    const oscModal = document.getElementById('oscModal');
                    if (oscModal) {
                        oscModal.style.display = 'block';
                        bringModalToFront('oscModal');
                        if (!oscModal._draggableSet) {
                            makeDraggable(oscModal);
                            oscModal._draggableSet = true;
                        }
                    }
                });
            }
            
            const fxPanelBtn = document.getElementById('fxPanelBtn');
            if (fxPanelBtn) {
                fxPanelBtn.addEventListener('click', () => {
                    // Open FX floating modal
                    const fxModal = document.getElementById('fxModal');
                    if (fxModal) {
                        fxModal.style.display = 'block';
                        bringModalToFront('fxModal');
                        if (!fxModal._draggableSet) {
                            makeDraggable(fxModal);
                            fxModal._draggableSet = true;
                        }
                    }
                });
            }
            
            const seqPanelBtn = document.getElementById('seqPanelBtn');
            if (seqPanelBtn) {
                seqPanelBtn.addEventListener('click', () => {
                    const originalBtn = document.getElementById('openTextChordParserBtn');
                    if (originalBtn) originalBtn.click();
                });
            }
            
            const loadXenBtn = document.getElementById('loadXenBtn');
            if (loadXenBtn) {
                loadXenBtn.addEventListener('click', () => {
                    const originalBtn = document.getElementById('bottomImportOMGBtn');
                    if (originalBtn) originalBtn.click();
                });
            }
            
            const saveXenBtn = document.getElementById('saveXenBtn');
            if (saveXenBtn) {
                saveXenBtn.addEventListener('click', () => {
                    const originalBtn = document.getElementById('bottomExportOMGBtn');
                    if (originalBtn) originalBtn.click();
                });
            }

            // Close buttons for OSC/FX modals
            const closeOsc = document.getElementById('closeOscModal');
            if (closeOsc && !closeOsc._wired) { closeOsc._wired = true; closeOsc.addEventListener('click', ()=>{ const m=document.getElementById('oscModal'); if(m) m.style.display='none'; }); }
            const closeFx = document.getElementById('closeFxModal');
            if (closeFx && !closeFx._wired) { closeFx._wired = true; closeFx.addEventListener('click', ()=>{ const m=document.getElementById('fxModal'); if(m) m.style.display='none'; }); }
            const closeTuning = document.getElementById('closeTuningModal');
            if (closeTuning && !closeTuning._wired) { closeTuning._wired = true; closeTuning.addEventListener('click', ()=>{ const m=document.getElementById('tuningModal'); if(m) m.style.display='none'; }); }
            
            const randomDiceBtnSidebar = document.getElementById('randomDiceBtnSidebar');
            if (randomDiceBtnSidebar) {
                randomDiceBtnSidebar.addEventListener('click', () => {
                    const originalBtn = document.getElementById('randomDiceButton');
                    if (originalBtn) originalBtn.click();
                });
            }
            
            const tutorialBtnSidebar = document.getElementById('tutorialBtnSidebar');
            if (tutorialBtnSidebar) {
                tutorialBtnSidebar.addEventListener('click', () => {
                    const originalBtn = document.getElementById('tutorialButton');
                    if (originalBtn) originalBtn.click();
                });
            }
            
            return true;
        };
        
        if (!bind()) {
            document.addEventListener('DOMContentLoaded', bind, { once: true });
        }
    })();
    </script>
</body>
</html>





